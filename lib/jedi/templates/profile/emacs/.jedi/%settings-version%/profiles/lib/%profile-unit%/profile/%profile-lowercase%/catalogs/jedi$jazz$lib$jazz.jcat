"Array-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Array-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Array-Tester" module (protected) () #f #f 37 18 37 50 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Array-Tester" class () ((extends . "Tester")) #f #f 45 7 45 19 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-array" "invoke")}
        {Lisp-Entry "array" definition () () #f #f 62 14 62 19 ("10" "int" "new-array")}
        {Lisp-Entry "test-array" method () () #f #f 66 11 66 21 ()}}}})
"Binding-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Binding-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Binding-Tester" module (protected) () #f #f 37 18 37 52 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Binding-Tester" class () ((extends . "Tester")) #f #f 45 7 45 21 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-function" "test-bind" "test-with" "test-letrec" "test-let" "invoke")}
        {Lisp-Entry "test-let" method () () #f #f 65 11 65 19 ("self" "code-walk" "error?" "begin" "cons" "lst" "reverse" "equal?" "5" "set!" "8" "3" "y" "4" "+" "2" "x" "let" "=" "rpt" "validate")}
        {Lisp-Entry "test-letrec" method () () #f #f 103 11 103 22 ("3" "+" "x" "error?" "begin" "120" "5" "-" "*" "1" "0" "if" "n" "lambda" "fact" "letrec" "=" "rpt" "validate")}
        {Lisp-Entry "test-with" method () () #f #f 125 11 125 20 ()}
        {Lisp-Entry "test-bind" method () () #f #f 134 11 134 20 ("error?" "begin" "6" "+" "3" "2" "1" "list" "z" "y" "x" "bind" "=" "rpt" "validate")}
        {Lisp-Entry "test-function" method () () #f #f 148 11 148 24 ("reverse" "cons" "for-each" "list" "25" "16" "9" "*" "map" "set!" "let" "4" "1" "equal?" "5" "3" "+" "y" "x" "2" "lambda" "=" "rpt" "validate")}}}})
"Boolean-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Boolean-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Boolean-Tester" module (protected) () #f #f 37 18 37 52 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Boolean-Tester" class () ((extends . "Tester")) #f #f 45 7 45 21 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-boolean" "invoke")}
        {Lisp-Entry "test-boolean" method () () #f #f 61 11 61 23 ("not" "nu<?" "ci=?" "nu/=?" "nu=?" "rpt" "validate")}}}})
"Catalog-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Catalog-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Catalog-Tester" module (protected) () #f #f 37 18 37 52 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Catalog-Tester" class () ((extends . "Tester")) #f #f 45 7 45 21 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-catalog" "invoke")}
        {Lisp-Entry "test-catalog" method () () #f #f 61 11 61 23 ()}}}})
"Char-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Char-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Char-Tester" module (protected) () #f #f 37 18 37 49 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Char-Tester" class () ((extends . "Tester")) #f #f 45 7 45 18 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-char" "invoke")}
        {Lisp-Entry "test-char" method () () #f #f 61 11 61 20 ()}}}})
"Collector-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Collector-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Collector-Tester" module (protected) () #f #f 37 18 37 54 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Collector-Tester" class () ((extends . "Tester")) #f #f 45 7 45 23 ("10" "9" "8" "7" "6" "5" "10000" "size:" "List" "new" "set!" "n" "lambda" "for-each" "let" "4" "begin" "list" "=" "rpt" "validate" "3" "2" "1" "x" "gc" "call-gc" "definition" "test-collector" "invoke" "test" "method" "Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}}}})
"Component-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Component-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Component-Tester" module (protected) () #f #f 37 18 37 54 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Component-Tester" class () ((extends . "Tester")) #f #f 45 7 45 23 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ()}}}})
"Control-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Control-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Control-Tester" module (protected) () #f #f 37 18 37 52 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Control-Tester" class () ((extends . "Tester")) #f #f 45 7 45 21 ("3" "set!" "begin" "x" "let" "unwind-protect" "new" "throw" "null?" "2" "Foo" "catch" "=" "rpt" "validate" "test-control" "test-return" "test-unwind-protect" "test-catch" "invoke" "test" "method" "Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}}
      {Lisp-Entry "Foo" class () ((extends . "Signal")) #f #f 102 7 102 10 ("Signal")}}})
"Debugger-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Debugger-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Debugger-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Debugger-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-assert" "test-error?" "invoke")}
        {Lisp-Entry "test-error?" method () () #f #f 62 11 62 22 ()}
        {Lisp-Entry "test-assert" method () () #f #f 71 11 71 22 ()}}}})
"Designer-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Designer-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Designer-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Designer-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("2" "7" "no" "description" "Tester-Error" "signal" "error" "suite" "null?" "and" "get-name" "get-name~" "format" "message" "/=" "when" "val" "remove-property" "remove-property~" "default-value" "rem" "set-property" "set-property~" "value" "set" "read-property" "trait:" "property" "component" "get" "prog1" "set-active-trait" "set-active-trait~" "get-active-trait" "get-active-trait~" "old" "let" "eq?" "if" "proc" "trait" "lambda" "in-trait" "T3" "T2" "T1" "W" "Z" "Y" "locate" "locate~" "X" "reference:" "form:" "Designer" "new" "designer" "instantiate" "instantiate~" "architecture" "read-form" "form" "Validate-Project" "File" "file" "let*" "test-path" "test-reference" "invoke" "test" "method" "Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}}}})
"Enumeration-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Enumeration-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Enumeration-Tester" module (protected) () #f #f 37 18 37 56 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Enumeration-Tester" class () ((extends . "Tester")) #f #f 45 7 45 25 ("test-enumeration" "invoke" "test" "method" "Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}}}})
"Error-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Error-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Error-Tester" module (protected) () #f #f 37 18 37 50 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Error-Tester" class () ((extends . "Tester")) #f #f 45 7 45 19 ("test-error" "invoke" "test" "method" "Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}}}})
"Explorer-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Explorer-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Explorer-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Explorer-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-sequence-explorer" "invoke")}
        {Lisp-Entry "test-sequence-explorer" method () () #f #f 61 11 61 33 ("backward" "direction:" "String" "type:" "2" "start:" "c" "b" "a" "Sequence-Explorer" "new" "gather" "equal?" "rpt" "validate")}}}})
"Form-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Form-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Form-Tester" module (protected) () #f #f 37 18 37 49 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.library" "jazz.jml")}
      {Lisp-Entry "Form-Tester" class () ((extends . "Tester")) #f #f 46 7 46 18 ("Tester")
        {Lisp-Entry "form" form () () #f #f 49 3 49 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test-form" method () () #f #f 53 11 53 20 ("test-fields" "invoke")}
        {Lisp-Entry "test-fields" method () () #f #f 62 11 62 22 ("1" "get-children" "get-children~" "length" "2" "a" "category-field" "list" "get-properties" "get-properties~" "get-name" "get-name~" "get-model" "get-model~" "=" "rpt" "validate" "get-class-form" "get-class-form~" "form" "let" "X" "new")}}
      {Lisp-Entry "F" class () ((extends . "Component")) #f #f 77 7 77 8 ("explicit" "Component")
        {Lisp-Entry "f1" property () ((initialize . "#f") (accessors . "explicit")) #f #f 80 12 80 14 ()}
        {Lisp-Entry "form" form () () #f #f 83 3 83 7 ("2" "f1:" "install" "<install>")}
        {Lisp-Entry "get-f1" method () () #f #f 87 11 87 17 ("f1")}
        {Lisp-Entry "set-f1" method () ("value") #f #f 88 11 88 17 ("f1" "set!" "value")}}
      {Lisp-Entry "X" class () ((extends . "Component")) #f #f 91 7 91 8 ("explicit" "Component")
        {Lisp-Entry "x1" property () ((initialize . "#f") (accessors . "explicit")) #f #f 94 12 94 14 ()}
        {Lisp-Entry "x2" property () ((initialize . "#f") (accessors . "explicit")) #f #f 95 12 95 14 ()}
        {Lisp-Entry "form" form () () #f #f 98 3 98 7 ("5" "fc" "4" "fb" "f1:" "fa" "name:" "F" "<F>" "3" "x2:" "2" "x1:" "install" "<install>")}
        {Lisp-Entry "get-x1" method () () #f #f 105 11 105 17 ("x1")}
        {Lisp-Entry "set-x1" method () ("value") #f #f 106 11 106 17 ("x1" "set!" "value")}
        {Lisp-Entry "get-x2" method () () #f #f 109 11 109 17 ("x2")}
        {Lisp-Entry "set-x2" method () ("value") #f #f 110 11 110 17 ("x2" "set!" "value")}}
      {Lisp-Entry "Y" class () ((extends . "X")) #f #f 113 7 113 8 ("X")
        {Lisp-Entry "form" form () () #f #f 116 3 116 7 ("5" "x2:" "install" "<install>")}}}})
"Format-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Format-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Format-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.locale" "jazz.jml")}
      {Lisp-Entry "Format-Tester" class () ((extends . "Tester")) #f #f 46 7 46 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 49 3 49 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 53 20 53 24 ("test-format" "invoke")}
        {Lisp-Entry "test-format" method () () #f #f 62 11 62 22 ("error-occurred?" ":right" "5" "12345" "hello" "yyy" "string" "3" ":b" ":a" "2.3" "#b1010" "#xA" "-1" ":reader" ":human" "2" "format" "equal?" "rpt" "validate")}}}})
"Function-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Function-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Function-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Function-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("120" "-" "fact" "30" "w" "z" "test-with" "*" "c" "b" "a" "fn" "with-proc" "cons" "rest" "yoo" "increase!" "prog1" "count" "0" "18" "17" "16" "7" "if" "p" "flag" "proc" "set!" "bar" "holder" "5" "foo5" "let" "foo" "add10" "definition" "n" "adder" "13" "12" "11" "3" "2" "1" "10" "=" "rpt" "validate" "+" "y" "lambda" "map" "list" "x" "add" "test-recursivity" "test-function" "test-rest-binding" "test-outer-binding" "test-indefinite-extent" "test-dynamic-closure" "invoke" "test" "method" "Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}}}})
"Iterator-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Iterator-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Iterator-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Iterator-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ()}}}})
"Language-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Language-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Language-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Language-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-conditionals" "test-binding" "test-language" "invoke")}
        {Lisp-Entry "test-language" method () () #f #f 63 11 63 24 ("foo" "error" "catch" "Error" "new" "throw" "8" "display" "procedure?" "error-occurred?" "16" "lambda" "walk-failed?" "4" "1" "+" "5" "eq?" "rpt" "validate" "2" "proc" "double-proc" "*" "x" "square" "define")}
        {Lisp-Entry "test-binding" method () () #f #f 109 11 109 23 ("10" "test" "set!" "begin" "values" "y" "-3" "list?" "receive" "rest" "first" "list" "bind" "error-occurred?" "6" "neq?" "letrec" "4" "5" "x" "25" "let*" "bool" "opposite" "3" "-" "*" "0" "=" "if" "n" "lambda" "fact" "b" "val" "arg" "func" "2" "define-macro" "unresolved-symbol" "procedure?" "equal?" "not" "eq?" "a" "let" "walk-failed?" "rpt" "validate" "bar" "1" "foo" "define")}
        {Lisp-Entry "test-conditionals" method () () #f #f 207 11 207 28 ("String" "List" "typecase" "display" "0" "ecase" "test" "bar" "foo" "equal?" "error-occurred?" "else" "cond" "not" "unless" "lambda" "when" "3" "2" "1" "eq?" "if" "walk-failed?" "rpt" "validate")}}}})
"List-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "List-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.List-Tester" module (protected) () #f #f 37 18 37 49 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "List-Tester" class () ((extends . "Tester")) #f #f 45 7 45 18 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-list" "invoke")}
        {Lisp-Entry "test-list" method () () #f #f 61 11 61 20 ("set-element!" "0" "element" "car" "error?" "begin" "second" "key:" "4" "8" "5" "<" "sort" "ci=?" "test:" "associate" "cdr" "=" "assoc" "eq?" "x" "let" "f" "e" "d" "append" "null?" "reverse" "3" "2" "1" "list" "equal?" "not" "c" "b" "a" "pair?" "rpt" "validate")}}}})
"Number-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Number-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Number-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Number-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-bit" "test-number" "invoke")}
        {Lisp-Entry "test-number" method () () #f #f 62 11 62 22 ("error?" "begin" "min" "8" "7" "max" "6" "<" "/=" "not" "24" "12" "0.25" "/" "60" "*" "4" "6.8" "3.2" "10" "-3.5" "3.5" "-2" "2" "-" "3" "1" "5" "+" "0" "=" "rpt" "validate")}
        {Lisp-Entry "test-bit" method () () #f #f 121 11 121 19 ("7" "bitwise-ior" "2" "14" "6" "0" "4" "1" "5" "bitwise-and" "=" "rpt" "validate")}}}})
"Object-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Object-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Object-Tester" module (protected) () #f #f 37 18 37 51 ("3" "1" "J" "v" "protected" "apply" "rest" "f" "aa" "meta" "9" "mak" "mak~" "bar~" "2" "I" "foo~" "mm" "test-part3" "yiyi~" "yuyu~" "equal?" "28" "4" "tata~" "tutu~" "toto~" "6" "set-bar" "set-bar~" "get-bar" "get-bar~" "test-part2" "call-bah2" "bah~" "obj" "call-bah" "X1" "get-foo" "get-foo~" "=" "get-goo" "get-goo~" "error?" "begin" "get-hoo" "get-hoo~" "neq?" "rpt" "validate" "test-part1" "0" "Cell" "new" "hoo" "W" "+" "Z" "bah" "20" "Y" "7" "12" "set!" "yiyi" "self" "bar~self" "list" "11" "let" "yuyu" "X2" "tata" "*" "x" "tutu" "toto" "method" "5" "initialize" "bar" "slot" "15" "goo" "10" "foo" "virtual" "public" "definition" "Object" "extends" "X" "class" "jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Object-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("test-meta" "test-inner" "test-interface" "test-inheritance" "test-reference" "test-super" "test-self" "test-slot" "test-definition" "invoke" "test" "method" "Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}}}})
"Pathname-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Pathname-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Pathname-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Pathname-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-pathname" "invoke")}
        {Lisp-Entry "test-pathname" method () () #f #f 61 11 61 24 ()}}}})
"Reader-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Reader-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Reader-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Reader-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-reader" "invoke")}
        {Lisp-Entry "test-reader" method () () #f #f 61 11 61 22 ("189" "#xbd" "#xBD" "16" "#x10" "=" "3" "2" "1" "equal?" "rpt" "validate")}}}})
"Scheme-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Scheme-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Scheme-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate")}
      {Lisp-Entry "Scheme-Tester" class () ((extends . "Tester")) #f #f 44 7 44 20 ("or" "/" "and" "i" "do" "increase!" "/=" "when" "iter" "0" "sum" "50" "10" "6" "4" "list" "z" "+" "let*" "3" "y" "2" "x" "let" "120" "5" "rpt" "validate" "*" "-" "1" "=" "if" "res" "n" "fact" "define" "test-or" "test-and" "test-do" "test-named-let" "test-letstar" "test-let" "test-define" "invoke" "test" "method" "title:" "install" "<install>" "form" "Tester")}}})
"Sequence-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Sequence-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Sequence-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Sequence-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-sequence" "invoke")}
        {Lisp-Entry "aaa" definition () () #f #f 61 14 61 17 ()}
        {Lisp-Entry "test-sequence" method () () #f #f 65 11 65 24 ("list" "aaa" "eq?" "replace-subseq!" "0" "insert!" "replace!" "fill!" "sequence?:" "substitute" "join" "split" "identity" "accumulate" "map" "search" "prefix?" "mismatch" "String" "e" "d" "c" "b" "a" "subseq" "upper-case?" "collect-if" "every?" "not" "9" "some?" "15" "start:" "reversed?:" "numeric?" "cadr" "odd?" "find-if" "find" "car" "key:" "denise" "mark" "william" "find-in" "8" "7" "6" "even?" "count-if" "4" "5" "2" "1" "3" "count" "equal?" "rpt" "validate")}}}})
"String-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "String-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.String-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "String-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-wi=" "test-string" "invoke")}
        {Lisp-Entry "string" definition () () #f #f 63 14 63 20 ()}
        {Lisp-Entry "test-string" method () () #f #f 67 11 67 22 ("4" "set-element!" "1" "string" "element" "nu=?" "rpt" "validate")}
        {Lisp-Entry "ansistring" definition () () #f #f 80 14 80 24 ("Ansi-String" "coerce")}
        {Lisp-Entry "test-ansi-string" method () () #f #f 85 11 85 27 ("4" "set-element!" "1" "ansistring" "element" "nu=?" "rpt" "validate")}
        {Lisp-Entry "test-wi=" method () () #f #f 96 11 96 19 ("not" "wi=" "rpt" "validate")}}}})
"Structure-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Structure-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Structure-Tester" module (protected) () #f #f 37 18 37 54 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Structure-Tester" class () ((extends . "Tester")) #f #f 45 7 45 23 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-structure" "invoke")}
        {Lisp-Entry "test-structure" method () () #f #f 61 11 61 25 ()}}}})
"Symbol-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Symbol-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Symbol-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Symbol-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-symbol" "invoke")}
        {Lisp-Entry "test-symbol" method () () #f #f 61 11 61 22 ()}}}})
"Syntax-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Syntax-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Syntax-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Syntax-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-decrease!" "test-increase!" "test-set!" "test-either" "test-essay" "test-or" "test-and" "test-typecase" "test-ecase" "test-case" "test-cond" "test-prog1" "test-begin" "test-for" "test-until" "test-while" "test-unless" "test-when" "test-if" "test-quote" "invoke")}
        {Lisp-Entry "test-quote" method () () #f #f 80 11 80 21 ("self" "quote" "code-walk" "error?" "begin" "list" "c" "b" "a" "equal?" "rpt" "validate")}
        {Lisp-Entry "test-if" method () () #f #f 94 11 94 18 ("self" "if" "code-walk" "error?" "rpt" "validate" "begin")}
        {Lisp-Entry "test-when" method () () #f #f 106 11 106 20 ("self" "when" "code-walk" "error?" "rpt" "validate" "begin")}
        {Lisp-Entry "test-unless" method () () #f #f 117 11 117 22 ("3" "5" "2" "unless" "equal?" "50" "foo" "=" "rpt" "validate")}
        {Lisp-Entry "test-while" method () () #f #f 128 11 128 21 ()}
        {Lisp-Entry "test-until" method () () #f #f 137 11 137 21 ()}
        {Lisp-Entry "test-for" method () () #f #f 146 11 146 19 ()}
        {Lisp-Entry "test-begin" method () () #f #f 155 11 155 21 ()}
        {Lisp-Entry "test-prog1" method () () #f #f 164 11 164 21 ()}
        {Lisp-Entry "test-cond" method () () #f #f 173 11 173 20 ("9" "else" "8" "7" "5" "=" "3" "y" "2" "x" "not" "rpt" "validate" "cond" "v" "let")}
        {Lisp-Entry "test-case" method () () #f #f 190 11 190 20 ("9" "else" "8" "7" "5" "3" "=" "not" "rpt" "validate" "2" "case" "v" "let")}
        {Lisp-Entry "test-ecase" method () () #f #f 206 11 206 21 ("9" "else" "8" "7" "=" "3" "y" "x" "not" "rpt" "validate" "2" "ecase" "v" "let")}
        {Lisp-Entry "test-typecase" method () () #f #f 224 11 224 24 ("9" "else" "8" "Number" "7" "Symbol" "3" "=" "not" "rpt" "validate" "2" "typecase" "v" "let")}
        {Lisp-Entry "test-and" method () () #f #f 240 11 240 19 ("5" "3" "2" "and" "equal?" "rpt" "validate")}
        {Lisp-Entry "test-or" method () () #f #f 253 11 253 18 ("5" "3" "2" "+" "or" "equal?" "rpt" "validate")}
        {Lisp-Entry "test-essay" method () () #f #f 266 11 266 21 ("5" "3" "2" "and" "equal?" "rpt" "validate")}
        {Lisp-Entry "test-either" method () () #f #f 276 11 276 22 ("5" "3" "2" "+" "or" "equal?" "rpt" "validate")}
        {Lisp-Entry "test-set!" method () () #f #f 287 11 287 20 ()}
        {Lisp-Entry "foo" method () () #f #f 296 11 296 14 ("5" "increase!" "10" "below" "from" "n" "for" "loop" "0" "total" "let")}
        {Lisp-Entry "test-increase!" method () () #f #f 303 11 303 25 ("50" "foo" "=" "rpt" "validate")}
        {Lisp-Entry "goo" method () ("n") #f #f 312 11 312 14 ("5" "decrease!" "10" "to" "1" "from" "i" "for" "loop" "100" "total" "let" "n")}
        {Lisp-Entry "test-decrease!" method () () #f #f 319 11 319 25 ("50" "5" "goo" "=" "rpt" "validate")}}
      {Lisp-Entry "X" class () ((extends . "Object")) #f #f 328 7 328 8 ("4" "Object")
        {Lisp-Entry "counter" slot () ((initialize . "4")) #f #f 331 8 331 15 ()}}}})
"Table-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Table-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Table-Tester" module (protected) () #f #f 37 18 37 50 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Table-Tester" class () ((extends . "Tester")) #f #f 45 7 45 19 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-growth" "test-table" "invoke")}
        {Lisp-Entry "table" definition () () #f #f 62 14 62 19 ("eq?" "test:" "make-table")}
        {Lisp-Entry "test-table" method () () #f #f 65 11 65 21 ("3" "5" "=" "goo" "table-ref" "not" "rpt" "validate" "2" "foo" "table" "table-set!")}
        {Lisp-Entry "small-table" definition () () #f #f 81 14 81 25 ("eq?" "test:" "make-table")}
        {Lisp-Entry "test-growth" method () () #f #f 84 11 84 22 ("5" "hoo" "3" "goo" "2" "foo" "small-table" "table-set!")}}}})
"Test-Architecture"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "support" "Test-Architecture.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.support.Test-Architecture" module (protected) () #f #f 37 18 37 57 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validate" "jazz.library")}
      {Lisp-Entry "Test-Architecture" class () ((extends . "Component")) #f #f 44 7 44 24 ("Component")
        {Lisp-Entry "author" property () ((initialize . "#f") (accessors . "generate")) #f #f 47 12 47 18 ()}
        {Lisp-Entry "get-author" accessor () () #f #f 47 43 47 51 ()}
        {Lisp-Entry "set-author" accessor () () #f #f 47 43 47 51 ()}
        {Lisp-Entry "get-class-descriptor" method (meta override) () #f #f 55 25 55 45 ("Test-Architecture-Descriptor" "new")}}
      {Lisp-Entry "design" submodule () () #f #f 64 11 64 17 ()
        {Lisp-Entry "import" import () () #f #f 67 1 67 7 ("jazz.designer")}
        {Lisp-Entry "Test-Architecture-Descriptor" class () ((extends . "Component-Descriptor")) #f #f 70 7 70 35 ("Component-Descriptor")
          {Lisp-Entry "form" form () () #f #f 73 3 73 7 ("name:" "Property-Descriptor" "<Property-Descriptor>" "author" "name-info" "class-info" "categorized:" ">" "<properties" "<properties~>" "Image-Resource" "image:" "title:" "install" "<install>")}
          {Lisp-Entry "component-get-addable-default-trait" method (override) ("component") #f #f 79 20 79 55 ("Test-Model" "component")}
          {Lisp-Entry "component-get-categorized-addable-classes" method (override) ("component") #f #f 83 20 83 61 ("Test-Table" "reference" "list" "component")}}}}})
"Test-Model"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "support" "Test-Model.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.support.Test-Model" module (protected) () #f #f 37 18 37 50 ("Test-Model" "register-trait-tag" "jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.library" "jazz.jml")}
      {Lisp-Entry "Test-Model" class () ((extends . "Trait")) #f #f 44 7 44 17 ("Trait")
        {Lisp-Entry "get-class-descriptor" method (meta override) () #f #f 52 25 52 45 ("Test-Model-Descriptor" "new")}}
      {Lisp-Entry "design" submodule () () #f #f 64 11 64 17 ()
        {Lisp-Entry "import" import () () #f #f 67 1 67 7 ("jazz.designer")}
        {Lisp-Entry "Test-Model-Descriptor" class () ((extends . "Trait-Descriptor")) #f #f 70 7 70 28 ("Trait-Descriptor")
          {Lisp-Entry "form" form () () #f #f 73 3 73 7 (">" "<properties" "<properties~>" "Image-Resource" "image:" "title:" "install" "<install>")}}}}})
"Test-Table"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "support" "Test-Table.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.support.Test-Table" module (protected) () #f #f 37 18 37 50 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.library" "jazz.designer")}
      {Lisp-Entry "Test-Table" class () ((extends . "Component")) #f #f 44 7 44 17 ("5" "Component")
        {Lisp-Entry "description" property () ((initialize . "#f") (accessors . "generate")) #f #f 47 12 47 23 ()}
        {Lisp-Entry "get-description" accessor () () #f #f 47 48 47 56 ()}
        {Lisp-Entry "set-description" accessor () () #f #f 47 48 47 56 ()}
        {Lisp-Entry "no" property () ((initialize . "5") (accessors . "generate")) #f #f 48 12 48 14 ()}
        {Lisp-Entry "get-no" accessor () () #f #f 48 48 48 56 ()}
        {Lisp-Entry "set-no" accessor () () #f #f 48 48 48 56 ()}
        {Lisp-Entry "get-class-descriptor" method (meta override) () #f #f 56 25 56 45 ("Test-Table-Descriptor" "new")}}
      {Lisp-Entry "design" submodule () () #f #f 65 11 65 17 ()
        {Lisp-Entry "import" import () () #f #f 68 1 68 7 ("jazz.designer")}
        {Lisp-Entry "Test-Table-Descriptor" class () ((extends . "Component-Descriptor")) #f #f 71 7 71 28 ("Component-Descriptor")
          {Lisp-Entry "form" form () () #f #f 74 3 74 7 ("Integer-Domain" "<Integer-Domain>" "nullable?:" "domain" "String-Domain" "<String-Domain>" "name:" "Property-Descriptor" "<Property-Descriptor>" "no" "description" "name-info" "class-info" "categorized:" ">" "<properties" "<properties~>" "Image-Resource" "image:" "title:" "install" "<install>")}}}}})
"Thread-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Thread-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Thread-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Thread-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-thread" "invoke")}
        {Lisp-Entry "test-thread" method () () #f #f 61 11 61 22 ()}}}})
"Trait-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Trait-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Trait-Tester" module (protected) () #f #f 37 18 37 50 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Trait-Tester" class () ((extends . "Tester")) #f #f 45 7 45 19 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ()}}}})
"Values-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Values-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Values-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Values-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-values" "invoke")}
        {Lisp-Entry "test-values" method () () #f #f 61 11 61 22 ()}}}})
"Variable-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Variable-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Variable-Tester" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Variable-Tester" class () ((extends . "Tester")) #f #f 45 7 45 22 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-free?" "invoke")}
        {Lisp-Entry "test-free?" method () () #f #f 61 11 61 21 ()}}}})
"Vector-Tester"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "suite" "Vector-Tester.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.suite.Vector-Tester" module (protected) () #f #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate" "jazz.jml")}
      {Lisp-Entry "Vector-Tester" class () ((extends . "Tester")) #f #f 45 7 45 20 ("Tester")
        {Lisp-Entry "form" form () () #f #f 48 3 48 7 ("title:" "install" "<install>")}
        {Lisp-Entry "test" method (override) () #f #f 52 20 52 24 ("test-vector" "invoke")}
        {Lisp-Entry "test-vector" method () () #f #f 61 11 61 22 ()}}}})
"X"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "X.jazz"} 231466232. jazz
    {Lisp-Entry "jazz.test.X" module (protected) () #f #f 0 18 0 29 ("jazz")
      {Lisp-Entry "X" class () ((extends . "Object")) #f #f 3 7 3 8 ("Object")
        {Lisp-Entry "foo" method (virtual) () #f #f 6 19 6 22 ("X.foo" "terminal")}}}})
"Y"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "Y.jazz"} 231466232. jazz
    {Lisp-Entry "jazz.test.Y" module (protected) () #f #f 0 18 0 29 ("jazz")
      {Lisp-Entry "import" import () () #f #f 3 1 3 7 ("jazz.test.autoload")}
      {Lisp-Entry "Y" class () ((extends . "Object")) #f #f 6 7 6 8 ("Object")
        {Lisp-Entry "foo" method () () #f #f 9 11 9 14 ("Y.foo" "terminal")}}}})
"_core"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "_core.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.core" module (protected) () #f #f 37 18 37 35 ("scheme")
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("jazz.dialect.core.vector" "jazz.dialect.core.time" "jazz.dialect.core.thread" "jazz.dialect.core.table" "jazz.dialect.core.system" "jazz.dialect.core.structure" "jazz.dialect.core.step" "jazz.dialect.core.stack" "jazz.dialect.core.repository" "jazz.dialect.core.reader" "jazz.dialect.core.port" "jazz.dialect.core.pathname" "jazz.dialect.core.number" "jazz.dialect.core.network" "jazz.dialect.core.memory" "jazz.dialect.core.list" "jazz.dialect.core.foreign" "jazz.dialect.core.exception" "jazz.dialect.core.development" "jazz.dialect.core.debug" "jazz.dialect.core.continuation" "jazz.dialect.core.base64")}}})
"_dialect"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "_dialect.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect" module (protected) () #f #f 37 18 37 30 ("scheme")
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("jazz.dialect.runtime" "jazz.dialect.runtime-classes" "jazz.dialect.dialect" "jazz.dialect.classes" "syntax" "phase" "jazz.dialect.core" "core.module")}
      {Lisp-Entry "export" export () () #f #f 48 1 48 7 ("scheme" "syntax" "phase" "jazz.dialect.syntax")}}})
"_jazz"
 ({Lisp-File-Entry {File :context "src" "jazz" "_jazz.scm"} 229929916. scheme
    {Lisp-Entry "jazz" module () () #f #f 37 8 37 12 ("scheme")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("jazz.dialect.walker" "jazz.dialect.language" "jazz.dialect.kernel" "jazz.dialect.syntax" "syntax" "phase" "jazz.dialect" "scheme")}}})
"_kernel"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "kernel" "_kernel.scm"} 246587394. scheme
    {Lisp-Entry "jazz.dialect.kernel" module (protected) () #f #f 38 18 38 37 ("scheme")
      {Lisp-Entry "get-autoload" native () () ("native") #f 46 8 46 25 ()}
      {Lisp-Entry "autoload" native () () ("native") #f 47 8 47 21 ()}
      {Lisp-Entry "autoreload" native () () ("native") #f 48 8 48 23 ()}
      {Lisp-Entry "boolean" native () () ("native") #f 56 8 56 20 ()}
      {Lisp-Entry "box?" native () () ("native") #f 64 8 64 12 ()}
      {Lisp-Entry "box" native () () ("native") #f 65 8 65 11 ()}
      {Lisp-Entry "unbox" native () () ("native") #f 66 8 66 13 ()}
      {Lisp-Entry "set-box!" native () () ("native") #f 67 8 67 16 ()}
      {Lisp-Entry "compile-unit" native () () ("native") #f 75 8 75 25 ()}
      {Lisp-Entry "build-unit" native () () ("native") #f 76 8 76 23 ()}
      {Lisp-Entry "build-image" native () () ("native") #f 77 8 77 24 ()}
      {Lisp-Entry "for-each-subunit" native () () ("native") #f 78 8 78 29 ()}
      {Lisp-Entry "load-manifest" native () () ("native") #f 79 8 79 26 ()}
      {Lisp-Entry "get-category-identifier" native () () ("native") #f 87 8 87 36 ()}
      {Lisp-Entry "get-category-descendants" native () () ("native") #f 88 8 88 37 ()}
      {Lisp-Entry "get-class-ascendant" native () () ("native") #f 89 8 89 32 ()}
      {Lisp-Entry "symbolic-char" native () () ("native") #f 97 8 97 26 ()}
      {Lisp-Entry "char-symbol" native () () ("native") #f 98 8 98 24 ()}
      {Lisp-Entry "closure?" native () () ("native") #f 106 8 106 21 ()}
      {Lisp-Entry "closure-code" native () () ("native") #f 107 8 107 25 ()}
      {Lisp-Entry "continuation?" native () () ("native") #f 115 8 115 26 ()}
      {Lisp-Entry "continuation-capture" native () () ("native") #f 116 8 116 33 ()}
      {Lisp-Entry "continuation-graft" native () () ("native") #f 117 8 117 31 ()}
      {Lisp-Entry "continuation-return" native () () ("native") #f 118 8 118 32 ()}
      {Lisp-Entry "continuation-checkpoint" native () () ("native") #f 119 8 119 36 ()}
      {Lisp-Entry "continuation-parent" native () () ("native") #f 120 8 120 32 ()}
      {Lisp-Entry "continuation-creator" native () () ("native") #f 121 8 121 33 ()}
      {Lisp-Entry "continuation-locat" native () () ("native") #f 122 8 122 31 ()}
      {Lisp-Entry "continuation-next" native () () ("native") #f 123 8 123 30 ()}
      {Lisp-Entry "run-loop?" native () () ("native") #f 131 8 131 22 ()}
      {Lisp-Entry "terminal" native () () ("native") #f 132 8 132 21 ()}
      {Lisp-Entry "terminal-string" native () () ("native") #f 133 8 133 28 ()}
      {Lisp-Entry "terminal-port" native () () ("native") #f 134 8 134 26 ()}
      {Lisp-Entry "unimplemented" native () () ("native") #f 135 8 135 26 ()}
      {Lisp-Entry "dump-stack" native () () ("native") #f 136 8 136 23 ()}
      {Lisp-Entry "log-object" native () () ("native") #f 137 8 137 23 ()}
      {Lisp-Entry "log-string" native () () ("native") #f 138 8 138 23 ()}
      {Lisp-Entry "log-newline" native () () ("native") #f 139 8 139 24 ()}
      {Lisp-Entry "close-log" native () () ("native") #f 140 8 140 22 ()}
      {Lisp-Entry "inspect-object" native () () ("native") #f 141 8 141 27 ()}
      {Lisp-Entry "generate-proper-tail-calls" native () () ("native") #f 142 8 142 34 ()}
      {Lisp-Entry "step" native () () ("native") #f 143 8 143 12 ()}
      {Lisp-Entry "step-level-set!" native () () ("native") #f 144 8 144 23 ()}
      {Lisp-Entry "install-step-handler" native () () ("native") #f 145 8 145 28 ()}
      {Lisp-Entry "?" native () () ("native") #f 157 8 157 9 ()}
      {Lisp-Entry "get-?" native () () ("native") #f 157 19 157 24 ()}
      {Lisp-Entry "set-?" native () () ("native") #f 157 34 157 39 ()}
      {Lisp-Entry "%" native () () ("native") #f 158 8 158 9 ()}
      {Lisp-Entry "get-%" native () () ("native") #f 158 19 158 24 ()}
      {Lisp-Entry "set-%" native () () ("native") #f 158 34 158 39 ()}
      {Lisp-Entry "?a" native () () ("native") #f 161 8 161 10 ()}
      {Lisp-Entry "get-?a" native () () ("native") #f 161 20 161 26 ()}
      {Lisp-Entry "set-?a" native () () ("native") #f 161 36 161 42 ()}
      {Lisp-Entry "?b" native () () ("native") #f 162 8 162 10 ()}
      {Lisp-Entry "get-?b" native () () ("native") #f 162 20 162 26 ()}
      {Lisp-Entry "set-?b" native () () ("native") #f 162 36 162 42 ()}
      {Lisp-Entry "?c" native () () ("native") #f 163 8 163 10 ()}
      {Lisp-Entry "get-?c" native () () ("native") #f 163 20 163 26 ()}
      {Lisp-Entry "set-?c" native () () ("native") #f 163 36 163 42 ()}
      {Lisp-Entry "?d" native () () ("native") #f 164 8 164 10 ()}
      {Lisp-Entry "get-?d" native () () ("native") #f 164 20 164 26 ()}
      {Lisp-Entry "set-?d" native () () ("native") #f 164 36 164 42 ()}
      {Lisp-Entry "?e" native () () ("native") #f 165 8 165 10 ()}
      {Lisp-Entry "get-?e" native () () ("native") #f 165 20 165 26 ()}
      {Lisp-Entry "set-?e" native () () ("native") #f 165 36 165 42 ()}
      {Lisp-Entry "?f" native () () ("native") #f 166 8 166 10 ()}
      {Lisp-Entry "get-?f" native () () ("native") #f 166 20 166 26 ()}
      {Lisp-Entry "set-?f" native () () ("native") #f 166 36 166 42 ()}
      {Lisp-Entry "?g" native () () ("native") #f 167 8 167 10 ()}
      {Lisp-Entry "get-?g" native () () ("native") #f 167 20 167 26 ()}
      {Lisp-Entry "set-?g" native () () ("native") #f 167 36 167 42 ()}
      {Lisp-Entry "?h" native () () ("native") #f 168 8 168 10 ()}
      {Lisp-Entry "get-?h" native () () ("native") #f 168 20 168 26 ()}
      {Lisp-Entry "set-?h" native () () ("native") #f 168 36 168 42 ()}
      {Lisp-Entry "?i" native () () ("native") #f 169 8 169 10 ()}
      {Lisp-Entry "get-?i" native () () ("native") #f 169 20 169 26 ()}
      {Lisp-Entry "set-?i" native () () ("native") #f 169 36 169 42 ()}
      {Lisp-Entry "?j" native () () ("native") #f 170 8 170 10 ()}
      {Lisp-Entry "get-?j" native () () ("native") #f 170 20 170 26 ()}
      {Lisp-Entry "set-?j" native () () ("native") #f 170 36 170 42 ()}
      {Lisp-Entry "?k" native () () ("native") #f 171 8 171 10 ()}
      {Lisp-Entry "get-?k" native () () ("native") #f 171 20 171 26 ()}
      {Lisp-Entry "set-?k" native () () ("native") #f 171 36 171 42 ()}
      {Lisp-Entry "?l" native () () ("native") #f 172 8 172 10 ()}
      {Lisp-Entry "get-?l" native () () ("native") #f 172 20 172 26 ()}
      {Lisp-Entry "set-?l" native () () ("native") #f 172 36 172 42 ()}
      {Lisp-Entry "?m" native () () ("native") #f 173 8 173 10 ()}
      {Lisp-Entry "get-?m" native () () ("native") #f 173 20 173 26 ()}
      {Lisp-Entry "set-?m" native () () ("native") #f 173 36 173 42 ()}
      {Lisp-Entry "?n" native () () ("native") #f 174 8 174 10 ()}
      {Lisp-Entry "get-?n" native () () ("native") #f 174 20 174 26 ()}
      {Lisp-Entry "set-?n" native () () ("native") #f 174 36 174 42 ()}
      {Lisp-Entry "?o" native () () ("native") #f 175 8 175 10 ()}
      {Lisp-Entry "get-?o" native () () ("native") #f 175 20 175 26 ()}
      {Lisp-Entry "set-?o" native () () ("native") #f 175 36 175 42 ()}
      {Lisp-Entry "?p" native () () ("native") #f 176 8 176 10 ()}
      {Lisp-Entry "get-?p" native () () ("native") #f 176 20 176 26 ()}
      {Lisp-Entry "set-?p" native () () ("native") #f 176 36 176 42 ()}
      {Lisp-Entry "?q" native () () ("native") #f 177 8 177 10 ()}
      {Lisp-Entry "get-?q" native () () ("native") #f 177 20 177 26 ()}
      {Lisp-Entry "set-?q" native () () ("native") #f 177 36 177 42 ()}
      {Lisp-Entry "?r" native () () ("native") #f 178 8 178 10 ()}
      {Lisp-Entry "get-?r" native () () ("native") #f 178 20 178 26 ()}
      {Lisp-Entry "set-?r" native () () ("native") #f 178 36 178 42 ()}
      {Lisp-Entry "?s" native () () ("native") #f 179 8 179 10 ()}
      {Lisp-Entry "get-?s" native () () ("native") #f 179 20 179 26 ()}
      {Lisp-Entry "set-?s" native () () ("native") #f 179 36 179 42 ()}
      {Lisp-Entry "?t" native () () ("native") #f 180 8 180 10 ()}
      {Lisp-Entry "get-?t" native () () ("native") #f 180 20 180 26 ()}
      {Lisp-Entry "set-?t" native () () ("native") #f 180 36 180 42 ()}
      {Lisp-Entry "?u" native () () ("native") #f 181 8 181 10 ()}
      {Lisp-Entry "get-?u" native () () ("native") #f 181 20 181 26 ()}
      {Lisp-Entry "set-?u" native () () ("native") #f 181 36 181 42 ()}
      {Lisp-Entry "?v" native () () ("native") #f 182 8 182 10 ()}
      {Lisp-Entry "get-?v" native () () ("native") #f 182 20 182 26 ()}
      {Lisp-Entry "set-?v" native () () ("native") #f 182 36 182 42 ()}
      {Lisp-Entry "?w" native () () ("native") #f 183 8 183 10 ()}
      {Lisp-Entry "get-?w" native () () ("native") #f 183 20 183 26 ()}
      {Lisp-Entry "set-?w" native () () ("native") #f 183 36 183 42 ()}
      {Lisp-Entry "?x" native () () ("native") #f 184 8 184 10 ()}
      {Lisp-Entry "get-?x" native () () ("native") #f 184 20 184 26 ()}
      {Lisp-Entry "set-?x" native () () ("native") #f 184 36 184 42 ()}
      {Lisp-Entry "?y" native () () ("native") #f 185 8 185 10 ()}
      {Lisp-Entry "get-?y" native () () ("native") #f 185 20 185 26 ()}
      {Lisp-Entry "set-?y" native () () ("native") #f 185 36 185 42 ()}
      {Lisp-Entry "?z" native () () ("native") #f 186 8 186 10 ()}
      {Lisp-Entry "get-?z" native () () ("native") #f 186 20 186 26 ()}
      {Lisp-Entry "set-?z" native () () ("native") #f 186 36 186 42 ()}
      {Lisp-Entry "%a" native () () ("native") #f 189 8 189 10 ()}
      {Lisp-Entry "get-%a" native () () ("native") #f 189 20 189 26 ()}
      {Lisp-Entry "set-%a" native () () ("native") #f 189 36 189 42 ()}
      {Lisp-Entry "%b" native () () ("native") #f 190 8 190 10 ()}
      {Lisp-Entry "get-%b" native () () ("native") #f 190 20 190 26 ()}
      {Lisp-Entry "set-%b" native () () ("native") #f 190 36 190 42 ()}
      {Lisp-Entry "%c" native () () ("native") #f 191 8 191 10 ()}
      {Lisp-Entry "get-%c" native () () ("native") #f 191 20 191 26 ()}
      {Lisp-Entry "set-%c" native () () ("native") #f 191 36 191 42 ()}
      {Lisp-Entry "%d" native () () ("native") #f 192 8 192 10 ()}
      {Lisp-Entry "get-%d" native () () ("native") #f 192 20 192 26 ()}
      {Lisp-Entry "set-%d" native () () ("native") #f 192 36 192 42 ()}
      {Lisp-Entry "%e" native () () ("native") #f 193 8 193 10 ()}
      {Lisp-Entry "get-%e" native () () ("native") #f 193 20 193 26 ()}
      {Lisp-Entry "set-%e" native () () ("native") #f 193 36 193 42 ()}
      {Lisp-Entry "%f" native () () ("native") #f 194 8 194 10 ()}
      {Lisp-Entry "get-%f" native () () ("native") #f 194 20 194 26 ()}
      {Lisp-Entry "set-%f" native () () ("native") #f 194 36 194 42 ()}
      {Lisp-Entry "%g" native () () ("native") #f 195 8 195 10 ()}
      {Lisp-Entry "get-%g" native () () ("native") #f 195 20 195 26 ()}
      {Lisp-Entry "set-%g" native () () ("native") #f 195 36 195 42 ()}
      {Lisp-Entry "%h" native () () ("native") #f 196 8 196 10 ()}
      {Lisp-Entry "get-%h" native () () ("native") #f 196 20 196 26 ()}
      {Lisp-Entry "set-%h" native () () ("native") #f 196 36 196 42 ()}
      {Lisp-Entry "%i" native () () ("native") #f 197 8 197 10 ()}
      {Lisp-Entry "get-%i" native () () ("native") #f 197 20 197 26 ()}
      {Lisp-Entry "set-%i" native () () ("native") #f 197 36 197 42 ()}
      {Lisp-Entry "%j" native () () ("native") #f 198 8 198 10 ()}
      {Lisp-Entry "get-%j" native () () ("native") #f 198 20 198 26 ()}
      {Lisp-Entry "set-%j" native () () ("native") #f 198 36 198 42 ()}
      {Lisp-Entry "%k" native () () ("native") #f 199 8 199 10 ()}
      {Lisp-Entry "get-%k" native () () ("native") #f 199 20 199 26 ()}
      {Lisp-Entry "set-%k" native () () ("native") #f 199 36 199 42 ()}
      {Lisp-Entry "%l" native () () ("native") #f 200 8 200 10 ()}
      {Lisp-Entry "get-%l" native () () ("native") #f 200 20 200 26 ()}
      {Lisp-Entry "set-%l" native () () ("native") #f 200 36 200 42 ()}
      {Lisp-Entry "%m" native () () ("native") #f 201 8 201 10 ()}
      {Lisp-Entry "get-%m" native () () ("native") #f 201 20 201 26 ()}
      {Lisp-Entry "set-%m" native () () ("native") #f 201 36 201 42 ()}
      {Lisp-Entry "%n" native () () ("native") #f 202 8 202 10 ()}
      {Lisp-Entry "get-%n" native () () ("native") #f 202 20 202 26 ()}
      {Lisp-Entry "set-%n" native () () ("native") #f 202 36 202 42 ()}
      {Lisp-Entry "%o" native () () ("native") #f 203 8 203 10 ()}
      {Lisp-Entry "get-%o" native () () ("native") #f 203 20 203 26 ()}
      {Lisp-Entry "set-%o" native () () ("native") #f 203 36 203 42 ()}
      {Lisp-Entry "%p" native () () ("native") #f 204 8 204 10 ()}
      {Lisp-Entry "get-%p" native () () ("native") #f 204 20 204 26 ()}
      {Lisp-Entry "set-%p" native () () ("native") #f 204 36 204 42 ()}
      {Lisp-Entry "%q" native () () ("native") #f 205 8 205 10 ()}
      {Lisp-Entry "get-%q" native () () ("native") #f 205 20 205 26 ()}
      {Lisp-Entry "set-%q" native () () ("native") #f 205 36 205 42 ()}
      {Lisp-Entry "%r" native () () ("native") #f 206 8 206 10 ()}
      {Lisp-Entry "get-%r" native () () ("native") #f 206 20 206 26 ()}
      {Lisp-Entry "set-%r" native () () ("native") #f 206 36 206 42 ()}
      {Lisp-Entry "%s" native () () ("native") #f 207 8 207 10 ()}
      {Lisp-Entry "get-%s" native () () ("native") #f 207 20 207 26 ()}
      {Lisp-Entry "set-%s" native () () ("native") #f 207 36 207 42 ()}
      {Lisp-Entry "%t" native () () ("native") #f 208 8 208 10 ()}
      {Lisp-Entry "get-%t" native () () ("native") #f 208 20 208 26 ()}
      {Lisp-Entry "set-%t" native () () ("native") #f 208 36 208 42 ()}
      {Lisp-Entry "%u" native () () ("native") #f 209 8 209 10 ()}
      {Lisp-Entry "get-%u" native () () ("native") #f 209 20 209 26 ()}
      {Lisp-Entry "set-%u" native () () ("native") #f 209 36 209 42 ()}
      {Lisp-Entry "%v" native () () ("native") #f 210 8 210 10 ()}
      {Lisp-Entry "get-%v" native () () ("native") #f 210 20 210 26 ()}
      {Lisp-Entry "set-%v" native () () ("native") #f 210 36 210 42 ()}
      {Lisp-Entry "%w" native () () ("native") #f 211 8 211 10 ()}
      {Lisp-Entry "get-%w" native () () ("native") #f 211 20 211 26 ()}
      {Lisp-Entry "set-%w" native () () ("native") #f 211 36 211 42 ()}
      {Lisp-Entry "%x" native () () ("native") #f 212 8 212 10 ()}
      {Lisp-Entry "get-%x" native () () ("native") #f 212 20 212 26 ()}
      {Lisp-Entry "set-%x" native () () ("native") #f 212 36 212 42 ()}
      {Lisp-Entry "%y" native () () ("native") #f 213 8 213 10 ()}
      {Lisp-Entry "get-%y" native () () ("native") #f 213 20 213 26 ()}
      {Lisp-Entry "set-%y" native () () ("native") #f 213 36 213 42 ()}
      {Lisp-Entry "%z" native () () ("native") #f 214 8 214 10 ()}
      {Lisp-Entry "get-%z" native () () ("native") #f 214 20 214 26 ()}
      {Lisp-Entry "set-%z" native () () ("native") #f 214 36 214 42 ()}
      {Lisp-Entry "open-digest" native () () ("native") #f 222 8 222 19 ()}
      {Lisp-Entry "close-digest" native () () ("native") #f 223 8 223 20 ()}
      {Lisp-Entry "digest-update-subu8vector" native () () ("native") #f 224 8 224 33 ()}
      {Lisp-Entry "digest-string" native () () ("native") #f 225 8 225 21 ()}
      {Lisp-Entry "digest-substring" native () () ("native") #f 226 8 226 24 ()}
      {Lisp-Entry "digest-u8vector" native () () ("native") #f 227 8 227 23 ()}
      {Lisp-Entry "digest-subu8vector" native () () ("native") #f 228 8 228 26 ()}
      {Lisp-Entry "digest-file" native () () ("native") #f 229 8 229 19 ()}
      {Lisp-Entry "enumerator?" native () () ("native") #f 237 8 237 24 ()}
      {Lisp-Entry "enumerator->symbol" native () () ("native") #f 238 8 238 31 ()}
      {Lisp-Entry "symbol->enumerator" native () () ("native") #f 239 8 239 31 ()}
      {Lisp-Entry "exception-reason" native () () ("native") #f 247 8 247 29 ()}
      {Lisp-Entry "exception-detail" native () () ("native") #f 248 8 248 29 ()}
      {Lisp-Entry "exception-location" native () () ("native") #f 249 8 249 31 ()}
      {Lisp-Entry "display-exception" native () () ("native") #f 250 8 250 30 ()}
      {Lisp-Entry "display-continuation-backtrace" native () () ("native") #f 251 8 251 43 ()}
      {Lisp-Entry "get-exception-hook" native () () ("native") #f 252 8 252 31 ()}
      {Lisp-Entry "set-exception-hook" native () () ("native") #f 253 8 253 31 ()}
      {Lisp-Entry "invoke-exception-hook" native () () ("native") #f 254 8 254 34 ()}
      {Lisp-Entry "system-exception-hook" native () () ("native") #f 255 8 255 34 ()}
      {Lisp-Entry "current-exception-handler" native () () ("native") #f 256 8 256 38 ()}
      {Lisp-Entry "with-exception-handler" native () () ("native") #f 257 8 257 35 ()}
      {Lisp-Entry "with-exception-catcher" native () () ("native") #f 258 8 258 35 ()}
      {Lisp-Entry "with-exception-filter" native () () ("native") #f 259 8 259 34 ()}
      {Lisp-Entry "with-exception-propagater" native () () ("native") #f 260 8 260 38 ()}
      {Lisp-Entry "dump-exception" native () () ("native") #f 261 8 261 27 ()}
      {Lisp-Entry "raise" native () () ("native") #f 262 8 262 18 ()}
      {Lisp-Entry "field?" native () () ("native") "<object:bool>" 270 8 270 19 ("object:bool" "<object:bool>")}
      {Lisp-Entry "field-name" native () () ("native") #f 271 8 271 23 ()}
      {Lisp-Entry "category-field" native () () ("native") #f 272 8 272 27 ()}
      {Lisp-Entry "add-field" native () () ("native") #f 273 8 273 22 ()}
      {Lisp-Entry "fixnum?" native () () ("native") "<object:bool>" 281 8 281 15 ("object:bool" "<object:bool>")}
      {Lisp-Entry "flonum?" native () () ("native") "<object:bool>" 282 8 282 15 ("object:bool" "<object:bool>")}
      {Lisp-Entry "fixnum->flonum" native () () ("native") "<fx:fl>" 283 8 283 27 ("fx:fl" "<fx:fl>")}
      {Lisp-Entry "flonum->fixnum" native () () ("native") "<fl:fx>" 284 8 284 27 ("fl:fx" "<fl:fx>")}
      {Lisp-Entry "fx+" native () () ("native") "<fx^fx:fx>" 285 8 285 11 ("fx^fx:fx" "<fx^fx:fx>")}
      {Lisp-Entry "fx-" native () () ("native") "<fx^fx:fx>" 286 8 286 11 ("fx^fx:fx" "<fx^fx:fx>")}
      {Lisp-Entry "fx*" native () () ("native") "<fx^fx:fx>" 287 8 287 11 ("fx^fx:fx" "<fx^fx:fx>")}
      {Lisp-Entry "+infinity" native () () ("native") #f 288 8 288 22 ()}
      {Lisp-Entry "-infinity" native () () ("native") #f 289 8 289 22 ()}
      {Lisp-Entry "fxmodulo" native () () ("native") #f 290 8 290 16 ()}
      {Lisp-Entry "fxquotient" native () () ("native") #f 291 8 291 18 ()}
      {Lisp-Entry "sharp/sharp/fl+" native (undocumented) () ("native") "<fl^fl:fl>" 301 21 301 41 ("fl^fl:fl" "<fl^fl:fl>")}
      {Lisp-Entry "sharp/sharp/fl-" native (undocumented) () ("native") "<fl^fl:fl>" 302 21 302 41 ("fl^fl:fl" "<fl^fl:fl>")}
      {Lisp-Entry "sharp/sharp/fl*" native (undocumented) () ("native") "<fl^fl:fl>" 303 21 303 41 ("fl^fl:fl" "<fl^fl:fl>")}
      {Lisp-Entry "sharp/sharp/fl/" native (undocumented) () ("native") "<fl^fl:fl>" 304 21 304 41 ("fl^fl:fl" "<fl^fl:fl>")}
      {Lisp-Entry "foreign?" native () () ("native") #f 312 8 312 21 ()}
      {Lisp-Entry "foreign-address" native () () ("native") #f 313 8 313 28 ()}
      {Lisp-Entry "foreign-release!" native () () ("native") #f 314 8 314 29 ()}
      {Lisp-Entry "foreign-released?" native () () ("native") #f 315 8 315 30 ()}
      {Lisp-Entry "foreign-tags" native () () ("native") #f 316 8 316 25 ()}
      {Lisp-Entry "still-obj-refcount-dec!" native () () ("native") #f 318 8 318 36 ()}
      {Lisp-Entry "still-obj-refcount-inc!" native () () ("native") #f 319 8 319 36 ()}
      {Lisp-Entry "base64-string->u8vector" native () () ("native") #f 327 8 327 31 ()}
      {Lisp-Entry "base64-substring->u8vector" native () () ("native") #f 328 8 328 34 ()}
      {Lisp-Entry "compile-file" native () () ("native") #f 329 8 329 20 ()}
      {Lisp-Entry "compile-file-to-c" native () () ("native") #f 330 8 330 25 ()}
      {Lisp-Entry "datum-parsing-exception?" native () () ("native") #f 331 8 331 32 ()}
      {Lisp-Entry "inactive-thread-exception?" native () () ("native") #f 332 8 332 34 ()}
      {Lisp-Entry "fxwrap*" native () () ("native") #f 333 8 333 15 ()}
      {Lisp-Entry "fxwrap+" native () () ("native") #f 334 8 334 15 ()}
      {Lisp-Entry "fxwrap-" native () () ("native") #f 335 8 335 15 ()}
      {Lisp-Entry "subu8vector->base64-string" native () () ("native") #f 336 8 336 34 ()}
      {Lisp-Entry "u8vector->base64-string" native () () ("native") #f 337 8 337 31 ()}
      {Lisp-Entry "object->string" native () () ("native") #f 338 8 338 22 ()}
      {Lisp-Entry "os-exception-arguments" native () () ("native") #f 339 8 339 30 ()}
      {Lisp-Entry "os-exception-code" native () () ("native") #f 340 8 340 25 ()}
      {Lisp-Entry "os-exception-message" native () () ("native") #f 341 8 341 28 ()}
      {Lisp-Entry "os-exception-procedure" native () () ("native") #f 342 8 342 30 ()}
      {Lisp-Entry "os-exception?" native () () ("native") #f 343 8 343 21 ()}
      {Lisp-Entry "s8vector" native () () ("native") #f 352 8 352 16 ()}
      {Lisp-Entry "make-s8vector" native () () ("native") #f 353 8 353 21 ()}
      {Lisp-Entry "s8vector-length" native () () ("native") #f 354 8 354 23 ()}
      {Lisp-Entry "s8vector-ref" native () () ("native") #f 355 8 355 20 ()}
      {Lisp-Entry "s8vector-set!" native () () ("native") #f 356 8 356 21 ()}
      {Lisp-Entry "s8vector?" native () () ("native") #f 357 8 357 17 ()}
      {Lisp-Entry "s8vector->list" native () () ("native") #f 358 8 358 22 ()}
      {Lisp-Entry "list->s8vector" native () () ("native") #f 359 8 359 22 ()}
      {Lisp-Entry "u8vector" native () () ("native") #f 362 8 362 16 ()}
      {Lisp-Entry "make-u8vector" native () () ("native") #f 363 8 363 21 ()}
      {Lisp-Entry "u8vector-length" native () () ("native") #f 364 8 364 23 ()}
      {Lisp-Entry "u8vector-ref" native () () ("native") #f 365 8 365 20 ()}
      {Lisp-Entry "u8vector-set!" native () () ("native") #f 366 8 366 21 ()}
      {Lisp-Entry "u8vector?" native () () ("native") #f 367 8 367 17 ()}
      {Lisp-Entry "u8vector->list" native () () ("native") #f 368 8 368 22 ()}
      {Lisp-Entry "list->u8vector" native () () ("native") #f 369 8 369 22 ()}
      {Lisp-Entry "u8vector->object" native () () ("native") #f 370 8 370 24 ()}
      {Lisp-Entry "object->u8vector" native () () ("native") #f 371 8 371 24 ()}
      {Lisp-Entry "u8vector-shrink!" native () () ("native") #f 372 8 372 24 ()}
      {Lisp-Entry "append-u8vectors" native () () ("native") #f 373 8 373 24 ()}
      {Lisp-Entry "s16vector" native () () ("native") #f 376 8 376 17 ()}
      {Lisp-Entry "make-s16vector" native () () ("native") #f 377 8 377 22 ()}
      {Lisp-Entry "s16vector-length" native () () ("native") #f 378 8 378 24 ()}
      {Lisp-Entry "s16vector-ref" native () () ("native") #f 379 8 379 21 ()}
      {Lisp-Entry "s16vector-set!" native () () ("native") #f 380 8 380 22 ()}
      {Lisp-Entry "s16vector?" native () () ("native") #f 381 8 381 18 ()}
      {Lisp-Entry "s16vector->list" native () () ("native") #f 382 8 382 23 ()}
      {Lisp-Entry "list->s16vector" native () () ("native") #f 383 8 383 23 ()}
      {Lisp-Entry "u16vector" native () () ("native") #f 386 8 386 17 ()}
      {Lisp-Entry "make-u16vector" native () () ("native") #f 387 8 387 22 ()}
      {Lisp-Entry "u16vector-length" native () () ("native") #f 388 8 388 24 ()}
      {Lisp-Entry "u16vector-ref" native () () ("native") #f 389 8 389 21 ()}
      {Lisp-Entry "u16vector-set!" native () () ("native") #f 390 8 390 22 ()}
      {Lisp-Entry "u16vector?" native () () ("native") #f 391 8 391 18 ()}
      {Lisp-Entry "u16vector->list" native () () ("native") #f 392 8 392 23 ()}
      {Lisp-Entry "list->u16vector" native () () ("native") #f 393 8 393 23 ()}
      {Lisp-Entry "s32vector" native () () ("native") #f 396 8 396 17 ()}
      {Lisp-Entry "make-s32vector" native () () ("native") #f 397 8 397 22 ()}
      {Lisp-Entry "s32vector-length" native () () ("native") #f 398 8 398 24 ()}
      {Lisp-Entry "s32vector-ref" native () () ("native") #f 399 8 399 21 ()}
      {Lisp-Entry "s32vector-set!" native () () ("native") #f 400 8 400 22 ()}
      {Lisp-Entry "s32vector?" native () () ("native") #f 401 8 401 18 ()}
      {Lisp-Entry "s32vector->list" native () () ("native") #f 402 8 402 23 ()}
      {Lisp-Entry "list->s32vector" native () () ("native") #f 403 8 403 23 ()}
      {Lisp-Entry "u32vector" native () () ("native") #f 406 8 406 17 ()}
      {Lisp-Entry "make-u32vector" native () () ("native") #f 407 8 407 22 ()}
      {Lisp-Entry "u32vector-length" native () () ("native") #f 408 8 408 24 ()}
      {Lisp-Entry "u32vector-ref" native () () ("native") #f 409 8 409 21 ()}
      {Lisp-Entry "u32vector-set!" native () () ("native") #f 410 8 410 22 ()}
      {Lisp-Entry "u32vector?" native () () ("native") #f 411 8 411 18 ()}
      {Lisp-Entry "u32vector->list" native () () ("native") #f 412 8 412 23 ()}
      {Lisp-Entry "list->u32vector" native () () ("native") #f 413 8 413 23 ()}
      {Lisp-Entry "s64vector" native () () ("native") #f 416 8 416 17 ()}
      {Lisp-Entry "make-s64vector" native () () ("native") #f 417 8 417 22 ()}
      {Lisp-Entry "s64vector-length" native () () ("native") #f 418 8 418 24 ()}
      {Lisp-Entry "s64vector-ref" native () () ("native") #f 419 8 419 21 ()}
      {Lisp-Entry "s64vector-set!" native () () ("native") #f 420 8 420 22 ()}
      {Lisp-Entry "s64vector?" native () () ("native") #f 421 8 421 18 ()}
      {Lisp-Entry "s64vector->list" native () () ("native") #f 422 8 422 23 ()}
      {Lisp-Entry "list->s64vector" native () () ("native") #f 423 8 423 23 ()}
      {Lisp-Entry "u64vector" native () () ("native") #f 426 8 426 17 ()}
      {Lisp-Entry "make-u64vector" native () () ("native") #f 427 8 427 22 ()}
      {Lisp-Entry "u64vector-length" native () () ("native") #f 428 8 428 24 ()}
      {Lisp-Entry "u64vector-ref" native () () ("native") #f 429 8 429 21 ()}
      {Lisp-Entry "u64vector-set!" native () () ("native") #f 430 8 430 22 ()}
      {Lisp-Entry "u64vector?" native () () ("native") #f 431 8 431 18 ()}
      {Lisp-Entry "u64vector->list" native () () ("native") #f 432 8 432 23 ()}
      {Lisp-Entry "list->u64vector" native () () ("native") #f 433 8 433 23 ()}
      {Lisp-Entry "f32vector" native () () ("native") #f 436 8 436 17 ()}
      {Lisp-Entry "make-f32vector" native () () ("native") #f 437 8 437 22 ()}
      {Lisp-Entry "f32vector-length" native () () ("native") #f 438 8 438 24 ()}
      {Lisp-Entry "f32vector-ref" native () () ("native") #f 439 8 439 21 ()}
      {Lisp-Entry "f32vector-set!" native () () ("native") #f 440 8 440 22 ()}
      {Lisp-Entry "f32vector?" native () () ("native") #f 441 8 441 18 ()}
      {Lisp-Entry "f32vector->list" native () () ("native") #f 442 8 442 23 ()}
      {Lisp-Entry "list->f32vector" native () () ("native") #f 443 8 443 23 ()}
      {Lisp-Entry "f64vector" native () () ("native") #f 446 8 446 17 ()}
      {Lisp-Entry "make-f64vector" native () () ("native") #f 447 8 447 22 ()}
      {Lisp-Entry "f64vector-length" native () () ("native") #f 448 8 448 24 ()}
      {Lisp-Entry "f64vector-ref" native () () ("native") #f 449 8 449 21 ()}
      {Lisp-Entry "f64vector-set!" native () () ("native") #f 450 8 450 22 ()}
      {Lisp-Entry "f64vector?" native () () ("native") #f 451 8 451 18 ()}
      {Lisp-Entry "f64vector->list" native () () ("native") #f 452 8 452 23 ()}
      {Lisp-Entry "list->f64vector" native () () ("native") #f 453 8 453 23 ()}
      {Lisp-Entry "command-line" native () () ("native") #f 461 8 461 20 ()}
      {Lisp-Entry "user-name" native () () ("native") #f 462 8 462 17 ()}
      {Lisp-Entry "host-name" native () () ("native") #f 463 8 463 17 ()}
      {Lisp-Entry "composite-identifier?" native () () ("native") #f 471 8 471 34 ()}
      {Lisp-Entry "composite-reference?" native () () ("native") #f 472 8 472 33 ()}
      {Lisp-Entry "compose-identifier" native () () ("native") #f 473 8 473 31 ()}
      {Lisp-Entry "compose-reference" native () () ("native") #f 474 8 474 30 ()}
      {Lisp-Entry "split-symbol" native () () ("native") #f 475 8 475 25 ()}
      {Lisp-Entry "split-identifier" native () () ("native") #f 476 8 476 29 ()}
      {Lisp-Entry "split-reference" native () () ("native") #f 477 8 477 28 ()}
      {Lisp-Entry "break-reference" native () () ("native") #f 478 8 478 28 ()}
      {Lisp-Entry "identifier-name" native () () ("native") "<symbol>" 479 8 479 28 ("symbol" "<symbol>")}
      {Lisp-Entry "reference-unit" native () () ("native") "<symbol>" 480 8 480 27 ("symbol" "<symbol>")}
      {Lisp-Entry "reference-name" native () () ("native") "<symbol>" 481 8 481 27 ("symbol" "<symbol>")}
      {Lisp-Entry "bitwise-not" native () () ("native") "<int:int>" 497 8 497 19 ("int:int" "<int:int>")}
      {Lisp-Entry "bitwise-and" native () () ("native") "<int*:int>" 498 8 498 19 ("int*:int" "<int*:int>")}
      {Lisp-Entry "bitwise-ior" native () () ("native") "<int*:int>" 499 8 499 19 ("int*:int" "<int*:int>")}
      {Lisp-Entry "bitwise-xor" native () () ("native") "<int*:int>" 500 8 500 19 ("int*:int" "<int*:int>")}
      {Lisp-Entry "arithmetic-shift" native () () ("native") "<int:int>" 501 8 501 24 ("int:int" "<int:int>")}
      {Lisp-Entry "bit-set?" native () () ("native") "<int^int:bool>" 502 8 502 16 ("int^int:bool" "<int^int:bool>")}
      {Lisp-Entry "extract-bit-field" native () () ("native") "<int^int^int:int>" 503 8 503 25 ("int^int^int:int" "<int^int^int:int>")}
      {Lisp-Entry "build-feedback" native () () ("native") #f 511 8 511 27 ()}
      {Lisp-Entry "boot-directory" native () () ("native") #f 512 8 512 27 ()}
      {Lisp-Entry "kernel-system" native () () ("native") #f 513 8 513 26 ()}
      {Lisp-Entry "kernel-platform" native () () ("native") #f 514 8 514 28 ()}
      {Lisp-Entry "kernel-windowing" native () () ("native") #f 515 8 515 29 ()}
      {Lisp-Entry "kernel-safety" native () () ("native") #f 516 8 516 26 ()}
      {Lisp-Entry "kernel-optimize?" native () () ("native") #f 517 8 517 29 ()}
      {Lisp-Entry "kernel-debug-environments?" native () () ("native") #f 518 8 518 39 ()}
      {Lisp-Entry "kernel-debug-location?" native () () ("native") #f 519 8 519 35 ()}
      {Lisp-Entry "kernel-debug-source?" native () () ("native") #f 520 8 520 33 ()}
      {Lisp-Entry "kernel-mutable-bindings?" native () () ("native") #f 521 8 521 37 ()}
      {Lisp-Entry "kernel-destination" native () () ("native") #f 522 8 522 31 ()}
      {Lisp-Entry "kernel-built" native () () ("native") #f 523 8 523 25 ()}
      {Lisp-Entry "kernel-install" native () () ("native") #f 524 8 524 27 ()}
      {Lisp-Entry "kernel-source" native () () ("native") #f 525 8 525 26 ()}
      {Lisp-Entry "kernel-source-access?" native () () ("native") #f 526 8 526 34 ()}
      {Lisp-Entry "kernel-version" native () () ("native") #f 527 8 527 27 ()}
      {Lisp-Entry "get-jazz-version-number" native () () ("native") #f 528 8 528 36 ()}
      {Lisp-Entry "jazz-settings-directory" native () () ("native") #f 529 8 529 36 ()}
      {Lisp-Entry "jazz-settings-version" native () () ("native") #f 530 8 530 34 ()}
      {Lisp-Entry "list->updates" native () () ("native") #f 531 8 531 26 ()}
      {Lisp-Entry "update-version" native () () ("native") #f 532 8 532 27 ()}
      {Lisp-Entry "update-targets" native () () ("native") #f 533 8 533 27 ()}
      {Lisp-Entry "update-description" native () () ("native") #f 534 8 534 31 ()}
      {Lisp-Entry "versioned-directory" native () () ("native") #f 535 8 535 32 ()}
      {Lisp-Entry "platform-eol-encoding" native () () ("native") #f 536 8 536 34 ()}
      {Lisp-Entry "load-debuggee-units" native () () ("native") #f 537 8 537 32 ()}
      {Lisp-Entry "jazz-product" native () () ("native") #f 538 8 538 25 ()}
      {Lisp-Entry "jazz-profile" native () () ("native") #f 539 8 539 25 ()}
      {Lisp-Entry "warn-interpreted?" native () () ("native") #f 540 8 540 30 ()}
      {Lisp-Entry "force-interpreted?" native () () ("native") #f 541 8 541 31 ()}
      {Lisp-Entry "delay-reporting?" native () () ("native") #f 542 8 542 29 ()}
      {Lisp-Entry "use-print?" native () () ("native") #f 543 8 543 23 ()}
      {Lisp-Entry "use-debugger?" native () () ("native") #f 544 8 544 26 ()}
      {Lisp-Entry "get-repositories" native () () ("native") #f 545 8 545 29 ()}
      {Lisp-Entry "get-build-repository" native () () ("native") #f 546 8 546 33 ()}
      {Lisp-Entry "make-repository" native () () ("native") #f 547 8 547 28 ()}
      {Lisp-Entry "install-repository" native () () ("native") #f 548 8 548 31 ()}
      {Lisp-Entry "uninstall-repository" native () () ("native") #f 549 8 549 33 ()}
      {Lisp-Entry "find-repository" native () () ("native") #f 550 8 550 28 ()}
      {Lisp-Entry "find-package" native () () ("native") #f 551 8 551 25 ()}
      {Lisp-Entry "repository?" native () () ("native") #f 552 8 552 24 ()}
      {Lisp-Entry "repository-name" native () () ("native") #f 553 8 553 28 ()}
      {Lisp-Entry "repository-title" native () () ("native") #f 554 8 554 29 ()}
      {Lisp-Entry "repository-directory" native () () ("native") #f 555 8 555 33 ()}
      {Lisp-Entry "repository-library-root" native () () ("native") #f 556 8 556 36 ()}
      {Lisp-Entry "repository-library-directory" native () () ("native") #f 557 8 557 41 ()}
      {Lisp-Entry "repository-binary?" native () () ("native") #f 558 8 558 31 ()}
      {Lisp-Entry "repository-packages" native () () ("native") #f 559 8 559 32 ()}
      {Lisp-Entry "repository-find-package" native () () ("native") #f 560 8 560 36 ()}
      {Lisp-Entry "repository-install-packages" native () () ("native") #f 561 8 561 40 ()}
      {Lisp-Entry "repository-add-package" native () () ("native") #f 562 8 562 35 ()}
      {Lisp-Entry "repository-remove-package" native () () ("native") #f 563 8 563 38 ()}
      {Lisp-Entry "package?" native () () ("native") #f 564 8 564 21 ()}
      {Lisp-Entry "package-repository" native () () ("native") #f 565 8 565 31 ()}
      {Lisp-Entry "package-name" native () () ("native") #f 566 8 566 25 ()}
      {Lisp-Entry "package-root" native () () ("native") #f 567 8 567 25 ()}
      {Lisp-Entry "package-pathname" native () () ("native") #f 568 8 568 29 ()}
      {Lisp-Entry "package-root-pathname" native () () ("native") #f 569 8 569 34 ()}
      {Lisp-Entry "package-directory" native () () ("native") #f 570 8 570 30 ()}
      {Lisp-Entry "package-products" native () () ("native") #f 571 8 571 29 ()}
      {Lisp-Entry "package-profiles" native () () ("native") #f 572 8 572 29 ()}
      {Lisp-Entry "package-profiles-set!" native () () ("native") #f 573 8 573 34 ()}
      {Lisp-Entry "package-project" native () () ("native") #f 574 8 574 28 ()}
      {Lisp-Entry "split-version" native () () ("native") #f 575 8 575 26 ()}
      {Lisp-Entry "present-version" native () () ("native") #f 576 8 576 28 ()}
      {Lisp-Entry "load-package" native () () ("native") #f 577 8 577 25 ()}
      {Lisp-Entry "register-product" native () () ("native") #f 578 8 578 29 ()}
      {Lisp-Entry "register-product-run" native () () ("native") #f 579 8 579 33 ()}
      {Lisp-Entry "get-product-descriptor" native () () ("native") #f 580 8 580 35 ()}
      {Lisp-Entry "find-product-descriptor" native () () ("native") #f 581 8 581 36 ()}
      {Lisp-Entry "product-descriptor-name" native () () ("native") #f 582 8 582 36 ()}
      {Lisp-Entry "product-descriptor-unit" native () () ("native") #f 583 8 583 36 ()}
      {Lisp-Entry "product-descriptor-title" native () () ("native") #f 584 8 584 37 ()}
      {Lisp-Entry "product-descriptor-icon" native () () ("native") #f 585 8 585 36 ()}
      {Lisp-Entry "product-descriptor-run" native () () ("native") #f 586 8 586 35 ()}
      {Lisp-Entry "product-descriptor-update" native () () ("native") #f 587 8 587 38 ()}
      {Lisp-Entry "product-descriptor-build" native () () ("native") #f 588 8 588 37 ()}
      {Lisp-Entry "product-descriptor-dependencies" native () () ("native") #f 589 8 589 44 ()}
      {Lisp-Entry "run-product-descriptor" native () () ("native") #f 590 8 590 35 ()}
      {Lisp-Entry "update-product-descriptor" native () () ("native") #f 591 8 591 38 ()}
      {Lisp-Entry "build-product-descriptor" native () () ("native") #f 592 8 592 37 ()}
      {Lisp-Entry "current-process-name" native () () ("native") #f 593 8 593 33 ()}
      {Lisp-Entry "current-process-name-set!" native () () ("native") #f 594 8 594 38 ()}
      {Lisp-Entry "current-process-title" native () () ("native") #f 595 8 595 34 ()}
      {Lisp-Entry "current-process-title-set!" native () () ("native") #f 596 8 596 39 ()}
      {Lisp-Entry "current-process-traits" native () () ("native") #f 597 8 597 35 ()}
      {Lisp-Entry "current-process-traits-set!" native () () ("native") #f 598 8 598 40 ()}
      {Lisp-Entry "current-process-icon" native () () ("native") #f 599 8 599 33 ()}
      {Lisp-Entry "current-process-icon-set!" native () () ("native") #f 600 8 600 38 ()}
      {Lisp-Entry "current-process-version" native () () ("native") #f 601 8 601 36 ()}
      {Lisp-Entry "current-process-version-set!" native () () ("native") #f 602 8 602 41 ()}
      {Lisp-Entry "current-process-present" native () () ("native") #f 603 8 603 36 ()}
      {Lisp-Entry "destination-directory" native () () ("native") #f 604 8 604 34 ()}
      {Lisp-Entry "executable-extension" native () () ("native") #f 605 8 605 33 ()}
      {Lisp-Entry "quote-pathname" native () () ("native") #f 606 8 606 27 ()}
      {Lisp-Entry "run-product" native () () ("native") #f 607 8 607 24 ()}
      {Lisp-Entry "update-product" native () () ("native") #f 608 8 608 27 ()}
      {Lisp-Entry "build-product" native () () ("native") #f 609 8 609 26 ()}
      {Lisp-Entry "install-product" native () () ("native") #f 610 8 610 28 ()}
      {Lisp-Entry "install-directory" native () () ("native") #f 611 8 611 30 ()}
      {Lisp-Entry "descendant-unit?" native () () ("native") #f 612 8 612 29 ()}
      {Lisp-Entry "find-pathname-unit" native () () ("native") #f 613 8 613 31 ()}
      {Lisp-Entry "find-unit-src" native () () ("native") #f 614 8 614 26 ()}
      {Lisp-Entry "gather-profiles" native () () ("native") #f 615 8 615 28 ()}
      {Lisp-Entry "make-profile" native () () ("native") #f 616 8 616 25 ()}
      {Lisp-Entry "profile-name" native () () ("native") #f 617 8 617 25 ()}
      {Lisp-Entry "profile-title" native () () ("native") #f 618 8 618 26 ()}
      {Lisp-Entry "profile-unit" native () () ("native") #f 619 8 619 25 ()}
      {Lisp-Entry "get-environment" native () () ("native") #f 620 8 620 28 ()}
      {Lisp-Entry "get-environment-unit" native () () ("native") #f 621 8 621 33 ()}
      {Lisp-Entry "unit-loaded?" native () () ("native") #f 622 8 622 25 ()}
      {Lisp-Entry "unit-status" native () () ("native") #f 623 8 623 24 ()}
      {Lisp-Entry "unit-uptodate-binary?" native () () ("native") #f 624 8 624 34 ()}
      {Lisp-Entry "load-unit" native () () ("native") #f 625 8 625 22 ()}
      {Lisp-Entry "script-arguments" native () () ("native") #f 626 8 626 29 ()}
      {Lisp-Entry "load-script" native () () ("native") #f 627 8 627 24 ()}
      {Lisp-Entry "unload-unit" native () () ("native") #f 628 8 628 24 ()}
      {Lisp-Entry "reload-unit" native () () ("native") #f 629 8 629 24 ()}
      {Lisp-Entry "get-load-mutex" native () () ("native") #f 630 8 630 27 ()}
      {Lisp-Entry "get-load-thread" native () () ("native") #f 631 8 631 28 ()}
      {Lisp-Entry "get-load-stack" native () () ("native") #f 632 8 632 27 ()}
      {Lisp-Entry "get-modules" native () () ("native") #f 633 8 633 24 ()}
      {Lisp-Entry "get-module" native () () ("native") #f 634 8 634 23 ()}
      {Lisp-Entry "require-module" native () () ("native") #f 635 8 635 27 ()}
      {Lisp-Entry "module-get" native () () ("native") #f 636 8 636 23 ()}
      {Lisp-Entry "module-ref" native () () ("native") #f 637 8 637 23 ()}
      {Lisp-Entry "module-set!" native () () ("native") #f 638 8 638 24 ()}
      {Lisp-Entry "walk-literal" native () () ("native") #f 639 8 639 25 ()}
      {Lisp-Entry "walk-for" native () () ("native") #f 640 8 640 21 ()}
      {Lisp-Entry "register-service" native () () ("native") #f 641 8 641 29 ()}
      {Lisp-Entry "get-service" native () () ("native") #f 642 8 642 24 ()}
      {Lisp-Entry "require-service" native () () ("native") #f 643 8 643 28 ()}
      {Lisp-Entry "global-bound?" native () () ("native") #f 644 8 644 26 ()}
      {Lisp-Entry "global-ref" native () () ("native") #f 645 8 645 23 ()}
      {Lisp-Entry "global-set!" native () () ("native") #f 646 8 646 24 ()}
      {Lisp-Entry "testing?" native () () ("native") #f 647 8 647 21 ()}
      {Lisp-Entry "testing" native () () ("native") #f 648 8 648 20 ()}
      {Lisp-Entry "generate-symbol-for" native () () ("native") #f 649 8 649 32 ()}
      {Lisp-Entry "generate-symbol-context" native () () ("native") #f 650 8 650 36 ()}
      {Lisp-Entry "generate-symbol-counter" native () () ("native") #f 651 8 651 36 ()}
      {Lisp-Entry "image-load-counter" native () () ("native") #f 652 8 652 31 ()}
      {Lisp-Entry "object-load-counter" native () () ("native") #f 653 8 653 32 ()}
      {Lisp-Entry "interpreted-load-counter" native () () ("native") #f 654 8 654 37 ()}
      {Lisp-Entry "set-crash-reporter" native () () ("native") #f 655 8 655 31 ()}
      {Lisp-Entry "crash-process" native () () ("native") #f 656 8 656 26 ()}
      {Lisp-Entry "invoke-process" native () () ("native") #f 657 8 657 27 ()}
      {Lisp-Entry "call-process" native () () ("native") #f 658 8 658 25 ()}
      {Lisp-Entry "load-foundation" native () () ("native") #f 659 8 659 28 ()}
      {Lisp-Entry "load-build" native () () ("native") #f 660 8 660 23 ()}
      {Lisp-Entry "split-command-line" native () () ("native") #f 661 8 661 31 ()}
      {Lisp-Entry "get-option" native () () ("native") #f 662 8 662 23 ()}
      {Lisp-Entry "main" native () () ("native") #f 663 8 663 12 ()}
      {Lisp-Entry "keyword?" native () () ("native") #f 671 8 671 21 ()}
      {Lisp-Entry "string->keyword" native () () ("native") #f 672 8 672 28 ()}
      {Lisp-Entry "keyword->string" native () () ("native") #f 673 8 673 28 ()}
      {Lisp-Entry "not-null?" native () () ("native") #f 681 8 681 22 ()}
      {Lisp-Entry "listify" native () () ("native") #f 682 8 682 20 ()}
      {Lisp-Entry "list-copy" native () () ("native") #f 683 8 683 22 ()}
      {Lisp-Entry "last-pair" native () () ("native") #f 684 8 684 22 ()}
      {Lisp-Entry "proper-list" native () () ("native") #f 685 8 685 24 ()}
      {Lisp-Entry "gc" native () () ("native") #f 693 8 693 15 ()}
      {Lisp-Entry "gc-report-set!" native () () ("native") #f 694 8 694 27 ()}
      {Lisp-Entry "gc-count" native () () ("native") #f 695 8 695 21 ()}
      {Lisp-Entry "process-memory" native () () ("native") #f 696 8 696 27 ()}
      {Lisp-Entry "symbols-memory" native () () ("native") #f 697 8 697 27 ()}
      {Lisp-Entry "classes-statistics" native () () ("native") #f 698 8 698 31 ()}
      {Lisp-Entry "vector-size" native () () ("native") #f 699 8 699 24 ()}
      {Lisp-Entry "f64vector-size" native () () ("native") #f 700 8 700 27 ()}
      {Lisp-Entry "list-size" native () () ("native") #f 701 8 701 22 ()}
      {Lisp-Entry "table-size" native () () ("native") #f 702 8 702 23 ()}
      {Lisp-Entry "open-tcp-client" native () () ("native") #f 710 8 710 28 ()}
      {Lisp-Entry "open-tcp-server" native () () ("native") #f 711 8 711 28 ()}
      {Lisp-Entry "tcp-server-socket-info" native () () ("native") #f 712 8 712 35 ()}
      {Lisp-Entry "call-with-tcp-client" native () () ("native") #f 713 8 713 33 ()}
      {Lisp-Entry "new" native () () ("native") #f 721 8 721 16 ()}
      {Lisp-Entry "nascent-new" native () () ("native") #f 722 8 722 24 ()}
      {Lisp-Entry "class-of" native () () ("native") #f 723 8 723 21 ()}
      {Lisp-Entry "object?" native () () ("native") #f 724 8 724 20 ()}
      {Lisp-Entry "type?" native () () ("native") #f 725 8 725 18 ()}
      {Lisp-Entry "category?" native () () ("native") #f 726 8 726 22 ()}
      {Lisp-Entry "interface?" native () () ("native") #f 727 8 727 23 ()}
      {Lisp-Entry "method?" native () () ("native") #f 728 8 728 20 ()}
      {Lisp-Entry "is?" native () () ("native") #f 729 8 729 16 ()}
      {Lisp-Entry "subtype?" native () () ("native") #f 730 8 730 21 ()}
      {Lisp-Entry "subcategory?" native () () ("native") #f 731 8 731 25 ()}
      {Lisp-Entry "subclass?" native () () ("native") #f 732 8 732 22 ()}
      {Lisp-Entry "iterate-class-overrides" native () () ("native") #f 733 8 733 36 ()}
      {Lisp-Entry "update-method" native () () ("native") #f 734 8 734 26 ()}
      {Lisp-Entry "make-parameter" native () () ("native") #f 742 8 742 22 ()}
      {Lisp-Entry "pathname-type" native () () ("native") #f 750 8 750 26 ()}
      {Lisp-Entry "pathname-expand" native () () ("native") #f 751 8 751 28 ()}
      {Lisp-Entry "pathname-normalize" native () () ("native") #f 752 8 752 31 ()}
      {Lisp-Entry "file-exists?" native () () ("native") #f 753 8 753 25 ()}
      {Lisp-Entry "file-delete" native () () ("native") #f 754 8 754 24 ()}
      {Lisp-Entry "file-copy" native () () ("native") #f 755 8 755 22 ()}
      {Lisp-Entry "file-modification-time" native () () ("native") #f 756 8 756 35 ()}
      {Lisp-Entry "file-rename" native () () ("native") #f 757 8 757 24 ()}
      {Lisp-Entry "add-extension" native () () ("native") #f 758 8 758 26 ()}
      {Lisp-Entry "current-directory" native () () ("native") #f 759 8 759 30 ()}
      {Lisp-Entry "current-directory-set!" native () () ("native") #f 760 8 760 35 ()}
      {Lisp-Entry "with-current-directory" native () () ("native") #f 761 8 761 35 ()}
      {Lisp-Entry "directory-create" native () () ("native") #f 762 8 762 29 ()}
      {Lisp-Entry "directory-content" native () () ("native") #f 763 8 763 30 ()}
      {Lisp-Entry "directory-delete" native () () ("native") #f 764 8 764 29 ()}
      {Lisp-Entry "open-string-pipe" native () () ("native") #f 772 8 772 24 ()}
      {Lisp-Entry "open-u8vector-pipe" native () () ("native") #f 773 8 773 26 ()}
      {Lisp-Entry "port?" native () () ("native") #f 781 8 781 13 ()}
      {Lisp-Entry "close-port" native () () ("native") #f 782 8 782 23 ()}
      {Lisp-Entry "input-port-timeout-set!" native () () ("native") #f 783 8 783 36 ()}
      {Lisp-Entry "output-port-timeout-set!" native () () ("native") #f 784 8 784 37 ()}
      {Lisp-Entry "open-event-queue" native () () ("native") #f 785 8 785 24 ()}
      {Lisp-Entry "eof-object" native () () ("native") #f 786 8 786 23 ()}
      {Lisp-Entry "read-substring" native () () ("native") #f 794 8 794 22 ()}
      {Lisp-Entry "open-vector" native () () ("native") #f 795 8 795 19 ()}
      {Lisp-Entry "call-with-input-u8vector" native () () ("native") #f 796 8 796 32 ()}
      {Lisp-Entry "open-output-u8vector" native () () ("native") #f 797 8 797 28 ()}
      {Lisp-Entry "get-output-u8vector" native () () ("native") #f 798 8 798 27 ()}
      {Lisp-Entry "read-u8" native () () ("native") #f 799 8 799 20 ()}
      {Lisp-Entry "write-u8" native () () ("native") #f 800 8 800 21 ()}
      {Lisp-Entry "read-subu8vector" native () () ("native") #f 801 8 801 29 ()}
      {Lisp-Entry "write-subu8vector" native () () ("native") #f 802 8 802 30 ()}
      {Lisp-Entry "read-proper-line" native () () ("native") #f 804 8 804 29 ()}
      {Lisp-Entry "read-all" native () () ("native") #f 805 8 805 21 ()}
      {Lisp-Entry "print" native () () ("native") #f 806 8 806 18 ()}
      {Lisp-Entry "pretty-print" native () () ("native") #f 807 8 807 25 ()}
      {Lisp-Entry "read-source-all" native () () ("native") #f 808 8 808 28 ()}
      {Lisp-Entry "read-source-first" native () () ("native") #f 809 8 809 30 ()}
      {Lisp-Entry "read-literal-hook" native () () ("native") #f 810 8 810 30 ()}
      {Lisp-Entry "force-output" native () () ("native") #f 811 8 811 20 ()}
      {Lisp-Entry "current-error-port" native () () ("native") #f 812 8 812 26 ()}
      {Lisp-Entry "with-output-to-port" native () () ("native") #f 813 8 813 27 ()}
      {Lisp-Entry "procedure-name" native () () ("native") #f 821 8 821 27 ()}
      {Lisp-Entry "procedure-name-set!" native () () ("native") #f 822 8 822 32 ()}
      {Lisp-Entry "procedure-locat" native () () ("native") #f 823 8 823 28 ()}
      {Lisp-Entry "new-property" native () () ("native") #f 831 8 831 25 ()}
      {Lisp-Entry "property-getter" native () () ("native") #f 832 8 832 28 ()}
      {Lisp-Entry "property-setter" native () () ("native") #f 833 8 833 28 ()}
      {Lisp-Entry "new-queue" native () () ("native") #f 841 8 841 22 ()}
      {Lisp-Entry "enqueue" native () () ("native") #f 842 8 842 20 ()}
      {Lisp-Entry "enqueue-list" native () () ("native") #f 843 8 843 25 ()}
      {Lisp-Entry "dequeue" native () () ("native") #f 844 8 844 20 ()}
      {Lisp-Entry "queue-list" native () () ("native") #f 845 8 845 23 ()}
      {Lisp-Entry "reset-queue" native () () ("native") #f 846 8 846 24 ()}
      {Lisp-Entry "random-integer" native () () ("native") #f 854 8 854 27 ()}
      {Lisp-Entry "random-real" native () () ("native") #f 855 8 855 24 ()}
      {Lisp-Entry "random-source-randomize!" native () () ("native") #f 856 8 856 37 ()}
      {Lisp-Entry "random-source-pseudo-randomize!" native () () ("native") #f 857 8 857 44 ()}
      {Lisp-Entry "default-random-source" native () () ("native") #f 858 8 858 34 ()}
      {Lisp-Entry "readtable?" native () () ("native") #f 866 8 866 23 ()}
      {Lisp-Entry "current-readtable" native () () ("native") #f 867 8 867 25 ()}
      {Lisp-Entry "make-standard-readtable" native () () ("native") #f 868 8 868 36 ()}
      {Lisp-Entry "readtable-copy" native () () ("native") #f 869 8 869 27 ()}
      {Lisp-Entry "readtable-char-delimiter?" native () () ("native") #f 870 8 870 38 ()}
      {Lisp-Entry "readtable-char-delimiter?-set!" native () () ("native") #f 871 8 871 43 ()}
      {Lisp-Entry "readtable-char-handler" native () () ("native") #f 872 8 872 35 ()}
      {Lisp-Entry "readtable-char-handler-set!" native () () ("native") #f 873 8 873 40 ()}
      {Lisp-Entry "readtable-char-sharp-handler" native () () ("native") #f 874 8 874 41 ()}
      {Lisp-Entry "readtable-char-sharp-handler-set!" native () () ("native") #f 875 8 875 46 ()}
      {Lisp-Entry "readtable-char-class-set!" native () () ("native") #f 876 8 876 38 ()}
      {Lisp-Entry "readtable-paren-keyword-set!" native () () ("native") #f 877 8 877 41 ()}
      {Lisp-Entry "readtable-bracket-keyword-set!" native () () ("native") #f 878 8 878 43 ()}
      {Lisp-Entry "readtable-brace-keyword-set!" native () () ("native") #f 879 8 879 41 ()}
      {Lisp-Entry "readtable-named-char-table" native () () ("native") #f 880 8 880 39 ()}
      {Lisp-Entry "readtable-named-char-table-set!" native () () ("native") #f 881 8 881 44 ()}
      {Lisp-Entry "with-readtable" native () () ("native") #f 882 8 882 27 ()}
      {Lisp-Entry "scheme-readtable" native () () ("native") #f 883 8 883 29 ()}
      {Lisp-Entry "jazz-readtable" native () () ("native") #f 884 8 884 27 ()}
      {Lisp-Entry "with-jazz-readtable" native () () ("native") #f 885 8 885 32 ()}
      {Lisp-Entry "resolve-runtime-reference" native () () ("native") #f 893 8 893 38 ()}
      {Lisp-Entry "serialize-runtime-reference" native () () ("native") #f 894 8 894 40 ()}
      {Lisp-Entry "deserialize-runtime-reference" native () () ("native") #f 895 8 895 42 ()}
      {Lisp-Entry "current-repl-context" native () () ("native") #f 903 8 903 33 ()}
      {Lisp-Entry "repl-context-level" native () () ("native") #f 904 8 904 31 ()}
      {Lisp-Entry "repl-context-depth" native () () ("native") #f 905 8 905 31 ()}
      {Lisp-Entry "repl-context-cont" native () () ("native") #f 906 8 906 30 ()}
      {Lisp-Entry "repl-context-initial-cont" native () () ("native") #f 907 8 907 38 ()}
      {Lisp-Entry "repl-context-prev-level" native () () ("native") #f 908 8 908 36 ()}
      {Lisp-Entry "repl-context-prev-depth" native () () ("native") #f 909 8 909 36 ()}
      {Lisp-Entry "with-repl-context" native () () ("native") #f 910 8 910 30 ()}
      {Lisp-Entry "inspect-repl-context" native () () ("native") #f 911 8 911 33 ()}
      {Lisp-Entry "repl" native () () ("native") #f 912 8 912 17 ()}
      {Lisp-Entry "eval-within-no-winding" native () () ("native") #f 913 8 913 35 ()}
      {Lisp-Entry "repl-result-history-add" native () () ("native") #f 914 8 914 36 ()}
      {Lisp-Entry "repl-result-history-ref" native () () ("native") #f 915 8 915 31 ()}
      {Lisp-Entry "resource-pathname" native () () ("native") #f 923 8 923 30 ()}
      {Lisp-Entry "get-object-slot" native () () ("native") #f 931 8 931 28 ()}
      {Lisp-Entry "set-object-slot" native () () ("native") #f 932 8 932 28 ()}
      {Lisp-Entry "find-slot-offset" native () () ("native") #f 933 8 933 29 ()}
      {Lisp-Entry "dispatch" native () () ("native") #f 934 8 934 21 ()}
      {Lisp-Entry "find-dispatch" native () () ("native") #f 935 8 935 26 ()}
      {Lisp-Entry "call-into-abstract" native () () ("native") #f 936 8 936 31 ()}
      {Lisp-Entry "get-core-classes" native () () ("native") #f 937 8 937 29 ()}
      {Lisp-Entry "object->serial" native () () ("native") #f 945 8 945 27 ()}
      {Lisp-Entry "serial->object" native () () ("native") #f 946 8 946 27 ()}
      {Lisp-Entry "object->serial-number" native () () ("native") #f 949 8 949 29 ()}
      {Lisp-Entry "serial-number->object" native () () ("native") #f 950 8 950 29 ()}
      {Lisp-Entry "shell-command" native () () ("native") #f 958 8 958 21 ()}
      {Lisp-Entry "slot?" native () () ("native") "<object:bool>" 966 8 966 18 ("object:bool" "<object:bool>")}
      {Lisp-Entry "slot-value" native () () ("native") #f 967 8 967 23 ()}
      {Lisp-Entry "set-slot-value" native () () ("native") #f 968 8 968 27 ()}
      {Lisp-Entry "socket-info-address" native () () ("native") #f 976 8 976 32 ()}
      {Lisp-Entry "socket-info-port-number" native () () ("native") #f 977 8 977 36 ()}
      {Lisp-Entry "hidden-frame?" native () () ("native") #f 985 8 985 26 ()}
      {Lisp-Entry "hidden-frame?-set!" native () () ("native") #f 986 8 986 31 ()}
      {Lisp-Entry "get-continuation-stack" native () () ("native") #f 987 8 987 35 ()}
      {Lisp-Entry "get-continuation-dynamic-environment" native () () ("native") #f 988 8 988 49 ()}
      {Lisp-Entry "get-continuation-lexical-environment" native () () ("native") #f 989 8 989 49 ()}
      {Lisp-Entry "get-continuation-location" native () () ("native") #f 990 8 990 38 ()}
      {Lisp-Entry "interpreted-continuation?" native () () ("native") #f 991 8 991 38 ()}
      {Lisp-Entry "string-find-reversed" native () () ("native") #f 999 8 999 33 ()}
      {Lisp-Entry "string-starts-with?" native () () ("native") #f 1000 8 1000 32 ()}
      {Lisp-Entry "string-ends-with?" native () () ("native") #f 1001 8 1001 30 ()}
      {Lisp-Entry "split-string" native () () ("native") #f 1002 8 1002 25 ()}
      {Lisp-Entry "join-strings" native () () ("native") #f 1003 8 1003 25 ()}
      {Lisp-Entry "kind?" native () () ("native") #f 1011 8 1011 18 ()}
      {Lisp-Entry "kind-id" native () () ("native") #f 1012 8 1012 20 ()}
      {Lisp-Entry "kind-name" native () () ("native") #f 1013 8 1013 22 ()}
      {Lisp-Entry "kind-flags" native () () ("native") #f 1014 8 1014 23 ()}
      {Lisp-Entry "kind-super" native () () ("native") #f 1015 8 1015 23 ()}
      {Lisp-Entry "kind-length" native () () ("native") #f 1016 8 1016 24 ()}
      {Lisp-Entry "kind-fields" native () () ("native") #f 1017 8 1017 24 ()}
      {Lisp-Entry "structure?" native () () ("native") #f 1018 8 1018 23 ()}
      {Lisp-Entry "structure-kind" native () () ("native") #f 1019 8 1019 27 ()}
      {Lisp-Entry "structure-ref" native () () ("native") #f 1020 8 1020 26 ()}
      {Lisp-Entry "structure-set!" native () () ("native") #f 1021 8 1021 27 ()}
      {Lisp-Entry "make-foo" native () () ("native") #f 1022 8 1022 16 ()}
      {Lisp-Entry "make-bar" native () () ("native") #f 1023 8 1023 16 ()}
      {Lisp-Entry "generate-symbol" native () () ("native") #f 1031 8 1031 28 ()}
      {Lisp-Entry "with-uniqueness" native () () ("native") #f 1032 8 1032 28 ()}
      {Lisp-Entry "source?" native () () ("native") #f 1040 8 1040 20 ()}
      {Lisp-Entry "source-code" native () () ("native") #f 1041 8 1041 24 ()}
      {Lisp-Entry "source-locat" native () () ("native") #f 1042 8 1042 25 ()}
      {Lisp-Entry "desourcify" native () () ("native") #f 1043 8 1043 23 ()}
      {Lisp-Entry "desourcify-all" native () () ("native") #f 1044 8 1044 27 ()}
      {Lisp-Entry "sourcify" native () () ("native") #f 1045 8 1045 21 ()}
      {Lisp-Entry "sourcify-if" native () () ("native") #f 1046 8 1046 24 ()}
      {Lisp-Entry "present-source" native () () ("native") #f 1047 8 1047 27 ()}
      {Lisp-Entry "locat-container" native () () ("native") #f 1048 8 1048 28 ()}
      {Lisp-Entry "locat-position" native () () ("native") #f 1049 8 1049 27 ()}
      {Lisp-Entry "locat->container/line/col" native () () ("native") #f 1050 8 1050 38 ()}
      {Lisp-Entry "position->filepos" native () () ("native") #f 1051 8 1051 30 ()}
      {Lisp-Entry "filepos-line" native () () ("native") #f 1052 8 1052 25 ()}
      {Lisp-Entry "filepos-col" native () () ("native") #f 1053 8 1053 24 ()}
      {Lisp-Entry "switch?" native () () ("native") #f 1061 8 1061 20 ()}
      {Lisp-Entry "switch-name" native () () ("native") #f 1062 8 1062 24 ()}
      {Lisp-Entry "command-argument" native () () ("native") #f 1063 8 1063 29 ()}
      {Lisp-Entry "command-argument?" native () () ("native") #f 1064 8 1064 30 ()}
      {Lisp-Entry "open-process" native () () ("native") #f 1065 8 1065 25 ()}
      {Lisp-Entry "process-status" native () () ("native") #f 1066 8 1066 27 ()}
      {Lisp-Entry "exit" native () () ("native") #f 1067 8 1067 17 ()}
      {Lisp-Entry "add-exit-job!" native () () ("native") #f 1068 8 1068 26 ()}
      {Lisp-Entry "table-clear" native () () ("native") #f 1083 8 1083 24 ()}
      {Lisp-Entry "table-length" native () () ("native") #f 1084 8 1084 25 ()}
      {Lisp-Entry "iterate-table-safe" native () () ("native") #f 1086 8 1086 31 ()}
      {Lisp-Entry "map-table" native () () ("native") #f 1087 8 1087 22 ()}
      {Lisp-Entry "table-entries" native () () ("native") #f 1088 8 1088 26 ()}
      {Lisp-Entry "eq?-hash" native () () ("native") #f 1089 8 1089 21 ()}
      {Lisp-Entry "eqv?-hash" native () () ("native") #f 1090 8 1090 22 ()}
      {Lisp-Entry "equal?-hash" native () () ("native") #f 1091 8 1091 24 ()}
      {Lisp-Entry "string=?-hash" native () () ("native") #f 1092 8 1092 26 ()}
      {Lisp-Entry "string-ci=?-hash" native () () ("native") #f 1093 8 1093 29 ()}
      {Lisp-Entry "make-will" native () () ("native") #f 1094 8 1094 17 ()}
      {Lisp-Entry "set-terminal-title" native () () ("native") #f 1102 8 1102 31 ()}
      {Lisp-Entry "bring-terminal-to-front" native () () ("native") #f 1103 8 1103 36 ()}
      {Lisp-Entry "clear-terminal" native () () ("native") #f 1104 8 1104 27 ()}
      {Lisp-Entry "disable-interrupts!" native () () ("native") #f 1112 8 1112 32 ()}
      {Lisp-Entry "enable-interrupts!" native () () ("native") #f 1113 8 1113 31 ()}
      {Lisp-Entry "current-thread" native () () ("native") #f 1114 8 1114 27 ()}
      {Lisp-Entry "thread?" native () () ("native") #f 1115 8 1115 20 ()}
      {Lisp-Entry "make-thread" native () () ("native") #f 1116 8 1116 24 ()}
      {Lisp-Entry "make-root-thread" native () () ("native") #f 1117 8 1117 29 ()}
      {Lisp-Entry "thread-name" native () () ("native") #f 1118 8 1118 24 ()}
      {Lisp-Entry "thread-specific" native () () ("native") #f 1119 8 1119 28 ()}
      {Lisp-Entry "thread-specific-set!" native () () ("native") #f 1120 8 1120 33 ()}
      {Lisp-Entry "thread-base-priority" native () () ("native") #f 1121 8 1121 33 ()}
      {Lisp-Entry "thread-base-priority-set!" native () () ("native") #f 1122 8 1122 38 ()}
      {Lisp-Entry "thread-priority-boost" native () () ("native") #f 1123 8 1123 34 ()}
      {Lisp-Entry "thread-priority-boost-set!" native () () ("native") #f 1124 8 1124 39 ()}
      {Lisp-Entry "thread-start!" native () () ("native") #f 1125 8 1125 26 ()}
      {Lisp-Entry "thread-yield!" native () () ("native") #f 1126 8 1126 26 ()}
      {Lisp-Entry "thread-sleep!" native () () ("native") #f 1127 8 1127 26 ()}
      {Lisp-Entry "thread-terminate!" native () () ("native") #f 1128 8 1128 30 ()}
      {Lisp-Entry "thread-join!" native () () ("native") #f 1129 8 1129 25 ()}
      {Lisp-Entry "thread-send" native () () ("native") #f 1130 8 1130 24 ()}
      {Lisp-Entry "thread-receive" native () () ("native") #f 1131 8 1131 27 ()}
      {Lisp-Entry "thread-interrupt!" native () () ("native") #f 1132 8 1132 30 ()}
      {Lisp-Entry "thread-thread-group" native () () ("native") #f 1133 8 1133 32 ()}
      {Lisp-Entry "thread-group->thread-group-list" native () () ("native") #f 1134 8 1134 44 ()}
      {Lisp-Entry "thread-group->thread-group-vector" native () () ("native") #f 1135 8 1135 46 ()}
      {Lisp-Entry "thread-group->thread-list" native () () ("native") #f 1136 8 1136 38 ()}
      {Lisp-Entry "thread-group->thread-vector" native () () ("native") #f 1137 8 1137 40 ()}
      {Lisp-Entry "thread-state" native () () ("native") #f 1138 8 1138 25 ()}
      {Lisp-Entry "thread-state-abnormally-terminated-reason" native () () ("native") #f 1139 8 1139 54 ()}
      {Lisp-Entry "thread-state-abnormally-terminated?" native () () ("native") #f 1140 8 1140 48 ()}
      {Lisp-Entry "thread-state-active-timeout" native () () ("native") #f 1141 8 1141 40 ()}
      {Lisp-Entry "thread-state-active-waiting-for" native () () ("native") #f 1142 8 1142 44 ()}
      {Lisp-Entry "thread-state-active?" native () () ("native") #f 1143 8 1143 33 ()}
      {Lisp-Entry "thread-state-initialized?" native () () ("native") #f 1144 8 1144 38 ()}
      {Lisp-Entry "thread-state-normally-terminated-result" native () () ("native") #f 1145 8 1145 52 ()}
      {Lisp-Entry "thread-state-normally-terminated?" native () () ("native") #f 1146 8 1146 46 ()}
      {Lisp-Entry "thread-state-uninitialized?" native () () ("native") #f 1147 8 1147 40 ()}
      {Lisp-Entry "thread-cont" native () () ("native") #f 1148 8 1148 24 ()}
      {Lisp-Entry "thread-continuation" native () () ("native") #f 1149 8 1149 32 ()}
      {Lisp-Entry "pristine-thread-continuation" native () () ("native") #f 1150 8 1150 41 ()}
      {Lisp-Entry "mutex?" native () () ("native") #f 1151 8 1151 19 ()}
      {Lisp-Entry "make-mutex" native () () ("native") #f 1152 8 1152 23 ()}
      {Lisp-Entry "mutex-name" native () () ("native") #f 1153 8 1153 23 ()}
      {Lisp-Entry "mutex-specific" native () () ("native") #f 1154 8 1154 27 ()}
      {Lisp-Entry "mutex-specific-set!" native () () ("native") #f 1155 8 1155 32 ()}
      {Lisp-Entry "mutex-state" native () () ("native") #f 1156 8 1156 24 ()}
      {Lisp-Entry "mutex-lock!" native () () ("native") #f 1157 8 1157 24 ()}
      {Lisp-Entry "mutex-unlock!" native () () ("native") #f 1158 8 1158 26 ()}
      {Lisp-Entry "mutex-wait" native () () ("native") #f 1159 8 1159 23 ()}
      {Lisp-Entry "mutex-owner" native () () ("native") #f 1160 8 1160 24 ()}
      {Lisp-Entry "condition?" native () () ("native") #f 1161 8 1161 23 ()}
      {Lisp-Entry "make-condition" native () () ("native") #f 1162 8 1162 27 ()}
      {Lisp-Entry "condition-name" native () () ("native") #f 1163 8 1163 27 ()}
      {Lisp-Entry "condition-specific" native () () ("native") #f 1164 8 1164 31 ()}
      {Lisp-Entry "condition-specific-set!" native () () ("native") #f 1165 8 1165 36 ()}
      {Lisp-Entry "condition-signal!" native () () ("native") #f 1166 8 1166 30 ()}
      {Lisp-Entry "condition-broadcast!" native () () ("native") #f 1167 8 1167 33 ()}
      {Lisp-Entry "current-systime" native () () ("native") #f 1175 8 1175 28 ()}
      {Lisp-Entry "systime?" native () () ("native") #f 1176 8 1176 21 ()}
      {Lisp-Entry "systime->seconds" native () () ("native") #f 1177 8 1177 29 ()}
      {Lisp-Entry "seconds->systime" native () () ("native") #f 1178 8 1178 29 ()}
      {Lisp-Entry "process-times" native () () ("native") #f 1179 8 1179 26 ()}
      {Lisp-Entry "cpu-time" native () () ("native") #f 1180 8 1180 21 ()}
      {Lisp-Entry "real-time" native () () ("native") #f 1181 8 1181 22 ()}
      {Lisp-Entry "unspecified" native () () ("native") #f 1189 8 1189 24 ()}
      {Lisp-Entry "unspecified?" native () () ("native") #f 1190 8 1190 25 ()}
      {Lisp-Entry "specified?" native () () ("native") #f 1191 8 1191 23 ()}
      {Lisp-Entry "vector-copy" native () () ("native") #f 1199 8 1199 24 ()}
      {Lisp-Entry "values?" native () () ("native") #f 1207 8 1207 20 ()}
      {Lisp-Entry "analysis-mode?" native () () ("native") #f 1215 8 1215 27 ()}
      {Lisp-Entry "analysis-data" native () () ("native") #f 1216 8 1216 26 ()}
      {Lisp-Entry "new-walk-context" native () () ("native") #f 1217 8 1217 29 ()}
      {Lisp-Entry "specifier?" native () () ("native") #f 1218 8 1218 23 ()}
      {Lisp-Entry "binding-specifier" native () () ("native") #f 1219 8 1219 30 ()}
      {Lisp-Entry "parse-specifier" native () () ("native") #f 1220 8 1220 28 ()}
      {Lisp-Entry "requested-unit-name" native () () ("native") #f 1221 8 1221 32 ()}
      {Lisp-Entry "requested-unit-resource" native () () ("native") #f 1222 8 1222 36 ()}
      {Lisp-Entry "get-private-lookup" native () () ("native") #f 1223 8 1223 31 ()}
      {Lisp-Entry "get-public-lookup" native () () ("native") #f 1224 8 1224 30 ()}
      {Lisp-Entry "get-protected-lookup" native () () ("native") #f 1225 8 1225 33 ()}
      {Lisp-Entry "get-catalog" native () () ("native") #f 1226 8 1226 24 ()}
      {Lisp-Entry "get-catalog-entry" native () () ("native") #f 1227 8 1227 30 ()}
      {Lisp-Entry "release-catalog-entries" native () () ("native") #f 1228 8 1228 36 ()}
      {Lisp-Entry "outline-feedback" native () () ("native") #f 1229 8 1229 29 ()}
      {Lisp-Entry "outline-unit" native () () ("native") #f 1230 8 1230 25 ()}
      {Lisp-Entry "walk-unit" native () () ("native") #f 1231 8 1231 22 ()}
      {Lisp-Entry "expand-unit" native () () ("native") #f 1232 8 1232 24 ()}
      {Lisp-Entry "expand-to-port" native () () ("native") #f 1233 8 1233 27 ()}
      {Lisp-Entry "expand-to-file" native () () ("native") #f 1234 8 1234 27 ()}
      {Lisp-Entry "find-declaration" native () () ("native") #f 1235 8 1235 29 ()}}})
"_language"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "_language.jazz"} 229929916. jazz
    {Lisp-Entry "jazz.dialect.language" module (protected) () #f #f 37 18 37 39 ("jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "export" export () () #f #f 43 1 43 7 ("jazz.dialect.language.platform" "jazz.dialect.language.parse" "jazz.dialect.language.object" "jazz.dialect.language.homogeneous" "jazz.dialect.language.geometry" "jazz.dialect.language.functional" "jazz.dialect.language.format" "jazz.dialect.language.exception" "jazz.dialect.language.debug")}}})
"_performance"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "_performance.scm"} 222341474. scheme
    {Lisp-Entry "test.performance" unit () () #f #f 0 6 0 22 ()
      {Lisp-Entry "require" require () () #f #f 3 1 3 8 ("test.performance.b" "test.performance.a" "test.performance.common" "syntax" "phase" "test.performance.syntax" "core.generic" "core.class")}}})
"_syntax"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "_syntax.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.syntax" module (protected) () #f #f 37 18 37 37 ("scheme")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("jazz.dialect.syntax.templates" "jazz.dialect.syntax.template" "jazz.dialect.syntax.macros" "jazz.dialect.syntax.with" "jazz.dialect.syntax.typecase" "jazz.dialect.syntax.loop" "jazz.dialect.syntax.increase" "jazz.dialect.syntax.enumeration" "jazz.dialect.syntax.ecase" "jazz.dialect.syntax.bind-keywords" "jazz.dialect.syntax.bind-optionals" "jazz.dialect.syntax.bind" "jazz.dialect.syntax.attributes")}}})
"_test"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "_test.jazz"} 246662659. jazz
    {Lisp-Entry "jazz.test" module () () #f #f 37 8 37 17 ("ppc" ":console" "pretty-print" "pretty-print~" "pprint-component" "object->serial" "serial" "get-size" "get-size~" "size" "get-position" "get-position~" "position" "get-name" "get-name~" "name" "properties:" "class-of" "category-name" "JML-Element" "p" "component->jml" "ps" "fold-component" "fold-node" "fold" "fold-linearize" "foldl-map" "fold-map" "identity" "iter-linearize" "get-output" "get-output~" "put" "put~" "List-Factory" "fact" "iter-map" "foldr" "foldr-component" "foldl-component" "foldr-node" "foldl" "foldl-node" "foldr-list" "not" "s" "foldl-list" "JML-Node" "is?" "null/pair?" "cond" "get-children" "get-children~" "iter" "letrec" "iter-node" "cdr" "car" "when" "proc" "lst" "iter-list" "func1" "struct1c" "struct1a" "make-S1" "s1" "ec" "eb" "ea" "enumeration" "cb" "ca" "constant" "typ6" "typ5" "t5" "typ4" "t4" "typ3" "gc" "still-obj-refcount" "foreign-tags" "typ2" "t2" "typ1" "t1" "scalar3" "scalar2" "scalar1" "init1" "cell+" "new-cell" "Cell" "Subseq" "length" "h" "g" "2.3" "fl" "<fl>" "set-element!" "axis-grow" "0" "Axis" "axis" "for-each" "POINT-make" "pt" "1000000" "repeat" "loop" "test.pt" "jazz.debug" "display" "newline" "test.baz!generic" "test.foo!generic" "display-tree" "jazz:display-tree" "native" "apply" "rest" "<U>" "u" "V" "U" "K" "J" "I" "interface" "baz" "throw" "XX" ".1" "error" "test-exception" "23" "thread-call" "test-delegate" "delegator" "current-thread" "sleep" "delegated" "thread-loop" "new-thread" "thread-start!" "thread-execute" "test-execute" "zz" "<Y>" "specific" "<X>" "generic" "f" "<Component>" "b:" "a:" "slot" "230" "blue:" "green:" "red:" "Color" "f3" "exc" "Exception" "catch" "bar~" "call-bar" "obj" "call-foo" "new-y" "new-x" "new-a" "virtual" "b" "a" "cons" "jazz.sample.module" "walk-unit" "fold-declaration" "pp" "port" "get-eol-encoding" "eol-encoding:" "path:" "list" "call-with-output-file" "palette-class" "meta" "200" "300" "500" "50" "exit" "close-window" "Palette" "My-Palette" "600" "host-size:" "host-title:" "My-Test" "new-palette" "show-toplevel" "foo~" "get-row~" "get-row-from" "get-row-from~" "locked?" "outline" "append" "get-row" "A" "foo" "boot-environment" "boot-environment~" "run" "public" "view-surrogate" "View-Surrogate-Actions" "<View-Surrogate-Actions>" "view-editor" "View-Editor-Actions" "<View-Editor-Actions>" "traits-tree" "Traits-Tree-Actions" "<Traits-Tree-Actions>" "components-tree" "Components-Tree-Actions" "<Components-Tree-Actions>" "components-viewer" "Components-Viewer-Actions" "<Components-Viewer-Actions>" "combo-text" "Combo-Text-Actions" "<Combo-Text-Actions>" "Application-Bindings" "Designer-Workspace" "<Designer-Workspace>" "designer" "active:" "<workspaces" "<workspaces~>" "Status-Toolbar" ":status" "Toolbar" ":toolbar" "Menubar" "Class-Reference" ":menubar" "toolbar-classes:" "maximized" "toplevel-state:" "Application-Preferences" "My-Bindings" "default-bindings" "My-Preferences" "default-preferences" "persist-preferences?" "client:" "View-Editor" "new-frame" "nextmethod" "finish-process" "override" "method" "Application" "My-App" "216" "574" "layout" "<Layout-View>" "221" "33" "image" "Image-View" "<Image-View>" "232" "541" "vertical" "Vertical-Line" "<Vertical-Line>" "249" "412" "horizontal" "Horizontal-Line" "<Horizontal-Line>" "44" "379" "36" "113" "Tab-Sheet" "<Tab-Sheet>" "120" "450" "348" "85" "tab" "Tab-View" "<Tab-View>" "214" "291" "Label-View" "<Label-View>" "190" "128" "radio" "Radio-Button" "<Radio-Button>" "297" "180" "combo" "Combo-Box" "<Combo-Box>" "18" "100" "283" "360" "checkbox" "Check-Box" "<Check-Box>" "173" "label" "Tree-Label-Column" "<Tree-Label-Column>" "display-images?:" "toplevel-controls?:" "176" "width:" "node" "Tree-Node-Column" "<Tree-Node-Column>" "15" "default-row-height:" "Label-User" "Font" "font:" "tree" "Tree-View" "<Tree-View>" "Tree-Header" "<Tree-Header>" "fill" "layout-type:" ">" "<content" "<content~>" "vscroll?:" "Scroller-View" "<Scroller-View>" "style:" "edge" "border-type:" "91" "373" "43" "311" "border" "Border-View" "<Border-View>" "97" "280" "8" "10" "group" "Group-Box" "<Group-Box>" "default?:" "on-search" ":form" "action-handler:" "24" "80" "Dimension" "size:" "14" "755" "Point" "position:" "title:" "search" "name:" "Push-Button" "<Push-Button>" "Layout-View" "My-Search" "jazz.ui.window" "jazz.ui.view" "jazz.system.application" "jazz.graphic" "jazz.designer" "start-repl" "set-default-context" "jazz.debuggee" "initialize-aliases" "format" "new-file" "new-file~" "parse" "parse~" "file:" "expand-to-file" "expanding" "terminal" "unit-name" "iterate-units" "create-directories" "create-directories~" "core.module.development" "load-unit" "Home" "Directory" "directory" "expand-all-with-feedback" "jazz.runtime" "jazz.io" "untrace" "yum" "yum~" "Y" "y" "yo" "yo~" "X" "bar" "trace" "jazz.test.advise" "YYY" "XXX" ",sym-f2" "f2" ",sym-f1" "f1" "sym-f2" "sym-f1" "gen-defs" ",var" ",sym" ",f-name" "var" "sym" "f-name" "def" "local-macro" "6" "var-2" "var-1" "test-when2" "4" "3" "test-swap!" "+" "-" "test!" "5" "va" "test-test!" ",var2" "set!" ",var1" "value" "caddr" "var2" "var1" "swap!" "cddr" "map" "begin" "cadr" "make-syntactic-closure" "if" "strip-source-info" "env" "lambda" "sc-macro-transformer" "when2" "define-local-syntax" "jazz.test.b" "x" "View" "collect" "reverse" "serialize-runtime-reference" "resolve-runtime-reference" "dr" "Object" "invoke" "invoke~" "some" "Event" "event" "get-handler" "get-handler~" "c" "define" ":reference" "Event-Handler" "handler:" "install" "<install>" "form" "reference" "generate" "accessors" "initialize" "handler" "property" "Component" "extends" "C" "class" "ca-marche" "evt" "some-handler" "jazz.library" "jazz.jml" ":error" ":warning" "1" "2" "walk-failed?" "get-height" "get-height~" "get-width" "get-width~" "get-handle" "get-handle~" "cairo_xlib_surface_create" "debug" "XDefaultScreen" "x11-default-display" "XDefaultVisual" "visual" "Window" "new" "window" "let" "get-setting" "initialize-windowing" "test" "package" "definition" "jazz.ui" "jazz.system" "jazz.platform.cairo" "jazz.platform" "fmt.implementation.test-fmt" "import" "jazz")
      {Lisp-Entry "foo" definition (public) ("x") #f #f 277 20 277 23 ("4" "3" "2" "+" "step" "-" "*" "1" "0" "=" "if" "n" "fact" "define" "x")}
      {Lisp-Entry "Blah" class () ((extends . "Object")) #f #f 505 7 505 11 ("Object")
        {Lisp-Entry "warnings" slot () ((getter . "generate")) #f #f 506 8 506 16 ()}
        {Lisp-Entry "get-warnings" accessor () () #f #f 506 26 506 34 ()}
        {Lisp-Entry "errors" slot () ((getter . "generate")) #f #f 507 8 507 14 ()}
        {Lisp-Entry "get-errors" accessor () () #f #f 507 26 507 34 ()}
        {Lisp-Entry "literals" slot () ((getter . "generate")) #f #f 508 8 508 16 ()}
        {Lisp-Entry "get-literals" accessor () () #f #f 508 26 508 34 ()}
        {Lisp-Entry "variables" slot () ((getter . "generate")) #f #f 509 8 509 17 ()}
        {Lisp-Entry "get-variables" accessor () () #f #f 509 26 509 34 ()}
        {Lisp-Entry "references" slot () ((getter . "generate")) #f #f 510 8 510 18 ()}
        {Lisp-Entry "get-references" accessor () () #f #f 510 26 510 34 ()}
        {Lisp-Entry "inclusions" slot () ((getter . "generate")) #f #f 511 8 511 18 ()}
        {Lisp-Entry "get-inclusions" accessor () () #f #f 511 26 511 34 ()}
        {Lisp-Entry "autoloads" slot () ((getter . "generate")) #f #f 512 8 512 17 ()}
        {Lisp-Entry "get-autoloads" accessor () () #f #f 512 26 512 34 ()}}
      {Lisp-Entry "Y" class () ((extends . "X")) #f #f 743 7 743 8 ("X")
        {Lisp-Entry "f" method (meta) () #f #f 746 16 746 17 ("2")}}
      {Lisp-Entry "Y~Class207" class () ((extends . "(:class X)")) #f #f 752 9 752 19 ("X" ":class")
        {Lisp-Entry "f" method () () #f #f 755 13 755 14 ("2")}}
      {Lisp-Entry "Y" class () ((metaclass . "Y~Class207") (extends . "X")) #f #f 759 9 759 10 ("X" "Class207" "Y" "Y~Class207")}
      {Lisp-Entry "f" definition () ("c" "<Cell+>") #f #f 847 13 847 14 ("=" "not" "if" "Cell+" "<Cell+>" "c")}
      {Lisp-Entry "import" import () () #f #f 888 1 888 7 ("test.a" "jazz.system" "jazz.ui.window" "jazz.ui.view" "jazz.ui.dialog" "jazz.ui" "jazz.platform" "jazz.library" "jazz.jml" "jazz.io" "jazz.git")}
      {Lisp-Entry "f" definition () () #f #f 907 13 907 14 ("+" "0" "n" "iter" "let")}
      {Lisp-Entry "TC" class () ((extends . "Object")) #f #f 914 7 914 9 ("3" "1" "Object")
        {Lisp-Entry "row" slot () ((initialize . "1")) #f "<Integer+>" 917 8 917 11 ("Integer+" "<Integer+>")}
        {Lisp-Entry "col" slot () ((initialize . "3")) #f "<fx>" 918 8 918 11 ("fx" "<fx>")}
        {Lisp-Entry "f" method () () #f #f 921 11 921 12 ("col" "0" "subseq!" "row" "when")}
        {Lisp-Entry "g" method () () #f #f 926 11 926 12 ("col" "0" "subseq!")}}
      {Lisp-Entry "f" definition () () #f #f 931 13 931 14 ("g" "g~" "TC" "new" "f" "f~" "class-of" "list")}}})
"_validate"
 ({Lisp-File-Entry {File :context "src" "jazz" "validate" "_validate.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate" module () () #f #f 37 8 37 21 ("jazz")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("jazz.validate.autoload")}}})
"_walker"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "walker" "_walker.jazz"} 229929916. jazz
    {Lisp-Entry "jazz.dialect.walker" module (protected) () #f #f 37 18 37 37 ("jazz.dialect")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("jazz.dialect.walker.jazz")}}})
"a"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "a.scm"} 222341474. scheme
    {Lisp-Entry "test.performance.a" unit () () #f #f 0 6 0 24 ()
      {Lisp-Entry "f-separate" define () ("s" "n") #f #f 8 9 8 19 ("1" "%%fx-" "g-separate" "0" "%%fx=" "if" "n" "s")}}}
  {Lisp-File-Entry {File :context "src" "jazz" "test" "a.jazz"} 231466232. jazz
    {Lisp-Entry "jazz.test.a" module () () #f #f 0 8 0 19 ("jazz")
      {Lisp-Entry "import" import () () #f #f 3 1 3 7 ("jazz.test" "jazz.library" "jazz.jml" "jazz.designer")}
      {Lisp-Entry "Test" class () ((extends . "A")) #f #f 9 7 9 11 ("A")
        {Lisp-Entry "form" form () () #f #f 12 3 12 7 ("f" "e" "b" "d" "visible?:" "c" "C" "<C>" "a" "name:" "B" "<B>" "install" "<install>")}}}})
"advise"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "advise.jazz"} 231466232. jazz
    {Lisp-Entry "jazz.test.advise" module () () #f #f 37 8 37 24 ("X" "<X>" "jazz")
      {Lisp-Entry "interaction-environment" native () () ("native") #f 45 8 45 31 ()}
      {Lisp-Entry "bootstrap-output-value" native () () ("native") #f 46 8 46 35 ()}
      {Lisp-Entry "abc" define () () #f #f 54 8 54 11 ("1")}
      {Lisp-Entry "zoo" define () ("x") #f #f 56 9 56 12 ("abc" "*" "2" "ha" "define" "x")}
      {Lisp-Entry "foo" definition (public) () #f #f 62 19 62 22 ("2")}
      {Lisp-Entry "goo" definition () () #f #f 65 12 65 15 ("3")}
      {Lisp-Entry "bar" definition (public) () #f #f 68 20 68 23 ("3" "zoo" "2" "+")}
      {Lisp-Entry "aaa" define () () #f #f 72 29 72 32 ("1")}
      {Lisp-Entry "I" interface () () #f #f 80 11 80 12 ()
        {Lisp-Entry "yyy" method (virtual) () #f #f 82 19 82 22 ()}}
      {Lisp-Entry "X" class () ((extends . "Object") (implements . "I")) #f #f 91 7 91 8 ("I" "Object")
        {Lisp-Entry "a" slot () ((accessors . "generate")) #f #f 93 8 93 9 ()}
        {Lisp-Entry "get-a" accessor () () #f #f 93 20 93 28 ()}
        {Lisp-Entry "set-a" accessor () () #f #f 93 20 93 28 ()}
        {Lisp-Entry "initialize" method (override) () #f #f 95 20 95 30 ("2" "a" "set!" "nextmethod")}
        {Lisp-Entry "ya" define () () #f #f 99 11 99 13 ("1")}
        {Lisp-Entry "yi" definition (public) () #f #f 102 22 102 24 ("ya")}
        {Lisp-Entry "yo" method (public) () #f #f 105 18 105 20 ("yi" "a" "+")}
        {Lisp-Entry "yum" method (public virtual) () #f #f 108 26 108 29 ("yo")}
        {Lisp-Entry "yyy" method (override) () #f #f 111 20 111 23 ("4")}}
      {Lisp-Entry "Y" class () ((extends . "X")) #f #f 115 7 115 8 ("X")
        {Lisp-Entry "yum" method (override) () #f #f 117 20 117 23 ("3" "nextmethod" "list")}}
      {Lisp-Entry "gen" generic/specific () ("." "rest") ("<X>") #f 126 10 126 13 ("rest")}
      {Lisp-Entry "gen" generic/specific () ("." "rest") ("<X>") #f 128 11 128 14 ("1" "rest")}}})
"attributes"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "attributes.scm"} 231466232. scheme
    {Lisp-Entry "jazz.dialect.syntax.attributes" module (protected) () #f #f 37 18 37 48 ("scheme")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "getf" native (private) () ("native") #f 43 16 43 25 ()}
      {Lisp-Entry "system-format" native (private) () ("native") #f 44 16 44 34 ()}
      {Lisp-Entry "attributes" macro (public) ("." "form") ("macro") #f 83 15 83 25 (",setter" "public" "setter" "set" ",getter" "system-format" "getter" "get" "queue-list" ",test" "enqueue" "test" "for-each" "new-queue" "clauses" "y" "x" "attribute=?" "get-attribute-no-default~" "not-null?" "get-ascendants" "scan" "iterate" "specified?" "if" "get-attribute-no-default" ",initialize" "unspecified" "not-found:" "getf" "initialize" "rest" "specifier" "parse-specifier" "get-attribute-default" "set!" ",value" "set-attribute" "nextmethod" "else" ",name" "name" "case" ",attribute" "get-attribute" "append" "get-attributes" "override" "method" ",slot-name" "slot" "lambda" "map" "begin" "value" "generate-symbol" "cdr" "attributes" "inherited" "let" "car" "symbol->string" "string-append" "string->symbol" "attribute" "slot-name" "define" "form")}}})
"autoload"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "autoload.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.test.autoload" module (protected) () #f #f 0 18 0 36 ("jazz")
      {Lisp-Entry "export" export () () #f #f 3 1 3 7 ("Y" "jazz.test.Y" "X" "autoload" "jazz.test.X")}}}
  {Lisp-File-Entry {File :context "src" "jazz" "validate" "autoload.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.autoload" module (protected) () #f #f 37 18 37 40 ("jazz")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("Test-Table" "jazz.validate.support.Test-Table" "Test-Model" "jazz.validate.support.Test-Model" "Test-Architecture" "jazz.validate.support.Test-Architecture" "Vector-Tester" "jazz.validate.suite.Vector-Tester" "Variable-Tester" "jazz.validate.suite.Variable-Tester" "Values-Tester" "jazz.validate.suite.Values-Tester" "Trait-Tester" "jazz.validate.suite.Trait-Tester" "Thread-Tester" "jazz.validate.suite.Thread-Tester" "Table-Tester" "jazz.validate.suite.Table-Tester" "Syntax-Tester" "jazz.validate.suite.Syntax-Tester" "Symbol-Tester" "jazz.validate.suite.Symbol-Tester" "Structure-Tester" "jazz.validate.suite.Structure-Tester" "String-Tester" "jazz.validate.suite.String-Tester" "Sequence-Tester" "jazz.validate.suite.Sequence-Tester" "Scheme-Tester" "jazz.validate.suite.Scheme-Tester" "Reader-Tester" "jazz.validate.suite.Reader-Tester" "Pathname-Tester" "jazz.validate.suite.Pathname-Tester" "Object-Tester" "jazz.validate.suite.Object-Tester" "Number-Tester" "jazz.validate.suite.Number-Tester" "List-Tester" "jazz.validate.suite.List-Tester" "Language-Tester" "jazz.validate.suite.Language-Tester" "Iterator-Tester" "jazz.validate.suite.Iterator-Tester" "Function-Tester" "jazz.validate.suite.Function-Tester" "Format-Tester" "jazz.validate.suite.Format-Tester" "Form-Tester" "jazz.validate.suite.Form-Tester" "Explorer-Tester" "jazz.validate.suite.Explorer-Tester" "Error-Tester" "jazz.validate.suite.Error-Tester" "Enumeration-Tester" "jazz.validate.suite.Enumeration-Tester" "Designer-Tester" "jazz.validate.suite.Designer-Tester" "Debugger-Tester" "jazz.validate.suite.Debugger-Tester" "Control-Tester" "jazz.validate.suite.Control-Tester" "Component-Tester" "jazz.validate.suite.Component-Tester" "Collector-Tester" "jazz.validate.suite.Collector-Tester" "Char-Tester" "jazz.validate.suite.Char-Tester" "Catalog-Tester" "jazz.validate.suite.Catalog-Tester" "Boolean-Tester" "jazz.validate.suite.Boolean-Tester" "Binding-Tester" "jazz.validate.suite.Binding-Tester" "Array-Tester" "autoload" "jazz.validate.suite.Array-Tester")}}})
"b"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "b.scm"} 222341474. scheme
    {Lisp-Entry "test.performance.b" unit () () #f #f 0 6 0 24 ()
      {Lisp-Entry "g-separate" define () ("s" "n") #f #f 8 9 8 19 ("1" "%%fx-" "f-separate" "0" "%%fx=" "if" "n" "s")}}}
  {Lisp-File-Entry {File :context "src" "jazz" "test" "b.jazz"} 231466232. jazz
    {Lisp-Entry "jazz.test.b" module () () #f #f 0 8 0 19 ("jazz")}})
"base64"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "base64.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.core.base64" unit (protected) () #f #f 0 16 0 40 ()
      {Lisp-Entry "macro-make-fifo" define-macro () () #f #f 28 17 28 32 ("macro-fifo-tail-set!" "##cons" "fifo" "let")}
      {Lisp-Entry "macro-fifo-next" define-macro () () #f #f 33 17 33 32 (",fifo" "##cdr" "fifo")}
      {Lisp-Entry "macro-fifo-next-set!" define-macro () () #f #f 34 17 34 37 (",x" ",fifo" "##set-cdr!" "x" "fifo")}
      {Lisp-Entry "macro-fifo-tail" define-macro () () #f #f 35 17 35 32 (",fifo" "##car" "fifo")}
      {Lisp-Entry "macro-fifo-tail-set!" define-macro () () #f #f 36 17 36 37 (",x" ",fifo" "##set-car!" "x" "fifo")}
      {Lisp-Entry "macro-fifo-elem" define-macro () () #f #f 37 17 37 32 (",fifo" "##car" "fifo")}
      {Lisp-Entry "macro-fifo-elem-set!" define-macro () () #f #f 38 17 38 37 (",x" ",fifo" "##set-car!" "x" "fifo")}
      {Lisp-Entry "macro-fifo->list" define-macro () () #f #f 40 17 40 33 (",fifo" "macro-fifo-next" "fifo")}
      {Lisp-Entry "macro-fifo-remove-all!" define-macro () () #f #f 43 17 43 39 ("macro-fifo-next-set!" "macro-fifo-tail-set!" "macro-fifo-next" "head" "interrupts-enabled" "not" "##declare" ",fifo" "let" "fifo")}
      {Lisp-Entry "macro-fifo-remove-head!" define-macro () () #f #f 53 17 53 40 ("macro-fifo-next-set!" "macro-fifo-tail-set!" "##null?" "next" "##pair?" "if" "macro-fifo-next" "head" "interrupts-enabled" "not" "##declare" ",fifo" "let" "fifo")}
      {Lisp-Entry "macro-fifo-insert-at-tail!" define-macro () () #f #f 67 17 67 43 ("##void" "macro-fifo-tail-set!" "macro-fifo-next-set!" "macro-fifo-tail" "tail" "interrupts-enabled" "not" "##declare" "##cons" "x" ",elem" ",fifo" "let" "elem" "fifo")}
      {Lisp-Entry "macro-fifo-insert-at-head!" define-macro () () #f #f 78 17 78 43 ("##void" "macro-fifo-next-set!" "macro-fifo-tail-set!" "##null?" "if" "macro-fifo-next" "head" "##check-heap-limit" "interrupts-enabled" "not" "##declare" "##cons" "x" ",elem" ",fifo" "let" "elem" "fifo")}
      {Lisp-Entry "macro-fifo-advance-to-tail!" define-macro () () #f #f 98 17 98 44 ("macro-fifo-elem" "macro-fifo-next-set!" "macro-fifo-tail" "new-head" ",fifo" "let" "fifo")}
      {Lisp-Entry "macro-fifo-advance!" define-macro () () #f #f 106 17 106 36 ("macro-fifo-elem" "macro-fifo-next-set!" "new-head" "macro-fifo-next" "head" "let*" ",fifo" "let" "fifo")}
      {Lisp-Entry "fifo->u8vector" define-macro () () #f #f 115 17 115 31 (",end" ",start" ",fifo" "##fifo->u8vector" "end" "start" "fifo")}
      {Lisp-Entry "u8vector-shrink!" define-macro () () #f #f 118 17 118 33 (",len" ",u8vect" "##u8vector-shrink!" "len" "u8vect")}
      {Lisp-Entry "fifo->string" define-macro () () #f #f 121 17 121 29 (",end" ",start" ",fifo" "##fifo->string" "end" "start" "fifo")}
      {Lisp-Entry "string-shrink!" define-macro () () #f #f 124 17 124 31 (",len" ",str" "##string-shrink!" "len" "str")}
      {Lisp-Entry "base64-string->u8vector" define () () #f #f 129 8 129 31 ("string-length" "0" "base64-substring->u8vector" "str" "lambda")}
      {Lisp-Entry "base64-substring->u8vector" define () () #f #f 133 8 133 34 ("begin" "c3" "loop3" "c2" "loop2" "c1" "loop1" "string-ref" "c0" "let*" ">=" "loop0" "6" "x3" "add3" "-2" "4" "#xff" "x2" "add2" "-4" "2" "arithmetic-shift" "add" "x1" "x0" "add1" "done" "else" "63" "62" "char=?" "52" "26" "char->integer" "char<=?" "char>=?" "cond" "c" "decode" "fifo->u8vector" "u8vector-shrink!" "u8vect" "<=" "<" "and" "get-output-u8vector" "macro-fifo-tail" "macro-fifo-elem" "macro-fifo-insert-at-tail!" "make-u8vector" "chunk" "=" "if" "u8vector-set!" "-" "bitwise-and" "i" "fifo" "1" "+" "vector-set!" "vector-ref" "ptr" "let" "x" "wr-u8" "macro-make-fifo" "0" "vector" "state" "64" "chunk-len" "error" "err" "define" "end" "start" "str" "lambda")}
      {Lisp-Entry "u8vector->base64-string" define () () #f #f 255 8 255 31 ("u8vector-length" "subu8vector->base64-string" "0" "width" "#!optional" "u8vect" "lambda")}
      {Lisp-Entry "subu8vector->base64-string" define () () #f #f 259 8 259 34 ("rest" "x3" "-6" "x2" "-4" "4" "#x3f" "x1" "-2" "arithmetic-shift" "x0" "2" "b2" "b1" "u8vector-ref" "b0" "3" ">" "loop" "63" "62" "52" "61" "26" "51" "char->integer" "integer->char" "25" "else" "-1" "cond" "new-n" "n" "x" "out" "add" "fifo->string" "string-shrink!" "str" "<=" "<" "and" "get-output-string" "macro-fifo-tail" "macro-fifo-elem" "macro-fifo-insert-at-tail!" "make-string" "chunk" "=" "if" "string-set!" "-" "bitwise-and" "i" "fifo" "1" "+" "vector-set!" "vector-ref" "ptr" "let" "c" "wr-char" "macro-make-fifo" "vector" "state" "64" "chunk-len" "define" "0" "width" "#!optional" "end" "start" "u8vect" "lambda")}}})
"bind"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "bind.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.syntax.bind" module (protected) () #f #f 38 18 38 42 ("scheme")
      {Lisp-Entry "import" import () () #f #f 41 1 41 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "bind" macro (public) ("form-src") ("syntax") #f 56 16 56 20 ("begin" "tree-value" "lambda" "with-uniqueness" "sourcify-if" "cddr" "source-code" "cadr" "desourcify" ",cdr-symbol" "cdr-symbol" ",@body" ",cdr-binding" "null?" ",car-symbol" "generate-symbol" "car-symbol" "pair?" "expand-bind-cdr" ",tree" ",specifier" ",car-binding" "if" "binding-specifier" "specifier" "symbol?" "cond" "cdr" "cdr-binding" "car" "car-binding" "let" "body" "tree" "bindings" "expand-bind-car" "define" "form-src")}}})
"bind-keywords"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "bind-keywords.scm"} 231466232. scheme
    {Lisp-Entry "jazz.dialect.syntax.bind-keywords" module (protected) () #f #f 38 18 38 51 ("scheme")
      {Lisp-Entry "import" import () () #f #f 41 1 41 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "last-tail" native (private) () ("native") #f 44 16 44 30 ()}
      {Lisp-Entry "bind-keywords" macro (public) ("form-src") ("syntax") #f 57 16 57 29 ("error" "not-null?" ",@body" "unbox-list" "symbol?" "proper-list" ",default" "symbol->string" "string->keyword" "find-keyword" ",specifier" ",variable" "caddr" "if" "default" "binding-specifier" "specifier" "variable" "binding" "lambda" "map" "let*" ",rest" "box-list" ",box" "sourcify-if" "last-tail" "oth" "new-queue" "bnd" "generate-symbol" "box" "cdr" "body" "cddr" "car" "rest" "cadr" "source-code" "bindings" "let" "form-src")}}})
"bind-optionals"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "bind-optionals.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.syntax.bind-optionals" module (protected) () #f #f 38 18 38 52 ("scheme")
      {Lisp-Entry "import" import () () #f #f 41 1 41 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "bind-optionals" macro (public) ("form-src") ("syntax") #f 61 16 61 30 (",@body" "error" "not-null?" "proper-list" ",value" ",specifier" ",variable" "set!" ",prog" ",default" "null?" "value" "caddr" "if" "default" "binding-specifier" "specifier" "variable" "binding" "lambda" "map" "let*" ",rest" ",scan" "sourcify-if" "prog" "generate-symbol" "scan" "cdr" "body" "cddr" "car" "rest" "cadr" "source-code" "bindings" "let" "form-src")}}})
"c"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "c.jazz"} 229929916. jazz
    {Lisp-Entry "jazz.test.c" module () () #f #f 0 8 0 19 ("jazz")}})
"catalog"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "catalog.jazz"} 231466232. jazz
    {Lisp-Entry "jazz.test.catalog" module () () #f #f 0 8 0 25 ("jazz")
      {Lisp-Entry "nativ" native () () ("native") #f 2 8 2 18 ()}
      {Lisp-Entry "foo" define () () #f #f 4 9 4 12 ("quoted" "tildeself" "tildeslot" "tildeslot~tildeself" "tilde" "tilde~" "ref2" "ref1" "refunit" "refunit:ref1:ref2" "prim" "jazz:prim" "keyw:" ":enum" "a.b.gigi" "symb" "Targ" "<Targ>")}}})
"cffi"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "cffi.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.test.cffi" module () () #f #f 37 8 37 22 ("#<<end-of-c-declare\nstatic int func2(mult* m, int n)\n{\n    return (*m)(n);\n}\nend-of-c-declare\n" "#<<end-of-c-declare\ntypedef int (mult)(int);\n\nstatic int multiply(int n)\n{\n    return n * n;\n}\n\nstatic mult* func1()\n{\n    return &multiply;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstruct S1_\n{\n    int x;\n    int y;\n};\n\ntypedef struct S1_ S1;\n\nstatic int struct1a(S1 s1)\n{\n    return s1.x + s1.y;\n}\n\n//static int struct1b(S1& s1)\n//{\n//    return s1.x + s1.y;\n//}\n\nstatic int struct1c(S1* s1)\n{\n    return s1->x + s1->y;\n}\n\nstatic void tst()\n{\n    S1 s;\n    \n    struct1a(s);\n    struct1c(&s);\n}\nend-of-c-declare\n" "typ6" "typ5" "typ4" "typ3" "typ2" "int" "c-function" "typ1" "definition" "#<<end-of-c-declare\nstatic int typ1(int i, int j)\n{\n    return i + j;\n}\n\nstatic int typ2(int i, int j)\n{\n    return i * j;\n}\n\nstatic int typ3(int i, int j)\n{\n    return 100 + i + j;\n}\nend-of-c-declare\n" "c-declare" "type" "int2" "int1" "c-type" "#<<end-of-c-declare\nstatic int scalar3(___SCMOBJ obj)\n{\n    return (int) obj;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic int scalar2(int n)\n{\n    return n + n;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic void scalar1(int n)\n{\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nN = 2;\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic int N;\nend-of-c-declare\n" "jazz")
      {Lisp-Entry "init1" definition () () #f #f 71 12 71 17 ("int" "c-function")}
      {Lisp-Entry "void" c-type () () #f #f 80 8 80 12 ("void" "native")}
      {Lisp-Entry "bool" c-type () () #f #f 81 8 81 12 ("bool" "native")}
      {Lisp-Entry "char" c-type () () #f #f 82 8 82 12 ("char" "native")}
      {Lisp-Entry "wchar_t" c-type () () #f #f 83 8 83 15 ("wchar_t" "native")}
      {Lisp-Entry "int" c-type () () #f #f 84 8 84 11 ("int" "native")}
      {Lisp-Entry "double" c-type () () #f #f 85 8 85 14 ("double" "native")}
      {Lisp-Entry "scheme-object" c-type () () #f #f 86 8 86 21 ("scheme-object" "native")}
      {Lisp-Entry "object" c-type () () #f #f 87 8 87 14 ("scheme-object")}
      {Lisp-Entry "scalar1" definition () () #f #f 98 12 98 19 ("void" "int" "c-function")}
      {Lisp-Entry "scalar2" definition () () #f #f 111 12 111 19 ("int" "c-function")}
      {Lisp-Entry "scalar3" definition () () #f #f 124 12 124 19 ("int" "object" "c-function")}
      {Lisp-Entry "ca" definition () () #f #f 186 12 186 14 ("2")}
      {Lisp-Entry "cb" definition () () #f #f 187 12 187 14 ("3")}
      {Lisp-Entry "e" c-enumeration () () #f #f 195 15 195 16 ("4" "ec" "2" "eb" "1" "ea")}
      {Lisp-Entry "S1" c-type () () #f #f 243 8 243 10 ("struct")}
      {Lisp-Entry "make-S1" definition () () #f #f 246 12 246 19 ("S1" "c-function")}
      {Lisp-Entry "struct1a" definition () () #f #f 251 12 251 20 ("int" "S1" "c-function")}
      {Lisp-Entry "struct1c" definition () () #f #f 257 12 257 20 ("int" "S1" "pointer" "c-function")}
      {Lisp-Entry "cast-S2->S2*" definition () () #f #f 268 12 268 24 ("error" "S2*" "object" "c-function" "S2" "foreign-tags" "car" "eq?" "if" "s2" "lambda")}
      {Lisp-Entry "mult*" c-type () () #f #f 305 8 305 13 ("int" "function" "pointer")}
      {Lisp-Entry "func1" definition () () #f #f 324 12 324 17 ("mult*" "c-function")}}})
"classes"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "classes.scm"} 246662659. scheme
    {Lisp-Entry "jazz.dialect.classes" unit (protected) () #f #f 37 16 37 36 ()
      {Lisp-Entry "Definition-Declaration" define-class () () ("class syntax") #f 45 19 45 46 ("%%set-definition-declaration-value" "%%get-definition-declaration-value" "value" "%%set-definition-declaration-signature" "%%get-definition-declaration-signature" "signature" "%%get-definition-declaration-expansion" "expansion" "allocate-definition-declaration" "jazz:allocate-definition-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Specialize" define-class () () ("class syntax") #f 56 19 56 34 ("allocate-specialize" "jazz:allocate-specialize" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Generic-Declaration" define-class () () ("class syntax") #f 65 19 65 43 ("%%set-generic-declaration-body" "%%get-generic-declaration-body" "body" "%%set-generic-declaration-signature" "%%get-generic-declaration-signature" "signature" "%%get-generic-declaration-dispatch-types" "dispatch-types" "allocate-generic-declaration" "jazz:allocate-generic-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Specific-Declaration" define-class () () ("class syntax") #f 76 19 76 44 ("%%get-specific-declaration-root?" "root?" "%%set-specific-declaration-body" "%%get-specific-declaration-body" "body" "%%get-specific-declaration-signature" "signature" "%%get-specific-declaration-generic" "generic" "allocate-specific-declaration" "jazz:allocate-specific-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Category-Declaration" define-class () () ("class syntax") #f 88 19 88 44 ("%%get-category-declaration-metaclass" "metaclass" "%%get-category-declaration-implementor" "implementor" "Object-Class" "jazz:Object-Class" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Namespace-Declaration" "jazz:Namespace-Declaration")}
      {Lisp-Entry "Class-Declaration" define-class () () ("class syntax") #f 98 19 98 41 ("%%get-class-declaration-interfaces" "interfaces" "%%get-class-declaration-ascendant-base" "ascendant-base" "%%get-class-declaration-ascendant-relation" "ascendant-relation" "%%get-class-declaration-ascendant" "ascendant" "allocate-class-declaration" "jazz:allocate-class-declaration" "Object-Class" "jazz:Object-Class" "metaclass" "implementor" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Category-Declaration" "jazz:Category-Declaration")}
      {Lisp-Entry "Interface-Declaration" define-class () () ("class syntax") #f 110 19 110 45 ("%%get-interface-declaration-ascendants" "ascendants" "allocate-interface-declaration" "jazz:allocate-interface-declaration" "Object-Class" "jazz:Object-Class" "metaclass" "implementor" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Category-Declaration" "jazz:Category-Declaration")}
      {Lisp-Entry "Field-Declaration" define-class () () ("class syntax") #f 119 19 119 41 ("Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Slot-Declaration" define-class () () ("class syntax") #f 128 19 128 40 ("%%get-slot-declaration-setter-name" "setter-name" "%%get-slot-declaration-getter-name" "getter-name" "%%set-slot-declaration-initialize" "%%get-slot-declaration-initialize" "initialize" "allocate-slot-declaration" "jazz:allocate-slot-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Field-Declaration" "jazz:Field-Declaration")}
      {Lisp-Entry "Property-Declaration" define-class () () ("class syntax") #f 139 19 139 44 ("%%set-property-declaration-setter" "%%get-property-declaration-setter" "setter" "%%set-property-declaration-getter" "%%get-property-declaration-getter" "getter" "allocate-property-declaration" "jazz:allocate-property-declaration" "Object-Class" "jazz:Object-Class" "setter-name" "getter-name" "initialize" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Slot-Declaration" "jazz:Slot-Declaration")}
      {Lisp-Entry "Method-Declaration" define-class () () ("class syntax") #f 149 19 149 42 ("%%set-method-declaration-body" "%%get-method-declaration-body" "body" "%%set-method-declaration-signature" "%%get-method-declaration-signature" "signature" "%%get-method-declaration-synchronized" "synchronized" "%%get-method-declaration-remote" "remote" "%%get-method-declaration-expansion" "expansion" "%%get-method-declaration-abstraction" "abstraction" "%%get-method-declaration-propagation" "propagation" "%%get-method-declaration-root" "root" "allocate-method-declaration" "jazz:allocate-method-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Field-Declaration" "jazz:Field-Declaration")}
      {Lisp-Entry "With-Self" define-class () () ("class syntax") #f 165 19 165 33 ("%%get-with-self-body" "body" "allocate-with-self" "jazz:allocate-with-self" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "With-Dynamic-Self" define-class () () ("class syntax") #f 174 19 174 41 ("%%get-with-dynamic-self-body" "body" "%%get-with-dynamic-self-code" "code" "allocate-with-dynamic-self" "jazz:allocate-with-dynamic-self" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Cast" define-class () () ("class syntax") #f 184 19 184 28 ("%%get-cast-expression" "expression" "allocate-cast" "jazz:allocate-cast" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Allocate" define-class () () ("class syntax") #f 193 19 193 32 ("%%get-allocate-values" "values" "%%get-allocate-class" "class" "allocate-allocate" "jazz:allocate-allocate" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Dispatch" define-class () () ("class syntax") #f 203 19 203 32 ("%%get-dispatch-arguments" "arguments" "%%get-dispatch-name" "name" "allocate-dispatch" "jazz:allocate-dispatch" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Jazz-Dialect" define-class () () ("class syntax") #f 213 19 213 36 ("allocate-jazz-dialect" "jazz:allocate-jazz-dialect" "Object-Class" "jazz:Object-Class" "bindings" "Dialect" "jazz:Dialect")}
      {Lisp-Entry "Jazz-Walker" define-class () () ("class syntax") #f 222 19 222 35 ("allocate-jazz-walker" "jazz:allocate-jazz-walker" "Object-Class" "jazz:Object-Class" "autoloads" "references" "variables" "literals" "errors" "warnings" "Scheme-Walker" "jazz:Scheme-Walker")}}})
"common"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "common.scm"} 231466232. scheme
    {Lisp-Entry "test.performance.common" unit () () #f #f 0 6 0 29 ("W" "Z" "X" "encapsulate-class" "jazz:encapsulate-class")
      {Lisp-Entry "require" require () () #f #f 3 1 3 8 ("syntax" "phase" "test.performance.syntax")}
      {Lisp-Entry "ff" define () ("n") #f #f 11 9 11 11 ("1" "%%fx-" "ff" "%%pair?" "begin" "0" "%%fx>" "if" "n")}
      {Lisp-Entry "gg" define () ("n") #f #f 24 9 24 11 ("1" "%%fx-" "gg" "%%pair?" "begin" "0" "%%fx>" "if" "n")}
      {Lisp-Entry "f-module-block/standard/not-safe" define () ("s" "n") #f #f 42 9 42 41 ("1" "%%fx-" "g-module-block/standard/not-safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/standard/not-safe" define () ("s" "n") #f #f 48 9 48 41 ("1" "%%fx-" "f-module-block/standard/not-safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-block/runtime/safe" define () ("s" "n") #f #f 66 9 66 36 ("1" "%%fx-" "g-module-block/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/runtime/safe" define () ("s" "n") #f #f 72 9 72 36 ("1" "%%fx-" "f-module-block/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-separate/runtime/safe" define () ("s" "n") #f #f 90 9 90 39 ("1" "%%fx-" "g-module-separate/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-separate/runtime/safe" define () ("s" "n") #f #f 96 9 96 39 ("1" "%%fx-" "f-module-separate/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-block/runtime/notsafe" define () ("s" "n") #f #f 114 9 114 39 ("1" "%%fx-" "g-module-block/runtime/notsafe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/runtime/notsafe" define () ("s" "n") #f #f 120 9 120 39 ("1" "%%fx-" "f-module-block/runtime/notsafe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module" define () ("s" "n") #f #f 137 9 137 17 ("1" "%%fx-" "g-module" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module" define () ("s" "n") #f #f 143 9 143 17 ("1" "%%fx-" "f-module" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "X" define-class () () ("class syntax") #f 160 19 160 20 ("allocate-x" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "X" define-class () () ("class runtime") #f 163 27 163 28 ()}
      {Lisp-Entry "new-x" define () () #f #f 168 9 168 14 ("X" "allocate-x")}
      {Lisp-Entry "f-generic" generic/specific () ("n") ("X") #f 172 22 172 31 ("n")}
      {Lisp-Entry "f-generic" generic/specific () ("n") ("X") #f 174 23 174 32 ("1" "%%fx-" "x" "g-generic" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "g-generic" generic/specific () ("n") ("X") #f 180 22 180 31 ("n")}
      {Lisp-Entry "g-generic" generic/specific () ("n") ("X") #f 182 23 182 32 ("1" "%%fx-" "x" "f-generic" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "Z" define-class () () ("class runtime") #f 193 27 193 28 ()}
      {Lisp-Entry "f-vtable" generic/specific () ("n") ("Z~virtual-runtime") #f 196 30 196 38 ("n")}
      {Lisp-Entry "g-vtable" generic/specific () ("n") ("Z~virtual-runtime") #f 197 30 197 38 ("n")}
      {Lisp-Entry "new-z" define () () #f #f 200 9 200 14 ("Z" "allocate-z")}
      {Lisp-Entry "f-vtable" generic/specific () ("n") ("Z") #f 204 21 204 29 ("1" "%%fx-" "z" "g-vtable" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "g-vtable" generic/specific () ("n") ("Z") #f 210 21 210 29 ("1" "%%fx-" "z" "f-vtable" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "W" define-class () () ("class runtime") #f 219 27 219 28 ()}
      {Lisp-Entry "f-vtable" generic/specific () ("n") ("W") #f 222 21 222 29 ("n")}
      {Lisp-Entry "h" generic/specific () () ("W~virtual-runtime") #f 226 30 226 31 ()}
      {Lisp-Entry "h" generic/specific () () ("W") #f 229 21 229 22 ()}}})
"continuation"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "continuation.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.continuation" unit (protected) () #f #f 37 16 37 46 ()
      {Lisp-Entry "continuation?" define () ("obj") #f #f 45 13 45 31 ("%%continuation?" "obj")}
      {Lisp-Entry "continuation-capture" define () ("proc") #f #f 49 13 49 38 ("%%continuation-capture" "proc")}
      {Lisp-Entry "continuation-graft" define () ("cont" "proc") #f #f 53 13 53 36 ("%%continuation-graft" "proc" "cont")}
      {Lisp-Entry "continuation-return" define () () #f #f 57 12 57 36 ("continuation-return")}
      {Lisp-Entry "continuation-checkpoint" define () ("before" "thunk" "after") #f #f 61 13 61 41 ("%%continuation-checkpoint" "after" "thunk" "before")}
      {Lisp-Entry "continuation-parent" define () ("cont") #f #f 65 13 65 37 ("%%continuation-parent" "cont")}
      {Lisp-Entry "continuation-creator" define () ("cont") #f #f 69 13 69 38 ("%%continuation-creator" "cont")}
      {Lisp-Entry "continuation-locat" define () ("cont") #f #f 73 13 73 36 ("%%continuation-locat" "cont")}
      {Lisp-Entry "continuation-next" define () ("cont") #f #f 77 13 77 35 ("%%continuation-next" "cont")}}})
"core"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "walker" "core.jazz"} 231466232. jazz
    {Lisp-Entry "jazz.dialect.walker.core" module (protected) () #f #f 37 18 37 42 ("jazz.dialect")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.dialect.language.object" "jazz.dialect.language.functional" "jazz.dialect.language.format" "jazz.dialect.language.exception" "jazz.dialect.kernel")}
      {Lisp-Entry "Walk-Binding" class () ((extends . "Type")) #f #f 52 7 52 19 ("Type")}
      {Lisp-Entry "walk-binding-lookup" native () () ("native-syntax") #f 55 15 55 39 ()}
      {Lisp-Entry "walk-binding-referenced" native () () ("native-syntax") #f 56 15 56 43 ()}
      {Lisp-Entry "emit-binding-reference" native () () ("native-syntax") #f 57 15 57 42 ()}
      {Lisp-Entry "walk-binding-validate-call" native () () ("native-syntax") #f 58 15 58 46 ()}
      {Lisp-Entry "emit-binding-call" native () () ("native-syntax") #f 59 15 59 37 ()}
      {Lisp-Entry "emit-inlined-binding-call" native () () ("native-syntax") #f 60 15 60 45 ()}
      {Lisp-Entry "walk-binding-validate-assignment" native () () ("native-syntax") #f 61 15 61 52 ()}
      {Lisp-Entry "walk-binding-assignable?" native () () ("native-syntax") #f 62 15 62 44 ()}
      {Lisp-Entry "emit-binding-assignment" native () () ("native-syntax") #f 63 15 63 43 ()}
      {Lisp-Entry "walk-binding-walkable?" native () () ("native-syntax") #f 64 15 64 42 ()}
      {Lisp-Entry "walk-binding-walk-form" native () () ("native-syntax") #f 65 15 65 42 ()}
      {Lisp-Entry "walk-binding-expandable?" native () () ("native-syntax") #f 66 15 66 44 ()}
      {Lisp-Entry "walk-binding-expand-form" native () () ("native-syntax") #f 67 15 67 44 ()}
      {Lisp-Entry "Lexical-Binding" class () ((extends . "Walk-Binding")) #f #f 75 7 75 22 ("Walk-Binding")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 78 8 78 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 78 20 78 28 ()}
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 79 8 79 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 79 20 79 28 ()}
        {Lisp-Entry "hits" slot () ((accessors . "generate")) #f #f 80 8 80 12 ()}
        {Lisp-Entry "get-hits" accessor () () #f #f 80 23 80 31 ()}
        {Lisp-Entry "set-hits" accessor () () #f #f 80 23 80 31 ()}
        {Lisp-Entry "print" method (override) ("output" "detail") #f #f 83 20 83 25 ("get-name" "format" "lambda" "self" "print-unreadable" "detail" "output")}}
      {Lisp-Entry "resolve-binding" native () () ("native-syntax") #f 89 15 89 35 ()}
      {Lisp-Entry "Declaration" class () ((extends . "Lexical-Binding")) #f #f 97 7 97 18 ("Lexical-Binding")
        {Lisp-Entry "access" slot () ((getter . "generate")) #f #f 100 8 100 14 ()}
        {Lisp-Entry "get-access" accessor () () #f #f 100 29 100 37 ()}
        {Lisp-Entry "compatibility" slot () ((getter . "generate")) #f #f 101 8 101 21 ()}
        {Lisp-Entry "get-compatibility" accessor () () #f #f 101 29 101 37 ()}
        {Lisp-Entry "attributes" slot () ((getter . "generate")) #f #f 102 8 102 18 ()}
        {Lisp-Entry "get-attributes" accessor () () #f #f 102 29 102 37 ()}
        {Lisp-Entry "toplevel" slot () ((getter . "generate")) #f #f 103 8 103 16 ()}
        {Lisp-Entry "get-toplevel" accessor () () #f #f 103 29 103 37 ()}
        {Lisp-Entry "parent" slot () ((getter . "generate")) #f #f 104 8 104 14 ()}
        {Lisp-Entry "get-parent" accessor () () #f #f 104 29 104 37 ()}
        {Lisp-Entry "locator" slot () ((getter . "generate")) #f #f 105 8 105 15 ()}
        {Lisp-Entry "get-locator" accessor () () #f #f 105 29 105 37 ()}
        {Lisp-Entry "source" slot () ((getter . "generate")) #f #f 106 8 106 14 ()}
        {Lisp-Entry "get-source" accessor () () #f #f 106 29 106 37 ()}}
      {Lisp-Entry "lookup-declaration" native () () ("native-syntax") #f 109 15 109 38 ()}
      {Lisp-Entry "update-declaration" native () () ("native-syntax") #f 110 15 110 38 ()}
      {Lisp-Entry "get-declaration-inclusions" native () () ("native-syntax") #f 111 15 111 46 ()}
      {Lisp-Entry "emit-declaration" native () () ("native-syntax") #f 112 15 112 36 ()}
      {Lisp-Entry "expand-referenced-declaration" native () () ("native-syntax") #f 113 15 113 49 ()}
      {Lisp-Entry "fold-statement" native () () ("native-syntax") #f 114 15 114 34 ()}
      {Lisp-Entry "fold-declaration" native () () ("native-syntax") #f 115 15 115 36 ()}
      {Lisp-Entry "fold-expression" native () () ("native-syntax") #f 116 15 116 35 ()}
      {Lisp-Entry "private-access" native () () ("native-syntax") #f 117 15 117 34 ()}
      {Lisp-Entry "public-access" native () () ("native-syntax") #f 118 15 118 33 ()}
      {Lisp-Entry "protected-access" native () () ("native-syntax") #f 119 15 119 36 ()}
      {Lisp-Entry "Declaration-Reference" class () ((extends . "Object")) #f #f 127 7 127 28 ("Object")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 130 8 130 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 130 27 130 35 ()}
        {Lisp-Entry "declaration" slot () ((getter . "generate")) #f #f 131 8 131 19 ()}
        {Lisp-Entry "get-declaration" accessor () () #f #f 131 27 131 35 ()}}
      {Lisp-Entry "resolve-reference" native () () ("native-syntax") #f 134 15 134 37 ()}
      {Lisp-Entry "Module-Reference" class () ((extends . "Declaration-Reference")) #f #f 142 7 142 23 ("Declaration-Reference")}
      {Lisp-Entry "Export-Reference" class () ((extends . "Declaration-Reference")) #f #f 150 7 150 23 ("Declaration-Reference")
        {Lisp-Entry "module-reference" slot () ((getter . "generate")) #f #f 153 8 153 24 ()}
        {Lisp-Entry "get-module-reference" accessor () () #f #f 153 32 153 40 ()}}
      {Lisp-Entry "Autoload-Reference" class () ((extends . "Export-Reference")) #f #f 161 7 161 25 ("Export-Reference")}
      {Lisp-Entry "Unit-Declaration" class () ((extends . "Declaration")) #f #f 169 7 169 23 ("Declaration")
        {Lisp-Entry "requires" slot () ((getter . "generate")) #f #f 172 8 172 16 ()}
        {Lisp-Entry "get-requires" accessor () () #f #f 172 24 172 32 ()}}
      {Lisp-Entry "Namespace-Declaration" class () ((extends . "Declaration")) #f #f 180 7 180 28 ("Declaration")
        {Lisp-Entry "lookups" slot () ((getter . "generate")) #f #f 183 8 183 15 ()}
        {Lisp-Entry "get-lookups" accessor () () #f #f 183 24 183 32 ()}
        {Lisp-Entry "children" slot () ((getter . "generate")) #f #f 184 8 184 16 ()}
        {Lisp-Entry "get-children" accessor () () #f #f 184 24 184 32 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 185 8 185 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 185 24 185 32 ()}}
      {Lisp-Entry "%%get-access-lookup" native () () ("native-syntax") #f 188 15 188 34 ()}
      {Lisp-Entry "Module-Declaration" class () ((extends . "Namespace-Declaration")) #f #f 196 7 196 25 ("Namespace-Declaration")
        {Lisp-Entry "walker" slot () ((getter . "generate")) #f #f 199 8 199 14 ()}
        {Lisp-Entry "get-walker" accessor () () #f #f 199 31 199 39 ()}
        {Lisp-Entry "dialect-name" slot () ((getter . "generate")) #f #f 200 8 200 20 ()}
        {Lisp-Entry "get-dialect-name" accessor () () #f #f 200 31 200 39 ()}
        {Lisp-Entry "dialect-invoice" slot () ((getter . "generate")) #f #f 201 8 201 23 ()}
        {Lisp-Entry "get-dialect-invoice" accessor () () #f #f 201 31 201 39 ()}
        {Lisp-Entry "requires" slot () ((getter . "generate")) #f #f 202 8 202 16 ()}
        {Lisp-Entry "get-requires" accessor () () #f #f 202 31 202 39 ()}
        {Lisp-Entry "exports" slot () ((getter . "generate")) #f #f 203 8 203 15 ()}
        {Lisp-Entry "get-exports" accessor () () #f #f 203 31 203 39 ()}
        {Lisp-Entry "imports" slot () ((getter . "generate")) #f #f 204 8 204 15 ()}
        {Lisp-Entry "get-imports" accessor () () #f #f 204 31 204 39 ()}
        {Lisp-Entry "proclaims" slot () ((getter . "generate")) #f #f 205 8 205 17 ()}
        {Lisp-Entry "get-proclaims" accessor () () #f #f 205 31 205 39 ()}
        {Lisp-Entry "inclusions" slot () ((getter . "generate")) #f #f 206 8 206 18 ()}
        {Lisp-Entry "get-inclusions" accessor () () #f #f 206 31 206 39 ()}
        {Lisp-Entry "local-macros" slot () ((getter . "generate")) #f #f 207 8 207 20 ()}
        {Lisp-Entry "get-local-macros" accessor () () #f #f 207 31 207 39 ()}}
      {Lisp-Entry "Module-Invoice" class () ((extends . "Object")) #f #f 215 7 215 21 ("Object")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 218 8 218 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 218 23 218 31 ()}
        {Lisp-Entry "module" slot () ((getter . "generate")) #f #f 219 8 219 14 ()}
        {Lisp-Entry "get-module" accessor () () #f #f 219 23 219 31 ()}
        {Lisp-Entry "phase" slot () ((getter . "generate")) #f #f 220 8 220 13 ()}
        {Lisp-Entry "get-phase" accessor () () #f #f 220 23 220 31 ()}
        {Lisp-Entry "version" slot () ((getter . "generate")) #f #f 221 8 221 15 ()}
        {Lisp-Entry "get-version" accessor () () #f #f 221 23 221 31 ()}
        {Lisp-Entry "only" slot () ((getter . "generate")) #f #f 222 8 222 12 ()}
        {Lisp-Entry "get-only" accessor () () #f #f 222 23 222 31 ()}
        {Lisp-Entry "except" slot () ((getter . "generate")) #f #f 223 8 223 14 ()}
        {Lisp-Entry "get-except" accessor () () #f #f 223 23 223 31 ()}
        {Lisp-Entry "prefix" slot () ((getter . "generate")) #f #f 224 8 224 14 ()}
        {Lisp-Entry "get-prefix" accessor () () #f #f 224 23 224 31 ()}
        {Lisp-Entry "rename" slot () ((getter . "generate")) #f #f 225 8 225 14 ()}
        {Lisp-Entry "get-rename" accessor () () #f #f 225 23 225 31 ()}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 228 20 228 25 ("name" "format" "lambda" "self" "print-unreadable" "readably" "output")}}
      {Lisp-Entry "Export-Invoice" class () ((extends . "Module-Invoice")) #f #f 240 7 240 21 ("Module-Invoice")
        {Lisp-Entry "autoload" slot () ((getter . "generate")) #f #f 243 8 243 16 ()}
        {Lisp-Entry "get-autoload" accessor () () #f #f 243 24 243 32 ()}}
      {Lisp-Entry "Import-Invoice" class () ((extends . "Module-Invoice")) #f #f 251 7 251 21 ("Module-Invoice")
        {Lisp-Entry "hit?" slot () ((getter . "generate")) #f #f 254 8 254 12 ()}
        {Lisp-Entry "get-hit?" accessor () () #f #f 254 20 254 28 ()}}
      {Lisp-Entry "Export-Declaration" class () ((extends . "Declaration")) #f #f 262 7 262 25 ("Declaration")
        {Lisp-Entry "symbol" slot () ((getter . "generate")) #f #f 265 8 265 14 ()}
        {Lisp-Entry "get-symbol" accessor () () #f #f 265 22 265 30 ()}}
      {Lisp-Entry "Export-Syntax-Declaration" class () ((extends . "Declaration")) #f #f 273 7 273 32 ("Declaration")
        {Lisp-Entry "symbol" slot () ((getter . "generate")) #f #f 276 8 276 14 ()}
        {Lisp-Entry "get-symbol" accessor () () #f #f 276 22 276 30 ()}}
      {Lisp-Entry "Autoload-Declaration" class () ((extends . "Declaration")) #f #f 284 7 284 27 ("Declaration")
        {Lisp-Entry "module" slot () ((getter . "generate")) #f #f 287 8 287 14 ()}
        {Lisp-Entry "get-module" accessor () () #f #f 287 31 287 39 ()}
        {Lisp-Entry "exported-module" slot () ((getter . "generate")) #f #f 288 8 288 23 ()}
        {Lisp-Entry "get-exported-module" accessor () () #f #f 288 31 288 39 ()}
        {Lisp-Entry "declaration" slot () ((getter . "generate")) #f #f 289 8 289 19 ()}
        {Lisp-Entry "get-declaration" accessor () () #f #f 289 31 289 39 ()}}
      {Lisp-Entry "*print-literal*" definition (public) () #f #f 297 19 297 34 ("make-parameter")}
      {Lisp-Entry "Literal" class () ((extends . "Object")) #f #f 301 7 301 14 ("Object")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 304 8 304 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 304 25 304 33 ()}
        {Lisp-Entry "arguments" slot () ((getter . "generate")) #f #f 305 8 305 17 ()}
        {Lisp-Entry "get-arguments" accessor () () #f #f 305 25 305 33 ()}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 308 20 308 25 ("lambda" "self" "print-unreadable" "arguments" "not-null?" "name" "format" "*print-literal*" "if" "readably" "output")}
        {Lisp-Entry "walk-references" method (override) ("proc") #f #f 317 20 317 35 ("arguments" "name" "source-code" "walk-literal" "proc")}}
      {Lisp-Entry "new-literal" native () () ("native") #f 321 8 321 24 ()}
      {Lisp-Entry "Macro-Declaration" class () ((extends . "Declaration")) #f #f 329 7 329 24 ("Declaration")
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 332 8 332 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 332 25 332 33 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 333 8 333 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 333 25 333 33 ()}}
      {Lisp-Entry "Syntax-Declaration" class () ((extends . "Declaration")) #f #f 341 7 341 25 ("Declaration")
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 344 8 344 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 344 25 344 33 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 345 8 345 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 345 25 345 33 ()}}
      {Lisp-Entry "Define-Syntax-Declaration" class () ((extends . "Syntax-Declaration")) #f #f 353 7 353 32 ("Syntax-Declaration")}
      {Lisp-Entry "Define-Local-Syntax-Declaration" class () ((extends . "Syntax-Declaration")) #f #f 361 7 361 38 ("Syntax-Declaration")}
      {Lisp-Entry "Opt-Type" class () ((extends . "Type")) #f #f 369 7 369 15 ("Type")
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 372 8 372 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 372 20 372 28 ()}}
      {Lisp-Entry "Key-Type" class () ((extends . "Type")) #f #f 380 7 380 15 ("Type")
        {Lisp-Entry "key" slot () ((getter . "generate")) #f #f 383 8 383 11 ()}
        {Lisp-Entry "get-key" accessor () () #f #f 383 20 383 28 ()}
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 384 8 384 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 384 20 384 28 ()}}
      {Lisp-Entry "Rest-Type" class () ((extends . "Type")) #f #f 392 7 392 16 ("Type")
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 395 8 395 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 395 20 395 28 ()}}
      {Lisp-Entry "Function-Type" class () ((extends . "Type")) #f #f 403 7 403 20 ("Type")
        {Lisp-Entry "mandatory" slot () ((getter . "generate")) #f #f 406 8 406 17 ()}
        {Lisp-Entry "get-mandatory" accessor () () #f #f 406 26 406 34 ()}
        {Lisp-Entry "positional" slot () ((getter . "generate")) #f #f 407 8 407 18 ()}
        {Lisp-Entry "get-positional" accessor () () #f #f 407 26 407 34 ()}
        {Lisp-Entry "optional" slot () ((getter . "generate")) #f #f 408 8 408 16 ()}
        {Lisp-Entry "get-optional" accessor () () #f #f 408 26 408 34 ()}
        {Lisp-Entry "named" slot () ((getter . "generate")) #f #f 409 8 409 13 ()}
        {Lisp-Entry "get-named" accessor () () #f #f 409 26 409 34 ()}
        {Lisp-Entry "rest" slot () ((getter . "generate")) #f #f 410 8 410 12 ()}
        {Lisp-Entry "get-rest" accessor () () #f #f 410 26 410 34 ()}
        {Lisp-Entry "result" slot () ((getter . "generate")) #f #f 411 8 411 14 ()}
        {Lisp-Entry "get-result" accessor () () #f #f 411 26 411 34 ()}}
      {Lisp-Entry "Category-Type" class () ((extends . "Type")) #f #f 419 7 419 20 ("Type")
        {Lisp-Entry "declaration" slot () ((getter . "generate")) #f #f 422 8 422 19 ()}
        {Lisp-Entry "get-declaration" accessor () () #f #f 422 27 422 35 ()}}
      {Lisp-Entry "Values-Type" class () ((extends . "Type")) #f #f 430 7 430 18 ("Type")
        {Lisp-Entry "types" slot () ((getter . "generate")) #f #f 433 8 433 13 ()}
        {Lisp-Entry "get-types" accessor () () #f #f 433 21 433 29 ()}}
      {Lisp-Entry "Restriction-Type" class () ((extends . "Type")) #f #f 441 7 441 23 ("Type")
        {Lisp-Entry "base" slot () ((getter . "generate")) #f #f 444 8 444 12 ()}
        {Lisp-Entry "get-base" accessor () () #f #f 444 20 444 28 ()}
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 445 8 445 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 445 20 445 28 ()}}
      {Lisp-Entry "Complement-Type" class () ((extends . "Type")) #f #f 453 7 453 22 ("Type")
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 456 8 456 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 456 20 456 28 ()}}
      {Lisp-Entry "Union-Type" class () ((extends . "Type")) #f #f 464 7 464 17 ("Type")
        {Lisp-Entry "types" slot () ((getter . "generate")) #f #f 467 8 467 13 ()}
        {Lisp-Entry "get-types" accessor () () #f #f 467 21 467 29 ()}}
      {Lisp-Entry "Template-Type" class () ((extends . "Type")) #f #f 475 7 475 20 ("Type")
        {Lisp-Entry "class" slot () ((getter . "generate")) #f #f 478 8 478 13 ()}
        {Lisp-Entry "get-class" accessor () () #f #f 478 21 478 29 ()}
        {Lisp-Entry "types" slot () ((getter . "generate")) #f #f 479 8 479 13 ()}
        {Lisp-Entry "get-types" accessor () () #f #f 479 21 479 29 ()}}
      {Lisp-Entry "Nillable-Type" class () ((extends . "Type")) #f #f 487 7 487 20 ("Type")
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 490 8 490 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 490 20 490 28 ()}}
      {Lisp-Entry "C-Type-Declaration" class () ((extends . "Declaration")) #f #f 498 7 498 25 ("Declaration")
        {Lisp-Entry "kind" slot () ((getter . "generate")) #f #f 501 8 501 12 ()}
        {Lisp-Entry "get-kind" accessor () () #f #f 501 29 501 37 ()}
        {Lisp-Entry "expansion" slot () ((getter . "generate")) #f #f 502 8 502 17 ()}
        {Lisp-Entry "get-expansion" accessor () () #f #f 502 29 502 37 ()}
        {Lisp-Entry "base-type" slot () ((getter . "generate")) #f #f 503 8 503 17 ()}
        {Lisp-Entry "get-base-type" accessor () () #f #f 503 29 503 37 ()}
        {Lisp-Entry "pointer-types" slot () ((getter . "generate")) #f #f 504 8 504 21 ()}
        {Lisp-Entry "get-pointer-types" accessor () () #f #f 504 29 504 37 ()}
        {Lisp-Entry "inclusions" slot () ((getter . "generate")) #f #f 505 8 505 18 ()}
        {Lisp-Entry "get-inclusions" accessor () () #f #f 505 29 505 37 ()}
        {Lisp-Entry "c-to-scheme" slot () ((getter . "generate")) #f #f 506 8 506 19 ()}
        {Lisp-Entry "get-c-to-scheme" accessor () () #f #f 506 29 506 37 ()}
        {Lisp-Entry "scheme-to-c" slot () ((getter . "generate")) #f #f 507 8 507 19 ()}
        {Lisp-Entry "get-scheme-to-c" accessor () () #f #f 507 29 507 37 ()}
        {Lisp-Entry "declare" slot () ((getter . "generate")) #f #f 508 8 508 15 ()}
        {Lisp-Entry "get-declare" accessor () () #f #f 508 29 508 37 ()}}
      {Lisp-Entry "C-Definition-Declaration" class () ((extends . "Declaration")) #f #f 516 7 516 31 ("Declaration")
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 519 8 519 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 519 31 519 39 ()}
        {Lisp-Entry "parameter-types" slot () ((getter . "generate")) #f #f 520 8 520 23 ()}
        {Lisp-Entry "get-parameter-types" accessor () () #f #f 520 31 520 39 ()}
        {Lisp-Entry "result-type" slot () ((getter . "generate")) #f #f 521 8 521 19 ()}
        {Lisp-Entry "get-result-type" accessor () () #f #f 521 31 521 39 ()}
        {Lisp-Entry "c-name" slot () ((getter . "generate")) #f #f 522 8 522 14 ()}
        {Lisp-Entry "get-c-name" accessor () () #f #f 522 31 522 39 ()}
        {Lisp-Entry "scope" slot () ((getter . "generate")) #f #f 523 8 523 13 ()}
        {Lisp-Entry "get-scope" accessor () () #f #f 523 31 523 39 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 524 8 524 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 524 31 524 39 ()}}
      {Lisp-Entry "Dialect" class () ((extends . "Object")) #f #f 532 7 532 14 ("Object")
        {Lisp-Entry "bindings" slot () ((getter . "generate")) #f #f 535 8 535 16 ()}
        {Lisp-Entry "get-bindings" accessor () () #f #f 535 24 535 32 ()}}
      {Lisp-Entry "Walker" class () ((extends . "Object")) #f #f 543 7 543 13 ("Object")
        {Lisp-Entry "warnings" slot () ((getter . "generate")) #f #f 546 8 546 16 ()}
        {Lisp-Entry "get-warnings" accessor () () #f #f 546 26 546 34 ()}
        {Lisp-Entry "errors" slot () ((getter . "generate")) #f #f 547 8 547 14 ()}
        {Lisp-Entry "get-errors" accessor () () #f #f 547 26 547 34 ()}
        {Lisp-Entry "literals" slot () ((getter . "generate")) #f #f 548 8 548 16 ()}
        {Lisp-Entry "get-literals" accessor () () #f #f 548 26 548 34 ()}
        {Lisp-Entry "variables" slot () ((getter . "generate")) #f #f 549 8 549 17 ()}
        {Lisp-Entry "get-variables" accessor () () #f #f 549 26 549 34 ()}
        {Lisp-Entry "references" slot () ((getter . "generate")) #f #f 550 8 550 18 ()}
        {Lisp-Entry "get-references" accessor () () #f #f 550 26 550 34 ()}
        {Lisp-Entry "autoloads" slot () ((getter . "generate")) #f #f 551 8 551 17 ()}
        {Lisp-Entry "get-autoloads" accessor () () #f #f 551 26 551 34 ()}}
      {Lisp-Entry "walker-environment" native () () ("native-syntax") #f 554 15 554 38 ()}
      {Lisp-Entry "walk-declaration" native () () ("native-syntax") #f 555 15 555 36 ()}
      {Lisp-Entry "validate-access" native () () ("native-syntax") #f 556 15 556 35 ()}
      {Lisp-Entry "walk-free-reference" native () () ("native-syntax") #f 557 15 557 39 ()}
      {Lisp-Entry "walk-symbol-assignment" native () () ("native-syntax") #f 558 15 558 42 ()}
      {Lisp-Entry "walk-free-assignment" native () () ("native-syntax") #f 559 15 559 40 ()}
      {Lisp-Entry "walk-symbol" native () () ("native-syntax") #f 560 15 560 31 ()}
      {Lisp-Entry "walk-form" native () () ("native-syntax") #f 561 15 561 29 ()}
      {Lisp-Entry "validate-proclaim" native () () ("native-syntax") #f 562 15 562 37 ()}
      {Lisp-Entry "validate-arguments" native () () ("native-syntax") #f 563 15 563 38 ()}
      {Lisp-Entry "Walk-Context" class () ((extends . "Object")) #f #f 571 7 571 19 ("Object")
        {Lisp-Entry "policy" slot () ((getter . "generate")) #f #f 574 8 574 14 ()}
        {Lisp-Entry "get-policy" accessor () () #f #f 574 24 574 32 ()}
        {Lisp-Entry "locator" slot () ((getter . "generate")) #f #f 575 8 575 15 ()}
        {Lisp-Entry "get-locator" accessor () () #f #f 575 24 575 32 ()}
        {Lisp-Entry "pathname" slot () ((getter . "generate")) #f #f 576 8 576 16 ()}
        {Lisp-Entry "get-pathname" accessor () () #f #f 576 24 576 32 ()}}
      {Lisp-Entry "Walk-Location" class (package) ((extends . "Object")) #f #f 584 15 584 28 ("Object")
        {Lisp-Entry "unit-locator" slot () ((getter . "generate")) #f #f 587 8 587 20 ()}
        {Lisp-Entry "get-unit-locator" accessor () () #f #f 587 35 587 43 ()}
        {Lisp-Entry "declaration-locator" slot () ((getter . "generate")) #f #f 588 8 588 27 ()}
        {Lisp-Entry "get-declaration-locator" accessor () () #f #f 588 35 588 43 ()}
        {Lisp-Entry "locat" slot () ((getter . "generate")) #f #f 589 8 589 13 ()}
        {Lisp-Entry "get-locat" accessor () () #f #f 589 35 589 43 ()}
        {Lisp-Entry "path" slot () ((getter . "generate")) #f #f 590 8 590 12 ()}
        {Lisp-Entry "get-path" accessor () () #f #f 590 35 590 43 ()}
        {Lisp-Entry "initialize" method (override) ("unit-locator" "declaration-locator" "locat" "path") #f #f 593 20 593 30 ("path~self" "locat~self" "declaration-locator~self" "self" "unit-locator~self" "set!" "nextmethod" "path" "locat" "declaration-locator" "unit-locator")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 601 20 601 25 ("path" "locat" "declaration-locator" "unit-locator" "self" "class-of" "category-name" "format" "readably" "output")}}
      {Lisp-Entry "Walk-Problem" class (package) ((extends . "Error")) #f #f 615 15 615 27 ("Error")
        {Lisp-Entry "location" slot () ((getter . "generate")) #f #f 618 8 618 16 ()}
        {Lisp-Entry "get-location" accessor () () #f #f 618 24 618 32 ()}}
      {Lisp-Entry "Walk-Problems" class (package) ((extends . "Error")) #f #f 626 15 626 28 ("Error")
        {Lisp-Entry "warnings" slot () ((getter . "generate")) #f #f 629 8 629 16 ()}
        {Lisp-Entry "get-warnings" accessor () () #f #f 629 24 629 32 ()}
        {Lisp-Entry "errors" slot () ((getter . "generate")) #f #f 630 8 630 14 ()}
        {Lisp-Entry "get-errors" accessor () () #f #f 630 24 630 32 ()}}
      {Lisp-Entry "Walk-Warning" class (package) ((extends . "Walk-Problem")) #f #f 638 15 638 27 ("Walk-Problem")}
      {Lisp-Entry "Walk-Error" class (package) ((extends . "Walk-Problem")) #f #f 646 15 646 25 ("Walk-Problem")}
      {Lisp-Entry "Unresolved-Error" class (package) ((extends . "Walk-Error")) #f #f 654 15 654 31 ("Walk-Error")
        {Lisp-Entry "symbol" slot () ((getter . "generate")) #f #f 657 8 657 14 ()}
        {Lisp-Entry "get-symbol" accessor () () #f #f 657 22 657 30 ()}}
      {Lisp-Entry "Walk-Frame" class () ((extends . "Walk-Binding")) #f #f 665 7 665 17 ("Walk-Binding")
        {Lisp-Entry "bindings" slot () ((getter . "generate")) #f #f 668 8 668 16 ()}
        {Lisp-Entry "get-bindings" accessor () () #f #f 668 24 668 32 ()}}
      {Lisp-Entry "Signature" class () ((extends . "Object")) #f #f 676 7 676 16 ("Object")
        {Lisp-Entry "mandatory" slot () ((getter . "generate")) #f #f 679 8 679 17 ()}
        {Lisp-Entry "get-mandatory" accessor () () #f #f 679 26 679 34 ()}
        {Lisp-Entry "positional" slot () ((getter . "generate")) #f #f 680 8 680 18 ()}
        {Lisp-Entry "get-positional" accessor () () #f #f 680 26 680 34 ()}
        {Lisp-Entry "optional" slot () ((getter . "generate")) #f #f 681 8 681 16 ()}
        {Lisp-Entry "get-optional" accessor () () #f #f 681 26 681 34 ()}
        {Lisp-Entry "named" slot () ((getter . "generate")) #f #f 682 8 682 13 ()}
        {Lisp-Entry "get-named" accessor () () #f #f 682 26 682 34 ()}
        {Lisp-Entry "rest" slot () ((getter . "generate")) #f #f 683 8 683 12 ()}
        {Lisp-Entry "get-rest" accessor () () #f #f 683 26 683 34 ()}}
      {Lisp-Entry "Symbol-Binding" class () ((extends . "Lexical-Binding")) #f #f 691 7 691 21 ("Lexical-Binding")
        {Lisp-Entry "gensym" slot () ((getter . "generate")) #f #f 694 8 694 14 ()}
        {Lisp-Entry "get-gensym" accessor () () #f #f 694 22 694 30 ()}}
      {Lisp-Entry "Variable" class () ((extends . "Symbol-Binding")) #f #f 702 7 702 15 ("Symbol-Binding")
        {Lisp-Entry "reference-count" slot () ((getter . "generate")) #f #f 705 8 705 23 ()}
        {Lisp-Entry "get-reference-count" accessor () () #f #f 705 31 705 39 ()}}
      {Lisp-Entry "NextMethod-Variable" class () ((extends . "Variable")) #f #f 713 7 713 26 ("Variable")}
      {Lisp-Entry "Parameter" class () ((extends . "Variable")) #f #f 721 7 721 16 ("Variable")}
      {Lisp-Entry "Dynamic-Parameter" class () ((extends . "Parameter")) #f #f 729 7 729 24 ("Parameter")
        {Lisp-Entry "class" slot () ((getter . "generate")) #f #f 732 8 732 13 ()}
        {Lisp-Entry "get-class" accessor () () #f #f 732 21 732 29 ()}}
      {Lisp-Entry "Optional-Parameter" class () ((extends . "Parameter")) #f #f 740 7 740 25 ("Parameter")
        {Lisp-Entry "default" slot () ((getter . "generate")) #f #f 743 8 743 15 ()}
        {Lisp-Entry "get-default" accessor () () #f #f 743 23 743 31 ()}}
      {Lisp-Entry "Named-Parameter" class () ((extends . "Parameter")) #f #f 751 7 751 22 ("Parameter")
        {Lisp-Entry "default" slot () ((getter . "generate")) #f #f 754 8 754 15 ()}
        {Lisp-Entry "get-default" accessor () () #f #f 754 23 754 31 ()}}
      {Lisp-Entry "Rest-Parameter" class () ((extends . "Parameter")) #f #f 762 7 762 21 ("Parameter")}
      {Lisp-Entry "Dynamic-Self-Binding" class () ((extends . "Lexical-Binding")) #f #f 770 7 770 27 ("Lexical-Binding")
        {Lisp-Entry "code" slot () ((getter . "generate")) #f #f 773 8 773 12 ()}
        {Lisp-Entry "get-code" accessor () () #f #f 773 20 773 28 ()}}
      {Lisp-Entry "Local-Variable-Binding" class () ((extends . "Lexical-Binding")) #f #f 781 7 781 29 ("Lexical-Binding")
        {Lisp-Entry "variable" slot () ((getter . "generate")) #f #f 784 8 784 16 ()}
        {Lisp-Entry "get-variable" accessor () () #f #f 784 24 784 32 ()}}
      {Lisp-Entry "Macro-Symbol" class () ((extends . "Symbol-Binding")) #f #f 792 7 792 19 ("Symbol-Binding")
        {Lisp-Entry "getter" slot () ((getter . "generate")) #f #f 795 8 795 14 ()}
        {Lisp-Entry "get-getter" accessor () () #f #f 795 22 795 30 ()}
        {Lisp-Entry "setter" slot () ((getter . "generate")) #f #f 796 8 796 14 ()}
        {Lisp-Entry "get-setter" accessor () () #f #f 796 22 796 30 ()}}
      {Lisp-Entry "Form-Binding" class () ((extends . "Lexical-Binding")) #f #f 804 7 804 19 ("Lexical-Binding")}
      {Lisp-Entry "Special-Form" class () ((extends . "Form-Binding")) #f #f 812 7 812 19 ("Form-Binding")
        {Lisp-Entry "walk" slot () ((getter . "generate")) #f #f 815 8 815 12 ()}
        {Lisp-Entry "get-walk" accessor () () #f #f 815 20 815 28 ()}}
      {Lisp-Entry "Macro-Form" class () ((extends . "Form-Binding")) #f #f 823 7 823 17 ("Form-Binding")
        {Lisp-Entry "expander" slot () ((getter . "generate")) #f #f 826 8 826 16 ()}
        {Lisp-Entry "get-expander" accessor () () #f #f 826 24 826 32 ()}}
      {Lisp-Entry "Syntax-Form" class () ((extends . "Form-Binding")) #f #f 834 7 834 18 ("Form-Binding")
        {Lisp-Entry "expander" slot () ((getter . "generate")) #f #f 837 8 837 16 ()}
        {Lisp-Entry "get-expander" accessor () () #f #f 837 24 837 32 ()}}
      {Lisp-Entry "Define-Syntax-Form" class () ((extends . "Syntax-Form")) #f #f 845 7 845 25 ("Syntax-Form")
        {Lisp-Entry "environment" slot () ((getter . "generate")) #f #f 848 8 848 19 ()}
        {Lisp-Entry "get-environment" accessor () () #f #f 848 27 848 35 ()}}
      {Lisp-Entry "Define-Local-Syntax-Form" class () ((extends . "Syntax-Form")) #f #f 856 7 856 31 ("Syntax-Form")
        {Lisp-Entry "environment" slot () ((getter . "generate")) #f #f 859 8 859 19 ()}
        {Lisp-Entry "get-environment" accessor () () #f #f 859 27 859 35 ()}}
      {Lisp-Entry "Syntactic-Closure" class () ((extends . "Object")) #f #f 867 7 867 24 ("Object")
        {Lisp-Entry "environment" slot () ((getter . "generate")) #f #f 870 8 870 19 ()}
        {Lisp-Entry "get-environment" accessor () () #f #f 870 27 870 35 ()}
        {Lisp-Entry "variables" slot () ((getter . "generate")) #f #f 871 8 871 17 ()}
        {Lisp-Entry "get-variables" accessor () () #f #f 871 27 871 35 ()}
        {Lisp-Entry "form" slot () ((getter . "generate")) #f #f 872 8 872 12 ()}
        {Lisp-Entry "get-form" accessor () () #f #f 872 27 872 35 ()}}
      {Lisp-Entry "Annotated-Variable" class () ((extends . "Object")) #f #f 880 7 880 25 ("Object")
        {Lisp-Entry "variable" slot () ((getter . "generate")) #f #f 883 8 883 16 ()}
        {Lisp-Entry "get-variable" accessor () () #f #f 883 29 883 37 ()}
        {Lisp-Entry "declared-type" slot () ((getter . "generate")) #f #f 884 8 884 21 ()}
        {Lisp-Entry "get-declared-type" accessor () () #f #f 884 29 884 37 ()}
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 885 8 885 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 885 29 885 37 ()}}
      {Lisp-Entry "Restricted-Binding" class () ((extends . "Object")) #f #f 893 7 893 25 ("Object")
        {Lisp-Entry "binding" slot () ((getter . "generate")) #f #f 896 8 896 15 ()}
        {Lisp-Entry "get-binding" accessor () () #f #f 896 23 896 31 ()}
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 897 8 897 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 897 23 897 31 ()}}
      {Lisp-Entry "Annotated-Frame" class () ((extends . "Object")) #f #f 905 7 905 22 ("Object")
        {Lisp-Entry "variables" slot () ((getter . "generate")) #f #f 908 8 908 17 ()}
        {Lisp-Entry "get-variables" accessor () () #f #f 908 25 908 33 ()}
        {Lisp-Entry "reset" slot () ((getter . "generate")) #f #f 909 8 909 13 ()}
        {Lisp-Entry "get-reset" accessor () () #f #f 909 25 909 33 ()}}
      {Lisp-Entry "Code" class () ((extends . "Object")) #f #f 917 7 917 11 ("Object")
        {Lisp-Entry "form" slot () ((getter . "generate")) #f #f 920 8 920 12 ()}
        {Lisp-Entry "get-form" accessor () () #f #f 920 22 920 30 ()}
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 921 8 921 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 921 22 921 30 ()}
        {Lisp-Entry "source" slot () ((getter . "generate")) #f #f 922 8 922 14 ()}
        {Lisp-Entry "get-source" accessor () () #f #f 922 22 922 30 ()}}
      {Lisp-Entry "Access" class () ((extends . "Object")) #f #f 930 7 930 13 ("Object")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 933 8 933 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 933 23 933 31 ()}
        {Lisp-Entry "context" slot () ((getter . "generate")) #f #f 934 8 934 15 ()}
        {Lisp-Entry "get-context" accessor () () #f #f 934 23 934 31 ()}}
      {Lisp-Entry "Expression" class () ((extends . "Object")) #f #f 942 7 942 17 ("Object")
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 945 8 945 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 945 22 945 30 ()}
        {Lisp-Entry "source" slot () ((getter . "generate")) #f #f 946 8 946 14 ()}
        {Lisp-Entry "get-source" accessor () () #f #f 946 22 946 30 ()}}
      {Lisp-Entry "emit-expression" native () () ("native-syntax") #f 949 15 949 35 ()}
      {Lisp-Entry "emit-call" native () () ("native-syntax") #f 950 15 950 29 ()}
      {Lisp-Entry "fold-expression" native () () ("native-syntax") #f 951 15 951 35 ()}
      {Lisp-Entry "Proclaim" class () ((extends . "Expression")) #f #f 959 7 959 15 ("Expression")
        {Lisp-Entry "clauses" slot () ((getter . "generate")) #f #f 962 8 962 15 ()}
        {Lisp-Entry "get-clauses" accessor () () #f #f 962 23 962 31 ()}}
      {Lisp-Entry "Constant" class () ((extends . "Expression")) #f #f 970 7 970 15 ("Expression")
        {Lisp-Entry "expansion" slot () ((getter . "generate")) #f #f 973 8 973 17 ()}
        {Lisp-Entry "get-expansion" accessor () () #f #f 973 25 973 33 ()}}
      {Lisp-Entry "Delay" class () ((extends . "Expression")) #f #f 981 7 981 12 ("Expression")
        {Lisp-Entry "expression" slot () ((getter . "generate")) #f #f 984 8 984 18 ()}
        {Lisp-Entry "get-expression" accessor () () #f #f 984 26 984 34 ()}}
      {Lisp-Entry "Quasiquote" class () ((extends . "Expression")) #f #f 992 7 992 17 ("Expression")
        {Lisp-Entry "form" slot () ((getter . "generate")) #f #f 995 8 995 12 ()}
        {Lisp-Entry "get-form" accessor () () #f #f 995 20 995 28 ()}}
      {Lisp-Entry "Binding-Reference" class () ((extends . "Expression")) #f #f 1003 7 1003 24 ("Expression")
        {Lisp-Entry "binding" slot () ((getter . "generate")) #f #f 1006 8 1006 15 ()}
        {Lisp-Entry "get-binding" accessor () () #f #f 1006 23 1006 31 ()}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 1009 20 1009 25 ("binding" "format" "lambda" "self" "print-unreadable" "readably" "output")}}
      {Lisp-Entry "Assignment" class () ((extends . "Expression")) #f #f 1021 7 1021 17 ("Expression")
        {Lisp-Entry "binding" slot () ((getter . "generate")) #f #f 1024 8 1024 15 ()}
        {Lisp-Entry "get-binding" accessor () () #f #f 1024 23 1024 31 ()}
        {Lisp-Entry "value" slot () ((getter . "generate")) #f #f 1025 8 1025 13 ()}
        {Lisp-Entry "get-value" accessor () () #f #f 1025 23 1025 31 ()}}
      {Lisp-Entry "Lambda" class () ((extends . "Expression")) #f #f 1033 7 1033 13 ("Expression")
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 1036 8 1036 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 1036 25 1036 33 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 1037 8 1037 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 1037 25 1037 33 ()}}
      {Lisp-Entry "Let" class () ((extends . "Expression")) #f #f 1045 7 1045 10 ("Expression")
        {Lisp-Entry "bindings" slot () ((getter . "generate")) #f #f 1048 8 1048 16 ()}
        {Lisp-Entry "get-bindings" accessor () () #f #f 1048 24 1048 32 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 1049 8 1049 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 1049 24 1049 32 ()}}
      {Lisp-Entry "Named-Let" class () ((extends . "Let")) #f #f 1057 7 1057 16 ("Let")
        {Lisp-Entry "variable" slot () ((getter . "generate")) #f #f 1060 8 1060 16 ()}
        {Lisp-Entry "get-variable" accessor () () #f #f 1060 24 1060 32 ()}}
      {Lisp-Entry "Letstar" class () ((extends . "Expression")) #f #f 1068 7 1068 14 ("Expression")
        {Lisp-Entry "bindings" slot () ((getter . "generate")) #f #f 1071 8 1071 16 ()}
        {Lisp-Entry "get-bindings" accessor () () #f #f 1071 24 1071 32 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 1072 8 1072 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 1072 24 1072 32 ()}}
      {Lisp-Entry "Letrec" class () ((extends . "Expression")) #f #f 1080 7 1080 13 ("Expression")
        {Lisp-Entry "bindings" slot () ((getter . "generate")) #f #f 1083 8 1083 16 ()}
        {Lisp-Entry "get-bindings" accessor () () #f #f 1083 24 1083 32 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 1084 8 1084 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 1084 24 1084 32 ()}}
      {Lisp-Entry "Receive" class () ((extends . "Expression")) #f #f 1092 7 1092 14 ("Expression")
        {Lisp-Entry "variables" slot () ((getter . "generate")) #f #f 1095 8 1095 17 ()}
        {Lisp-Entry "get-variables" accessor () () #f #f 1095 26 1095 34 ()}
        {Lisp-Entry "expression" slot () ((getter . "generate")) #f #f 1096 8 1096 18 ()}
        {Lisp-Entry "get-expression" accessor () () #f #f 1096 26 1096 34 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 1097 8 1097 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 1097 26 1097 34 ()}}
      {Lisp-Entry "Body" class () ((extends . "Expression")) #f #f 1105 7 1105 11 ("Expression")
        {Lisp-Entry "internal-defines" slot () ((getter . "generate")) #f #f 1108 8 1108 24 ()}
        {Lisp-Entry "get-internal-defines" accessor () () #f #f 1108 32 1108 40 ()}
        {Lisp-Entry "expressions" slot () ((getter . "generate")) #f #f 1109 8 1109 19 ()}
        {Lisp-Entry "get-expressions" accessor () () #f #f 1109 32 1109 40 ()}}
      {Lisp-Entry "Internal-Define" class () ((extends . "Expression")) #f #f 1117 7 1117 22 ("Expression")
        {Lisp-Entry "variable" slot () ((getter . "generate")) #f #f 1120 8 1120 16 ()}
        {Lisp-Entry "get-variable" accessor () () #f #f 1120 24 1120 32 ()}
        {Lisp-Entry "value" slot () ((getter . "generate")) #f #f 1121 8 1121 13 ()}
        {Lisp-Entry "get-value" accessor () () #f #f 1121 24 1121 32 ()}}
      {Lisp-Entry "Begin" class () ((extends . "Expression")) #f #f 1129 7 1129 12 ("Expression")
        {Lisp-Entry "expressions" slot () ((getter . "generate")) #f #f 1132 8 1132 19 ()}
        {Lisp-Entry "get-expressions" accessor () () #f #f 1132 27 1132 35 ()}}
      {Lisp-Entry "Do" class () ((extends . "Expression")) #f #f 1140 7 1140 9 ("Expression")
        {Lisp-Entry "bindings" slot () ((getter . "generate")) #f #f 1143 8 1143 16 ()}
        {Lisp-Entry "get-bindings" accessor () () #f #f 1143 24 1143 32 ()}
        {Lisp-Entry "test" slot () ((getter . "generate")) #f #f 1144 8 1144 12 ()}
        {Lisp-Entry "get-test" accessor () () #f #f 1144 24 1144 32 ()}
        {Lisp-Entry "result" slot () ((getter . "generate")) #f #f 1145 8 1145 14 ()}
        {Lisp-Entry "get-result" accessor () () #f #f 1145 24 1145 32 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 1146 8 1146 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 1146 24 1146 32 ()}}
      {Lisp-Entry "Call" class () ((extends . "Expression")) #f #f 1154 7 1154 11 ("Expression")
        {Lisp-Entry "operator" slot () ((getter . "generate")) #f #f 1157 8 1157 16 ()}
        {Lisp-Entry "get-operator" accessor () () #f #f 1157 25 1157 33 ()}
        {Lisp-Entry "arguments" slot () ((getter . "generate")) #f #f 1158 8 1158 17 ()}
        {Lisp-Entry "get-arguments" accessor () () #f #f 1158 25 1158 33 ()}}
      {Lisp-Entry "If" class () ((extends . "Expression")) #f #f 1166 7 1166 9 ("Expression")
        {Lisp-Entry "test" slot () ((getter . "generate")) #f #f 1169 8 1169 12 ()}
        {Lisp-Entry "get-test" accessor () () #f #f 1169 20 1169 28 ()}
        {Lisp-Entry "yes" slot () ((getter . "generate")) #f #f 1170 8 1170 11 ()}
        {Lisp-Entry "get-yes" accessor () () #f #f 1170 20 1170 28 ()}
        {Lisp-Entry "no" slot () ((getter . "generate")) #f #f 1171 8 1171 10 ()}
        {Lisp-Entry "get-no" accessor () () #f #f 1171 20 1171 28 ()}}
      {Lisp-Entry "Cond" class () ((extends . "Expression")) #f #f 1179 7 1179 11 ("Expression")
        {Lisp-Entry "clauses" slot () ((getter . "generate")) #f #f 1182 8 1182 15 ()}
        {Lisp-Entry "get-clauses" accessor () () #f #f 1182 23 1182 31 ()}}
      {Lisp-Entry "Case" class () ((extends . "Expression")) #f #f 1190 7 1190 11 ("Expression")
        {Lisp-Entry "target" slot () ((getter . "generate")) #f #f 1193 8 1193 14 ()}
        {Lisp-Entry "get-target" accessor () () #f #f 1193 23 1193 31 ()}
        {Lisp-Entry "clauses" slot () ((getter . "generate")) #f #f 1194 8 1194 15 ()}
        {Lisp-Entry "get-clauses" accessor () () #f #f 1194 23 1194 31 ()}}
      {Lisp-Entry "And" class () ((extends . "Expression")) #f #f 1202 7 1202 10 ("Expression")
        {Lisp-Entry "expressions" slot () ((getter . "generate")) #f #f 1205 8 1205 19 ()}
        {Lisp-Entry "get-expressions" accessor () () #f #f 1205 27 1205 35 ()}}
      {Lisp-Entry "Or" class () ((extends . "Expression")) #f #f 1213 7 1213 9 ("Expression")
        {Lisp-Entry "expressions" slot () ((getter . "generate")) #f #f 1216 8 1216 19 ()}
        {Lisp-Entry "get-expressions" accessor () () #f #f 1216 27 1216 35 ()}}
      {Lisp-Entry "Declare" class () ((extends . "Expression")) #f #f 1224 7 1224 14 ("Expression")
        {Lisp-Entry "declarations" slot () ((getter . "generate")) #f #f 1227 8 1227 20 ()}
        {Lisp-Entry "get-declarations" accessor () () #f #f 1227 28 1227 36 ()}}
      {Lisp-Entry "C-Include" class () ((extends . "Expression")) #f #f 1235 7 1235 16 ("Expression")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 1238 8 1238 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 1238 20 1238 28 ()}}
      {Lisp-Entry "C-Declare" class () ((extends . "Expression")) #f #f 1246 7 1246 16 ("Expression")
        {Lisp-Entry "code" slot () ((getter . "generate")) #f #f 1249 8 1249 12 ()}
        {Lisp-Entry "get-code" accessor () () #f #f 1249 20 1249 28 ()}}
      {Lisp-Entry "C-Named-Declare-Declaration" class () ((extends . "Declaration")) #f #f 1257 7 1257 34 ("Declaration")
        {Lisp-Entry "code" slot () ((getter . "generate")) #f #f 1260 8 1260 12 ()}
        {Lisp-Entry "get-code" accessor () () #f #f 1260 20 1260 28 ()}}
      {Lisp-Entry "C-Initialize" class () ((extends . "Expression")) #f #f 1268 7 1268 19 ("Expression")
        {Lisp-Entry "code" slot () ((getter . "generate")) #f #f 1271 8 1271 12 ()}
        {Lisp-Entry "get-code" accessor () () #f #f 1271 20 1271 28 ()}}
      {Lisp-Entry "C-Function" class () ((extends . "Expression")) #f #f 1279 7 1279 17 ("Expression")
        {Lisp-Entry "expansion" slot () ((getter . "generate")) #f #f 1282 8 1282 17 ()}
        {Lisp-Entry "get-expansion" accessor () () #f #f 1282 25 1282 33 ()}}
      {Lisp-Entry "Parameterize" class () ((extends . "Expression")) #f #f 1290 7 1290 19 ("Expression")
        {Lisp-Entry "bindings" slot () ((getter . "generate")) #f #f 1293 8 1293 16 ()}
        {Lisp-Entry "get-bindings" accessor () () #f #f 1293 24 1293 32 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 1294 8 1294 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 1294 24 1294 32 ()}}
      {Lisp-Entry "Time-Special" class () ((extends . "Expression")) #f #f 1302 7 1302 19 ("Expression")
        {Lisp-Entry "expressions" slot () ((getter . "generate")) #f #f 1305 8 1305 19 ()}
        {Lisp-Entry "get-expressions" accessor () () #f #f 1305 27 1305 35 ()}}
      {Lisp-Entry "Analysis-Data" class () ((extends . "Object")) #f #f 1313 7 1313 20 ("Object")
        {Lisp-Entry "autoload-reference" slot () ((getter . "generate")) #f #f 1316 8 1316 26 ()}
        {Lisp-Entry "get-autoload-reference" accessor () () #f #f 1316 38 1316 46 ()}
        {Lisp-Entry "declaration-references" slot () ((getter . "generate")) #f #f 1317 8 1317 30 ()}
        {Lisp-Entry "get-declaration-references" accessor () () #f #f 1317 38 1317 46 ()}}
      {Lisp-Entry "Core-Dialect" class () ((extends . "Dialect")) #f #f 1325 7 1325 19 ("Dialect")}
      {Lisp-Entry "Core-Walker" class () ((extends . "Walker")) #f #f 1333 7 1333 18 ("Walker")}}})
"debug"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "debug.scm"} 245382884. scheme
    {Lisp-Entry "jazz.dialect.core.debug" unit (protected) () #f #f 37 16 37 39 ()
      {Lisp-Entry "inspect" define () ("obj") #f #f 41 9 41 16 ("serial->object" "jazz:serial->object" "integer?" "if" "inspect-object" "jazz:inspect-object" "obj")}
      {Lisp-Entry "run-loop" define () () #f #f 46 9 46 17 ("Process" "jazz.system.process.Process" "jazz.system.process.Process:Process:run-loop" "run-loop" "jazz.system.access" "jazz.system.access:get-process" "global-ref" "jazz:global-ref" "get-process" "let")}
      {Lisp-Entry "resume" define () () #f #f 53 9 53 15 ("Process" "jazz.system.process.Process" "jazz.system.process.Process:Process:invoke-resume-loop" "invoke-resume-loop" "jazz.system.access" "jazz.system.access:get-process" "global-ref" "jazz:global-ref" "get-process" "let")}}}
  {Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "debug.jazz"} 233805977. jazz
    {Lisp-Entry "jazz.dialect.language.debug" module (protected) () #f #f 37 18 37 45 ("get-console-port" ":console" "register-printer" "jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("jazz.dialect.language.functional" "jazz.dialect.language.format" "jazz.dialect.kernel")}
      {Lisp-Entry "*console-port-getter*" definition () () #f #f 53 12 53 33 ()}
      {Lisp-Entry "set-console-port-getter" definition (public) ("getter") #f #f 57 20 57 43 ("*console-port-getter*" "set!" "getter")}
      {Lisp-Entry "get-console-port" definition (public) () #f #f 61 20 61 36 ("terminal-port" "*console-port-getter*" "not" "if")}
      {Lisp-Entry "console-input-port" definition (public) () #f #f 67 20 67 38 ("get-console-port")}
      {Lisp-Entry "console-output-port" definition (public) () #f #f 70 20 70 39 ("get-console-port")}
      {Lisp-Entry "force-console" definition (public) () #f #f 74 20 74 33 ("get-console-port" "force-output")}
      {Lisp-Entry "console" definition (public) ("." "rest") #f #f 86 20 86 27 ("format" "console-string" "rest")}
      {Lisp-Entry "console-string" definition (public) ("string" "(color: color #f)") #f #f 90 20 90 34 ("unspecified" "force-output" "format" "terminal-string" "not" "if" "console-output-port" "output" "let" "color" "color:" "string")}
      {Lisp-Entry "debug" definition (public) ("." "rest") #f #f 103 20 103 25 ("console" "apply" "lambda" "debug" "primordial-thread" "thread-execute" "rest")}
      {Lisp-Entry "debug-string" definition (public) ("." "rest") #f #f 109 20 109 32 ("console-string" "apply" "lambda" "debug-string" "primordial-thread" "thread-execute" "rest")}
      {Lisp-Entry "get-procedure-name" definition (public) ("procedure") #f #f 120 20 120 38 ("procedure-name" "or" "if" "get-output-string" "write" "open-output-string" "output" "let" "present-anonymous" "define" "procedure")}
      {Lisp-Entry "get-continuation-name" definition (public) ("cont") #f #f 133 20 133 41 ("continuation-creator" "get-procedure-name" "cont")}
      {Lisp-Entry "continuation-stack" definition (public) ("cont" "(dynamic-environment?: dynamic-environment? #f)" "(lexical-environment?: lexical-environment? #f)" "(identifiers?: identifiers? #f)" "(depth: depth #f)") #f #f 137 20 137 38 ("get-continuation-dynamic-environment" "append" "else" "get-continuation-lexical-environment" "cons" "not" "cond" "get-continuation-name" "lambda" "get-continuation-stack" "stack" "let" "map" "variables" "package-variables" "list" "mutable?" "value" "bind" "variable" "package-variable" "reference-name" "symbol?" "and" "if" "name" "package-name" "define" "depth" "depth:" "identifiers?" "identifiers?:" "lexical-environment?" "lexical-environment?:" "dynamic-environment?" "dynamic-environment?:" "cont")}
      {Lisp-Entry "execution-stack" definition (public) ("(dynamic-environment?: dynamic-environment? #f)" "(lexical-environment?: lexical-environment? #f)" "(identifiers?: identifiers? #f)" "(depth: depth #f)") #f #f 163 20 163 35 ("continuation-stack" "cont" "lambda" "continuation-capture" "depth" "depth:" "identifiers?" "identifiers?:" "lexical-environment?" "lexical-environment?:" "dynamic-environment?" "dynamic-environment?:")}
      {Lisp-Entry "break" definition (public) ("." "rest") #f #f 174 20 174 25 ("break-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "inspect" definition (public) ("." "rest") #f #f 178 20 178 27 ("inspect-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "advise" definition (public) ("." "rest") #f #f 182 20 182 26 ("advise-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "unadvise" definition (public) ("." "rest") #f #f 185 20 185 28 ("unadvise-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "debug-advice" definition (public) ("." "rest") #f #f 189 20 189 32 ("debug-advice-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "count-advice" definition (public) ("." "rest") #f #f 193 20 193 32 ("count-advice-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "time-advice" definition (public) ("." "rest") #f #f 197 20 197 31 ("time-advice-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "trace" definition (public) ("." "rest") #f #f 201 20 201 25 ("trace-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "untrace" definition (public) ("." "rest") #f #f 204 20 204 27 ("untrace-internal" "jazz.debuggee" "module-ref" "apply" "rest")}
      {Lisp-Entry "start-repl" definition (public) ("." "rest") #f #f 208 20 208 30 ("start-repl-internal" "jazz.debuggee" "module-ref" "apply" "rest")}}})
"declares"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "declares.scm"} 222341474. scheme
    {Lisp-Entry "f-run-time-bindings/safe" define () ("x") #f #f 3 9 3 33 ("car" "x")}
    {Lisp-Entry "f-not-run-time-bindings/safe" define () ("x") #f #f 10 9 10 37 ("car" "x")}
    {Lisp-Entry "f-run-time-bindings/not-safe" define () ("x") #f #f 17 9 17 37 ("car" "x")}
    {Lisp-Entry "f-not-run-time-bindings/not-safe" define () ("x") #f #f 24 9 24 41 ("car" "x")}
    {Lisp-Entry "f-standard-bindings/not-run-time-bindings/not-safe" define () ("x") #f #f 32 9 32 59 ("##pair?" "car" "x")}
    {Lisp-Entry "f-standard-bindings/run-time-bindings/not-safe" define () ("x") #f #f 41 9 41 55 ("##pair?" "car" "x")}
    {Lisp-Entry "f-standard-bindings/extended-bindings/not-safe" define () ("x") #f #f 50 9 50 55 ("##pair?" "car" "x")}
    {Lisp-Entry "f-block" define () () #f #f 57 9 57 16 ("g-block")}
    {Lisp-Entry "g-block" define () () #f #f 60 9 60 16 ("f-block")}
    {Lisp-Entry "f-separate" define () () #f #f 66 9 66 19 ("g-separate")}
    {Lisp-Entry "g-separate" define () () #f #f 69 9 69 19 ("f-separate")}})
"development"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "development.scm"} 231807278. scheme
    {Lisp-Entry "jazz.dialect.core.development" unit (protected) () #f #f 37 16 37 45 ()
      {Lisp-Entry "define-global" define-macro () () ("macro") #f 45 20 45 38 ("set!" ",value" ",setter" ",getter" ",name" "define" "begin" "generate-symbol" "jazz:generate-symbol" "value" "setter" "%%symbol->string" "%%string-append" "%%string->symbol" "getter" "let" "name")}
      {Lisp-Entry "?" define-macro () () ("global") #f 63 20 63 21 ()}
      {Lisp-Entry "%" define-macro () () ("global") #f 64 20 64 21 ()}
      {Lisp-Entry "?a" define-macro () () ("global") #f 67 20 67 22 ()}
      {Lisp-Entry "?b" define-macro () () ("global") #f 68 20 68 22 ()}
      {Lisp-Entry "?c" define-macro () () ("global") #f 69 20 69 22 ()}
      {Lisp-Entry "?d" define-macro () () ("global") #f 70 20 70 22 ()}
      {Lisp-Entry "?e" define-macro () () ("global") #f 71 20 71 22 ()}
      {Lisp-Entry "?f" define-macro () () ("global") #f 72 20 72 22 ()}
      {Lisp-Entry "?g" define-macro () () ("global") #f 73 20 73 22 ()}
      {Lisp-Entry "?h" define-macro () () ("global") #f 74 20 74 22 ()}
      {Lisp-Entry "?i" define-macro () () ("global") #f 75 20 75 22 ()}
      {Lisp-Entry "?j" define-macro () () ("global") #f 76 20 76 22 ()}
      {Lisp-Entry "?k" define-macro () () ("global") #f 77 20 77 22 ()}
      {Lisp-Entry "?l" define-macro () () ("global") #f 78 20 78 22 ()}
      {Lisp-Entry "?m" define-macro () () ("global") #f 79 20 79 22 ()}
      {Lisp-Entry "?n" define-macro () () ("global") #f 80 20 80 22 ()}
      {Lisp-Entry "?o" define-macro () () ("global") #f 81 20 81 22 ()}
      {Lisp-Entry "?p" define-macro () () ("global") #f 82 20 82 22 ()}
      {Lisp-Entry "?q" define-macro () () ("global") #f 83 20 83 22 ()}
      {Lisp-Entry "?r" define-macro () () ("global") #f 84 20 84 22 ()}
      {Lisp-Entry "?s" define-macro () () ("global") #f 85 20 85 22 ()}
      {Lisp-Entry "?t" define-macro () () ("global") #f 86 20 86 22 ()}
      {Lisp-Entry "?u" define-macro () () ("global") #f 87 20 87 22 ()}
      {Lisp-Entry "?v" define-macro () () ("global") #f 88 20 88 22 ()}
      {Lisp-Entry "?w" define-macro () () ("global") #f 89 20 89 22 ()}
      {Lisp-Entry "?x" define-macro () () ("global") #f 90 20 90 22 ()}
      {Lisp-Entry "?y" define-macro () () ("global") #f 91 20 91 22 ()}
      {Lisp-Entry "?z" define-macro () () ("global") #f 92 20 92 22 ()}
      {Lisp-Entry "%a" define-macro () () ("global") #f 95 20 95 22 ()}
      {Lisp-Entry "%b" define-macro () () ("global") #f 96 20 96 22 ()}
      {Lisp-Entry "%c" define-macro () () ("global") #f 97 20 97 22 ()}
      {Lisp-Entry "%d" define-macro () () ("global") #f 98 20 98 22 ()}
      {Lisp-Entry "%e" define-macro () () ("global") #f 99 20 99 22 ()}
      {Lisp-Entry "%f" define-macro () () ("global") #f 100 20 100 22 ()}
      {Lisp-Entry "%g" define-macro () () ("global") #f 101 20 101 22 ()}
      {Lisp-Entry "%h" define-macro () () ("global") #f 102 20 102 22 ()}
      {Lisp-Entry "%i" define-macro () () ("global") #f 103 20 103 22 ()}
      {Lisp-Entry "%j" define-macro () () ("global") #f 104 20 104 22 ()}
      {Lisp-Entry "%k" define-macro () () ("global") #f 105 20 105 22 ()}
      {Lisp-Entry "%l" define-macro () () ("global") #f 106 20 106 22 ()}
      {Lisp-Entry "%m" define-macro () () ("global") #f 107 20 107 22 ()}
      {Lisp-Entry "%n" define-macro () () ("global") #f 108 20 108 22 ()}
      {Lisp-Entry "%o" define-macro () () ("global") #f 109 20 109 22 ()}
      {Lisp-Entry "%p" define-macro () () ("global") #f 110 20 110 22 ()}
      {Lisp-Entry "%q" define-macro () () ("global") #f 111 20 111 22 ()}
      {Lisp-Entry "%r" define-macro () () ("global") #f 112 20 112 22 ()}
      {Lisp-Entry "%s" define-macro () () ("global") #f 113 20 113 22 ()}
      {Lisp-Entry "%t" define-macro () () ("global") #f 114 20 114 22 ()}
      {Lisp-Entry "%u" define-macro () () ("global") #f 115 20 115 22 ()}
      {Lisp-Entry "%v" define-macro () () ("global") #f 116 20 116 22 ()}
      {Lisp-Entry "%w" define-macro () () ("global") #f 117 20 117 22 ()}
      {Lisp-Entry "%x" define-macro () () ("global") #f 118 20 118 22 ()}
      {Lisp-Entry "%y" define-macro () () ("global") #f 119 20 119 22 ()}
      {Lisp-Entry "%z" define-macro () () ("global") #f 120 20 120 22 ()}}}
  {Lisp-File-Entry {File :context "src" "jazz" "development.jazz"} 246587394. jazz
    {Lisp-Entry "jazz.development" module () () #f #f 37 8 37 24 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.library" "jazz.jml")}
      {Lisp-Entry "iter-list" definition () ("lst" "proc") #f #f 52 13 52 22 ("cdr" "iter-list" "car" "when" "proc" "lst")}
      {Lisp-Entry "iter-node" definition () ("node" "proc") #f #f 58 13 58 22 ("get-children" "get-children~" "for-each" "iter" "define" "proc" "node")}
      {Lisp-Entry "iter" definition () ("obj" "proc") #f #f 66 13 66 17 ("iter-node" "JML-Node" "is?" "iter-list" "null/pair?" "cond" "proc" "obj")}
      {Lisp-Entry "foldl-list" definition () ("x" "f" "s") #f #f 71 13 71 23 ("car" "cdr" "foldl-list" "not" "if" "s" "f" "x")}
      {Lisp-Entry "foldr-list" definition () ("x" "f" "s") #f #f 77 13 77 23 ("cdr" "foldr-list" "car" "not" "if" "s" "f" "x")}
      {Lisp-Entry "foldl-node" definition () ("x" "f" "s") #f #f 83 13 83 23 ("foldl-node" "c" "lambda" "get-children" "get-children~" "foldl" "s" "f" "x")}
      {Lisp-Entry "foldr-node" definition () ("x" "f" "s") #f #f 90 13 90 23 ("s" "f" "x")}
      {Lisp-Entry "foldl-component" definition () ("x" "f" "s") #f #f 94 13 94 28 ("foldl-component" "c" "lambda" "get-children" "get-children~" "foldl" "s" "f" "x")}
      {Lisp-Entry "foldr-component" definition () ("x" "f" "s") #f #f 101 13 101 28 ("s" "f" "x")}
      {Lisp-Entry "foldl" definition () ("x" "f" "s") #f #f 105 13 105 18 ("foldl-component" "Component" "foldl-node" "JML-Node" "is?" "foldl-list" "null/pair?" "cond" "s" "f" "x")}
      {Lisp-Entry "foldr" definition () ("x" "f" "s") #f #f 111 13 111 18 ("foldr-component" "Component" "foldr-node" "JML-Node" "is?" "foldr-list" "null/pair?" "cond" "s" "f" "x")}
      {Lisp-Entry "iter-map" definition () ("proc" "obj") #f #f 117 13 117 21 ("get-output" "get-output~" "put" "put~" "x" "lambda" "iter" "List-Factory" "new" "fact" "let" "obj" "proc")}
      {Lisp-Entry "iter-linearize" definition () ("obj") #f #f 125 13 125 27 ("identity" "iter-map" "obj")}
      {Lisp-Entry "fold-map" definition () ("proc" "obj") #f #f 129 13 129 21 ("cons" "lst" "x" "lambda" "foldr" "obj" "proc")}
      {Lisp-Entry "foldl-map" definition () ("proc" "obj") #f #f 136 13 136 22 ("cons" "lst" "x" "lambda" "foldl" "obj" "proc")}
      {Lisp-Entry "fold-linearize" definition () ("obj") #f #f 143 13 143 27 ("identity" "fold-map" "obj")}
      {Lisp-Entry "fold" definition (public) ("x" "f" "s") #f #f 147 20 147 24 ("fold-component" "Component" "fold-node" "JML-Node" "is?" "foldl-list" "null/pair?" "cond" "s" "f" "x")}
      {Lisp-Entry "fold-node" definition () ("x" "f" "s") #f #f 153 13 153 22 ("get-children" "get-children~" "fold-node" "c" "lambda" "for-each" "ps" "let" "s" "f" "x")}
      {Lisp-Entry "fold-component" definition () ("x" "f" "s") #f #f 161 13 161 27 ("get-children" "get-children~" "fold-component" "c" "lambda" "for-each" "ps" "let" "s" "f" "x")}
      {Lisp-Entry "component->jml" definition (public) ("x" "(properties: properties #f)") #f #f 169 20 169 34 ("component-self->jml" "p" "c" "lambda" "fold" "properties" "properties:" "x")}
      {Lisp-Entry "component-self->jml" definition () ("c" "p" "(properties: properties #f)") #f #f 176 13 176 32 ("object->serial" "format" "serial" "read-property" "list" "property-field?" "when" "property" "lambda" "collect" "append" "apply" "get-name" "get-name~" "name" "class-of" "category-name" "JML-Element" "new" "size" "position" "or" "let" "properties" "properties:" "p" "c")}
      {Lisp-Entry "component-ascendants->jml" definition () ("c" "(properties: properties #f)") #f #f 188 13 188 38 ("find-toplevel" "if" "get-parent" "get-parent~" "parent" "let" "component-self->jml" "component->jml" "define" "properties" "properties:" "c")}
      {Lisp-Entry "pprint-component" definition (public) ("x" "(properties: properties #f)") #f #f 205 20 205 36 (":console" "component->jml" "pretty-print" "pretty-print~" "properties" "properties:" "x")}
      {Lisp-Entry "pprint-component-ascendants" definition (public) ("x" "(properties: properties #f)") #f #f 211 20 211 47 ("align-name?:" ":console" "component-ascendants->jml" "pretty-print" "pretty-print~" "properties" "properties:" "x")}
      {Lisp-Entry "ppd" definition (public) ("c" "(properties: properties #f)") #f #f 223 20 223 23 ("unspecified" "pprint-component" "properties" "properties:" "c")}
      {Lisp-Entry "ppa" definition (public) ("c" "(properties: properties #f)") #f #f 228 20 228 23 ("unspecified" "pprint-component-ascendants" "properties" "properties:" "c")}
      {Lisp-Entry "hex" definition (public) ("n") #f #f 238 20 238 23 ("format" "n")}}})
"dialect"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "dialect.scm"} 246662659. scheme
    {Lisp-Entry "jazz.dialect.dialect" unit (protected) () #f #f 37 16 37 36 ("Dispatch" "jazz:Dispatch" "Allocate" "jazz:Allocate" "Cast" "jazz:Cast" "With-Dynamic-Self" "jazz:With-Dynamic-Self" "With-Self" "jazz:With-Self" "Jazz-Walker" "jazz:Jazz-Walker" "Jazz-Dialect" "jazz:Jazz-Dialect" "Method-Declaration" "jazz:Method-Declaration" "Property-Declaration" "jazz:Property-Declaration" "Slot-Declaration" "jazz:Slot-Declaration" "Field-Declaration" "jazz:Field-Declaration" "Interface-Declaration" "jazz:Interface-Declaration" "%%get-class-declaration-ascendant" "%%not" "%%class-is?" "and" "type" "lambda" "object-declaration?" "jazz:object-declaration?" "set!" "Class-Declaration" "jazz:Class-Declaration" "Category-Declaration" "jazz:Category-Declaration" "Specific-Declaration" "jazz:Specific-Declaration" "Generic-Declaration" "jazz:Generic-Declaration" "Specialize" "jazz:Specialize" "encapsulate-class" "jazz:encapsulate-class" "Definition-Declaration" "jazz:Definition-Declaration")
      {Lisp-Entry "Definition-Declaration" define-class () () ("class runtime") #f 45 27 45 54 ()}
      {Lisp-Entry "new-definition-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "expansion" "signature") #f #f 48 9 48 40 ("setup-declaration" "jazz:setup-declaration" "Definition-Declaration" "jazz:Definition-Declaration" "allocate-definition-declaration" "jazz:allocate-definition-declaration" "new-declaration" "let" "signature" "expansion" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Definition-Declaration") #f 54 21 54 52 ("validate-arguments" "jazz:validate-arguments" "if" "declaration" "%%get-definition-declaration-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-inlined-binding-call" generic/specific () ("arguments" "call" "source-declaration" "environment") ("jazz:Definition-Declaration") #f 60 21 60 51 ("%%get-lexical-binding-name" "error" "jazz:error" "call-return-type" "jazz:call-return-type" "%%get-expression-source" "%%get-code-form" "sourcify-list" "jazz:sourcify-list" "%%get-signature-positional" "%%get-lexical-binding-type" "emit-type-cast" "jazz:emit-type-cast" "emit-binding-symbol" "jazz:emit-binding-symbol" "argument" "parameter" "map" "new-code" "jazz:new-code" "emit-expression" "jazz:emit-expression" "body-code" "%%cons" "augmented-environment" "frame" "lambda" "annotate-inlined-signature" "jazz:annotate-inlined-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "only-positional?" "jazz:only-positional?" "%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "untyped-inline-definition?" "jazz:untyped-inline-definition?" "inline-definitions?" "jazz:inline-definitions?" "or" "inline" "%%get-definition-declaration-expansion" "%%eq?" "and" "Lambda" "jazz:Lambda" "%%class-is?" "if" "declaration" "%%get-definition-declaration-value" "value" "let" "environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "untyped-inline-definition?" define () ("value") #f #f 92 9 92 40 ("%%get-lambda-signature" "%%get-signature-positional" "%%get-lexical-binding-type" "%%not" "parameter" "lambda" "every?" "jazz:every?" "value")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Definition-Declaration") #f 98 21 98 42 ("%%get-declaration-source" "new-definition" "jazz:new-definition" "add-field" "jazz:add-field" ",name" "register-definition" "jazz:register-definition" "Module-Declaration" "jazz:Module-Declaration" "%%is?" "if" "%%get-declaration-parent" "parent" "%%get-lexical-binding-name" "name" "%%get-lexical-binding-type" "emit-expression" "jazz:emit-expression" "emit-type-cast" "jazz:emit-type-cast" ",locator" "define" "begin" "sourcify-if" "jazz:sourcify-if" "%%get-definition-declaration-value" "value" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Definition-Declaration") #f 113 21 113 48 ("Any" "jazz:Any" "%%get-lexical-binding-type" "or" "declaration" "%%get-declaration-locator" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "walk-binding-validate-assignment" generic/specific () ("walker" "resume" "source-declaration" "symbol-src") ("jazz:Definition-Declaration") #f 121 21 121 58 ("%%get-lexical-binding-name" "walk-error" "jazz:walk-error" "%%get-declaration-toplevel" "%%neq?" "%%when" "declaration" "nextmethod" "symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "walk-binding-assignable?" generic/specific () () ("jazz:Definition-Declaration") #f 127 21 127 50 ()}
      {Lisp-Entry "emit-binding-assignment" generic/specific () ("value" "source-declaration" "environment") ("jazz:Definition-Declaration") #f 131 21 131 49 ("Any" "jazz:Any" "%%get-lexical-binding-type" "emit-expression" "jazz:emit-expression" "emit-type-cast" "jazz:emit-type-cast" ",locator" "set!" "new-code" "jazz:new-code" "declaration" "%%get-declaration-locator" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Definition-Declaration") #f 139 21 139 42 ("%%get-definition-declaration-value" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "Specialize" define-class () () ("class runtime") #f 153 27 153 42 ()}
      {Lisp-Entry "new-specialize" define () () #f #f 156 9 156 28 ("Specialize" "jazz:Specialize" "allocate-specialize" "jazz:allocate-specialize")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Specialize") #f 160 21 160 41 ("Any" "jazz:Any" "begin" "new-code" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Specialize") #f 167 21 167 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "Generic-Declaration" define-class () () ("class runtime") #f 179 27 179 51 ()}
      {Lisp-Entry "new-generic-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "dispatch-types" "signature") #f #f 182 9 182 37 ("setup-declaration" "jazz:setup-declaration" "Generic-Declaration" "jazz:Generic-Declaration" "allocate-generic-declaration" "jazz:allocate-generic-declaration" "new-declaration" "let" "signature" "dispatch-types" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Generic-Declaration") #f 188 21 188 52 ("%%get-generic-declaration-signature" "declaration" "validate-arguments" "jazz:validate-arguments" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Generic-Declaration") #f 192 21 192 42 ("%%get-declaration-source" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "emit-signature" "jazz:emit-signature" "define-generic" "jazz:define-generic" "sourcify-if" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-generic-declaration-body" "body" "%%get-generic-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "generic-locator" "let" "environment")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Generic-Declaration") #f 205 21 205 48 ("Any" "jazz:Any" "declaration" "%%get-declaration-locator" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Generic-Declaration") #f 212 21 212 42 ("%%get-generic-declaration-body" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "Specific-Declaration" define-class () () ("class runtime") #f 226 27 226 52 ()}
      {Lisp-Entry "new-specific-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "generic" "signature" "root?") #f #f 229 9 229 38 ("setup-declaration" "jazz:setup-declaration" "Specific-Declaration" "jazz:Specific-Declaration" "allocate-specific-declaration" "jazz:allocate-specific-declaration" "new-declaration" "let" "root?" "signature" "generic" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "get-nextmethod-signature" generic/specific () () ("jazz:Specific-Declaration") #f 235 21 235 50 ("declaration" "%%get-specific-declaration-signature")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Specific-Declaration") #f 239 21 239 42 ("%%get-declaration-source" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" ",modifier" "emit-signature" "jazz:emit-signature" "define-specific" "jazz:define-specific" "sourcify-if" "jazz:sourcify-if" "child" "root" "%%get-specific-declaration-root?" "if" "modifier" "%%cons" "augmented-environment" "let" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-specific-declaration-body" "body" "%%get-specific-declaration-signature" "signature" "jazz:generic-object-locator" "generic-object-locator" "%%get-declaration-locator" "generic-locator" "declaration" "%%get-specific-declaration-generic" "generic-declaration" "let*" "environment")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Specific-Declaration") #f 255 21 255 42 ("%%get-specific-declaration-body" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "Category-Declaration" define-class () () ("class runtime") #f 269 27 269 52 ()}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Category-Declaration") #f 272 21 272 48 ("Category-Declaration" "jazz:Category-Declaration" "declaration" "%%get-declaration-locator" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "Class-Declaration" define-class () () ("class runtime") #f 287 27 287 49 ()}
      {Lisp-Entry "new-class-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "implementor" "metaclass" "ascendant" "ascendant-relation" "ascendant-base" "interfaces") #f #f 290 9 290 35 ("setup-declaration" "jazz:setup-declaration" "new-queue" "jazz:new-queue" "protected-access" "jazz:protected-access" "make-access-lookups" "jazz:make-access-lookups" "Class-Declaration" "jazz:Class-Declaration" "allocate-class-declaration" "jazz:allocate-class-declaration" "new-declaration" "let" "interfaces" "ascendant-base" "ascendant-relation" "ascendant" "metaclass" "implementor" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "setup-class-lookups" define () ("class-declaration") #f #f 296 9 296 33 ("protected-access" "jazz:protected-access" "%%get-namespace-declaration-lookups" "%%vector-set!" "not-private" "public" "interface" "lambda" "for-each" "public-access" "jazz:public-access" "%%table-merge!" "%%get-declaration-toplevel" "%%eq?" "same-module?" "private-access" "jazz:private-access" "%%get-access-lookup" "private" "%%get-class-declaration-interfaces" "map" "interfaces" "%%get-class-declaration-ascendant" "ascendant" "Interface-Declaration" "jazz:Interface-Declaration" "interface-declaration" "resolve-interface" "Class-Declaration" "jazz:Class-Declaration" "%%is?" "%%assert" "resolve-binding" "jazz:resolve-binding" "let" "if" "decl" "resolve-class" "define" "class-declaration")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Class-Declaration") #f 343 21 343 48 ("Class-Declaration" "jazz:Class-Declaration" "%%get-category-declaration-metaclass" "or" "declaration" "%%get-declaration-locator" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Class-Declaration") #f 351 21 351 37 ("%%get-class-declaration-ascendant" "%%eq?" "resolve-binding" "jazz:resolve-binding" "target-declaration" "%%not" "target" "iter" "let" "Class-Declaration" "jazz:Class-Declaration" "%%class-is?" "and" "declaration" "object-declaration?" "jazz:object-declaration?" "if" "subtype")}
      {Lisp-Entry "specifiable?" generic/specific () () ("jazz:Class-Declaration") #f 364 21 364 38 ()}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Class-Declaration") #f 368 21 368 42 ("%%get-declaration-source" "emit-namespace-statements" "jazz:emit-namespace-statements" "register-module-entry" "jazz:register-module-entry" "%%get-declaration-toplevel" "toplevel-declaration" ",@interface-accesses" "%%list" ",metaclass-access" "new-class" "jazz:new-class" "global-ref" "jazz:global-ref" "global-bound?" "jazz:global-bound?" "lambda" "map" "interface-accesses" ",ascendant-access" "%%get-object-class" "Object-Class" "jazz:Object-Class" "metaclass-access" "emit-ascendant-access" "jazz:emit-ascendant-access" "%%get-category-declaration-metaclass" "metaclass-declaration" "remove-own-slots" "jazz:remove-own-slots" ",name" "set-core-class-redefined" "jazz:set-core-class-redefined" "%%get-class-level" ",level-locator" ",core-class-locator" ",locator" "define" "emit-binding-reference" "jazz:emit-binding-reference" "sourcified-form" "jazz:sourcified-form" "ascendant-access" "%%get-category-identifier" "core-class-locator" "validate-core-class" "jazz:validate-core-class" "%%symbol?" "%%not" "get-core-class" "jazz:get-core-class" "core-class" "core-class?" "jazz:core-class?" "if" "begin" "sourcify-if" "jazz:sourcify-if" "level" "compose-helper" "jazz:compose-helper" "level-locator" "%%get-namespace-declaration-body" "body" "%%get-class-declaration-interfaces" "interface-declarations" "%%get-class-declaration-ascendant" "ascendant-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "emit-ascendant-access" define () ("declaration" "environment") #f #f 403 9 403 35 ("%%cdr" "%%get-object-class" "%%null?" "if" "rel" "rec" "else" "emit-binding-reference" "jazz:emit-binding-reference" "sourcified-form" "jazz:sourcified-form" "%%not" "cond" "%%get-class-declaration-ascendant-base" "ascendant-base" "%%get-class-declaration-ascendant-relation" "ascendant-relation" "%%get-class-declaration-ascendant" "ascendant" "let" "environment" "declaration")}
      {Lisp-Entry "find-class-declaration" define () ("declaration") #f #f 421 9 421 36 ("%%get-declaration-parent" "else" "Class-Declaration" "jazz:Class-Declaration" "%%class-is?" "error" "jazz:error" "%%not" "cond" "decl" "iter" "let" "declaration")}
      {Lisp-Entry "validate-core-class" define () ("core-class" "declaration") #f #f 442 9 442 33 ("%%equal?" "%%get-namespace-declaration-body" "decl" "declaration-slot-names" "%%get-class-instance-slots" "%%get-field-name" "%%symbol?" "name/slot" "lambda" "map" "core-class-slot-names" "queue-list" "jazz:queue-list" "%%get-begin-expressions" "for-each" "Begin" "jazz:Begin" "enqueue" "jazz:enqueue" "Slot-Declaration" "jazz:Slot-Declaration" "%%is?" "cond" "obj" "process" "new-queue" "jazz:new-queue" "queue" "lst" "collect-slots" "validate-slots" "%%null?" "%%get-class-declaration-interfaces" "declaration-interfaces" "let" "validate-interfaces" "%%get-lexical-binding-name" "error" "jazz:error" "%%eq?" "%%when" "%%get-declaration-locator" "declaration-ascendant-name" "%%get-class-declaration-ascendant" "declaration-ascendant" "%%get-category-identifier" "reference-name" "jazz:reference-name" "%%not" "if" "core-class-ascendant-name" "%%get-class-ascendant" "core-class-ascendant" "let*" "validate-ascendant" "validate-category" "define" "declaration" "core-class")}
      {Lisp-Entry "Interface-Declaration" define-class () () ("class runtime") #f 486 27 486 53 ()}
      {Lisp-Entry "new-interface-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "implementor" "metaclass" "ascendants") #f #f 489 9 489 39 ("setup-declaration" "jazz:setup-declaration" "new-queue" "jazz:new-queue" "protected-access" "jazz:protected-access" "make-access-lookups" "jazz:make-access-lookups" "Interface-Declaration" "jazz:Interface-Declaration" "allocate-interface-declaration" "jazz:allocate-interface-declaration" "new-declaration" "let" "ascendants" "metaclass" "implementor" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "setup-interface-lookups" define () ("interface-declaration") #f #f 495 9 495 37 ("protected-access" "jazz:protected-access" "%%get-namespace-declaration-lookups" "%%vector-set!" "public-access" "jazz:public-access" "%%table-merge!" "interface" "lambda" "for-each" "private-access" "jazz:private-access" "%%get-access-lookup" "private" "%%get-interface-declaration-ascendants" "map" "ascendants" "Interface-Declaration" "jazz:Interface-Declaration" "%%is?" "%%assert" "resolve-binding" "jazz:resolve-binding" "let" "if" "decl" "resolve-interface" "define" "interface-declaration")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Interface-Declaration") #f 528 21 528 37 ("subtype")}
      {Lisp-Entry "specifiable?" generic/specific () () ("jazz:Interface-Declaration") #f 533 21 533 38 ()}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Interface-Declaration") #f 537 21 537 42 ("%%get-declaration-source" "emit-namespace-statements" "jazz:emit-namespace-statements" ",name" "register-module-entry" "jazz:register-module-entry" "%%get-declaration-toplevel" "toplevel-declaration" "let" "%%get-interface-rank" ",rank-locator" ",@ascendant-accesses" "%%list" ",metaclass-access" "new-interface" "jazz:new-interface" ",locator" "define" "begin" "sourcify-if" "jazz:sourcify-if" "%%get-namespace-declaration-body" "body" "lambda" "map" "ascendant-accesses" "emit-binding-reference" "jazz:emit-binding-reference" "sourcified-form" "jazz:sourcified-form" "Interface" "jazz:Interface" "%%not" "if" "metaclass-access" "%%get-category-declaration-metaclass" "metaclass-declaration" "%%get-interface-declaration-ascendants" "ascendant-declarations" "rank" "compose-helper" "jazz:compose-helper" "rank-locator" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "Field-Declaration" define-class () () ("class runtime") #f 566 27 566 49 ()}
      {Lisp-Entry "Slot-Declaration" define-class () () ("class runtime") #f 577 27 577 48 ()}
      {Lisp-Entry "new-slot-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "initialize" "getter-name" "setter-name") #f #f 580 9 580 34 ("setup-declaration" "jazz:setup-declaration" "Slot-Declaration" "jazz:Slot-Declaration" "allocate-slot-declaration" "jazz:allocate-slot-declaration" "new-declaration" "let" "setter-name" "getter-name" "initialize" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Slot-Declaration") #f 586 21 586 52 ("form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Slot-Declaration") #f 590 21 590 42 ("%%get-declaration-source" "declaration-result" "jazz:declaration-result" "%%get-slot-offset" ",offset-locator" ",allocate?" ",name" ",class-locator" "add-slot" "jazz:add-slot" ",slot-locator" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "self" ",initialize-locator" "define" "if" "begin" "sourcify-if" "jazz:sourcify-if" "offset" "offset-locator" "slot" "slot-locator" "compose-helper" "jazz:compose-helper" "initialize-locator" "%%not" "and" "initialize?" "%%get-slot-declaration-initialize" "initialize" "core-class?" "jazz:core-class?" "core?" "Void" "jazz:Void" "%%get-lexical-binding-type" "%%neq?" "allocate?" "class-locator" "%%get-declaration-parent" "class-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Slot-Declaration") #f 616 21 616 48 ("error" "jazz:error" "find-annotated-type" "jazz:find-annotated-type" ",offset-locator" "sourcified-form" "jazz:sourcified-form" "%%object-ref" "new-code" "jazz:new-code" "offset" "declaration" "%%get-declaration-locator" "compose-helper" "jazz:compose-helper" "offset-locator" "if" "*self*" "jazz:*self*" "self" "let" "environment" "source-declaration")}
      {Lisp-Entry "walk-binding-assignable?" generic/specific () () ("jazz:Slot-Declaration") #f 627 21 627 50 ()}
      {Lisp-Entry "emit-binding-assignment" generic/specific () ("value" "source-declaration" "environment") ("jazz:Slot-Declaration") #f 631 21 631 49 ("error" "jazz:error" "Any" "jazz:Any" "emit-expression" "jazz:emit-expression" ",offset-locator" "sourcified-form" "jazz:sourcified-form" "%%object-set!" "new-code" "jazz:new-code" "offset" "declaration" "%%get-declaration-locator" "compose-helper" "jazz:compose-helper" "offset-locator" "if" "*self*" "jazz:*self*" "self" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Slot-Declaration") #f 642 21 642 42 ("%%get-slot-declaration-initialize" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "Property-Declaration" define-class () () ("class runtime") #f 656 27 656 52 ()}
      {Lisp-Entry "new-property-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "initialize" "getter-name" "setter-name") #f #f 659 9 659 38 ("setup-declaration" "jazz:setup-declaration" "Property-Declaration" "jazz:Property-Declaration" "allocate-property-declaration" "jazz:allocate-property-declaration" "new-declaration" "let" "setter-name" "getter-name" "initialize" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Property-Declaration") #f 665 21 665 42 ("%%get-declaration-source" "declaration-result" "jazz:declaration-result" "%%get-slot-offset" ",offset-locator" ",allocate?" ",name" ",class-locator" "add-property" "jazz:add-property" ",slot-locator" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" ",initialize-locator" "begin" "sourcify-if" "jazz:sourcify-if" "cddr" "cdadr" "self" "car" "cons" "pair?" "if" "expr" "fix-self" "define" "%%get-property-declaration-setter" "setter" "%%get-property-declaration-getter" "getter" "offset" "offset-locator" "slot" "slot-locator" "compose-helper" "jazz:compose-helper" "initialize-locator" "%%not" "and" "initialize?" "%%get-slot-declaration-initialize" "initialize" "core-class?" "jazz:core-class?" "core?" "Void" "jazz:Void" "%%get-lexical-binding-type" "%%neq?" "allocate?" "class-locator" "%%get-declaration-parent" "class-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "Method-Declaration" define-class () () ("class runtime") #f 708 27 708 50 ()}
      {Lisp-Entry "new-method-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "root" "propagation" "abstraction" "expansion" "remote" "synchronized" "signature") #f #f 711 9 711 36 ("setup-declaration" "jazz:setup-declaration" "Method-Declaration" "jazz:Method-Declaration" "allocate-method-declaration" "jazz:allocate-method-declaration" "new-declaration" "let" "signature" "synchronized" "remote" "expansion" "abstraction" "propagation" "root" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "method-dispatch-info" define () ("declaration") #f #f 717 9 717 34 ("error" "else" "interface" "Interface-Declaration" "jazz:Interface-Declaration" "class" "Class-Declaration" "jazz:Class-Declaration" "%%class-is?" "cond" "%%get-declaration-parent" "category-declaration" "or" "method-declaration" "root-method-declaration" "values" "final" "%%eq?" "%%not" "and" "if" "%%get-method-declaration-propagation" "propagation" "%%get-method-declaration-root" "root" "let" "declaration")}
      {Lisp-Entry "native-category?" define () ("category-declaration") #f #f 733 9 733 30 ("primitive" "%%get-category-declaration-implementor" "%%neq?" "category-declaration")}
      {Lisp-Entry "emit-method-dispatch" define () ("object" "declaration" "source-declaration" "environment") #f #f 737 9 737 34 ("%%get-lexical-binding-type" "call-return-type" "jazz:call-return-type" ",interface-rank-locator" "%%interface-dispatch" "interface-rank-locator" "interface" ",method-rank-locator" ",class-level-locator" "%%get-object-class" "%%class-dispatch" "native-category?" "jazz:native-category?" "if" "rank" "method-rank-locator" "level" "compose-helper" "jazz:compose-helper" "class-level-locator" "class" ",implementation-locator" ",object-cast" "class-of" "jazz:class-of" "%%final-dispatch" "%%get-declaration-locator" "implementation-locator" "final" "case" "new-code" "jazz:new-code" "emit-type-cast" "jazz:emit-type-cast" "object-cast" "%%get-declaration-parent" "category-declaration" "method-dispatch-info" "jazz:method-dispatch-info" "method-declaration" "dispatch-type" "receive" "%%get-lexical-binding-name" "name" "let" "environment" "source-declaration" "declaration" "object")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Method-Declaration") #f 763 21 763 48 ("%%get-declaration-locator" "%%get-lexical-binding-name" "error" "jazz:error" "%%get-code-type" "sourcified-form" "jazz:sourcified-form" "apply" "rest" "lambda" "new-code" "jazz:new-code" "declaration" "emit-method-dispatch" "jazz:emit-method-dispatch" "dispatch-code" "if" "*self*" "jazz:*self*" "self" "let" "environment" "source-declaration")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Method-Declaration") #f 775 21 775 52 ("validate-arguments" "jazz:validate-arguments" "if" "declaration" "%%get-method-declaration-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-inlined-binding-call" generic/specific () ("arguments" "call" "source-declaration" "environment") ("jazz:Method-Declaration") #f 781 21 781 51 ("else" "%%get-lexical-binding-name" "error" "jazz:error" "call-return-type" "jazz:call-return-type" "%%get-expression-source" "%%get-code-form" "desourcify-all" "jazz:desourcify-all" "sourcify-if" "jazz:sourcify-if" "%%get-signature-positional" "%%get-lexical-binding-type" "emit-type-cast" "jazz:emit-type-cast" "emit-binding-symbol" "jazz:emit-binding-symbol" "argument" "parameter" "map" "new-code" "jazz:new-code" "emit-expression" "jazz:emit-expression" "body-code" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "only-positional?" "jazz:only-positional?" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "let" "final" "case" "method-dispatch-info" "jazz:method-dispatch-info" "method-declaration" "dispatch-type" "receive" "inline" "declaration" "%%get-method-declaration-expansion" "%%eq?" "if" "environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "emit-binding-call" generic/specific () ("binding-src" "arguments" "source-declaration" "environment") ("jazz:Method-Declaration") #f 811 21 811 43 ("%%get-declaration-locator" "%%get-lexical-binding-name" "error" "jazz:error" "%%get-code-type" ",@arguments" "sourcified-form" "jazz:sourcified-form" "new-code" "jazz:new-code" "emit-method-dispatch" "jazz:emit-method-dispatch" "dispatch-code" "codes-forms" "jazz:codes-forms" "declaration" "%%get-lexical-binding-type" "type" "if" "*self*" "jazz:*self*" "self" "let" "environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "get-nextmethod-signature" generic/specific () () ("jazz:Method-Declaration") #f 826 21 826 50 ("%%get-method-declaration-signature" "next-method-declaration" "cdr" "car" "null?" "%%get-class-declaration-interfaces" "scan" "iter" "%%get-class-declaration-ascendant" "ascendant" "or" "%%get-declaration-parent" "declaration" "%%get-lexical-binding-name" "get-next-method-declaration" "private-access" "jazz:private-access" "lookup-declaration" "jazz:lookup-declaration" "%%get-autoload-declaration-declaration" "let" "Autoload-Declaration" "jazz:Autoload-Declaration" "%%is?" "if" "method-name" "category-declaration" "lookup" "define")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Method-Declaration") #f 849 21 849 42 ("%%get-declaration-source" ",method-rank-locator" "call-into-abstract" "jazz:call-into-abstract" "rest" "abstract" "%%eq?" "declaration-result" "jazz:declaration-result" ",name" ",class-locator" ",method-call" ",method-node-locator" "%%get-method-node-next-implementation" "nextmethod" "emit-signature-casts" "jazz:emit-signature-casts" "emit-signature" "jazz:emit-signature" "self" ",method-locator" "define" "begin" "generate-symbol" "jazz:generate-symbol" "sourcify-if" "jazz:sourcify-if" "emit-type-cast" "jazz:emit-type-cast" "emit-expression" "jazz:emit-expression" "body-code" "emit-body" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "Interface-Declaration" "jazz:Interface-Declaration" "add-virtual-method" "jazz:add-virtual-method" "chained" "virtual" "add-final-method" "jazz:add-final-method" "final" "add-method-node" "jazz:add-method-node" "override" "case" "Class-Declaration" "jazz:Class-Declaration" "%%class-is?" "cond" "method-call" "node" "method-node-locator" "rank" "compose-helper" "jazz:compose-helper" "method-rank-locator" "method-locator" "%%get-declaration-locator" "class-locator" "and" "root-category-declaration" "%%get-method-declaration-root" "root-method-declaration" "%%get-declaration-parent" "category-declaration" "let*" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "%%get-method-declaration-abstraction" "abstraction" "%%get-method-declaration-propagation" "propagation" "Any" "jazz:Any" "%%get-function-type-result" "Function-Type" "jazz:Function-Type" "%%is?" "if" "%%get-lexical-binding-type" "type" "body-type" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Method-Declaration") #f 912 21 912 42 ("fold-statement" "jazz:fold-statement" "%%not" "if" "%%get-method-declaration-body" "body" "let" "declaration" "s" "k" "f")}
      {Lisp-Entry "Jazz-Dialect" define-class () () ("class runtime") #f 928 27 928 44 ()}
      {Lisp-Entry "new-jazz-dialect" define () () #f #f 931 9 931 30 ("Jazz-Dialect" "jazz:Jazz-Dialect" "allocate-jazz-dialect" "jazz:allocate-jazz-dialect")}
      {Lisp-Entry "dialect-name" generic/specific () () ("jazz:Jazz-Dialect") #f 935 21 935 38 ("jazz")}
      {Lisp-Entry "dialect-walker" generic/specific () () ("jazz:Jazz-Dialect") #f 939 21 939 40 ("new-jazz-walker" "jazz:new-jazz-walker")}
      {Lisp-Entry "Jazz-Walker" define-class () () ("class runtime") #f 951 27 951 43 ()}
      {Lisp-Entry "new-jazz-walker" define () () #f #f 954 9 954 29 ("eq?" "test:" "%%make-table" "new-queue" "jazz:new-queue" "Jazz-Walker" "jazz:Jazz-Walker" "allocate-jazz-walker" "jazz:allocate-jazz-walker")}
      {Lisp-Entry "runtime-export" generic/specific () ("declaration") ("jazz:Jazz-Walker") #f 958 21 958 40 ("%%get-declaration-locator" "Category-Declaration" "jazz:Category-Declaration" "Generic-Declaration" "jazz:Generic-Declaration" "Definition-Declaration" "jazz:Definition-Declaration" "%%is?" "if" "walker" "nextmethod" "or" "declaration")}
      {Lisp-Entry "walker-bindings" generic/specific () () ("jazz:Jazz-Walker") #f 972 21 972 41 ("walker" "nextmethod" "jazz" "get-dialect" "jazz:get-dialect" "%%get-dialect-bindings" "append")}
      {Lisp-Entry "walk-declaration" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Jazz-Walker") #f 982 21 982 42 ("nextmethod" "else" "walk-c-definition-declaration" "jazz:walk-c-definition-declaration" "c-definition" "walk-c-type-declaration" "jazz:walk-c-type-declaration" "c-type" "walk-c-named-declare-declaration" "jazz:walk-c-named-declare-declaration" "c-named-declare" "c-include" "walk-with-local-variables-declaration" "jazz:walk-with-local-variables-declaration" "with-local-variables" "walk-with-dynamic-self-declaration" "jazz:walk-with-dynamic-self-declaration" "with-dynamic-self" "walk-method-declaration" "jazz:walk-method-declaration" "method" "walk-%slot-declaration" "jazz:walk-%slot-declaration" "%property" "%slot" "walk-interface-declaration" "jazz:walk-interface-declaration" "interface" "walk-%class-declaration" "jazz:walk-%class-declaration" "%class" "specific" "walk-generic-declaration" "jazz:walk-generic-declaration" "generic" "walk-%specialize-declaration" "jazz:walk-%specialize-declaration" "%specialize" "walker" "walk-definition-declaration" "jazz:walk-definition-declaration" "definition" "case" "%%car" "first" "let" "source-code" "jazz:source-code" "%%pair?" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "expand-declaration-path" define () ("walker" "resume" "declaration" "environment") #f #f 1004 9 1004 37 ("get-declaration-path" "jazz:get-declaration-path" "quote" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-declaration-locator" define () ("walker" "resume" "declaration" "environment") #f #f 1008 9 1008 40 ("get-declaration-path" "jazz:get-declaration-path" "compose-reference" "jazz:compose-reference" "apply" "quote" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "parse-keywords" define () ("keywords" "rest") #f #f 1017 9 1017 28 ("%%list" "unspecified" "jazz:unspecified" "%%table-ref" "keyword" "lambda" "map" "%%append" "values" "%%apply" "%%cddr" "%%cadr" "%%desourcify" "%%table-set!" "begin" "set!" "%%memq" "if" "%%car" "source-code" "jazz:source-code" "symbol" "%%null?" "%%not" "and" "%%while" "done?" "eq?" "test:" "%%make-table" "table" "let" "rest" "keywords")}
      {Lisp-Entry "emit-specialized-locator" define-macro () () ("variable-override") #f 1038 31 1038 60 ("else" "%%car" "emit-specialized-class-of" "jazz:emit-specialized-class-of" "%%cdr" "%%null?" "%%pair?" "and" "%%assert" "class-of" "jazz.dialect.kernel" "jazz.dialect.kernel:class-of" "case" "environment" "arguments" "locator" "lambda")}
      {Lisp-Entry "emit-specialized-class-of" define () ("object" "environment") #f #f 1048 9 1048 39 ("%%get-category-declaration-metaclass" "Class-Declaration" "jazz:Class-Declaration" "%%class-is?" "if" "%%get-code-type" "type" "let" "sourcified-form" "jazz:sourcified-form" "class-of" "jazz:class-of" "new-code" "jazz:new-code" "environment" "object")}
      {Lisp-Entry "emit-primitive-new-call" define-macro () () ("variable-override") #f 1063 31 1063 59 ("jazz:new" "else" "new2" "jazz:new2" "2" "new1" "jazz:new1" "1" "codes-forms" "jazz:codes-forms" "new0" "jazz:new0" "0" "%%length" "case" "new-code" "jazz:new-code" "%%cdr" "values-codes" "Autoload-Declaration" "jazz:Autoload-Declaration" "Class-Declaration" "jazz:Class-Declaration" "or" "%%get-reference-binding" "binding" "Binding-Reference" "jazz:Binding-Reference" "%%class-is?" "%%car" "class-expression" "let" "%%pair?" "%%assert" "new" "jazz.dialect.kernel" "jazz.dialect.kernel:new" "%%eq?" "if" "environment" "declaration" "arguments-codes" "arguments" "locator" "operator" "lambda")}
      {Lisp-Entry "walk-symbol" generic/specific () ("resume" "declaration" "environment" "symbol-src") ("jazz:Jazz-Walker") #f 1091 21 1091 37 ("nextmethod" "else" "walk-error" "jazz:walk-error" ",method-symbol-src" "~" "apply" "rest" "object" "walk" "jazz:walk" "dispatch->symbol" "jazz:dispatch->symbol" "sourcify-if" "jazz:sourcify-if" "method-symbol-src" "not" "new-method-reference" "jazz:new-method-reference" "Method-Declaration" "jazz:Method-Declaration" "method-declaration" "Category-Declaration" "jazz:Category-Declaration" "walker" "lookup-reference" "jazz:lookup-reference" "resolve-binding" "jazz:resolve-binding" "category-declaration" "new-binding-reference" "jazz:new-binding-reference" "Slot-Declaration" "jazz:Slot-Declaration" "%%class-is?" "%%assert" "private-access" "jazz:private-access" "find-class-declaration" "jazz:find-class-declaration" "lookup-declaration" "jazz:lookup-declaration" "slot-declaration" "self" "%%eq?" "and" "cond" "if" "self/class-name" "name" "tilde?" "lambda" "split-tilde" "jazz:split-tilde" "unwrap-syntactic-closure" "symbol" "let" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "split-tilde" define () ("symbol" "proc") #f #f 1116 9 1116 25 ("1" "%%fx+" "%%fx<" "%%substring" "%%string->symbol" "0" "%%fx>" "%%string-length" "len" "%%not" "if" "string-find-reversed" "jazz:string-find-reversed" "n" "%%symbol->string" "str" "let" "proc" "symbol")}
      {Lisp-Entry "lookup-analyse" generic/specific () ("declaration" "symbol-src" "referenced-declaration") ("jazz:Jazz-Walker") #f 1127 21 1127 40 ("%%get-analysis-data-declaration-references" "%%cons" "%%set-analysis-data-declaration-references" "%%get-declaration-locator" "get-analysis-data" "jazz:get-analysis-data" "data" "let" "Slot-Declaration" "jazz:Slot-Declaration" "self" "source-code" "jazz:source-code" "or" "final" "%%get-method-declaration-propagation" "%%eq?" "Method-Declaration" "jazz:Method-Declaration" "%%is?" "and" "if" "referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "walk-symbol-assignment" generic/specific () ("resume" "declaration" "environment" "symbol-src" "value") ("jazz:Jazz-Walker") #f 1142 21 1142 48 ("nextmethod" "%%desourcify" "walk-error" "jazz:walk-error" "walker" "walk" "jazz:walk" "new-assignment" "jazz:new-assignment" "Slot-Declaration" "jazz:Slot-Declaration" "%%class-is?" "%%assert" "private-access" "jazz:private-access" "find-class-declaration" "jazz:find-class-declaration" "lookup-declaration" "jazz:lookup-declaration" "slot-declaration" "let" "self" "%%eq?" "and" "if" "self/class-name" "name" "tilde?" "lambda" "source-code" "jazz:source-code" "split-tilde" "jazz:split-tilde" "value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-form" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Jazz-Walker") #f 1159 21 1159 35 ("nextmethod" "walker" "walk-dispatch" "jazz:walk-dispatch" "dispatch?" "jazz:dispatch?" "if" "%%car" "source-code" "jazz:source-code" "procedure-expr" "let" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "With-Self" define-class () () ("class runtime") #f 1171 27 1171 41 ()}
      {Lisp-Entry "new-with-self" define () ("body") #f #f 1174 9 1174 27 ("With-Self" "jazz:With-Self" "allocate-with-self" "jazz:allocate-with-self" "body")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:With-Self") #f 1178 21 1178 41 ("Any" "jazz:Any" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "self" "*self*" "jazz:*self*" "parameterize" "begin" "simplify-begin" "jazz:simplify-begin" "new-code" "jazz:new-code" "expression" "%%get-with-self-body" "body" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:With-Self") #f 1189 21 1189 41 ("%%get-with-self-body" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "With-Dynamic-Self" define-class () () ("class runtime") #f 1203 27 1203 49 ()}
      {Lisp-Entry "new-with-dynamic-self" define () ("code" "body") #f #f 1206 9 1206 35 ("With-Dynamic-Self" "jazz:With-Dynamic-Self" "allocate-with-dynamic-self" "jazz:allocate-with-dynamic-self" "body" "code")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:With-Dynamic-Self") #f 1210 21 1210 41 ("Any" "jazz:Any" "emit-statements-code" "jazz:emit-statements-code" "sourcified-form" "jazz:sourcified-form" "*self*" "jazz:*self*" "parameterize" "begin" "simplify-begin" "jazz:simplify-begin" "new-code" "jazz:new-code" "%%get-with-dynamic-self-body" "body" "expression" "%%get-with-dynamic-self-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:With-Dynamic-Self") #f 1222 21 1222 41 ("%%get-with-dynamic-self-body" "fold-expressions" "jazz:fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "Cast" define-class () () ("class runtime") #f 1235 27 1235 36 ()}
      {Lisp-Entry "new-cast" define () ("type" "expression") #f #f 1238 9 1238 22 ("Cast" "jazz:Cast" "allocate-cast" "jazz:allocate-cast" "expression" "type")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Cast") #f 1242 21 1242 41 ("emit-expression" "jazz:emit-expression" "emit-type-cast" "jazz:emit-type-cast" "new-code" "jazz:new-code" "%%get-cast-expression" "expression" "%%get-expression-type" "type" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Cast") #f 1255 21 1255 41 ("%%get-cast-expression" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "Allocate" define-class () () ("class runtime") #f 1268 27 1268 40 ()}
      {Lisp-Entry "new-allocate" define () ("class" "values") #f #f 1271 9 1271 26 ("Allocate" "jazz:Allocate" "allocate-allocate" "jazz:allocate-allocate" "values" "class")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Allocate") #f 1275 21 1275 41 ("Any" "jazz:Any" "emit-expressions" "jazz:emit-expressions" "codes-forms" "jazz:codes-forms" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "%%object" "new-code" "jazz:new-code" "%%get-allocate-values" "values" "expression" "%%get-allocate-class" "class" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Allocate") #f 1285 21 1285 41 ("%%get-allocate-values" "fold-expressions" "jazz:fold-expressions" "%%get-allocate-class" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "cache-dispatch" define () ("name" "setter") #f #f 1299 9 1299 28 ("interface-dispatch" "jazz:interface-dispatch" "interface" "class-dispatch" "jazz:class-dispatch" "final-dispatch" "jazz:final-dispatch" "final" "%%get-method-dispatch-type" "case" "proc" "Method" "jazz:Method" "%%class-is?" "%%get-category-field" "field" "error" "jazz:error" "%%assertion" "locate-method-owner" "jazz:locate-method-owner" "category" "class-of" "jazz:class-of" "class" "let" "object" "lambda" "setter" "name")}
      {Lisp-Entry "final-dispatch" define () ("field" "type") #f #f 1318 9 1318 28 ("%%get-method-implementation" "class-of" "jazz:class-of" "%%final-dispatch" "dispatch-error" "jazz:dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "type" "field")}
      {Lisp-Entry "class-dispatch" define () ("field" "type") #f #f 1324 9 1324 28 ("class-of" "jazz:class-of" "%%class-dispatch" "dispatch-error" "jazz:dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "class-level" "let" "type" "field")}
      {Lisp-Entry "interface-dispatch" define () ("field" "type") #f #f 1332 9 1332 32 ("class-of" "jazz:class-of" "%%interface-dispatch" "dispatch-error" "jazz:dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "interface-rank" "let" "type" "field")}
      {Lisp-Entry "dispatch" define () ("class" "name") #f #f 1340 9 1340 22 ("error" "jazz:error" "find-dispatch" "jazz:find-dispatch" "or" "name" "class")}
      {Lisp-Entry "find-dispatch" define () ("class" "name") #f #f 1345 9 1345 27 ("%%interface-dispatch" "interface" "%%get-method-implementation-rank" "%%get-method-category-rank" "%%class-dispatch" "%%get-method-implementation" "%%final-dispatch" "final" "%%get-method-dispatch-type" "case" "error" "jazz:error" "Method" "jazz:Method" "%%class-is?" "not" "%%get-category-field" "field" "%%not" "if" "locate-method-owner" "jazz:locate-method-owner" "category" "let" "name" "class")}
      {Lisp-Entry "Dispatch" define-class () () ("class runtime") #f 1361 27 1361 40 ()}
      {Lisp-Entry "new-dispatch" define () ("source" "name" "arguments") #f #f 1364 9 1364 26 ("Dispatch" "jazz:Dispatch" "allocate-dispatch" "jazz:allocate-dispatch" "arguments" "name" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Dispatch") #f 1368 21 1368 41 ("expression" "emit-dispatch" "jazz:emit-dispatch" "environment" "declaration")}
      {Lisp-Entry "emit-dispatch" define () ("expression" "declaration" "environment") #f #f 1372 9 1372 27 ("Any" "jazz:Any" ",object" "object" "with-uniqueness" "jazz:with-uniqueness" ",d" "set!" ",name" "cache-dispatch" "jazz:cache-dispatch" "%%set-cdr!" "d" "%%symbol->string" "%%string-append" "register-variable" "jazz:register-variable" "dv" "%%get-expression-source" "codes-forms" "jazz:codes-forms" "sourcified-form" "jazz:sourcified-form" "new-code" "jazz:new-code" "emit-method-dispatch" "jazz:emit-method-dispatch" "dispatch-code" "code" "lambda" "with-code-value" "jazz:with-code-value" "emit-inlined-final-dispatch" "jazz:emit-inlined-final-dispatch" "or" "emit-expressions" "jazz:emit-expressions" "rest-codes" "emit-expression" "jazz:emit-expression" "%%cdr" "rest-arguments" "%%car" "object-argument" "add-to-module-references" "jazz:add-to-module-references" "method" "dispatch" "find" "to" "unable" "%%get-declaration-locator" "In" "Warning:" "debug" "jazz:debug" "optimizations" "%%get-declaration-toplevel" "get-module-warn?" "jazz:get-module-warn?" "warnings?" "jazz:warnings?" "begin" "%%not" "method-declaration" "lookup-method/warn" "Method-Declaration" "jazz:Method-Declaration" "and" "public-access" "jazz:public-access" "lookup-declaration" "jazz:lookup-declaration" "Category-Declaration" "jazz:Category-Declaration" "lookup-method" "resolve-binding" "jazz:resolve-binding" "Autoload-Declaration" "jazz:Autoload-Declaration" "%%class-is?" "if" "%%get-code-type" "patch-type-until-unification" "jazz:patch-type-until-unification" "object-type" "object-code" "resolve-type" "define" "%%get-dispatch-arguments" "arguments" "%%get-dispatch-name" "name" "let" "environment" "declaration" "expression")}
      {Lisp-Entry "with-code-value" define () ("code" "proc") #f #f 1428 9 1428 29 ("%%get-code-source" ",form" ",value" "%%get-code-type" "new-code" "jazz:new-code" "generate-symbol" "jazz:generate-symbol" "value" "%%symbol?" "if" "%%get-code-form" "form" "let" "proc" "code")}
      {Lisp-Entry "emit-inlined-final-dispatch" define () ("expression" "declaration" "object" "arguments" "source-declaration" "environment") #f #f 1441 9 1441 41 ("else" "%%get-lexical-binding-name" "error" "jazz:error" "call-return-type" "jazz:call-return-type" "%%get-expression-source" "%%get-code-form" "desourcify-all" "jazz:desourcify-all" "sourcify-if" "jazz:sourcify-if" "%%get-signature-positional" "%%get-lexical-binding-type" "emit-type-cast" "jazz:emit-type-cast" "emit-binding-symbol" "jazz:emit-binding-symbol" "argument" "parameter" "map" "sourcified-form" "jazz:sourcified-form" "self" "new-code" "jazz:new-code" "emit-expression" "jazz:emit-expression" "body-code" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "only-positional?" "jazz:only-positional?" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "let" "final" "case" "method-dispatch-info" "jazz:method-dispatch-info" "method-declaration" "dispatch-type" "receive" "inline" "%%get-method-declaration-expansion" "%%eq?" "if" "environment" "source-declaration" "arguments" "object" "declaration" "expression")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Dispatch") #f 1472 21 1472 41 ("%%get-dispatch-arguments" "fold-expressions" "jazz:fold-expressions" "%%get-dispatch-name" "expression" "s" "k" "f")}
      {Lisp-Entry "walk-dispatch" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1481 9 1481 27 ("walk-list" "jazz:walk-list" "new-dispatch" "jazz:new-dispatch" "%%desourcify" "walk-error" "jazz:walk-error" "%%null?" "%%not" "%%assertion" "%%cdr" "arguments" "source-code" "jazz:source-code" "%%car" "unwrap-syntactic-closure" "dispatch->symbol" "jazz:dispatch->symbol" "name" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "definition-modifiers" define () () #f #f 1494 8 1494 33 ("onsite" "inline" "uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-definition" define () ("walker" "resume" "declaration" "rest") #f #f 1500 9 1500 30 (",@effective-body" ",@specifier-list" ",parameters" "value" "specifier-list" "unspecified" "%%list" "%%null?" "effective-body" "body" "%%desourcify" "parameters" "let*" "values" "specifier" "lambda" "%%cdr" "parse-specifier" "jazz:parse-specifier" "name" "let" "%%car" "source-code" "jazz:source-code" "%%symbol?" "if" "definition-modifiers" "jazz:definition-modifiers" "parse-modifiers" "jazz:parse-modifiers" "expansion" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-definition-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1519 9 1519 41 ("walk" "jazz:walk" "%%set-definition-declaration-value" "%%set-definition-declaration-signature" "%%cons" "new-environment" "inline" "%%eq?" "%%when" "add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-definition-declaration" "jazz:new-definition-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "build-function-type" "jazz:build-function-type" "if" "effective-type" "walk-parameters" "jazz:walk-parameters" "and" "signature" "specifier->type" "jazz:specifier->type" "type" "let" "walk-error" "jazz:walk-error" "Namespace-Declaration" "jazz:Namespace-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "%%cdr" "parse-definition" "jazz:parse-definition" "parameters" "value" "expansion" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-definition" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1537 9 1537 29 ("%%set-declaration-source" "walk" "jazz:walk" "%%set-definition-declaration-value" "%%cons" "%%set-definition-declaration-signature" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "if" "new-environment" "inline" "%%neq?" "%%when" "require-declaration" "jazz:require-declaration" "new-declaration" "let" "walk-error" "jazz:walk-error" "Namespace-Declaration" "jazz:Namespace-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "%%cdr" "parse-definition" "jazz:parse-definition" "parameters" "value" "expansion" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "build-function-type" define () ("signature" "result-type") #f #f 1557 9 1557 33 ("and" "%%get-signature-rest" "rest" "let" "%%get-signature-named" "%%get-signature-optional" "%%get-signature-positional" "map" "new-function-type" "jazz:new-function-type" "Any" "jazz:Any" "%%get-lexical-binding-type" "or" "parameter" "parameter-type" "define" "result-type" "signature")}
      {Lisp-Entry "specialize-modifiers" define () () #f #f 1576 8 1576 33 ("onsite" "inline")}
      {Lisp-Entry "parse-specialize" define () ("walker" "resume" "declaration" "rest") #f #f 1580 9 1580 30 ("%%cddr" "%%cadr" "values" "as" "%%car" "%%eq?" "if" "specialize-modifiers" "jazz:specialize-modifiers" "parse-modifiers" "jazz:parse-modifiers" "expansion" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-specialize" define () ("walker" "resume" "declaration" "environment" "." "rest") #f #f 1587 9 1587 31 (",operator" "%specialize" ",@rest" ",@parameters" ",name" ",expansion" "undocumented" "public" "definition" "begin" "compose-specializer-name" "jazz:compose-specializer-name" "or" "name" "parameters" "operator" "%%cdr" "%%car" "signature" "let" "parse-specialize" "jazz:parse-specialize" "as" "expansion" "receive" "rest" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "compose-specializer-name" define () ("operator" "parameters") #f #f 1599 9 1599 38 ("specifier->name" "jazz:specifier->name" "%%list" "specifier?" "jazz:specifier?" "if" "parameter" "lambda" "map" "append" "string-append" "%%apply" "%%symbol->string" "%%string-append" "%%string->symbol" "parameters" "operator")}
      {Lisp-Entry "walk-%specialize-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1614 9 1614 42 ("new-specialize" "jazz:new-specialize" "add-specializer" "jazz:add-specializer" "specializer-declaration" "lookup-reference" "jazz:lookup-reference" "specialized-declaration" "%%cddr" "%%car" "specializer" "%%cadr" "source-code" "jazz:source-code" "specialized" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-%specialize" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1624 9 1624 30 ("new-specialize" "jazz:new-specialize" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "generic-modifiers" define () () #f #f 1633 8 1633 30 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-generic" define () ("walker" "resume" "declaration" "rest") #f #f 1638 9 1638 27 ("values" "body" "specifier" "lambda" "parse-specifier" "jazz:parse-specifier" "%%cdr" "parameters" "name" "%%car" "source-code" "jazz:source-code" "signature" "let" "generic-modifiers" "jazz:generic-modifiers" "parse-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-generic-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1648 9 1648 38 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-generic-declaration" "jazz:new-generic-declaration" "new-declaration" "walk-parameters" "jazz:walk-parameters" "signature" "dynamic-parameter-types" "jazz:dynamic-parameter-types" "lookup-reference" "jazz:lookup-reference" "dynamic-parameter-type" "lambda" "map" "dispatch-type-declarations" "Any" "jazz:Any" "walk-specifier" "jazz:walk-specifier" "if" "type" "let" "walk-error" "jazz:walk-error" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "%%cdr" "parse-generic" "jazz:parse-generic" "body" "parameters" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-generic" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1662 9 1662 26 ("%%set-declaration-source" "walk-body" "jazz:walk-body" "%%set-generic-declaration-body" "%%set-generic-declaration-signature" "require-declaration" "jazz:require-declaration" "new-declaration" "let" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "walk-error" "jazz:walk-error" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "%%cdr" "parse-generic" "jazz:parse-generic" "body" "parameters" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "specific-modifiers" define () () #f #f 1679 8 1679 31 ()}
      {Lisp-Entry "parse-specific" define () ("walker" "resume" "declaration" "rest") #f #f 1683 9 1683 28 ("values" "parameters" "name" "unspecified" "%%list" "%%null?" "if" "effective-body" "%%cdr" "body" "%%car" "desourcify" "jazz:desourcify" "signature" "let*" "specific-modifiers" "jazz:specific-modifiers" "parse-modifiers" "jazz:parse-modifiers" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-specific" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1693 9 1693 27 ("%%set-declaration-source" "walk-body" "jazz:walk-body" "%%set-specific-declaration-body" "nextmethod" "new-nextmethod-variable" "jazz:new-nextmethod-variable" "body-environment" "uptodate" "public" "new-specific-declaration" "jazz:new-specific-declaration" "new-declaration" "let*" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "Generic-Declaration" "jazz:Generic-Declaration" "private-access" "jazz:private-access" "lookup-declaration" "jazz:lookup-declaration" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "parse-specific" "jazz:parse-specific" "body" "receive" "else" "or" "%%cons" "%%get-declaration-locator" "%%get-lexical-binding-name" "walk-error" "jazz:walk-error" "%%eq?" "%%cdr" "of-subtype?" "jazz:of-subtype?" "if" "specific-class" "%%get-dynamic-parameter-class" "%%get-reference-binding" "resolve-binding" "jazz:resolve-binding" "generic-class" "cond" "specific-dynamic?" "Dynamic-Parameter" "jazz:Dynamic-Parameter" "%%is?" "generic-dynamic?" "specific-parameter" "%%car" "%%pair?" "and" "generic-parameter" "root?" "specific-parameters" "%%get-generic-declaration-signature" "%%get-signature-positional" "generic-parameters" "iter" "let" "parameters" "name" "specific-signature" "generic-declaration" "root-dynamic-parameters?" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "class-modifiers" define () () #f #f 1738 8 1738 28 ("native" "primitive" "uptodate" "undocumented" "deprecated" "concrete" "abstract" "public" "package" "protected" "private")}
      {Lisp-Entry "class-keywords" define () () #f #f 1744 8 1744 27 ("attributes" "implements" "extends" "metaclass")}
      {Lisp-Entry "parse-class" define () ("walker" "resume" "declaration" "rest") #f #f 1748 9 1748 25 ("values" "class-keywords" "jazz:class-keywords" "parse-keywords" "jazz:parse-keywords" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "%%symbol?" "%%assert" "%%cdr" "Any" "jazz:Any" "type" "%%car" "source-code" "jazz:source-code" "name" "let" "class-modifiers" "jazz:class-modifiers" "parse-modifiers" "jazz:parse-modifiers" "implementor" "compatibility" "abstraction" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-class" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1758 9 1758 26 (",@class-body" ",interface-names" "implements" ",name" ",implementor" ",compatibility" ",abstraction" ",access" ",@metaclass-body" ",ascendant-name" ":class" "extends" ",metaclass-name" "%%symbol->string" "%%string-append" "%%string->symbol" "%class" "%%unspecified?" "core-class?" "jazz:core-class?" "or" "walk-error" "jazz:walk-error" "%%specified?" "%%not-null?" "class-body" "metaclass-body" "parse-class" "jazz:parse-class" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "queue-list" "jazz:queue-list" "values" "else" "%%cddr" "%%cons" "sourcify-if" "jazz:sourcify-if" "enqueue" "jazz:enqueue" "meta" "%%cadr" "%%cdr" "for-each" "begin" "cond" "preprocess" "expand-macros" "jazz:expand-macros" "form" "%%car" "%%eq?" "source-code" "jazz:source-code" "%%pair?" "and" "if" "expr" "expand-form-hack" "class" "new-queue" "jazz:new-queue" "metaclass" "let" "body" "preprocess-meta" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-%class-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1808 9 1808 37 ("walk-declarations" "jazz:walk-declarations" "%%cons" "new-environment" "setup-class-lookups" "jazz:setup-class-lookups" "add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-class-declaration" "jazz:new-class-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "listify" "jazz:listify" "lookup-reference" "jazz:lookup-reference" "interface-name" "lambda" "map" "unspecified?" "jazz:unspecified?" "if" "interfaces" "lookup-metaclass" "jazz:lookup-metaclass" "metaclass" "let" "lookup-ascendant" "jazz:lookup-ascendant" "ascendant-base" "ascendant-relation" "ascendant" "walk-error" "jazz:walk-error" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "%%cdr" "parse-class" "jazz:parse-class" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-%class" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1825 9 1825 25 ("%%set-declaration-source" "walk-namespace" "jazz:walk-namespace" "%%set-namespace-declaration-body" "begin" "Object" "%%neq?" "%%not" "and" "if" "%%get-class-declaration-ascendant" "ascendant-declaration" "%%cons" "new-environment" "require-declaration" "jazz:require-declaration" "new-declaration" "let*" "walk-error" "jazz:walk-error" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "%%cdr" "parse-class" "jazz:parse-class" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "lookup-metaclass" define () ("walker" "resume" "declaration" "environment" "ascendant" "metaclass-name") #f #f 1839 9 1839 30 ("lookup-reference" "jazz:lookup-reference" "Object-Class" "%%eq?" "unspecified?" "jazz:unspecified?" "or" "if" "metaclass-name" "ascendant" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "lookup-ascendant" define () ("walker" "resume" "declaration" "environment" "ascendant-name") #f #f 1845 9 1845 30 ("else" "%%cons" "effective-class-declaration-metaclass" "jazz:effective-class-declaration-metaclass" "or" "%%cadr" "base" "relation" "decl" "receive" "if" "rec" "Object-Class" "lookup-reference" "jazz:lookup-reference" "object-class" "let" ":class" "%%car" "%%eq?" "%%pair?" "and" "values" "unspecified?" "jazz:unspecified?" "cond" "ascendant-name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "effective-class-declaration-metaclass" define () ("class-declaration") #f #f 1869 9 1869 51 ("effective-class-declaration-metaclass" "jazz:effective-class-declaration-metaclass" "%%get-class-declaration-ascendant" "ascendant" "%%get-category-declaration-metaclass" "or" "resolve-binding" "jazz:resolve-binding" "let" "%%not" "if" "class-declaration")}
      {Lisp-Entry "interface-modifiers" define () () #f #f 1885 8 1885 32 ("native" "primitive" "uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "interface-keywords" define () () #f #f 1890 8 1890 31 ("attributes" "extends" "metaclass")}
      {Lisp-Entry "parse-interface" define () ("walker" "resume" "declaration" "rest") #f #f 1894 9 1894 29 ("values" "interface-keywords" "jazz:interface-keywords" "parse-keywords" "jazz:parse-keywords" "body" "attributes" "ascendant-names" "metaclass-name" "%%symbol?" "%%assert" "%%cdr" "Any" "jazz:Any" "type" "%%car" "name" "let" "interface-modifiers" "jazz:interface-modifiers" "parse-modifiers" "jazz:parse-modifiers" "implementor" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-interface-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1904 9 1904 40 ("walk-declarations" "jazz:walk-declarations" "%%cons" "new-environment" "setup-interface-lookups" "jazz:setup-interface-lookups" "add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-interface-declaration" "jazz:new-interface-declaration" "find-child-declaration" "jazz:find-child-declaration" "new-declaration" "listify" "jazz:listify" "ascendant-name" "lambda" "map" "ascendants" "lookup-reference" "jazz:lookup-reference" "Interface" "%%eq?" "unspecified?" "jazz:unspecified?" "or" "if" "metaclass" "walk-error" "jazz:walk-error" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%assertion" "%%cdr" "parse-interface" "jazz:parse-interface" "body" "attributes" "ascendant-names" "metaclass-name" "implementor" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-interface" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1920 9 1920 28 ("%%set-declaration-source" "walk-namespace" "jazz:walk-namespace" "%%set-namespace-declaration-body" "%%cons" "new-environment" "require-declaration" "jazz:require-declaration" "new-declaration" "let*" "walk-error" "jazz:walk-error" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%assertion" "%%cdr" "parse-interface" "jazz:parse-interface" "body" "attributes" "ascendant-names" "metaclass-name" "implementor" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "slot-modifiers" define () () #f #f 1936 8 1936 27 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "slot-keywords" define () () #f #f 1940 8 1940 26 ("setter" "getter" "accessors" "initialize")}
      {Lisp-Entry "slot-accessors-modifiers" define () () #f #f 1944 8 1944 37 ("explicit" "generate" "none" "onsite" "inline" "concrete" "abstract" "override" "chained" "virtual" "final" "public" "package" "protected" "private")}
      {Lisp-Entry "slot-accessor-modifiers" define () () #f #f 1952 8 1952 36 ("explicit" "generate" "none" "onsite" "inline" "concrete" "abstract" "override" "chained" "virtual" "final" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-slot" define () ("walker" "resume" "declaration" "form-src") #f #f 1960 9 1960 24 ("values" "walk-error" "jazz:walk-error" "%%not-null?" "if" "slot-keywords" "jazz:slot-keywords" "parse-keywords" "jazz:parse-keywords" "setter" "getter" "accessors" "initialize" "specifier" "lambda" "parse-specifier" "jazz:parse-specifier" "%%car" "name" "let" "source-code" "jazz:source-code" "%%cdr" "slot-modifiers" "jazz:slot-modifiers" "parse-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-slot" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1971 9 1971 25 ("%slot" "expand-slot-form" "jazz:expand-slot-form" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-slot-form" define () ("walker" "resume" "declaration" "form-src" "symbol") #f #f 1975 9 1975 30 ("set!" "void" "<void>" "value" ",setter-expansion" ",setter-abstraction" ",setter-propagation" "protected" ",name-self" ",@specifier-list" ",getter-expansion" ",getter-abstraction" ",getter-propagation" "public" "method" ",setter-name" ",getter-name" ",initialize" "with-self" "%%unspecified?" ",compatibility" ",access" ",specifier" ",name" ",symbol" "sourcify-if" "jazz:sourcify-if" "begin" "specifier-list" "generate-setter?" "generate" "%%eq?" "generate-getter?" "name-self" "setter-name" "setter-generation" "setter-expansion" "setter-abstraction" "setter-propagation" "setter-access" "getter-name" "getter-generation" "getter-expansion" "getter-abstraction" "getter-propagation" "getter-access" "%%list" "%%symbol?" "unspecified?" "jazz:unspecified?" "desourcify" "jazz:desourcify" "info" "lambda" "standardize" "parse-slot" "jazz:parse-slot" "setter" "getter" "accessors" "initialize" "compatibility" "specifier" "else" "%%car" "%%cdr" "%%symbol->string" "%%string-append" "%%string->symbol" "none" "%%neq?" "and" "%%null?" "cond" "name" "let" "slot-accessor-modifiers" "jazz:slot-accessor-modifiers" "prefix" "default-generation" "default-expansion" "default-abstraction" "default-propagation" "default-access" "slot-name" "parse-accessor" "or" "values" "walk-error" "jazz:walk-error" "%%not-null?" "if" "slot-accessors-modifiers" "jazz:slot-accessors-modifiers" "parse-modifiers" "jazz:parse-modifiers" "rest" "generation" "expansion" "abstraction" "propagation" "access" "receive" "slot-access" "form" "parse-accessors" "define" "symbol" "form-src" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-%slot-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2033 9 2033 36 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "new-slot-declaration" "jazz:new-slot-declaration" "new-property-declaration" "jazz:new-property-declaration" "%property" "%%car" "%%eq?" "new" "Any" "jazz:Any" "walk-specifier" "jazz:walk-specifier" "if" "type" "walk-error" "jazz:walk-error" "Class-Declaration" "jazz:Class-Declaration" "%%class-is?" "%%assertion" "%%cdr" "setter-name" "getter-name" "initialize" "compatibility" "access" "specifier" "name" "bind" "jazz:bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-%slot" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2046 9 2046 24 ("%%set-declaration-source" "set!" ",setter-name" ",value" "generate-symbol" "jazz:generate-symbol" "value" "%%set-property-declaration-setter" "else" ",name" ",getter-name" "with-self" "self" "lambda" "cond" "%%set-property-declaration-getter" "Void" "jazz:Void" "%%get-lexical-binding-type" "%%neq?" "allocate?" "Property-Declaration" "jazz:Property-Declaration" "%%when" "walk" "jazz:walk" "%%specified?" "and" "%%set-slot-declaration-initialize" "%%cadr" "require-declaration" "jazz:require-declaration" "new-declaration" "walk-error" "jazz:walk-error" "Class-Declaration" "jazz:Class-Declaration" "%%class-is?" "%%assertion" "%%cdr" "setter-name" "getter-name" "initialize" "compatibility" "access" "specifier" "name" "bind" "jazz:bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-property" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2086 9 2086 29 ("%property" "expand-slot-form" "jazz:expand-slot-form" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "method-modifiers" define () () #f #f 2095 8 2095 29 ("notsynchronized" "synchronized" "notremote" "remote" "onsite" "inline" "concrete" "abstract" "override" "chained" "virtual" "final" "uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-method" define () ("walker" "resume" "declaration" "rest") #f #f 2106 9 2106 26 ("values" "unspecified" "%%list" "%%null?" "if" "effective-body" "body" "specifier" "lambda" "parse-specifier" "jazz:parse-specifier" "%%desourcify" "%%cdr" "wrap-parameters" "jazz:wrap-parameters" "parameters" "name" "let" "desourcify-all" "jazz:desourcify-all" "method" "%%cons" "%%get-declaration-toplevel" "%%get-lexical-binding-name" "walk-error" "jazz:walk-error" "%%car" "source-code" "jazz:source-code" "%%pair?" "and" "%%assertion" "method-modifiers" "jazz:method-modifiers" "parse-modifiers" "jazz:parse-modifiers" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-method-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2117 9 2117 37 (",@body" "with-self" "walk" "jazz:walk" "%%set-method-declaration-body" "%%set-method-declaration-signature" "%%when" "add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-method-declaration" "jazz:new-method-declaration" "find-child-declaration" "jazz:find-child-declaration" "new-declaration" "unspecified" "jazz:unspecified" "values" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "concrete" "inline" "inline?" "Procedure" "jazz:Procedure" "walk-specifier" "jazz:walk-specifier" "new-function-type" "jazz:new-function-type" "type" "let" "walk-error" "jazz:walk-error" "Category-Declaration" "jazz:Category-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "%%cdr" "parse-method" "jazz:parse-method" "body" "parameters" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "specifier" "receive" "%%get-declaration-parent" "%%eq?" "if" "%%get-method-declaration-root" "or" "and" "root-declaration" "private-access" "jazz:private-access" "lookup-declaration" "jazz:lookup-declaration" "next-declaration" "let*" "name" "find-root-declaration" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-method" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2149 9 2149 25 ("%%set-declaration-source" "%%set-method-declaration-body" "%%set-method-declaration-signature" "inline" "%%when" "concrete" ",@body" "with-self" "%%get-lexical-binding-type" "nextmethod" "new-nextmethod-variable" "jazz:new-nextmethod-variable" "%%cons" "walk" "jazz:walk" "body-expression" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "%%set-analysis-data-declaration-references" "%%get-declaration-locator" "get-analysis-data" "jazz:get-analysis-data" "data" "let" "analysis-mode?" "jazz:analysis-mode?" "if" "else" "Interface-Declaration" "jazz:Interface-Declaration" "%%not" "case" "override" "%%neq?" "chained" "virtual" "%%memq" "final" "%%eq?" "cond" "root-category-declaration" "%%get-method-declaration-propagation" "and" "root-method-propagation" "%%get-method-declaration-root" "root-method-declaration" "%%get-declaration-parent" "category-declaration" "private-access" "jazz:private-access" "lookup-declaration" "jazz:lookup-declaration" "new-declaration" "let*" "walk-error" "jazz:walk-error" "Category-Declaration" "jazz:Category-Declaration" "%%class-is?" "%%assertion" "source-code" "jazz:source-code" "%%cdr" "parse-method" "jazz:parse-method" "body" "parameters" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "wrap-parameters" define () ("parameters") #f #f 2190 9 2190 29 ("queue-list" "jazz:queue-list" "%%cdr" "with-self" ",@specifier-list" "%%cadr" "%%list" "specifier-list" "rest" "specifier" "lambda" "%%cddr" "parse-specifier" "jazz:parse-specifier" "%%keyword?" "enqueue" "jazz:enqueue" "specifier?" "jazz:specifier?" "%%pair?" "if" "%%car" "parameter" "else" "enqueue-list" "jazz:enqueue-list" "%%symbol?" "%%null?" "cond" "scan" "iter" "new-queue" "jazz:new-queue" "queue" "let" "parameters")}
      {Lisp-Entry "walk-cast" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2220 9 2220 23 ("walk" "jazz:walk" "walk-specifier" "jazz:walk-specifier" "new-cast" "jazz:new-cast" "%%cddr" "%%car" "expression" "%%cadr" "specifier" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-allocate" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2233 9 2233 27 ("walk-list" "jazz:walk-list" "walk" "jazz:walk" "new-allocate" "jazz:new-allocate" "%%cddr" "values" "%%cadr" "class" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-with-self" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2246 9 2246 28 ("walk-body" "jazz:walk-body" "%%cdr" "body" "new-with-self" "jazz:new-with-self" "new-self-binding" "jazz:new-self-binding" "%%cons" "new-environment" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "parse-with-dynamic-self" define () ("form") #f #f 2259 9 2259 37 ("values" "%%cdr" "body" "%%car" "code" "let" "form")}
      {Lisp-Entry "walk-with-dynamic-self-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2265 9 2265 48 ("walk-declarations" "jazz:walk-declarations" "%%desourcify" "%%cdr" "parse-with-dynamic-self" "jazz:parse-with-dynamic-self" "body" "code" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-with-dynamic-self" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2270 9 2270 36 ("walk-list" "jazz:walk-list" "new-with-dynamic-self" "jazz:new-with-dynamic-self" "new-dynamic-self-binding" "jazz:new-dynamic-self-binding" "%%cons" "new-environment" "let" "%%desourcify" "%%cdr" "parse-with-dynamic-self" "jazz:parse-with-dynamic-self" "body" "code" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "parse-with-local-variables" define () ("form") #f #f 2283 9 2283 40 ("values" "%%cdr" "body" "%%car" "variables" "let" "form")}
      {Lisp-Entry "walk-with-local-variables-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2289 9 2289 51 ("walk-declarations" "jazz:walk-declarations" "%%desourcify" "%%cdr" "parse-with-local-variables" "jazz:parse-with-local-variables" "body" "variables" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-with-local-variables" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2294 9 2294 39 ("walk-list" "jazz:walk-list" "new-begin" "jazz:new-begin" "new-local-variable-binding" "jazz:new-local-variable-binding" "variable" "lambda" "map" "new-walk-frame" "jazz:new-walk-frame" "%%cons" "new-environment" "let" "%%desourcify" "%%cdr" "parse-with-local-variables" "jazz:parse-with-local-variables" "body" "variables" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "validate-proclaim" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Jazz-Walker") #f 2305 21 2305 43 ("walker" "walk-error" "jazz:walk-error" "Category-Declaration" "jazz:Category-Declaration" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%not" "and" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "remotable-stub-modifiers" define () () #f #f 2316 8 2316 37 ("public" "package" "protected" "private")}
      {Lisp-Entry "remotable-stub-keywords" define () () #f #f 2319 8 2319 36 ("extends")}
      {Lisp-Entry "parse-remotable-stub" define () ("walker" "resume" "declaration" "rest") #f #f 2323 9 2323 34 ("values" "remotable-stub-keywords" "jazz:remotable-stub-keywords" "parse-keywords" "jazz:parse-keywords" "body" "ascendant-name" "%%cdr" "%%car" "name" "let" "remotable-stub-modifiers" "jazz:remotable-stub-modifiers" "parse-modifiers" "jazz:parse-modifiers" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "method-stub-modifiers" define () () #f #f 2331 8 2331 34 ("value" "reference" "call" "exec" "post" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-method-stub" define () ("walker" "resume" "declaration" "rest") #f #f 2337 9 2337 31 ("Any" "jazz:Any" "values" "body" "%%cdr" "parameters" "name" "%%car" "signature" "let*" "method-stub-modifiers" "jazz:method-stub-modifiers" "parse-modifiers" "jazz:parse-modifiers" "passage" "invocation" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-remotable-stub" define () ("walker" "resume" "declaration" "environment" "." "rest") #f #f 2346 9 2346 35 ("Remote-Proxy" ",@values-method" "stub-reference" "implements" "Local-Proxy" "metaclass" "Remotable-Stub" ",stub-interface" ",stub-access" "interface" ",remote-class" ",local-class" "Stub-Interface" "specified?" "jazz:specified?" "extends" ",interface-class" "package" "class" "begin" "nextmethod" ",@values-list" "list" "append" "proxy-values" "values-method" "values-list" ",call" ",value-keyword" "proxy-value" "self" ",invoker" "if" ",dispatch" ",@local-result" ",rest" ",@positional" "object" "~" "apply" "%%not-null?" "override" "%%when" ",@parameters" ",name" "abstract" "virtual" ",access" "value-keyword" "unspecified" "local-result" "dispatch" "call-remote" "call" "exec-remote" "exec" "post-remote" "post" "invoker" "parse-method-stub" "jazz:parse-method-stub" "invocation" "access" "method" "%%eq?" "method-form" "lambda" "for-each" "remotes" "locals" "proxies" "remote-class" "local-class" "stub-interface" "interface-class" "string->keyword" "jazz:string->keyword" "0" "%%substring" "%%string=?" "4" "%%fx>" "and" "%%assert" "%%string-length" "len" "str" "let*" "value" "reference" "case" "passage" "parse-value-keyword" "%%cdr" "enqueue" "jazz:enqueue" "%%car" "else" "enqueue-list" "jazz:enqueue-list" "%%symbol?" "queue-list" "jazz:queue-list" "values" "%%null?" "cond" "scan" "iter" "parameter" "encode" "positional" "new-queue" "jazz:new-queue" "parameters" "let" "params" "parse-parameters" "%%symbol->string" "%%string-append" "%%string->symbol" "suffix" "add" "define" "parse-remotable-stub" "jazz:parse-remotable-stub" "body" "ascendant-name" "stub-access" "type" "name" "receive" "rest" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-com-external" define () ("walker" "resume" "declaration" "environment" "signature" "result-type" "com-interface" "offset") #f #f 2489 9 2489 33 ("emit-com-external" "jazz:emit-com-external" ",name" "public" "emit-com-function" "jazz:emit-com-function" ",lowlevel-name" "definition" "begin" "%%cons" "C-Type-Declaration" "jazz:C-Type-Declaration" "%%class-is?" "resolved" "every?" "jazz:every?" "HRESULT" "jazz.platform.windows.com" "jazz.platform.windows.com:HRESULT" "%%get-declaration-locator" "%%eq?" "hresult?" "%%symbol->string" "%%string-append" "%%string->symbol" "lowlevel-name" "car" "resolved-directions" "resolved-params" "resolved-result" "let" "walk-error" "jazz:walk-error" "resolve-c-type-reference" "jazz:resolve-c-type-reference" "%%symbol?" "if" "type" "lambda" "resolve-declaration" "%%cdr" "cadr" "map" "param-types" "%%car" "name" "let*" "offset" "com-interface" "result-type" "signature" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "emit-com-function" define () ("offset" "result-type" "resolved-result" "param-types" "resolved-params") #f #f 2506 9 2506 31 ("1" "%%fx+" "cons" "2" "order" "%%number->string" "%%cdr" "%%car" "%%pair?" "iter" "let" "%%apply" "%%get-lexical-binding-name" "->string" "jazz:->string" "string-append" ",result-type" "map" "IUnknown*" "%%cons" "c-function" "%%symbol->string" "%%string-append" "%%string->symbol" "%%get-c-type-declaration-kind" "%%eq?" "if" "declaration" "type" "fix-locator" "define" "resolved-params" "param-types" "resolved-result" "result-type" "offset")}
      {Lisp-Entry "emit-com-external" define () ("hresult?" "lowlevel-name" "resolved-params" "resolved-directions" "com-interface") #f #f 2537 9 2537 31 ("%%fx=" ",@out-list" "values" "else" "unspecified" "0" "%%length" "case" "validate-hresult" ",com-interface" "validate-hresult-with-errorinfo" "list" ",lowlevel-name" "result" "coptr" "lambda" "out-list" "%%fx+" "%%cdr" "cons" "%%car" "generated" "%%pair?" "1" "iter" "generator" "generate-cotype-transform" ",free" "get-cotype-free" "free" "generate-free" ",ref" "get-cotype-ref" "ref" "generate-ref" ",value" ",encode/enref" ",binding" "get-cotype-default-value" "value" "get-cotype-encode/enref" "encode/enref" "binding" "let" "generate-encode/enref" "in" "generate-out" "generate-low" "%%number->string" "%%string-append" "%%string->symbol" "out" "%%eq?" "if" "order" "resolved-direction" "resolved-param" "generate-in" "define" "com-interface" "resolved-directions" "resolved-params" "lowlevel-name" "hresult?")}
      {Lisp-Entry "get-cotype-default-value" define () ("cotype") #f #f 2612 9 2612 33 ("else" "LONG*" "jazz.platform.windows.WinTypes:LONG*" "0" "INT*" "jazz.platform.windows.WinTypes" "jazz.platform.windows.WinTypes:INT*" "IUnknown**" "jazz.platform.windows.com:IUnknown**" "IUnknown*" "jazz.platform.windows.com:IUnknown*" "VARIANT*" "jazz.platform.windows.com:VARIANT*" "VARIANT" "jazz.platform.windows.com:VARIANT" "VARIANT_BOOL*" "jazz.platform.windows.com:VARIANT_BOOL*" "VARIANT_BOOL" "jazz.platform.windows.com:VARIANT_BOOL" "GUID*" "jazz.platform.windows.com:GUID*" "GUID" "jazz.platform.windows.com:GUID" "BSTR*" "jazz.platform.windows.com:BSTR*" "error" "BSTR" "jazz.platform.windows.com" "jazz.platform.windows.com:BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-encode/enref" define () ("cotype") #f #f 2629 9 2629 32 ("else" "LONG-enref" "LONG*" "jazz.platform.windows.WinTypes:LONG*" "INT-enref" "INT*" "jazz.platform.windows.WinTypes" "jazz.platform.windows.WinTypes:INT*" "IUnknown*-enref" "IUnknown**" "jazz.platform.windows.com:IUnknown**" "IUnknown*" "jazz.platform.windows.com:IUnknown*" "VARIANT*" "jazz.platform.windows.com:VARIANT*" "VARIANT-encode" "VARIANT" "jazz.platform.windows.com:VARIANT" "VARIANT_BOOL-enref" "VARIANT_BOOL*" "jazz.platform.windows.com:VARIANT_BOOL*" "VARIANT_BOOL-encode" "VARIANT_BOOL" "jazz.platform.windows.com:VARIANT_BOOL" "GUID*" "jazz.platform.windows.com:GUID*" "GUID-encode" "GUID" "jazz.platform.windows.com:GUID" "BSTR*-enref" "BSTR*" "jazz.platform.windows.com:BSTR*" "BSTR-encode" "BSTR" "jazz.platform.windows.com" "jazz.platform.windows.com:BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-ref" define () ("cotype") #f #f 2646 9 2646 23 ("else" "LONG*-ref" "LONG*" "jazz.platform.windows.WinTypes:LONG*" "INT*-ref" "INT*" "jazz.platform.windows.WinTypes" "jazz.platform.windows.WinTypes:INT*" "IUnknown**-ref" "IUnknown**" "jazz.platform.windows.com:IUnknown**" "IUnknown*" "jazz.platform.windows.com:IUnknown*" "VARIANT*" "jazz.platform.windows.com:VARIANT*" "VARIANT-ref" "VARIANT" "jazz.platform.windows.com:VARIANT" "VARIANT_BOOL*-ref" "VARIANT_BOOL*" "jazz.platform.windows.com:VARIANT_BOOL*" "VARIANT_BOOL-decode" "VARIANT_BOOL" "jazz.platform.windows.com:VARIANT_BOOL" "GUID*" "jazz.platform.windows.com:GUID*" "GUID-ref" "GUID" "jazz.platform.windows.com:GUID" "BSTR*-ref" "BSTR*" "jazz.platform.windows.com:BSTR*" "BSTR-ref" "BSTR" "jazz.platform.windows.com" "jazz.platform.windows.com:BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-free" define () ("cotype") #f #f 2663 9 2663 24 ("else" "LONG*-free" "LONG*" "jazz.platform.windows.WinTypes:LONG*" "INT*-free" "INT*" "jazz.platform.windows.WinTypes" "jazz.platform.windows.WinTypes:INT*" "IUnknown**-free" "IUnknown**" "jazz.platform.windows.com:IUnknown**" "IUnknown*" "jazz.platform.windows.com:IUnknown*" "VARIANT*" "jazz.platform.windows.com:VARIANT*" "VARIANT-decode" "VARIANT" "jazz.platform.windows.com:VARIANT" "VARIANT_BOOL*-free" "VARIANT_BOOL*" "jazz.platform.windows.com:VARIANT_BOOL*" "VARIANT_BOOL" "jazz.platform.windows.com:VARIANT_BOOL" "GUID*" "jazz.platform.windows.com:GUID*" "GUID-free" "GUID" "jazz.platform.windows.com:GUID" "BSTR*-free" "BSTR*" "jazz.platform.windows.com:BSTR*" "BSTR-free" "BSTR" "jazz.platform.windows.com" "jazz.platform.windows.com:BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "expand-assert" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2685 9 2685 27 ("expand-assert-test" "jazz:expand-assert-test" "sourcify-if" "jazz:sourcify-if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-assertion" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2692 9 2692 30 ("expand-assertion-test" "jazz:expand-assertion-test" "sourcify-if" "jazz:sourcify-if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-debug-assert" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2699 9 2699 33 ("debug-user?" "jazz:debug-user?" "expand-assert-test" "jazz:expand-assert-test" "sourcify-if" "jazz:sourcify-if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-debug-assertion" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2705 9 2705 36 ("debug-user?" "jazz:debug-user?" "expand-assertion-test" "jazz:expand-assertion-test" "sourcify-if" "jazz:sourcify-if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-assert-test" define () ("test?" "src") #f #f 2711 9 2711 32 ("error" "%%list" "expand-assertion-body" "jazz:expand-assertion-body" "get-output-string" "%%desourcify" "write" "display" "open-output-string" "port" "message" "%%cddr" "body" "source-code" "jazz:source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "expand-assertion-test" define () ("test?" "src") #f #f 2722 9 2722 35 ("expand-assertion-body" "jazz:expand-assertion-body" "%%cdr" "body" "%%cddr" "%%car" "action" "source-code" "jazz:source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "expand-assertion-body" define () ("test?" "assertion" "action" "body") #f #f 2729 9 2729 35 (",@body" "begin" "simplify-begin" "jazz:simplify-begin" ",action" ",assertion" "not" "unspecified" "%%not-null?" "if" "let" "body" "action" "assertion" "test?")}
      {Lisp-Entry "walk-declare" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2745 9 2745 26 ("new-declare" "jazz:new-declare" "%%cdr" "declarations" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-include" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2756 9 2756 28 ("new-c-include" "jazz:new-c-include" "%%cdr" "name" "bind" "jazz:bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-declare" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2767 9 2767 28 ("new-c-declare" "jazz:new-c-declare" "%%cdr" "code" "bind" "jazz:bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "c-named-declare-modifiers" define () () #f #f 2778 8 2778 38 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-c-named-declare" define () ("walker" "resume" "declaration" "rest") #f #f 2783 9 2783 35 ("values" "Any" "jazz:Any" "type" "let" "code" "name" "bind" "jazz:bind" "c-named-declare-modifiers" "jazz:c-named-declare-modifiers" "parse-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-named-declare-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2790 9 2790 46 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "new-c-named-declare-declaration" "jazz:new-c-named-declare-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "let" "%%desourcify" "%%cdr" "parse-c-named-declare" "jazz:parse-c-named-declare" "code" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "resolve-c-named-declare-reference" define () ("walker" "resume" "declaration" "environment" "symbol") #f #f 2798 9 2798 47 ("%%get-declaration-locator" "walk-error" "jazz:walk-error" "C-Named-Declare-Declaration" "jazz:C-Named-Declare-Declaration" "%%class-is?" "if" "lookup-reference" "jazz:lookup-reference" "c-named-declare-declaration" "let" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-named-declare" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2805 9 2805 34 ("require-declaration" "jazz:require-declaration" "new-declaration" "%%cdr" "parse-c-named-declare" "jazz:parse-c-named-declare" "code" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-initialize" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2817 9 2817 31 ("new-c-initialize" "jazz:new-c-initialize" "%%cdr" "code" "bind" "jazz:bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "c-type-modifiers" define () () #f #f 2828 8 2828 29 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-c-type" define () ("walker" "resume" "declaration" "rest") #f #f 2833 9 2833 26 ("declare" "scheme-to-c" "c-to-scheme" "values" "%%null?" "if" "Any" "jazz:Any" "type" "let" "conversions" "c-type" "name" "bind" "jazz:bind" "c-type-modifiers" "jazz:c-type-modifiers" "parse-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-type-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2843 9 2843 37 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%get-c-type-declaration-pointer-types" "%%set-c-type-declaration-pointer-types" "%%when" "new-c-type-declaration" "jazz:new-c-type-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "walk-error" "jazz:walk-error" "resolve-c-named-declare-reference" "jazz:resolve-c-named-declare-reference" "%%cons" "%%string?" "let" "resolve-c-type" "jazz:resolve-c-type" "inclusions" "base-type-declaration" "expansion" "kind" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "if" "%%desourcify" "%%cdr" "parse-c-type" "jazz:parse-c-type" "declare" "scheme-to-c" "c-to-scheme" "c-type" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-type" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2861 9 2861 25 ("require-declaration" "jazz:require-declaration" "%%cdr" "parse-c-type" "jazz:parse-c-type" "declare" "scheme-to-c" "c-to-scheme" "c-type" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "resolve-c-type" define () ("walker" "resume" "declaration" "environment" "type") #f #f 2867 9 2867 28 ("queue-list" "jazz:queue-list" "base-type-declaration" "expansion" "kind" "receive" "walk-error" "jazz:walk-error" "else" "union" "struct" "map" "result-type" "parameter-types" "function" "and" "resolve-expansion" "base-type" "pointer" ",@tag-rest" ",c-string" "%%cdr" "tag-rest" "c-string" "bind" "jazz:bind" "%%cadr" "native" "%%car" "case" "%%pair?" "%%string?" "%%get-declaration-locator" "alias" "values" "enqueue" "jazz:enqueue" "resolve-c-type-reference" "jazz:resolve-c-type-reference" "c-type-declaration" "%%symbol?" "cond" "resolve" "define" "new-queue" "jazz:new-queue" "queue" "let" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "resolve-c-type-reference" define () ("walker" "resume" "declaration" "environment" "symbol") #f #f 2907 9 2907 38 ("%%get-declaration-locator" "walk-error" "jazz:walk-error" "C-Type-Declaration" "jazz:C-Type-Declaration" "%%class-is?" "if" "lookup-reference" "jazz:lookup-reference" "c-type-declaration" "let" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-c-type-reference" define () ("walker" "resume" "declaration" "environment" "type") #f #f 2914 9 2914 37 ("%%get-module-declaration-inclusions" "%%append" "%%set-module-declaration-inclusions" "%%get-declaration-toplevel" "module-declaration" "let" "resolve-c-type" "jazz:resolve-c-type" "inclusions" "base-type-declaration" "expansion" "kind" "receive" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-function" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2926 9 2926 29 (",c-name-or-code" "map" "c-lambda" "new-c-function" "jazz:new-c-function" "expand-c-type-reference" "jazz:expand-c-type-reference" "type" "lambda" "resolve-access" "%%cdr" "c-name-or-code" "result-type" "types" "bind" "jazz:bind" "walk-error" "jazz:walk-error" "%%length" "4" "%%fx=" "list?" "and" "%%assertion" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "c-definition-modifiers" define () () #f #f 2940 8 2940 35 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-c-definition" define () ("walker" "resume" "declaration" "rest") #f #f 2945 9 2945 32 ("values" "%%cdr" "parameters" "Any" "jazz:Any" "type" "%%car" "name" "let" "body" "scope" "c-name" "result-type" "parameter-types" "signature" "bind" "jazz:bind" "c-definition-modifiers" "jazz:c-definition-modifiers" "parse-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-definition-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2954 9 2954 43 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "map" "new-c-definition-declaration" "jazz:new-c-definition-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "walk-parameters" "jazz:walk-parameters" "signature" "expand-c-type-reference" "jazz:expand-c-type-reference" "lambda" "resolve-access" "%%cdr" "parse-c-definition" "jazz:parse-c-definition" "body" "scope" "c-name" "result-type" "parameter-types" "parameters" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-c-definition" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 2966 9 2966 31 ("%%set-declaration-source" "walk-body" "jazz:walk-body" "%%set-c-definition-declaration-body" "%%set-c-definition-declaration-signature" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "require-declaration" "jazz:require-declaration" "new-declaration" "let*" "%%cdr" "parse-c-definition" "jazz:parse-c-definition" "body" "scope" "c-name" "result-type" "parameter-types" "parameters" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "build-pointer-symbol" define () ("type") #f #f 2983 9 2983 34 ("%%symbol->string" "%%string-append" "%%string->symbol" "type")}
      {Lisp-Entry "pointer?" define () ("type") #f #f 2987 9 2987 22 ("1" "%%fx-" "%%string-ref" "%%eq?" "%%string-length" "lgt" "%%symbol->string" "str" "let*" "type")}
      {Lisp-Entry "build-method-symbol" define () ("struct" "." "rest") #f #f 2993 9 2993 33 ("symbol->string" "map" "%%symbol->string" "string-append" "apply" "%%string->symbol" "rest" "struct")}
      {Lisp-Entry "parse-structure-name" define () ("name") #f #f 2997 9 2997 34 ("%%cddr" "%%cadr" "%%car" "%%symbol->string" "values" "%%symbol?" "if" "name")}
      {Lisp-Entry "kind+type" define () ("walker" "resume" "declaration" "environment" "type") #f #f 3003 9 3003 23 ("values" "%%car" "alias" "%%eq?" "if" "%%get-c-type-declaration-inclusions" "inclusions" "%%get-c-type-declaration-expansion" "expansion" "%%get-c-type-declaration-kind" "kind" "resolve-c-type-reference" "jazz:resolve-c-type-reference" "loop" "let" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-accessor" define () ("walker" "resume" "declaration" "environment" "clause" "struct") #f #f 3013 9 3013 29 ("values" ",setter-string" "void" "-set!" "setter" ",getter-string" ",type" ",struct*" "c-function" "-ref" "build-method-symbol" "jazz:build-method-symbol" "public" "definition" "getter" "%%memq" "wchar_t-string" "char-string" "type*" "build-pointer-symbol" "jazz:build-pointer-symbol" "struct*" "let*" "else" "%%number->string" "size-string" "cond" "setter-string" "union" "function" "pointer" "native" "case" "%%string-append" "wchar_t" "char" "%%eq?" "or" "if" "getter-string" "%%symbol->string" "id-string" "kind+type" "jazz:kind+type" "expansion" "kind" "receive" "walk-error" "jazz:walk-error" "%%symbol?" "%%integer?" "%%when" "%%null?" "%%not" "and" "%%cddr" "clause-rest" "size" "%%cadr" "id" "%%car" "type" "let" "struct" "clause" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-structure/union" define () ("walker" "resume" "declaration" "environment" "name" "clauses") #f #f 3069 9 3069 36 ("map" "append" "%%apply" "unsigned-int" "void" "native" "free" "c-function" "make" "build-method-symbol" "jazz:build-method-symbol" "public" "definition" ",@tag*-rest" "pointer" ",struct*" ",@tag-rest" ",c-struct-string" "type" ",struct" "c-type" "begin" "%%list" "jazz:expand-accessor" "setter" "getter" "clause" "expand-accessor" "define" "%%cdr" "%%car" "%%cons" "%%null?" "if" "tag*-rest" "%%string-append" "sizeof" "build-pointer-symbol" "jazz:build-pointer-symbol" "struct*" "let" "parse-structure-name" "jazz:parse-structure-name" "tag-rest" "c-struct-string" "struct" "receive" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-c-structure" define () ("walker" "resume" "declaration" "environment" "name" "." "clauses") #f #f 3091 9 3091 32 ("expand-structure/union" "jazz:expand-structure/union" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-c-structure-array" define () ("walker" "resume" "declaration" "environment" "name" "." "rest") #f #f 3095 9 3095 38 ("array-element" "%%string-append" ",struct*" "int" "c-function" "array-make" "build-method-symbol" "jazz:build-method-symbol" "public" "definition" "begin" "%%symbol->string" "%%car" "%%null?" "%%not" "if" "c-struct-string" "build-pointer-symbol" "jazz:build-pointer-symbol" "struct*" "struct" "let*" "rest" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-c-union" define () ("walker" "resume" "declaration" "environment" "name" "." "clauses") #f #f 3106 9 3106 28 ("expand-structure/union" "jazz:expand-structure/union" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "expand-c-external" define () ("walker" "resume" "declaration" "environment" "signature" "type" "." "rest") #f #f 3115 9 3115 31 (",c-name" ",type" ",params" "c-function" ",s-name" "public" "definition" "%%symbol->string" "%%null?" "if" "c-name" "%%cdr" "params" "%%car" "s-name" "let*" "rest" "type" "signature" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-parameterize" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 3128 9 3128 31 ("walk-body" "jazz:walk-body" "queue-list" "jazz:queue-list" "new-parameterize" "jazz:new-parameterize" "walk" "jazz:walk" "%%cons" "enqueue" "jazz:enqueue" "%%cdr" "value" "%%car" "variable" "continuation-capture" "binding-form" "lambda" "for-each" "new-queue" "jazz:new-queue" "expanded-bindings" "unspecified" "%%list" "%%null?" "if" "effective-body" "%%cddr" "body" "%%cadr" "source-code" "jazz:source-code" "bindings" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-with-slots" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 3155 9 3155 29 (",@body" ",setter-name" "value" ",getter-name" "%%list" "%%get-slot-declaration-setter-name" "setter-name" "%%get-slot-declaration-getter-name" "getter-name" "lookup-reference" "jazz:lookup-reference" "slot-declaration" "let*" "slot-name" "lambda" "map" "let-symbol" ",object" ",object-symbol" "walk" "jazz:walk" "generate-symbol" "jazz:generate-symbol" "object-symbol" "%%cdr" "body" "object" "slot-names" "bind" "jazz:bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-time" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 3175 9 3175 23 ("walk-list" "jazz:walk-list" "new-time-special" "jazz:new-time-special" "%%cdr" "forms" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz" define () () ("dialect") #f 3189 21 3189 25 ("new-jazz-dialect" "jazz:new-jazz-dialect")}
      {Lisp-Entry "jazz.dialect" define () () ("dialect") #f 3192 21 3192 33 ("new-jazz-dialect" "jazz:new-jazz-dialect")}
      {Lisp-Entry "definition" define () () ("special") #f 3196 28 3196 38 ("walk-definition" "jazz:walk-definition" "jazz")}
      {Lisp-Entry "generic" define () () ("special") #f 3197 28 3197 35 ("walk-generic" "jazz:walk-generic" "jazz")}
      {Lisp-Entry "specific" define () () ("special") #f 3198 28 3198 36 ("walk-specific" "jazz:walk-specific" "jazz")}
      {Lisp-Entry "class" define () () ("syntax") #f 3199 28 3199 33 ("expand-class" "jazz:expand-class" "jazz")}
      {Lisp-Entry "%class" define () () ("special") #f 3200 28 3200 34 ("walk-%class" "jazz:walk-%class" "jazz")}
      {Lisp-Entry "interface" define () () ("special") #f 3201 28 3201 37 ("walk-interface" "jazz:walk-interface" "jazz")}
      {Lisp-Entry "slot" define () () ("syntax") #f 3202 28 3202 32 ("expand-slot" "jazz:expand-slot" "jazz")}
      {Lisp-Entry "property" define () () ("syntax") #f 3203 28 3203 36 ("expand-property" "jazz:expand-property" "jazz")}
      {Lisp-Entry "%slot" define () () ("special") #f 3204 28 3204 33 ("walk-%slot" "jazz:walk-%slot" "jazz")}
      {Lisp-Entry "%property" define () () ("special") #f 3205 28 3205 37 ("walk-%slot" "jazz:walk-%slot" "jazz")}
      {Lisp-Entry "method" define () () ("special") #f 3206 28 3206 34 ("walk-method" "jazz:walk-method" "jazz")}
      {Lisp-Entry "declare" define () () ("special") #f 3207 28 3207 35 ("walk-declare" "jazz:walk-declare" "jazz")}
      {Lisp-Entry "c-include" define () () ("special") #f 3208 28 3208 37 ("walk-c-include" "jazz:walk-c-include" "jazz")}
      {Lisp-Entry "c-declare" define () () ("special") #f 3209 28 3209 37 ("walk-c-declare" "jazz:walk-c-declare" "jazz")}
      {Lisp-Entry "c-named-declare" define () () ("special") #f 3210 28 3210 43 ("walk-c-named-declare" "jazz:walk-c-named-declare" "jazz")}
      {Lisp-Entry "c-initialize" define () () ("special") #f 3211 28 3211 40 ("walk-c-initialize" "jazz:walk-c-initialize" "jazz")}
      {Lisp-Entry "c-function" define () () ("special") #f 3212 28 3212 38 ("walk-c-function" "jazz:walk-c-function" "jazz")}
      {Lisp-Entry "c-type" define () () ("special") #f 3213 28 3213 34 ("walk-c-type" "jazz:walk-c-type" "jazz")}
      {Lisp-Entry "c-definition" define () () ("special") #f 3214 28 3214 40 ("walk-c-definition" "jazz:walk-c-definition" "jazz")}
      {Lisp-Entry "specialize" define () () ("macro") #f 3215 28 3215 38 ("expand-specialize" "jazz:expand-specialize" "jazz")}
      {Lisp-Entry "%specialize" define () () ("special") #f 3216 28 3216 39 ("walk-%specialize" "jazz:walk-%specialize" "jazz")}
      {Lisp-Entry "parameterize" define () () ("special") #f 3217 28 3217 40 ("walk-parameterize" "jazz:walk-parameterize" "jazz")}
      {Lisp-Entry "with-slots" define () () ("special") #f 3218 28 3218 38 ("walk-with-slots" "jazz:walk-with-slots" "jazz")}
      {Lisp-Entry "with-self" define () () ("special") #f 3219 28 3219 37 ("walk-with-self" "jazz:walk-with-self" "jazz")}
      {Lisp-Entry "with-dynamic-self" define () () ("special") #f 3220 28 3220 45 ("walk-with-dynamic-self" "jazz:walk-with-dynamic-self" "jazz")}
      {Lisp-Entry "with-local-variables" define () () ("special") #f 3221 28 3221 48 ("walk-with-local-variables" "jazz:walk-with-local-variables" "jazz")}
      {Lisp-Entry "cast" define () () ("special") #f 3222 28 3222 32 ("walk-cast" "jazz:walk-cast" "jazz")}
      {Lisp-Entry "allocate" define () () ("special") #f 3223 28 3223 36 ("walk-allocate" "jazz:walk-allocate" "jazz")}
      {Lisp-Entry "time" define () () ("special") #f 3224 28 3224 32 ("walk-time" "jazz:walk-time" "jazz")}
      {Lisp-Entry "remotable-stub" define () () ("macro") #f 3225 28 3225 42 ("expand-remotable-stub" "jazz:expand-remotable-stub" "jazz")}
      {Lisp-Entry "assert" define () () ("syntax") #f 3226 28 3226 34 ("expand-assert" "jazz:expand-assert" "jazz")}
      {Lisp-Entry "assertion" define () () ("syntax") #f 3227 28 3227 37 ("expand-assertion" "jazz:expand-assertion" "jazz")}
      {Lisp-Entry "c-structure" define () () ("macro") #f 3228 28 3228 39 ("expand-c-structure" "jazz:expand-c-structure" "jazz")}
      {Lisp-Entry "c-union" define () () ("macro") #f 3229 28 3229 35 ("expand-c-union" "jazz:expand-c-union" "jazz")}
      {Lisp-Entry "c-external" define () () ("macro") #f 3230 28 3230 38 ("expand-c-external" "jazz:expand-c-external" "jazz")}
      {Lisp-Entry "com-external" define () () ("macro") #f 3231 28 3231 40 ("expand-com-external" "jazz:expand-com-external" "jazz")}
      {Lisp-Entry "declaration-path" define () () ("macro") #f 3232 28 3232 44 ("expand-declaration-path" "jazz:expand-declaration-path" "jazz")}
      {Lisp-Entry "declaration-locator" define () () ("macro") #f 3233 28 3233 47 ("expand-declaration-locator" "jazz:expand-declaration-locator" "jazz")}
      {Lisp-Entry "debug-assert" define () () ("syntax") #f 3234 28 3234 40 ("expand-debug-assert" "jazz:expand-debug-assert" "jazz")}
      {Lisp-Entry "debug-assertion" define () () ("syntax") #f 3235 28 3235 43 ("expand-debug-assertion" "jazz:expand-debug-assertion" "jazz")}}})
"ecase"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "ecase.scm"} 231466232. scheme
    {Lisp-Entry "jazz.dialect.syntax.ecase" module (protected) () #f #f 37 18 37 43 ("scheme")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "error" native (private) () ("native") #f 43 16 43 26 ()}
      {Lisp-Entry "ecase" macro (public) ("form-src") ("syntax") #f 53 16 53 21 ("desourcify" "eqv?" "=" "list" "integer?" "value" "or" "pair?" "cons" "else" "eq?" "body" "car" "selector" "clause" "map" "cond" "symbol" "lambda" "with-uniqueness" "sourcify-if" "cddr" "clauses" "cadr" "target" "let" "error" "source-code" "cdr" "null?" "if" "form-src")}}})
"enumeration"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "enumeration.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.syntax.enumeration" module (protected) () #f #f 37 18 37 49 ("scheme")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "enumeration" macro (public) ("form-src") ("syntax") #f 43 16 43 27 (",name" "new" "symbol->string" "string-append" "string->symbol" "define" "name" "name-src" "lambda" "map" "Enumeration-Member" "extends" ",enumeration-name" "class" "begin" "cddr" "names" "source-code" "cadr" "enumeration-name" "let" "form-src")}}})
"exception"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "exception.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.exception" unit (protected) () #f #f 39 16 39 43 ()
      {Lisp-Entry "get-exception-hook" define () () #f #f 47 9 47 32 ("##primordial-exception-handler-hook")}
      {Lisp-Entry "set-exception-hook" define () ("hook") #f #f 50 9 50 32 ("##primordial-exception-handler-hook" "set!" "hook")}
      {Lisp-Entry "invoke-exception-hook" define () ("hook" "exc") #f #f 54 9 54 35 ("##thread-end-with-uncaught-exception!" "exc" "hook")}
      {Lisp-Entry "system-exception-hook" define () ("exc" "other") #f #f 63 9 63 35 ("##repl-exception-handler-hook" "other" "exc")}
      {Lisp-Entry "set-terminal-title" define () () #f #f 72 9 72 32 ("repl-output-port" "display")}
      {Lisp-Entry "bring-terminal-to-front" define () () #f #f 75 9 75 37 ("repl-output-port" "display")}
      {Lisp-Entry "clear-terminal" define () () #f #f 78 9 78 28 ("repl-output-port" "display")}}}
  {Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "exception.jazz"} 245375501. jazz
    {Lisp-Entry "jazz.dialect.language.exception" module (protected) () #f #f 37 18 37 49 ("jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("jazz.dialect.language.object" "jazz.dialect.language.geometry" "jazz.dialect.language.functional" "jazz.dialect.language.format" "jazz.dialect.kernel")}
      {Lisp-Entry "*exception-debugger*" definition () () #f #f 55 12 55 32 ()}
      {Lisp-Entry "get-exception-debugger" definition (public) () #f #f 59 20 59 42 ("*exception-debugger*")}
      {Lisp-Entry "set-exception-debugger" definition (public) ("exception-debugger") #f #f 62 20 62 42 ("*exception-debugger*" "set!" "exception-debugger")}
      {Lisp-Entry "current-exception-debugger" definition (public) () #f #f 66 19 66 45 ("make-parameter")}
      {Lisp-Entry "exception-debugger-hook" definition (package) ("exc" "other") #f #f 70 21 70 44 ("system-exception-hook" "if" "active-exception-debugger" "exception-debugger" "let" "other" "exc")}
      {Lisp-Entry "with-exception-debugger" definition (public) ("exception-debugger" "thunk") #f #f 77 20 77 43 ("current-exception-debugger" "parameterize" "thunk" "exception-debugger")}
      {Lisp-Entry "active-exception-debugger" definition (public) () #f #f 82 20 82 45 ("*exception-debugger*" "current-exception-debugger" "or")}
      {Lisp-Entry "system-exception-debugger" definition (public) ("exc") #f #f 86 20 86 45 ("system-exception-hook" "invoke-exception-hook" "exc")}
      {Lisp-Entry "with-system-exception-debugger" definition (public) ("thunk") #f #f 90 20 90 50 ("system-exception-debugger" "with-exception-debugger" "thunk")}
      {Lisp-Entry "Exception" class () ((extends . "Object")) #f #f 95 7 95 16 ("Object")
        {Lisp-Entry "get-message" method (public virtual) () #f #f 98 26 98 37 ()}
        {Lisp-Entry "present-message" method (public virtual) ("." "rest") #f #f 102 26 102 41 ("get-message" "list" "rest")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 106 20 106 25 ("get-message" "format" "lambda" "self" "print-unreadable" "readably" "output")}}
      {Lisp-Entry "exception?" definition (public) ("obj") #f #f 112 20 112 30 ("Exception" "is?" "object?" "and" "obj")}
      {Lisp-Entry "Exception-Detail" class (package) ((extends . "Object")) #f #f 117 15 117 31 ("Object")
        {Lisp-Entry "icon" slot () ((getter . "generate")) #f #f 120 8 120 12 ()}
        {Lisp-Entry "get-icon" accessor () () #f #f 120 24 120 32 ()}
        {Lisp-Entry "title" slot () ((getter . "generate")) #f #f 121 8 121 13 ()}
        {Lisp-Entry "get-title" accessor () () #f #f 121 24 121 32 ()}
        {Lisp-Entry "location" slot () ((getter . "generate")) #f #f 122 8 122 16 ()}
        {Lisp-Entry "get-location" accessor () () #f #f 122 24 122 32 ()}
        {Lisp-Entry "children" slot () ((getter . "generate")) #f #f 123 8 123 16 ()}
        {Lisp-Entry "get-children" accessor () () #f #f 123 24 123 32 ()}
        {Lisp-Entry "initialize" method (override) ("icon" "title" "location" "children") #f #f 126 20 126 30 ("children~self" "location~self" "title~self" "self" "icon~self" "set!" "nextmethod" "children" "location" "title" "icon")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 134 20 134 25 ("children" "location" "title" "icon" "self" "class-of" "category-name" "format" "readably" "output")}}
      {Lisp-Entry "System-Exception" class () ((extends . "Exception")) #f #f 143 7 143 23 ("Exception")
        {Lisp-Entry "exception" slot () ((getter . "generate")) #f #f 146 8 146 17 ()}
        {Lisp-Entry "get-exception" accessor () () #f #f 146 25 146 33 ()}
        {Lisp-Entry "initialize" method (override) ("exception") #f #f 149 20 149 30 ("self" "exception~self" "set!" "nextmethod" "exception")}}
      {Lisp-Entry "wrap-exception" definition (public) ("obj") #f #f 154 20 154 34 ("System-Exception" "new" "exception?" "if" "obj")}
      {Lisp-Entry "Break" class () ((extends . "Exception")) #f #f 160 7 160 12 ("Exception")
        {Lisp-Entry "continue" slot () () #f #f 163 8 163 16 ()}
        {Lisp-Entry "initialize" method (override) ("continue") #f #f 166 20 166 30 ("self" "continue~self" "set!" "nextmethod" "continue")}}
      {Lisp-Entry "Continue" class () ((extends . "Exception")) #f #f 171 7 171 15 ("Exception")}
      {Lisp-Entry "Error" class () ((extends . "Exception")) #f #f 174 7 174 12 ("generate" "override" "Exception")
        {Lisp-Entry "message" slot () ((setter . "generate") (getter . "(override generate)")) #f #f 177 8 177 15 ()}
        {Lisp-Entry "set-message" accessor () () #f #f 177 23 177 31 ()}
        {Lisp-Entry "initialize" method (override) ("(message: message #f)") #f #f 180 20 180 30 ("set-message" "nextmethod" "message" "message:")}}
      {Lisp-Entry "error?" definition (public) ("obj") #f #f 185 20 185 26 ("Error" "is?" "object?" "and" "obj")}
      {Lisp-Entry "Read-Error" class (package) ((extends . "Error")) #f #f 190 15 190 25 ("Error")
        {Lisp-Entry "source" slot () ((getter . "generate")) #f #f 193 8 193 14 ()}
        {Lisp-Entry "get-source" accessor () () #f #f 193 22 193 30 ()}
        {Lisp-Entry "start" slot () ((getter . "generate")) #f #f 194 8 194 13 ()}
        {Lisp-Entry "get-start" accessor () () #f #f 194 22 194 30 ()}
        {Lisp-Entry "end" slot () ((getter . "generate")) #f #f 195 8 195 11 ()}
        {Lisp-Entry "get-end" accessor () () #f #f 195 22 195 30 ()}
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 198 20 198 30 ("end~self" "start~self" "self" "source~self" "set!" "nextmethod" "apply" "others" "end" "start" "source" "bind-keywords" "rest")}
        {Lisp-Entry "get-range" method (public) () #f #f 206 18 206 27 ("end" "start" "Range" "new")}}
      {Lisp-Entry "Parse-Error" class (package) ((extends . "Error")) #f #f 210 15 210 26 ("Error")
        {Lisp-Entry "source" slot () ((getter . "generate")) #f #f 213 8 213 14 ()}
        {Lisp-Entry "get-source" accessor () () #f #f 213 22 213 30 ()}
        {Lisp-Entry "start" slot () ((getter . "generate")) #f #f 214 8 214 13 ()}
        {Lisp-Entry "get-start" accessor () () #f #f 214 22 214 30 ()}
        {Lisp-Entry "end" slot () ((getter . "generate")) #f #f 215 8 215 11 ()}
        {Lisp-Entry "get-end" accessor () () #f #f 215 22 215 30 ()}
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 218 20 218 30 ("end~self" "start~self" "self" "source~self" "set!" "nextmethod" "apply" "others" "end" "start" "source" "bind-keywords" "rest")}}
      {Lisp-Entry "Conversion-Error" class (package) ((extends . "Parse-Error")) #f #f 226 15 226 31 ("Parse-Error")
        {Lisp-Entry "object" slot () ((getter . "generate")) #f #f 229 8 229 14 ()}
        {Lisp-Entry "get-object" accessor () () #f #f 229 22 229 30 ()}
        {Lisp-Entry "type" slot () ((getter . "generate")) #f #f 230 8 230 12 ()}
        {Lisp-Entry "get-type" accessor () () #f #f 230 22 230 30 ()}
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 233 20 233 30 ("type~self" "self" "object~self" "set!" "nextmethod" "apply" "others" "type" "object" "bind-keywords" "rest")}
        {Lisp-Entry "get-message" method (override) () #f #f 240 20 240 31 ("format-gender" "object" "format" "category-identifier" "string?" "if" "type" "let")}}
      {Lisp-Entry "Signal" class () ((extends . "Exception")) #f #f 248 7 248 13 ("Exception")}
      {Lisp-Entry "Cancel-Signal" class (package) ((extends . "Signal")) #f #f 251 15 251 28 ("Signal")}
      {Lisp-Entry "call-with-catch" definition (public) ("predicate/type" "catcher" "thunk") #f #f 254 20 254 35 ("is?" "object?" "and" "procedure?" "if" "obj" "lambda" "with-exception-filter" "thunk" "catcher" "predicate/type")}
      {Lisp-Entry "throw" definition (public) ("exception") #f #f 272 20 272 25 ("raise" "exception")}
      {Lisp-Entry "throw-cancel" definition (public inline) () #f #f 276 27 276 39 ("Cancel-Signal" "new" "throw")}
      {Lisp-Entry "signal" definition (public) () #f #f 280 19 280 25 ("throw")}
      {Lisp-Entry "error" definition (public) ("." "rest") #f #f 283 20 283 25 ("format" "apply" "message:" "Error" "new" "signal" "rest")}
      {Lisp-Entry "disabled-functionality" definition (public) () #f #f 287 20 287 42 ("error")}
      {Lisp-Entry "must-implement" definition (public) ("definition-name" "(what #f)") #f #f 291 20 291 34 ("or" "error" "what" "definition-name")}
      {Lisp-Entry "warn" definition (public) ("string" "." "rest") #f #f 297 20 297 24 ("apply" ":console" "format" "rest" "string")}
      {Lisp-Entry "warn-unimplemented" definition (public) ("name") #f #f 302 20 302 38 (":console" "format" "name")}
      {Lisp-Entry "Restart" class () ((extends . "Object")) #f #f 311 7 311 14 ("Object")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 314 8 314 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 314 23 314 31 ()}
        {Lisp-Entry "message" slot () ((getter . "generate")) #f #f 315 8 315 15 ()}
        {Lisp-Entry "get-message" accessor () () #f #f 315 23 315 31 ()}
        {Lisp-Entry "handler" slot () ((getter . "generate")) #f #f 316 8 316 15 ()}
        {Lisp-Entry "get-handler" accessor () () #f #f 316 23 316 31 ()}
        {Lisp-Entry "initialize" method (override) ("name" "message" "handler") #f #f 319 20 319 30 ("handler~self" "message~self" "self" "name~self" "set!" "nextmethod" "handler" "message" "name")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 326 20 326 25 ("name" "format" "lambda" "self" "print-unreadable" "readably" "output")}}
      {Lisp-Entry "current-restarts" definition (public) () #f #f 333 19 333 35 ("make-parameter")}
      {Lisp-Entry "with-restart-handler" definition (public) ("name" "message" "handler" "thunk") #f #f 337 20 337 40 ("Restart" "new" "cons" "current-restarts" "parameterize" "thunk" "handler" "message" "name")}
      {Lisp-Entry "with-restart-catcher" definition (public) ("name" "message" "thunk") #f #f 342 20 342 40 ("car" "not-null?" "if" "continuation-return" "rest" "with-restart-handler" "catcher-cont" "lambda" "continuation-capture" "thunk" "message" "name")}
      {Lisp-Entry "find-restart" definition (public) ("name") #f #f 354 20 354 32 ("current-restarts" "get-name" "get-name~" "eq?" "restart" "lambda" "find-if" "name")}
      {Lisp-Entry "find-restarts" definition (public) ("name") #f #f 360 20 360 33 ("current-restarts" "get-name" "get-name~" "eq?" "restart" "lambda" "collect-if" "name")}
      {Lisp-Entry "invoke-restart" definition (public) ("restart" "." "rest") #f #f 366 20 366 34 ("apply" "get-handler" "get-handler~" "handler" "let" "rest" "restart")}
      {Lisp-Entry "new-system-thread" definition (public) ("thunk" "." "rest") #f #f 376 20 376 37 ("with-system-exception-debugger" "lambda" "new-thread" "apply" "rest" "thunk")}}})
"foreign"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "foreign.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.foreign" unit (protected) () #f #f 37 16 37 41 ()
      {Lisp-Entry "foreign?" define () () #f #f 42 12 42 25 ("foreign?")}
      {Lisp-Entry "foreign-address" define () () #f #f 43 12 43 32 ("foreign-address")}
      {Lisp-Entry "foreign-release!" define () () #f #f 44 12 44 33 ("foreign-release!")}
      {Lisp-Entry "foreign-released?" define () () #f #f 45 12 45 34 ("foreign-released?")}
      {Lisp-Entry "foreign-tags" define () () #f #f 46 12 46 29 ("foreign-tags")}
      {Lisp-Entry "still-obj-refcount-dec!" define () ("foreign") #f #f 51 13 51 41 ("%%still-obj-refcount-dec!" "foreign")}
      {Lisp-Entry "still-obj-refcount-inc!" define () ("foreign") #f #f 54 13 54 41 ("%%still-obj-refcount-inc!" "foreign")}}})
"format"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "format.jazz"} 239854515. jazz
    {Lisp-Entry "jazz.dialect.language.format" module (protected) () #f #f 37 18 37 46 ("jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("jazz.dialect.language.functional" "jazz.dialect.kernel")}
      {Lisp-Entry "error" native (private) () ("native") #f 47 16 47 26 ()}
      {Lisp-Entry "format" definition (public) ("." "rest") #f #f 68 20 68 26 ("with-printer" "list" "<list>" "string" "<string>" ":string" "string?" "parse-format" "cdr" "prog1" ":reader" "detail:" "unspecified" "empty-value:" "properties:" "3" "precision:" "after:" "before:" "last-separator:" "separator:" "padding:" "justify:" "width:" "list?:" "get-list?" "not-found:" "getf" "keyword" "keyword-parameter" ":v" "param" "default" ":right" ":left" "n" ">=" "cardinality" "size" "justify" "buffer" "get-padding" "padding" "get-justify" "justification" "get-width" "width" "proc" "localize" "unimplemented" "force-output" "-" "fresh-line" "newline" "do" "repeat" "loop" "1" "optional-parameter" "count" "cddr" "neq?" "unspecified?" "memq" "cadr" "value" "car" "key" "not-null?" "scan" "get-empty-value" "empty-value" "get-properties" "properties" "print-list" "get-detail" "get-after" "after" "get-before" "before" "get-last-separator" "last-separator" "get-separator" "separator" "let*" "print-real" "get-precision" "precision" "print-hexadecimal" "print-binary" "print-unsigned" "print-expr" "detail" "textual" "write" "display" "lambda" "with-justification" "argument" "peek-argument" "next-argument" "or" "open-input-string" "subreader" "explicit?" "get-output-string" "begin" "open-output-string" "output" "read-control-string" "process-conditional" "eqv?" "cond" "null?" "eq?" "read-delimited" "arguments-empty?" "toplevel?" "and" "localize-directive" "z" "force-directive" "!" "freshline-directive" "$" "newline-directive" "%" "tab-directive" "&" "column-directive" "_" "properties-directive" "k" "list-directive" "l" "real-directive" "r" "hexadecimal-directive" "x" "binary-directive" "b" "unsigned-directive" "u" "char-directive" "print-directive" "p" "text-directive" "t" "write-directive" "s" "display-directive" "a" "read-parameters" "parameters" "read" "directive" "else" "conditional-directive" "error" "peek-char" "write-char" "when" "require-char" "case" "set!" "eof-object?" "if" "read-char" "c" "not" "while" "done?" "let" "output?" "input" "process" "arguments-scan" "control-reader" "out" "arguments" "control-string" "destination" "process-format" "define" "rest")}
      {Lisp-Entry "format-cardinality" definition (public) ("n" "<fx>") #f #f 420 20 420 38 ("->string" "0" "=" "if" "fx" "<fx>" "n")}
      {Lisp-Entry "format-plural" definition (public) ("n" "<fx>" "(plural \"s\")") #f #f 426 20 426 33 ("1" "=" "if" "plural" "fx" "<fx>" "n")}
      {Lisp-Entry "format-gender" definition (public) ("word") #f #f 432 20 432 33 ("first" "vowel?" "if" "word")}
      {Lisp-Entry "format-is/are" definition (public) ("n" "<fx>") #f #f 438 20 438 33 ("1" "=" "if" "fx" "<fx>" "n")}
      {Lisp-Entry "format-was/were" definition (public) ("n" "<fx>") #f #f 444 20 444 35 ("1" "=" "if" "fx" "<fx>" "n")}
      {Lisp-Entry "format-y/ies" definition (public) ("n" "<fx>") #f #f 450 20 450 32 ("1" "=" "if" "fx" "<fx>" "n")}
      {Lisp-Entry "format-following" definition (public) ("name" "n" "<fx>") #f #f 456 20 456 36 ("format" "1" "=" "if" "fx" "<fx>" "n" "name")}
      {Lisp-Entry "print-expr" definition () ("expr" "detail" "(output (current-output-port))") #f #f 467 13 467 23 ("print" "print~" "current-output-port" "output" "detail" "expr")}
      {Lisp-Entry "print-unsigned" definition () ("n" "(output (current-output-port))") #f #f 471 13 471 27 ("print-unsigned" "unimplemented" "current-output-port" "output" "n")}
      {Lisp-Entry "print-binary" definition () ("n" "(output (current-output-port))") #f #f 475 13 475 25 ("2" "number->string" "display" "current-output-port" "output" "n")}
      {Lisp-Entry "print-hexadecimal" definition () ("n" "(output (current-output-port))") #f #f 479 13 479 30 ("16" "number->string" "display" "current-output-port" "output" "n")}
      {Lisp-Entry "print-real" definition () ("r" "d" "(output (current-output-port))") #f #f 483 13 483 23 ("display" "lsf" "string-length" "lsi" "set!" "string-set!" "+" "sf" "number->string" ">" "=" "and" "0" "<" "if" "string-append" "si" "modulo" "f" "quotient" "i" "10" "expt" "abs" "*" "fxround" "n" "let" "current-output-port" "output" "d" "r")}
      {Lisp-Entry "print-list" definition () ("list" "separator" "last-separator" "before" "after" "detail" "(output (current-output-port))") #f #f 500 13 500 23 ("null?" "pair?" "if" "cdr" "next" "print" "print~" "car" "expr" "scan" "iter" "let" "display" "not-null?" "when" "current-output-port" "output" "detail" "after" "before" "last-separator" "separator" "list")}}})
"functional"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "functional.jazz"} 246692653. jazz
    {Lisp-Entry "jazz.dialect.language.functional" module (protected) () #f #f 37 18 37 50 ("terminal-port" ":terminal" "register-printer" "axis-find-in" "axis-find" "Axis" "<Axis>" "axis-for-each" "instantiate-ends-with?" "instantiate-starts-with?" "string-find-in" "instantiate-find-in" "string-find" "instantiate-find" "instantiate-butlast" "string" "<string>" "string-for-each" "instantiate-for-each" "jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("irregex" "jazz.dialect.language.object" "jazz.dialect.kernel")}
      {Lisp-Entry "error" native (private) () ("native") #f 48 16 48 26 ()}
      {Lisp-Entry "system-format" native (private) () ("native") #f 49 16 49 34 ()}
      {Lisp-Entry "Module" class () ((extends . "Object")) #f #f 57 7 57 13 ("Object")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 60 8 60 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 60 23 60 31 ()}
        {Lisp-Entry "access" slot () ((getter . "generate")) #f #f 61 8 61 14 ()}
        {Lisp-Entry "get-access" accessor () () #f #f 61 23 61 31 ()}
        {Lisp-Entry "exports" slot () ((getter . "generate")) #f #f 62 8 62 15 ()}
        {Lisp-Entry "get-exports" accessor () () #f #f 62 23 62 31 ()}
        {Lisp-Entry "entries" slot () ((getter . "generate")) #f #f 63 8 63 15 ()}
        {Lisp-Entry "get-entries" accessor () () #f #f 63 23 63 31 ()}}
      {Lisp-Entry "Field" class () ((extends . "Object")) #f #f 71 7 71 12 ("Object")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 74 8 74 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 74 20 74 28 ()}
        {Lisp-Entry "print" method (override) ("output" "detail") #f #f 77 20 77 25 ("get-name" "system-format" "lambda" "self" "print-unreadable" "detail" "output")}
        {Lisp-Entry "field-locator" method (protected virtual abstract) () #f #f 83 38 83 51 ()}
        {Lisp-Entry "field-ref" method (protected virtual abstract) () #f #f 84 38 84 47 ()}
        {Lisp-Entry "field-set!" method (protected virtual abstract) ("value") #f #f 85 38 85 48 ("value")}}
      {Lisp-Entry "Native" class () ((extends . "Field")) #f #f 93 7 93 13 ("Field")
        {Lisp-Entry "symbol" slot () ((getter . "generate")) #f #f 96 8 96 14 ()}
        {Lisp-Entry "get-symbol" accessor () () #f #f 96 22 96 30 ()}
        {Lisp-Entry "field-locator" method (override) () #f #f 99 20 99 33 ("symbol")}
        {Lisp-Entry "field-ref" method (override) () #f #f 103 20 103 29 ("global-ref" "symbol" "global-bound?" "and")}
        {Lisp-Entry "field-set!" method (override) ("value") #f #f 108 20 108 30 ("global-set!" "symbol" "global-bound?" "when" "value")}}
      {Lisp-Entry "Runtime-Reference" class () ((extends . "Object")) #f #f 118 7 118 24 ("Object")
        {Lisp-Entry "resolver" slot () ((getter . "generate")) #f #f 121 8 121 16 ()}
        {Lisp-Entry "get-resolver" accessor () () #f #f 121 29 121 37 ()}
        {Lisp-Entry "serialization" slot () ((getter . "generate")) #f #f 122 8 122 21 ()}
        {Lisp-Entry "get-serialization" accessor () () #f #f 122 29 122 37 ()}}
      {Lisp-Entry "Define" class () ((extends . "Field")) #f #f 130 7 130 13 ("Field")
        {Lisp-Entry "locator" slot () ((getter . "generate")) #f #f 133 8 133 15 ()}
        {Lisp-Entry "get-locator" accessor () () #f #f 133 23 133 31 ()}
        {Lisp-Entry "field-locator" method (override) () #f #f 136 20 136 33 ("locator")}
        {Lisp-Entry "field-ref" method (override) () #f #f 140 20 140 29 ("locator" "global-ref")}
        {Lisp-Entry "field-set!" method (override) ("value") #f #f 144 20 144 30 ("locator" "global-set!" "value")}}
      {Lisp-Entry "Definition" class () ((extends . "Field")) #f #f 153 7 153 17 ("Field")
        {Lisp-Entry "locator" slot () ((getter . "generate")) #f #f 156 8 156 15 ()}
        {Lisp-Entry "get-locator" accessor () () #f #f 156 23 156 31 ()}
        {Lisp-Entry "field-locator" method (override) () #f #f 159 20 159 33 ("locator")}
        {Lisp-Entry "field-ref" method (override) () #f #f 163 20 163 29 ("locator" "global-ref")}
        {Lisp-Entry "field-set!" method (override) ("value") #f #f 167 20 167 30 ("locator" "global-set!" "value")}}
      {Lisp-Entry "Type" class () ((extends . "Object")) #f #f 176 7 176 11 ("Object")}
      {Lisp-Entry "Category" class () ((extends . "Type")) #f #f 184 7 184 15 ("Type")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 187 8 187 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 187 28 187 36 ()}
        {Lisp-Entry "fields" slot () ((getter . "generate")) #f #f 188 8 188 14 ()}
        {Lisp-Entry "get-fields" accessor () () #f #f 188 28 188 36 ()}
        {Lisp-Entry "virtual-size" slot () ((getter . "generate")) #f #f 189 8 189 20 ()}
        {Lisp-Entry "get-virtual-size" accessor () () #f #f 189 28 189 36 ()}
        {Lisp-Entry "ancestors" slot () ((getter . "generate")) #f #f 190 8 190 17 ()}
        {Lisp-Entry "get-ancestors" accessor () () #f #f 190 28 190 36 ()}
        {Lisp-Entry "descendants" slot () ((getter . "generate")) #f #f 191 8 191 19 ()}
        {Lisp-Entry "get-descendants" accessor () () #f #f 191 28 191 36 ()}
        {Lisp-Entry "print" method (override) ("output" "detail") #f #f 194 20 194 25 ("get-name" "system-format" "lambda" "self" "print-unreadable" "detail" "output")}
        {Lisp-Entry "mop-category-field" method (public virtual) ("field-name") #f #f 200 26 200 44 ("self" "category-field" "field-name")}
        {Lisp-Entry "mop-field-value" method (public virtual) ("property") #f #f 204 26 204 41 ("property")}}
      {Lisp-Entry "typed?" definition (public) ("obj" "category-identifier") #f #f 208 20 208 26 ("class-of" "get-ancestors" "get-ancestors~" "get-name" "get-name~" "eq?" "category" "lambda" "some?" "category-identifier" "obj")}
      {Lisp-Entry "Class" class () ((extends . "Category")) #f #f 219 7 219 12 ("Category")
        {Lisp-Entry "ascendant" slot () ((getter . "generate")) #f #f 222 8 222 17 ()}
        {Lisp-Entry "get-ascendant" accessor () () #f #f 222 34 222 42 ()}
        {Lisp-Entry "interfaces" slot () ((getter . "generate")) #f #f 223 8 223 18 ()}
        {Lisp-Entry "get-interfaces" accessor () () #f #f 223 34 223 42 ()}
        {Lisp-Entry "slots" slot () ((getter . "generate")) #f #f 224 8 224 13 ()}
        {Lisp-Entry "get-slots" accessor () () #f #f 224 34 224 42 ()}
        {Lisp-Entry "instance-slots" slot () ((getter . "generate")) #f #f 225 8 225 22 ()}
        {Lisp-Entry "get-instance-slots" accessor () () #f #f 225 34 225 42 ()}
        {Lisp-Entry "instance-size" slot () ((getter . "generate")) #f #f 226 8 226 21 ()}
        {Lisp-Entry "get-instance-size" accessor () () #f #f 226 34 226 42 ()}
        {Lisp-Entry "level" slot () ((getter . "generate")) #f #f 227 8 227 13 ()}
        {Lisp-Entry "get-level" accessor () () #f #f 227 34 227 42 ()}
        {Lisp-Entry "dispatch-table" slot () ((getter . "generate")) #f #f 228 8 228 22 ()}
        {Lisp-Entry "get-dispatch-table" accessor () () #f #f 228 34 228 42 ()}
        {Lisp-Entry "core-method-alist" slot () ((getter . "generate")) #f #f 229 8 229 25 ()}
        {Lisp-Entry "get-core-method-alist" accessor () () #f #f 229 34 229 42 ()}
        {Lisp-Entry "core-virtual-alist" slot () ((getter . "generate")) #f #f 230 8 230 26 ()}
        {Lisp-Entry "get-core-virtual-alist" accessor () () #f #f 230 34 230 42 ()}
        {Lisp-Entry "core-virtual-names" slot () ((getter . "generate")) #f #f 231 8 231 26 ()}
        {Lisp-Entry "get-core-virtual-names" accessor () () #f #f 231 34 231 42 ()}
        {Lisp-Entry "core-vtable" slot () ((getter . "generate")) #f #f 232 8 232 19 ()}
        {Lisp-Entry "get-core-vtable" accessor () () #f #f 232 34 232 42 ()}
        {Lisp-Entry "class-table" slot () ((getter . "generate")) #f #f 233 8 233 19 ()}
        {Lisp-Entry "get-class-table" accessor () () #f #f 233 34 233 42 ()}
        {Lisp-Entry "interface-table" slot () ((getter . "generate")) #f #f 234 8 234 23 ()}
        {Lisp-Entry "get-interface-table" accessor () () #f #f 234 34 234 42 ()}
        {Lisp-Entry "coerce-object" method (public virtual) ("obj") #f #f 237 26 237 39 ("self" "category-name" "error" "obj")}
        {Lisp-Entry "external-name" method (public virtual) ("(error?: error? #t)") #f #f 241 26 241 39 ("self" "category-name" "error" "when" "error?" "error?:")}
        {Lisp-Entry "mop-instance-slots" method (public virtual) ("object") #f #f 246 26 246 44 ("get-instance-slots" "object")}}
      {Lisp-Entry "Object-Class" class () ((metaclass . "Class") (extends . "Class")) #f #f 250 7 250 19 ("Class")}
      {Lisp-Entry "class?" definition (public inline) ("obj") #f #f 253 27 253 33 ("Class" "is?" "obj")}
      {Lisp-Entry "instance-of?" definition (public inline) ("obj" "class") #f #f 257 27 257 39 ("class-of" "eq?" "class" "obj")}
      {Lisp-Entry "coerce" definition (public inline) ("object" "<Object>" "class" "<Class>") #f #f 261 27 261 33 ("coerce-object" "coerce-object~" "is?" "if" "Class" "<Class>" "class" "Object" "<Object>" "object")}
      {Lisp-Entry "Interface" class () ((extends . "Category")) #f #f 272 7 272 16 ("Category")
        {Lisp-Entry "ascendants" slot () ((getter . "generate")) #f #f 275 8 275 18 ()}
        {Lisp-Entry "get-ascendants" accessor () () #f #f 275 26 275 34 ()}
        {Lisp-Entry "rank" slot () ((getter . "generate")) #f #f 276 8 276 12 ()}
        {Lisp-Entry "get-rank" accessor () () #f #f 276 26 276 34 ()}}
      {Lisp-Entry "Method" class () ((extends . "Field")) #f #f 284 7 284 13 ("Field")
        {Lisp-Entry "dispatch-type" slot () ((getter . "generate")) #f #f 287 8 287 21 ()}
        {Lisp-Entry "get-dispatch-type" accessor () () #f #f 287 35 287 43 ()}
        {Lisp-Entry "implementation" slot () ((getter . "generate")) #f #f 288 8 288 22 ()}
        {Lisp-Entry "get-implementation" accessor () () #f #f 288 35 288 43 ()}
        {Lisp-Entry "implementation-tree" slot () ((getter . "generate")) #f #f 289 8 289 27 ()}
        {Lisp-Entry "get-implementation-tree" accessor () () #f #f 289 35 289 43 ()}
        {Lisp-Entry "category-rank" slot () ((getter . "generate")) #f #f 290 8 290 21 ()}
        {Lisp-Entry "get-category-rank" accessor () () #f #f 290 35 290 43 ()}
        {Lisp-Entry "implementation-rank" slot () ((getter . "generate")) #f #f 291 8 291 27 ()}
        {Lisp-Entry "get-implementation-rank" accessor () () #f #f 291 35 291 43 ()}}
      {Lisp-Entry "object-method" definition (public) ("object" "name") #f #f 295 20 295 33 ("apply" "rest" "lambda" "class-of" "category-field" "get-implementation" "get-implementation~" "impl" "let" "name" "object")}
      {Lisp-Entry "Method-Node" class () ((extends . "Object")) #f #f 306 7 306 18 ("Object")
        {Lisp-Entry "category" slot () ((getter . "generate")) #f #f 309 8 309 16 ()}
        {Lisp-Entry "get-category" accessor () () #f #f 309 35 309 43 ()}
        {Lisp-Entry "implementation" slot () ((getter . "generate")) #f #f 310 8 310 22 ()}
        {Lisp-Entry "get-implementation" accessor () () #f #f 310 35 310 43 ()}
        {Lisp-Entry "next-node" slot () ((getter . "generate")) #f #f 311 8 311 17 ()}
        {Lisp-Entry "get-next-node" accessor () () #f #f 311 35 311 43 ()}
        {Lisp-Entry "next-implementation" slot () ((getter . "generate")) #f #f 312 8 312 27 ()}
        {Lisp-Entry "get-next-implementation" accessor () () #f #f 312 35 312 43 ()}
        {Lisp-Entry "children" slot () ((getter . "generate")) #f #f 313 8 313 16 ()}
        {Lisp-Entry "get-children" accessor () () #f #f 313 35 313 43 ()}}
      {Lisp-Entry "Queue" class () ((extends . "Object")) #f #f 321 7 321 12 ("Object")
        {Lisp-Entry "head" slot () ((getter . "generate")) #f #f 324 8 324 12 ()}
        {Lisp-Entry "get-head" accessor () () #f #f 324 23 324 31 ()}
        {Lisp-Entry "tail" slot () ((getter . "generate")) #f #f 325 8 325 12 ()}
        {Lisp-Entry "get-tail" accessor () () #f #f 325 23 325 31 ()}
        {Lisp-Entry "shared?" slot () ((getter . "generate")) #f #f 326 8 326 15 ()}
        {Lisp-Entry "get-shared?" accessor () () #f #f 326 23 326 31 ()}}
      {Lisp-Entry "Generic" class () ((extends . "Object")) #f #f 334 7 334 14 ("Object")
        {Lisp-Entry "locator" slot () ((getter . "generate")) #f #f 337 8 337 15 ()}
        {Lisp-Entry "get-locator" accessor () () #f #f 337 36 337 44 ()}
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 338 8 338 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 338 36 338 44 ()}
        {Lisp-Entry "root-specific" slot () ((getter . "generate")) #f #f 339 8 339 21 ()}
        {Lisp-Entry "get-root-specific" accessor () () #f #f 339 36 339 44 ()}
        {Lisp-Entry "pending-specifics" slot () ((getter . "generate")) #f #f 340 8 340 25 ()}
        {Lisp-Entry "get-pending-specifics" accessor () () #f #f 340 36 340 44 ()}}
      {Lisp-Entry "Specific" class () ((extends . "Object")) #f #f 343 7 343 15 ("Object")
        {Lisp-Entry "dynamic-signature" slot () ((getter . "generate")) #f #f 346 8 346 25 ()}
        {Lisp-Entry "get-dynamic-signature" accessor () () #f #f 346 36 346 44 ()}
        {Lisp-Entry "implementation" slot () ((getter . "generate")) #f #f 347 8 347 22 ()}
        {Lisp-Entry "get-implementation" accessor () () #f #f 347 36 347 44 ()}
        {Lisp-Entry "ancestor-specifics" slot () ((getter . "generate")) #f #f 348 8 348 26 ()}
        {Lisp-Entry "get-ancestor-specifics" accessor () () #f #f 348 36 348 44 ()}
        {Lisp-Entry "descendant-specifics" slot () ((getter . "generate")) #f #f 349 8 349 28 ()}
        {Lisp-Entry "get-descendant-specifics" accessor () () #f #f 349 36 349 44 ()}}
      {Lisp-Entry "Boolean-Class" class () ((extends . "Class")) #f #f 357 7 357 20 ("Class")}
      {Lisp-Entry "Boolean" class (primitive) ((metaclass . "Boolean-Class") (extends . "Object")) #f #f 360 17 360 24 ("Object" "Boolean-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 363 20 363 30 ("native-class" "rest")}}
      {Lisp-Entry "/=" definition (public inline) ("x" "y") #f #f 367 27 367 29 ("=" "not" "y" "x")}
      {Lisp-Entry "neq?" definition (public inline) ("x" "y") #f #f 371 27 371 31 ("eq?" "not" "y" "x")}
      {Lisp-Entry "xor" definition (public inline) ("x" "y") #f #f 375 27 375 30 ("not" "and" "or" "y" "x")}
      {Lisp-Entry "nu=?" definition (public) ("n" "m" "." "rest") #f #f 380 20 380 24 ("cdr" "else" "car" "neq?" "null?" "cond" "scan" "iter" "first" "let" ":equal" "compare" "eq?" "and" "rest" "m" "n")}
      {Lisp-Entry "nu/=?" definition (public) ("n" "m" "." "rest") #f #f 392 20 392 25 ("nu=?" "apply" "not" ":equal" "compare" "neq?" "null?" "if" "rest" "m" "n")}
      {Lisp-Entry "nu<?" definition (public) ("n" "m" "." "rest") #f #f 398 20 398 24 ("cdr" "car" "value" "null?" "if" "max" "scan" "iter" "let" "error" "else" ":equal" ":greater" ":less" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu<=?" definition (public) ("n" "m" "." "rest") #f #f 413 20 413 25 ("cdr" "car" "value" "null?" "if" "max" "scan" "iter" "let" "error" "else" ":greater" ":equal" ":less" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu>?" definition (public) ("n" "m" "." "rest") #f #f 428 20 428 24 ("cdr" "car" "value" "null?" "if" "min" "scan" "iter" "let" "error" "else" ":equal" ":less" ":greater" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu>=?" definition (public) ("n" "m" "." "rest") #f #f 443 20 443 25 ("cdr" "car" "value" "null?" "if" "min" "scan" "iter" "let" "error" "else" ":less" ":equal" ":greater" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "ci=?" definition (public) ("." "rest") #f #f 458 20 458 24 ("finally" "return" ":equal" "ci-compare" "neq?" "when" "cdr" "in" "object" "for" "loop" "car" "first" "let" "null?" "if" "rest")}
      {Lisp-Entry "ci/=?" definition (public) ("." "rest") #f #f 468 20 468 25 ("ci=?" "apply" "not" "rest")}
      {Lisp-Entry "ci<?" definition (public) ("n" "." "rest") #f #f 472 20 472 24 ("error" "else" ":equal" ":greater" "cdr" ":less" "ci-compare" "case" "car" "value" "null?" "if" "max" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci<=?" definition (public) ("n" "." "rest") #f #f 483 20 483 25 ("error" "else" ":greater" "cdr" ":equal" ":less" "ci-compare" "case" "car" "value" "null?" "if" "max" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci>?" definition (public) ("n" "." "rest") #f #f 494 20 494 24 ("error" "else" ":equal" ":less" "cdr" ":greater" "ci-compare" "case" "car" "value" "null?" "if" "min" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci>=?" definition (public) ("n" "." "rest") #f #f 505 20 505 25 ("error" "else" ":less" "cdr" ":equal" ":greater" "ci-compare" "case" "car" "value" "null?" "if" "min" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "di=?" definition (public) ("x" "y") #f #f 516 20 516 24 (":equal" "di-compare" "eq?" "y" "x")}
      {Lisp-Entry "di<?" definition (public) ("x" "y") #f #f 519 20 519 24 (":less" "di-compare" "eq?" "y" "x")}
      {Lisp-Entry "di<=?" definition (public) ("x" "y") #f #f 522 20 522 25 (":equal" ":less" "di-compare" "memq?" "y" "x")}
      {Lisp-Entry "di>?" definition (public) ("x" "y") #f #f 525 20 525 24 (":greater" "di-compare" "eq?" "y" "x")}
      {Lisp-Entry "di>=?" definition (public) ("x" "y") #f #f 528 20 528 25 (":equal" ":greater" "di-compare" "memq?" "y" "x")}
      {Lisp-Entry "di-sort-ascending" definition (public) ("seq" "(key: key #f)") #f #f 532 20 532 37 ("nu<?" "di=?" "and" "di<?" "or" "y" "x" "lambda" "sort" "key" "key:" "seq")}
      {Lisp-Entry "di-sort-descending" definition (public) ("seq" "(key: key #f)") #f #f 541 20 541 38 ("nu>?" "di=?" "and" "di>?" "or" "y" "x" "lambda" "sort" "key" "key:" "seq")}
      {Lisp-Entry "boolean->integer" definition (public inline) ("bool") #f #f 550 27 550 43 ("0" "1" "if" "bool")}
      {Lisp-Entry "integer->boolean" definition (public inline) ("n" "<int>") #f #f 554 27 554 43 ("0" "/=" "int" "<int>" "n")}
      {Lisp-Entry "false" definition (public) () #f #f 563 19 563 24 ("false" "list")}
      {Lisp-Entry "false?" definition (public inline) ("obj") #f #f 567 27 567 33 ("false" "eq?" "obj")}
      {Lisp-Entry "true" definition (public) () #f #f 571 19 571 23 ("true" "list")}
      {Lisp-Entry "true?" definition (public inline) ("obj") #f #f 575 27 575 32 ("true" "eq?" "obj")}
      {Lisp-Entry "truth?" definition (public) ("obj") #f #f 579 20 579 26 ("true?" "false?" "or" "obj")}
      {Lisp-Entry "boolean->truth" definition (public) ("bool") #f #f 584 20 584 34 ("false" "true" "if" "bool")}
      {Lisp-Entry "truth->boolean" definition (public) ("data") #f #f 588 20 588 34 ("true?" "data")}
      {Lisp-Entry "Whitespace-Chars" definition (public) () #f #f 597 19 597 35 ()}
      {Lisp-Entry "Uppercase-Chars" definition (public) () #f #f 600 19 600 34 ()}
      {Lisp-Entry "Lowercase-Chars" definition (public) () #f #f 603 19 603 34 ()}
      {Lisp-Entry "Alphabetic-Chars" definition (public) () #f #f 606 19 606 35 ("Lowercase-Chars" "Uppercase-Chars" "append")}
      {Lisp-Entry "Numeric-Chars" definition (public) () #f #f 609 19 609 32 ()}
      {Lisp-Entry "Uppercase-Lowerbound" definition () () #f "<fx>" 613 12 613 32 ("char->integer" "fx" "<fx>")}
      {Lisp-Entry "Uppercase-Upperbound" definition () () #f "<fx>" 616 12 616 32 ("char->integer" "fx" "<fx>")}
      {Lisp-Entry "Lowercase-Lowerbound" definition () () #f "<fx>" 619 12 619 32 ("char->integer" "fx" "<fx>")}
      {Lisp-Entry "Lowercase-Upperbound" definition () () #f "<fx>" 622 12 622 32 ("char->integer" "fx" "<fx>")}
      {Lisp-Entry "Numeric-Lowerbound" definition () () #f "<fx>" 625 12 625 30 ("char->integer" "fx" "<fx>")}
      {Lisp-Entry "Numeric-Upperbound" definition () () #f "<fx>" 628 12 628 30 ("char->integer" "fx" "<fx>")}
      {Lisp-Entry "Diacritic-Equivalences" definition () () #f #f 634 12 634 34 ()}
      {Lisp-Entry "make-diacritic-table" definition () ("equivalences") #f #f 643 13 643 33 ("table-set!" "char" "car" "equivalent" "lambda" "for-each" "eqv?" "test:" "make-table" "table" "let" "equivalences")}
      {Lisp-Entry "Diacritic-Table" definition () () #f #f 653 12 653 27 ("Diacritic-Equivalences" "make-diacritic-table")}
      {Lisp-Entry "diacritic-equivalent" definition (public) ("c") #f #f 657 20 657 40 ("Diacritic-Table" "table-ref" "or" "c")}
      {Lisp-Entry "Char-Class" class () ((extends . "Class")) #f #f 662 7 662 17 ("Class")}
      {Lisp-Entry "Char" class (primitive) ((metaclass . "Char-Class") (extends . "Object")) #f #f 665 17 665 21 ("Object" "Char-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 668 20 668 30 ("native-class" "rest")}
        {Lisp-Entry "coerce-string" method (override) () #f #f 672 20 672 33 ("get-output-string" "self" "write-char" "open-output-string" "port" "let")}
        {Lisp-Entry "compare-object" method (override) ("c") #f #f 678 20 678 34 (":incompatible" ":less" "else" ":greater" ">" ":equal" "=" "cond" "v2" "self" "char->integer" "v1" "let" "Char" "is?" "if" "c")}
        {Lisp-Entry "ci-compare-object" method (override) ("c") #f #f 688 20 688 37 ("self" "downcase" "compare" "c")}
        {Lisp-Entry "di-compare-object" method (override) ("c") #f #f 693 20 693 37 ("self" "diacritic-equivalent" "ci-compare" "c")}
        {Lisp-Entry "object-similar?" method (override) ("object") #f #f 698 20 698 35 ("self" "char-similar?" "char?" "and" "object-similar?" "unimplemented" "object")}
        {Lisp-Entry "object-alphabetic?" method (override) () #f #f 705 20 705 38 ("object-lower-case?" "object-upper-case?" "or")}
        {Lisp-Entry "object-numeric?" method (override) () #f #f 710 20 710 35 ("Numeric-Upperbound" "<=" "Numeric-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-alphanumeric?" method (override) () #f #f 716 20 716 40 ("object-numeric?" "object-alphabetic?" "or")}
        {Lisp-Entry "object-whitespace?" method (override) () #f #f 721 20 721 38 ("self" "eqv?" "or")}
        {Lisp-Entry "object-upper-case?" method (override) () #f #f 729 20 729 38 ("Uppercase-Upperbound" "<=" "Uppercase-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-lower-case?" method (override) () #f #f 735 20 735 38 ("Lowercase-Upperbound" "<=" "Lowercase-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-upcase" method (override) () #f #f 741 20 741 33 ("32" "char->integer" "-" "integer->char" "self" "lower-case?" "if")}
        {Lisp-Entry "object-downcase" method (override) () #f #f 747 20 747 35 ("32" "char->integer" "+" "integer->char" "self" "upper-case?" "if")}
        {Lisp-Entry "object-capitalize" method (override) () #f #f 753 20 753 37 ("object-upcase")}}
      {Lisp-Entry "whitechar?" definition () () #f #f 757 12 757 22 ("char-whitespace?")}
      {Lisp-Entry "char-presentation" definition (public) ("char") #f #f 761 20 761 37 ("string" "char-symbol" "or" "char")}
      {Lisp-Entry "alphabetic?" definition (public inline) ("object" "<Object>") #f #f 766 27 766 38 ("object-alphabetic?" "object-alphabetic?~" "Object" "<Object>" "object")}
      {Lisp-Entry "numeric?" definition (public inline) ("object" "<Object>") #f #f 770 27 770 35 ("object-numeric?" "object-numeric?~" "Object" "<Object>" "object")}
      {Lisp-Entry "alphanumeric?" definition (public inline) ("object" "<Object>") #f #f 774 27 774 40 ("object-alphanumeric?" "object-alphanumeric?~" "Object" "<Object>" "object")}
      {Lisp-Entry "whitespace?" definition (public inline) ("object" "<Object>") #f #f 778 27 778 38 ("object-whitespace?" "object-whitespace?~" "Object" "<Object>" "object")}
      {Lisp-Entry "upper-case?" definition (public inline) ("object" "<Object>") #f #f 782 27 782 38 ("object-upper-case?" "object-upper-case?~" "Object" "<Object>" "object")}
      {Lisp-Entry "lower-case?" definition (public inline) ("object" "<Object>") #f #f 786 27 786 38 ("object-lower-case?" "object-lower-case?~" "Object" "<Object>" "object")}
      {Lisp-Entry "upcase" definition (public inline) ("object" "<Object>") #f #f 790 27 790 33 ("object-upcase" "object-upcase~" "Object" "<Object>" "object")}
      {Lisp-Entry "downcase" definition (public inline) ("object" "<Object>") #f #f 794 27 794 35 ("object-downcase" "object-downcase~" "Object" "<Object>" "object")}
      {Lisp-Entry "capitalize" definition (public inline) ("object" "<Object>") #f #f 798 27 798 37 ("object-capitalize" "object-capitalize~" "Object" "<Object>" "object")}
      {Lisp-Entry "vowel?" definition (public) ("c") #f #f 802 20 802 26 ("downcase" "memv?" "c")}
      {Lisp-Entry "character-types" definition () () #f #f 806 12 806 27 ("delete" "symbol" "literal" "quasiquote" "backslash" "reference" "exprcomment" "comment" "unquote" "terminator" "list" "quote" "sharp" "string" "constituent" "whitespace" "backspace" "invalid" "#")}
      {Lisp-Entry "character-type" definition (public) ("ascii-c" "<char>") #f "<symbol>" 825 20 825 34 ("character-types" "vector-ref" "constituent" "127" ">" "if" "char->integer" "num" "let" "symbol" "<symbol>" "char" "<char>" "ascii-c")}
      {Lisp-Entry "invalid-character?" definition (public) ("c" "<char>") #f "<bool>" 832 20 832 38 ("invalid" "character-type" "eq?" "bool" "<bool>" "char" "<char>" "c")}
      {Lisp-Entry "word-constituent?" definition (public) ("c" "<char>") #f "<bool>" 836 20 836 37 ("memq?" "alphanumeric?" "or" "bool" "<bool>" "char" "<char>" "c")}
      {Lisp-Entry "scheme-constituent?" definition (public) ("c" "<char>") #f "<bool>" 841 20 841 39 ("eqv?" "constituent" "character-type" "eq?" "alphanumeric?" "or" "bool" "<bool>" "char" "<char>" "c")}
      {Lisp-Entry "jazz-constituent?" definition (public) ("c" "<char>") #f "<bool>" 848 20 848 37 ("eqv?" "constituent" "character-type" "eq?" "alphanumeric?" "or" "bool" "<bool>" "char" "<char>" "c")}
      {Lisp-Entry "c-constituent?" definition (public) ("c" "<char>") #f "<bool>" 854 20 854 34 ("eqv?" "alphanumeric?" "or" "bool" "<bool>" "char" "<char>" "c")}
      {Lisp-Entry "sql-constituent?" definition (public) ("c" "<char>") #f "<bool>" 859 20 859 36 ("eqv?" "alphanumeric?" "or" "bool" "<bool>" "char" "<char>" "c")}
      {Lisp-Entry "Port-Class" class () ((extends . "Class")) #f #f 872 7 872 17 ("Class")}
      {Lisp-Entry "Port" class (primitive) ((metaclass . "Port-Class") (extends . "Object")) #f #f 875 17 875 21 ("Object" "Port-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 878 20 878 30 ("native-class" "rest")}
        {Lisp-Entry "destroy" method (override) () #f #f 882 20 882 27 ("nextmethod" "self" "close-port")}}
      {Lisp-Entry "Symbol-Class" class () ((extends . "Class")) #f #f 892 7 892 19 ("Class")}
      {Lisp-Entry "Symbol" class (primitive) ((metaclass . "Symbol-Class") (extends . "Object")) #f #f 895 17 895 23 ("Object" "Symbol-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 898 20 898 30 ("native-class" "rest")}
        {Lisp-Entry "coerce-string" method (override) () #f #f 902 20 902 33 ("self" "symbol->string")}
        {Lisp-Entry "compare-object" method (override) ("obj") #f #f 906 20 906 34 (":incompatible" "self" "symbol->string" "compare" "symbol?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" method (override) ("obj") #f #f 912 20 912 37 (":incompatible" "self" "symbol->string" "ci-compare" "symbol?" "if" "obj")}}
      {Lisp-Entry "=" specialize (inline) ("s1" "<symbol>" "s2" "<symbol>") #f #f 918 20 918 21 ("eq?" "bool" "<bool>" "s2" "symbol" "<symbol>" "s1")}
      {Lisp-Entry "generated-symbol?" definition (public) ("symbol") #f #f 922 20 922 37 ("symbol->string" "starts-with?" "symbol")}
      {Lisp-Entry "symbol->keyword" definition (public inline) ("symbol") #f #f 926 27 926 42 ("symbol->string" "string->keyword" "symbol")}
      {Lisp-Entry "keyword->symbol" definition (public inline) ("keyword") #f #f 930 27 930 42 ("keyword->string" "string->symbol" "keyword")}
      {Lisp-Entry "find-symbol" definition (public) ("str") #f #f 934 20 934 31 ("string->symbol" "str")}
      {Lisp-Entry "symbol-bound?" definition (public) ("name" "." "rest") #f #f 939 20 939 33 ("rest" "name")}
      {Lisp-Entry "symbol-unbound?" definition (public) ("name" "." "rest") #f #f 942 20 942 35 ("rest" "name")}
      {Lisp-Entry "Keyword-Class" class () ((extends . "Class")) #f #f 952 7 952 20 ("Class")}
      {Lisp-Entry "Keyword" class (primitive) ((metaclass . "Keyword-Class") (extends . "Object")) #f #f 955 17 955 24 ("Object" "Keyword-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 958 20 958 30 ("native-class" "rest")}}
      {Lisp-Entry "find-keyword" definition (public) ("keyword" "box" "default") #f #f 962 20 962 32 ("else" "cadr" "cddr" "set-cdr!" "eq?" "error" "car" "keyword?" "cdr" "pair?" "not" "or" "null?" "cond" "before" "unbox-list" "ls" "lp" "let" "default" "box" "keyword")}
      {Lisp-Entry "box-list" definition (package) ("lst") #f #f 981 21 981 29 ("cons" "lst")}
      {Lisp-Entry "unbox-list" definition (package) ("box") #f #f 985 21 985 31 ("cdr" "box")}
      {Lisp-Entry "Continuation-Class" class () ((extends . "Class")) #f #f 994 7 994 25 ("Class")}
      {Lisp-Entry "Continuation" class (primitive) ((metaclass . "Continuation-Class") (extends . "Object")) #f #f 997 17 997 29 ("Object" "Continuation-Class")}
      {Lisp-Entry "Procedure-Class" class () ((extends . "Class")) #f #f 1005 7 1005 22 ("Class")}
      {Lisp-Entry "Procedure" class (primitive) ((metaclass . "Procedure-Class") (extends . "Object")) #f #f 1008 17 1008 26 ("Object" "Procedure-Class")}
      {Lisp-Entry "Foreign-Class" class () ((extends . "Class")) #f #f 1016 7 1016 20 ("Class")}
      {Lisp-Entry "Foreign" class (primitive) ((metaclass . "Foreign-Class") (extends . "Object")) #f #f 1019 17 1019 24 ("Object" "Foreign-Class")}
      {Lisp-Entry "Numeric-Class" class () ((extends . "Class")) #f #f 1027 7 1027 20 ("Class")}
      {Lisp-Entry "Numeric" class (primitive) ((metaclass . "Numeric-Class") (extends . "Object")) #f #f 1030 17 1030 24 ("Object" "Numeric-Class")
        {Lisp-Entry "numeric-norm" method (public virtual abstract) () #f #f 1033 35 1033 47 ()}
        {Lisp-Entry "numeric-add" method (public virtual abstract) ("obj") #f #f 1034 35 1034 46 ("obj")}
        {Lisp-Entry "numeric-negate" method (public virtual abstract) () #f #f 1035 35 1035 49 ()}
        {Lisp-Entry "numeric-multiply" method (public virtual abstract) ("n") #f #f 1036 35 1036 51 ("n")}
        {Lisp-Entry "numeric-inverse" method (public virtual abstract) () #f #f 1037 35 1037 50 ()}}
      {Lisp-Entry "Number-Class" class () ((extends . "Numeric-Class")) #f #f 1045 7 1045 19 ("Numeric-Class")}
      {Lisp-Entry "Number" class (primitive) ((metaclass . "Number-Class") (extends . "Numeric")) #f #f 1048 17 1048 23 ("Numeric" "Number-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 1051 20 1051 30 ("native-class" "rest")}
        {Lisp-Entry "compare-object" method (override) ("obj") #f #f 1055 20 1055 34 (":incompatible" ":greater" "else" ":less" "<" ":equal" "self" "=" "cond" "number?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" method (override) ("obj") #f #f 1063 20 1063 37 ("compare-object" "obj")}
        {Lisp-Entry "di-compare-object" method (override) ("obj") #f #f 1067 20 1067 37 ("compare-object" "obj")}
        {Lisp-Entry "numeric-norm" method (override) () #f #f 1071 20 1071 32 ("self" "abs")}
        {Lisp-Entry "numeric-add" method (override) ("obj") #f #f 1075 20 1075 31 ("error" "self" "+" "number?" "if" "obj")}
        {Lisp-Entry "numeric-negate" method (override) () #f #f 1081 20 1081 34 ("self" "-")}
        {Lisp-Entry "numeric-multiply" method (override) ("obj") #f #f 1085 20 1085 36 ("error" "self" "*" "number?" "if" "obj")}
        {Lisp-Entry "numeric-inverse" method (override) () #f #f 1091 20 1091 35 ("self" "/")}}
      {Lisp-Entry "Complex-Class" class () ((extends . "Number-Class")) #f #f 1100 7 1100 20 ("Number-Class")}
      {Lisp-Entry "Complex" class (primitive) ((metaclass . "Complex-Class") (extends . "Number")) #f #f 1103 17 1103 24 ("Number" "Complex-Class")
        {Lisp-Entry "numeric-norm" method (override) () #f #f 1106 20 1106 32 ("imag-part" "2" "self" "real-part" "expt" "+" "sqrt")}}
      {Lisp-Entry "Real-Class" class () ((extends . "Complex-Class")) #f #f 1115 7 1115 17 ("Complex-Class")}
      {Lisp-Entry "Real" class (primitive) ((metaclass . "Real-Class") (extends . "Complex")) #f #f 1118 17 1118 21 ("Complex" "Real-Class")}
      {Lisp-Entry "Rational-Class" class () ((extends . "Real-Class")) #f #f 1126 7 1126 21 ("Real-Class")}
      {Lisp-Entry "Rational" class (primitive) ((metaclass . "Rational-Class") (extends . "Real")) #f #f 1129 17 1129 25 ("Real" "Rational-Class")}
      {Lisp-Entry "Integer-Class" class () ((extends . "Rational-Class")) #f #f 1137 7 1137 20 ("Rational-Class")}
      {Lisp-Entry "Integer" class (primitive) ((metaclass . "Integer-Class") (extends . "Rational")) #f #f 1140 17 1140 24 ("Rational" "Integer-Class")}
      {Lisp-Entry "Fixnum-Class" class () ((extends . "Integer-Class")) #f #f 1148 7 1148 19 ("Integer-Class")}
      {Lisp-Entry "Fixnum" class (primitive) ((metaclass . "Fixnum-Class") (extends . "Integer")) #f #f 1151 17 1151 23 ("Integer" "Fixnum-Class")}
      {Lisp-Entry "Flonum-Class" class () ((extends . "Real-Class")) #f #f 1159 7 1159 19 ("Real-Class")}
      {Lisp-Entry "Flonum" class (primitive) ((metaclass . "Flonum-Class") (extends . "Real")) #f #f 1162 17 1162 23 ("Real" "Flonum-Class")}
      {Lisp-Entry "fl+" definition (public inline) ("x" "<fl>" "y" "<fl>") #f "<fl>" 1167 27 1167 30 ("sharp/sharp/fl+" "y" "fl" "<fl>" "x")}
      {Lisp-Entry "fl-" definition (public inline) ("x" "<fl>" "y" "<fl>") #f "<fl>" 1170 27 1170 30 ("sharp/sharp/fl-" "y" "fl" "<fl>" "x")}
      {Lisp-Entry "fl*" definition (public inline) ("x" "<fl>" "y" "<fl>") #f "<fl>" 1173 27 1173 30 ("sharp/sharp/fl*" "y" "fl" "<fl>" "x")}
      {Lisp-Entry "fl/" definition (public inline) ("x" "<fl>" "y" "<fl>") #f "<fl>" 1176 27 1176 30 ("sharp/sharp/fl/" "y" "fl" "<fl>" "x")}
      {Lisp-Entry "flmodulo" definition (public) ("x" "<fl>" "y" "<fl>") #f #f 1180 20 1180 28 ("/" "floor" "*" "-" "y" "fl" "<fl>" "x")}
      {Lisp-Entry "relate" definition (public) ("x" "y") #f #f 1189 20 1189 26 ("0" "else" "1" ">" "-1" "<" "cond" "y" "x")}
      {Lisp-Entry "sign" definition (public) ("n") #f #f 1195 20 1195 24 ("0" "relate" "n")}
      {Lisp-Entry "nu+" definition (public) ("." "rest") #f #f 1199 20 1199 23 ("numeric-add" "numeric-add~" "cdr" "scan" "car" "Numeric" "<Numeric>" "result" "iter" "let" "0" "null?" "if" "rest")}
      {Lisp-Entry "nu-" definition (public) ("n" "<Numeric>" "." "rest") #f #f 1208 20 1208 23 ("nu+" "apply" "r" "let" "numeric-negate" "numeric-negate~" "null?" "if" "rest" "Numeric" "<Numeric>" "n")}
      {Lisp-Entry "nu*" definition (public) ("." "rest") #f #f 1215 20 1215 23 ("numeric-multiply" "numeric-multiply~" "cdr" "scan" "car" "Numeric" "<Numeric>" "result" "iter" "let" "1" "null?" "if" "rest")}
      {Lisp-Entry "nu/" definition (public) ("n" "<Numeric>" "." "rest") #f #f 1224 20 1224 23 ("nu*" "apply" "r" "let" "numeric-inverse" "numeric-inverse~" "null?" "if" "rest" "Numeric" "<Numeric>" "n")}
      {Lisp-Entry "minimum" definition (public) ("lst" "<pair>" "(key: key #f)" "(compare: compare compare)") #f #f 1231 20 1231 27 ("cdr" "set!" ":less" "apply-key" "eq?" "when" "object" "lambda" "for-each" "car" "min" "let" "compare" "compare:" "key" "key:" "pair" "<pair>" "lst")}
      {Lisp-Entry "maximum" definition (public) ("lst" "<pair>" "(key: key #f)" "(compare: compare compare)") #f #f 1240 20 1240 27 ("cdr" "set!" ":greater" "apply-key" "eq?" "when" "object" "lambda" "for-each" "car" "max" "let" "compare" "compare:" "key" "key:" "pair" "<pair>" "lst")}
      {Lisp-Entry "between?" definition (public) ("n" "lower" "upper") #f #f 1249 20 1249 28 ("<=" ">=" "not" "or" "and" "upper" "lower" "n")}
      {Lisp-Entry "between" definition (public) ("lower" "n" "upper") #f #f 1254 20 1254 27 ("else" ">" "<" "cond" "upper" "n" "lower")}
      {Lisp-Entry "in-interval?" definition (public) ("n" "lower" "upper") #f #f 1260 20 1260 32 ("<" ">=" "and" "upper" "lower" "n")}
      {Lisp-Entry "norm" definition (public inline) ("x" "<Numeric>") #f #f 1264 27 1264 31 ("numeric-norm" "numeric-norm~" "Numeric" "<Numeric>" "x")}
      {Lisp-Entry "distance" definition (public) ("start" "<Numeric>" "end" "<Numeric>") #f #f 1268 20 1268 28 ("nu-" "norm" "end" "Numeric" "<Numeric>" "start")}
      {Lisp-Entry "near?" definition (public) ("x" "y" "distance") #f "<bool>" 1272 20 1272 25 ("nu-" "norm" "<=" "bool" "<bool>" "distance" "y" "x")}
      {Lisp-Entry "contiguous-range" definition (public) ("lst") #f #f 1276 20 1276 36 ("cons" "cdr" "continuation-return" "set!" "1" "+" "=" "if" "n" "for-each" "second" "car" "first" "let*" "return" "lambda" "continuation-capture" "not-null?" "when" "lst")}
      {Lisp-Entry "naturals" definition (public) ("lower" "<int>" "upper" "<int>") #f "<list>" 1290 20 1290 28 ("collect" "below" "from" "n" "for" "loop" "list" "<list>" "upper" "int" "<int>" "lower")}
      {Lisp-Entry "lobyte" definition (public) ("word" "<int>") #f "<int>" 1295 20 1295 26 ("#xFF" "bitwise-and" "int" "<int>" "word")}
      {Lisp-Entry "hibyte" definition (public) ("word" "<int>") #f "<int>" 1299 20 1299 26 ("-8" "arithmetic-shift" "lobyte" "int" "<int>" "word")}
      {Lisp-Entry "make-word" definition (public) ("lo" "<int>" "hi" "<int>") #f "<int>" 1303 20 1303 29 ("8" "arithmetic-shift" "bitwise-ior" "hi" "int" "<int>" "lo")}
      {Lisp-Entry "lochar" definition (public) ("word" "<int>") #f "<int>" 1307 20 1307 26 ("#xFF" "#x80" "+" "bitwise-and" "-" "int" "<int>" "word")}
      {Lisp-Entry "hichar" definition (public) ("word" "<int>") #f "<int>" 1311 20 1311 26 ("-8" "arithmetic-shift" "lochar" "int" "<int>" "word")}
      {Lisp-Entry "make-int" definition (public) ("lo" "<int>" "hi" "<int>") #f "<int>" 1315 20 1315 28 ("16" "arithmetic-shift" "bitwise-ior" "hi" "int" "<int>" "lo")}
      {Lisp-Entry "loword" definition (public) ("dword" "<int>") #f "<int>" 1319 20 1319 26 ("#xFFFF" "bitwise-and" "int" "<int>" "dword")}
      {Lisp-Entry "hiword" definition (public) ("dword" "<int>") #f "<int>" 1323 20 1323 26 ("-16" "arithmetic-shift" "loword" "int" "<int>" "dword")}
      {Lisp-Entry "signed-loword" definition (public) ("dword" "<int>") #f "<int>" 1327 20 1327 33 ("#xFFFF" "#x8000" "+" "bitwise-and" "-" "int" "<int>" "dword")}
      {Lisp-Entry "signed-hiword" definition (public) ("dword" "<int>") #f "<int>" 1331 20 1331 33 ("-16" "arithmetic-shift" "signed-loword" "int" "<int>" "dword")}
      {Lisp-Entry "sign-word" definition (public) ("word" "<int>") #f "<int>" 1335 20 1335 29 ("#x10000" "-" "15" "bit-set?" "if" "int" "<int>" "word")}
      {Lisp-Entry "separate" definition (public) ("int1" "<int>" "int2" "<int>") #f #f 1341 20 1341 28 ("values" "*" "-" "r" "quotient" "q" "let*" "int2" "int" "<int>" "int1")}
      {Lisp-Entry "randomize" definition (public) () #f #f 1347 20 1347 29 ("default-random-source" "random-source-randomize!")}
      {Lisp-Entry "random" definition (public) ("n") #f #f 1350 20 1350 26 ("random-integer" "n")}
      {Lisp-Entry "bit-set" definition (public) ("num" "<int>" "pos" "<int>" "bit" "<bool>") #f "<int>" 1354 20 1354 27 ("bitwise-not" "bitwise-and" "bitwise-ior" "if" "1" "arithmetic-shift" "msk" "let" "bool" "<bool>" "bit" "pos" "int" "<int>" "num")}
      {Lisp-Entry "mask-bit-set" definition (public) ("num" "<int>" "msk" "<int>" "bit" "<bool>") #f "<int>" 1361 20 1361 32 ("bitwise-not" "bitwise-and" "bitwise-ior" "if" "bool" "<bool>" "bit" "msk" "int" "<int>" "num")}
      {Lisp-Entry "mask-bit-set?" definition (public) ("num" "<int>" "msk" "<int>") #f "<bool>" 1367 20 1367 33 ("0" "bitwise-and" "/=" "bool" "<bool>" "msk" "int" "<int>" "num")}
      {Lisp-Entry "bit-mask" definition (public) ("hi" "<int>" "lo" "<int>") #f #f 1371 20 1371 28 ("1" "arithmetic-shift" "-" "lo" "int" "<int>" "hi")}
      {Lisp-Entry "random-seed" definition (public) () #f #f 1375 20 1375 31 ("10000" "random" "randomize")}
      {Lisp-Entry "sqr" definition (public inline) ("num") #f #f 1381 27 1381 30 ("2" "expt" "num")}
      {Lisp-Entry "percentage" definition (public inline) ("part" "<real>" "total" "<real>") #f "<real>" 1385 27 1385 37 ("100" "fl" "<fl>" "cast" "/" "*" "total" "real" "<real>" "part")}
      {Lisp-Entry "percent" definition (public inline) ("percent" "<real>" "n" "<real>") #f "<real>" 1389 27 1389 34 ("100" "*" "fl" "<fl>" "cast" "/" "n" "real" "<real>" "percent")}
      {Lisp-Entry "fxfloor" definition (public inline) ("r" "<fl>") #f "<fx>" 1393 27 1393 34 ("floor" "flonum->fixnum" "fx" "<fx>" "fl" "<fl>" "r")}
      {Lisp-Entry "fxceiling" definition (public inline) ("r" "<fl>") #f "<fx>" 1396 27 1396 36 ("ceiling" "flonum->fixnum" "fx" "<fx>" "fl" "<fl>" "r")}
      {Lisp-Entry "fxtruncate" definition (public inline) ("r" "<fl>") #f "<fx>" 1399 27 1399 37 ("truncate" "flonum->fixnum" "fx" "<fx>" "fl" "<fl>" "r")}
      {Lisp-Entry "fxround" definition (public inline) ("r" "<fl>") #f "<fx>" 1402 27 1402 34 ("round" "flonum->fixnum" "fx" "<fx>" "fl" "<fl>" "r")}
      {Lisp-Entry "fxfloor/" definition (public inline) ("n" "<fx>" "d" "<fx>") #f "<fx>" 1408 27 1408 35 ("fl" "<fl>" "cast" "/" "fxfloor" "d" "fx" "<fx>" "n")}
      {Lisp-Entry "fxceiling/" definition (public inline) ("n" "<fx>" "d" "<fx>") #f "<fx>" 1411 27 1411 37 ("fl" "<fl>" "cast" "/" "fxceiling" "d" "fx" "<fx>" "n")}
      {Lisp-Entry "fxtruncate/" definition (public inline) ("n" "<fx>" "d" "<fx>") #f "<fx>" 1414 27 1414 38 ("fl" "<fl>" "cast" "/" "fxtruncate" "d" "fx" "<fx>" "n")}
      {Lisp-Entry "fxround/" definition (public inline) ("n" "<fx>" "d" "<fx>") #f "<fx>" 1417 27 1417 35 ("fl" "<fl>" "cast" "/" "fxround" "d" "fx" "<fx>" "n")}
      {Lisp-Entry "Iterator" class (package) ((extends . "Object")) #f #f 1426 15 1426 23 ("Empty" "Object")
        {Lisp-Entry "Empty" definition () () #f #f 1429 14 1429 19 ("empty")}
        {Lisp-Entry "peeked" slot () ((initialize . "Empty")) #f #f 1433 8 1433 14 ()}
        {Lisp-Entry "iterate-object" method (override) () #f #f 1436 20 1436 34 ("self")}
        {Lisp-Entry "get-next" method (public virtual) () #f #f 1440 26 1440 34 ("next" "peek" "prog1")}
        {Lisp-Entry "peek" method (public virtual) () #f #f 1445 26 1445 30 ("next" "set!" "Empty" "peeked" "eq?" "when")}
        {Lisp-Entry "unget" method (public virtual) ("object") #f #f 1451 26 1451 31 ("error" "set!" "Empty" "peeked" "eq?" "if" "object")}
        {Lisp-Entry "next" method (public virtual) () #f #f 1457 26 1457 30 ("get-next!" "else" "set!" "prog1" "Empty" "neq?" "peeked" "eof-object?" "cond")}
        {Lisp-Entry "done?" method (public virtual) () #f "<bool>" 1467 26 1467 31 ("peek" "eof-object?" "bool" "<bool>")}
        {Lisp-Entry "get-next!" method (public virtual) () #f #f 1471 26 1471 35 ()}
        {Lisp-Entry "put" method (public virtual) ("object") #f #f 1475 26 1475 29 ("error" "object")}
        {Lisp-Entry "get-position" method (public virtual) () #f #f 1479 26 1479 38 ("self" "error")}
        {Lisp-Entry "set-position" method (public virtual) ("pos") #f #f 1483 26 1483 38 ("self" "error" "pos")}
        {Lisp-Entry "get-state" method (public virtual) () #f #f 1487 26 1487 35 ()}
        {Lisp-Entry "reset-state" method (public virtual) ("old") #f #f 1491 26 1491 37 ("old")}}
      {Lisp-Entry "iterate-sequence" definition (public inline) ("obj" "<Object>") #f "<Iterator>" 1495 27 1495 43 ("iterate-object" "iterate-object~" "Iterator" "<Iterator>" "Object" "<Object>" "obj")}
      {Lisp-Entry "Explorer" class (package) ((extends . "Iterator")) #f #f 1504 15 1504 23 ("forward" "Iterator")
        {Lisp-Entry "direction" slot () ((initialize . "'forward") (setter . "generate")) #f #f 1507 8 1507 17 ()}
        {Lisp-Entry "set-direction" accessor () () #f #f 1507 45 1507 53 ()}
        {Lisp-Entry "peek-forward" method (protected virtual) () #f #f 1510 29 1510 41 ("error")}
        {Lisp-Entry "peek-backward" method (protected virtual) () #f #f 1514 29 1514 42 ("error")}
        {Lisp-Entry "peek" method (override) () #f #f 1518 20 1518 24 ("peek-backward" "backward" "peek-forward" "forward" "direction" "case" "eof-object" "done?" "if")}
        {Lisp-Entry "goto-beginning" method (public virtual) () #f #f 1526 26 1526 40 ("error")}
        {Lisp-Entry "goto-end" method (public virtual) () #f #f 1530 26 1530 34 ("error")}
        {Lisp-Entry "forward" method (public virtual) () #f #f 1534 26 1534 33 ("error")}
        {Lisp-Entry "backward" method (public virtual) () #f #f 1538 26 1538 34 ("error")}
        {Lisp-Entry "next" method (override) () #f #f 1542 20 1542 24 ("backward" "forward" "direction" "case" "done?" "not" "when")}
        {Lisp-Entry "done-forward?" method (protected virtual) () #f #f 1549 29 1549 42 ("error")}
        {Lisp-Entry "done-backward?" method (protected virtual) () #f #f 1553 29 1553 43 ("error")}
        {Lisp-Entry "done?" method (override) () #f #f 1557 20 1557 25 ("done-backward?" "backward" "done-forward?" "forward" "direction" "case")}
        {Lisp-Entry "put-forward" method (protected virtual) ("object") #f #f 1563 29 1563 40 ("error" "object")}
        {Lisp-Entry "put-backward" method (protected virtual) ("object") #f #f 1567 29 1567 41 ("error" "object")}
        {Lisp-Entry "put" method (override) ("object") #f #f 1571 20 1571 23 ("put-backward" "backward" "put-forward" "forward" "direction" "case" "object")}}
      {Lisp-Entry "explore" definition (public) ("object" "<Object>" "." "rest") #f "<Explorer>" 1577 20 1577 27 ("Sequence-Explorer" "new" "apply" "Explorer" "<Explorer>" "rest" "Object" "<Object>" "object")}
      {Lisp-Entry "coerce-sequence" definition () ("seq" "class") #f #f 1587 13 1587 28 ("set-element!" "in-sequence" "elem" "below" "0" "from" "n" "for" "loop" "make-sequence" "make-sequence~" "new-sequence" "cardinality" "len" "let" "class" "seq")}
      {Lisp-Entry "Sequence-Class" class () ((extends . "Class")) #f #f 1596 7 1596 21 ("Class")
        {Lisp-Entry "make-sequence" method (public virtual abstract) ("len" "<int>") #f #f 1599 35 1599 48 ("int" "<int>" "len")}
        {Lisp-Entry "coerce-object" method (override) ("seq") #f #f 1602 20 1602 33 ("self" "coerce-sequence" "seq")}}
      {Lisp-Entry "Sequence" class (primitive) ((metaclass . "Sequence-Class") (extends . "Object")) #f #f 1606 17 1606 25 ("Object" "Sequence-Class")
        {Lisp-Entry "coerce-string" method (override) () #f #f 1609 20 1609 33 ("String" "self" "coerce-sequence")}
        {Lisp-Entry "compare-object" method (override) ("seq") #f #f 1613 20 1613 34 (":incompatible" "compare" "self" "compare-sequence" "Sequence" "is?" "if" "seq")}
        {Lisp-Entry "di-compare-object" method (override) ("seq") #f #f 1619 20 1619 37 ("di-compare" "self" "compare-sequence" "seq")}
        {Lisp-Entry "copy-object" method (override) ("deep?" "<bool>") #f #f 1623 20 1623 31 ("1" "+" "element" "set-element!" "begin" "=" "0" "fx" "<fx>" "i" "iter" "let" "class-of" "make-sequence" "make-sequence~" "new-seq" "self" "cardinality" "len" "identity" "x" "lambda" "if" "subcopy" "let*" "bool" "<bool>" "deep?")}
        {Lisp-Entry "iterate-object" method (override) () #f #f 1635 20 1635 34 ("self" "Sequence-Explorer" "new")}
        {Lisp-Entry "object-alphabetic?" method (override) () #f #f 1639 20 1639 38 ("self" "alphabetic?" "every?")}
        {Lisp-Entry "object-numeric?" method (override) () #f #f 1643 20 1643 35 ("self" "numeric?" "every?")}
        {Lisp-Entry "object-alphanumeric?" method (override) () #f #f 1647 20 1647 40 ("self" "alphanumeric?" "every?")}
        {Lisp-Entry "object-whitespace?" method (override) () #f #f 1651 20 1651 38 ("self" "whitespace?" "every?")}
        {Lisp-Entry "object-upper-case?" method (override) () #f #f 1655 20 1655 38 ("self" "upper-case?" "every?")}
        {Lisp-Entry "object-lower-case?" method (override) () #f #f 1659 20 1659 38 ("self" "lower-case?" "every?")}
        {Lisp-Entry "object-upcase" method (override) () #f #f 1663 20 1663 33 ("class-of" "upcase" "self" "accumulate")}
        {Lisp-Entry "object-downcase" method (override) () #f #f 1667 20 1667 35 ("class-of" "downcase" "self" "accumulate")}
        {Lisp-Entry "object-capitalize" method (override) () #f #f 1671 20 1671 37 ("class-of" "upcase" "set!" "not" "alphanumeric?" "if" "object" "lambda" "self" "accumulate" "break?" "let")}
        {Lisp-Entry "sequence-element" method (protected virtual abstract) ("n" "<fx>") #f "<any>" 1685 38 1685 54 ("any" "<any>" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-set-element!" method (protected virtual abstract) ("n" "<fx>" "obj" "<any>") #f "<void>" 1688 38 1688 59 ("void" "<void>" "any" "<any>" "obj" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-cardinality" method (protected virtual abstract) () #f "<fx>" 1691 38 1691 58 ("fx" "<fx>")}
        {Lisp-Entry "sequence-tail" method (protected virtual abstract) ("start") #f #f 1694 38 1694 51 ("start")}
        {Lisp-Entry "sequence-last" method (protected virtual abstract) () #f #f 1697 38 1697 51 ()}
        {Lisp-Entry "sequence-butlast" method (protected virtual abstract) () #f #f 1700 38 1700 54 ()}
        {Lisp-Entry "sequence-subseq!" method (protected virtual) ("start" "<fx>" "end" "<fx>") #f #f 1703 29 1703 45 ("cardinality" "-" "Subseq" "new" "self" "-1" "0" "=" "and" "if" "end" "fx" "<fx>" "start")}
        {Lisp-Entry "sequence-replace-subseq!" method (protected virtual) ("start" "<fx>" "end" "<fx>" "replacement") #f #f 1709 29 1709 53 ("cardinality" "0" "self" "subseq" "concatenate!" "replacement" "end" "fx" "<fx>" "start")}}
      {Lisp-Entry "sequence?" definition (public inline) ("obj") #f #f 1715 27 1715 36 ("Sequence" "is?" "obj")}
      {Lisp-Entry "element" definition (public inline) ("seq" "<Sequence>" "n" "<int>") #f "<any>" 1719 27 1719 34 ("sequence-element" "sequence-element~" "any" "<any>" "int" "<int>" "n" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "set-element!" definition (public inline) ("seq" "<Sequence>" "n" "<int>" "obj" "<any>") #f "<void>" 1723 27 1723 39 ("sequence-set-element!" "sequence-set-element!~" "void" "<void>" "any" "<any>" "obj" "int" "<int>" "n" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "cardinality" definition (public inline) ("seq" "<Sequence>") #f "<int>" 1727 27 1727 38 ("sequence-cardinality" "sequence-cardinality~" "int" "<int>" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "empty?" definition (public inline) ("seq") #f #f 1731 27 1731 33 ("cardinality" "0" "=" "seq")}
      {Lisp-Entry "tail" definition (public inline) ("seq" "<Sequence>" "start") #f #f 1735 27 1735 31 ("sequence-tail" "sequence-tail~" "start" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "last" definition (public inline) ("seq" "<Sequence>") #f #f 1739 27 1739 31 ("sequence-last" "sequence-last~" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "butlast" definition (public inline) ("seq" "<Sequence>") #f #f 1743 27 1743 34 ("sequence-butlast" "sequence-butlast~" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "compare-sequence" definition (public) ("s1" "s2" "compare") #f #f 1747 20 1747 36 ("1" "+" "eq?" "element" "cmp" ":less" "else" ":greater" ">" ":equal" "=" "cond" ">=" "or" "if" "0" "fx" "<fx>" "i" "iter" "l2" "cardinality" "l1" "let" "compare" "s2" "s1")}
      {Lisp-Entry "skip-whitespace" definition (public) ("seq" "<Sequence>" "(start: start #f)") #f #f 1761 20 1761 35 ("else" "1" "+" "element" "eq?" "cardinality" "=" "cond" "0" "or" "fx" "<fx>" "i" "iter" "let" "start" "start:" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "subseq" definition (public) ("seq" "start" "(end #f)" "(type #f)") #f #f 1768 20 1768 26 ("1" "+" "set!" "element" "set-element!" "<" "while" "j" "0" "i" "make-sequence" "make-sequence~" "sub" "class-of" "Sequence-Class" "<Sequence-Class>" "cls" "cardinality" "or" "-" "len" "let*" "type" "end" "start" "seq")}
      {Lisp-Entry "replace-subseq!" definition (public inline) ("seq" "<Sequence>" "start" "end" "replacement") #f #f 1781 27 1781 42 ("sequence-replace-subseq!" "sequence-replace-subseq!~" "replacement" "end" "start" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "subseq!" definition (public) ("seq" "<Sequence>" "start" "(end (cardinality seq))") #f #f 1785 20 1785 27 ("sequence-subseq!" "sequence-subseq!~" "cardinality" "end" "start" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "sort" definition (public) ("test" "seq" "(key: key #f)") #f #f 1789 20 1789 24 ("class-of" "List" "sort" "coerce" "null/pair?" "let*" "cddr" "or" "split" "cdr" "cons" "apply-key" "if" "e2" "car" "e1" "let" "else" "null?" "cond" "l2" "l1" "merge" "merge-sort" "smaller" "l" "sort-list" "define" "key" "key:" "seq" "test")}
      {Lisp-Entry "first" definition (public inline) ("seq") #f #f 1820 27 1820 32 ("0" "element" "seq")}
      {Lisp-Entry "second" definition (public inline) ("seq") #f #f 1821 27 1821 33 ("1" "element" "seq")}
      {Lisp-Entry "third" definition (public inline) ("seq") #f #f 1822 27 1822 32 ("2" "element" "seq")}
      {Lisp-Entry "fourth" definition (public inline) ("seq") #f #f 1823 27 1823 33 ("3" "element" "seq")}
      {Lisp-Entry "fifth" definition (public inline) ("seq") #f #f 1824 27 1824 32 ("4" "element" "seq")}
      {Lisp-Entry "sixth" definition (public inline) ("seq") #f #f 1825 27 1825 32 ("5" "element" "seq")}
      {Lisp-Entry "seventh" definition (public inline) ("seq") #f #f 1826 27 1826 34 ("6" "element" "seq")}
      {Lisp-Entry "eighth" definition (public inline) ("seq") #f #f 1827 27 1827 33 ("7" "element" "seq")}
      {Lisp-Entry "ninth" definition (public inline) ("seq") #f #f 1828 27 1828 32 ("8" "element" "seq")}
      {Lisp-Entry "tenth" definition (public inline) ("seq") #f #f 1829 27 1829 32 ("9" "element" "seq")}
      {Lisp-Entry "set-first!" definition (public inline) ("seq" "value") #f #f 1831 27 1831 37 ("0" "set-element!" "value" "seq")}
      {Lisp-Entry "set-second!" definition (public inline) ("seq" "value") #f #f 1832 27 1832 38 ("1" "set-element!" "value" "seq")}
      {Lisp-Entry "set-third!" definition (public inline) ("seq" "value") #f #f 1833 27 1833 37 ("2" "set-element!" "value" "seq")}
      {Lisp-Entry "set-fourth!" definition (public inline) ("seq" "value") #f #f 1834 27 1834 38 ("3" "set-element!" "value" "seq")}
      {Lisp-Entry "set-fifth!" definition (public inline) ("seq" "value") #f #f 1835 27 1835 37 ("4" "set-element!" "value" "seq")}
      {Lisp-Entry "set-sixth!" definition (public inline) ("seq" "value") #f #f 1836 27 1836 37 ("5" "set-element!" "value" "seq")}
      {Lisp-Entry "set-seventh!" definition (public inline) ("seq" "value") #f #f 1837 27 1837 39 ("6" "set-element!" "value" "seq")}
      {Lisp-Entry "set-eighth!" definition (public inline) ("seq" "value") #f #f 1838 27 1838 38 ("7" "set-element!" "value" "seq")}
      {Lisp-Entry "set-ninth!" definition (public inline) ("seq" "value") #f #f 1839 27 1839 37 ("8" "set-element!" "value" "seq")}
      {Lisp-Entry "set-tenth!" definition (public inline) ("seq" "value") #f #f 1840 27 1840 37 ("9" "set-element!" "value" "seq")}
      {Lisp-Entry "element-reversed" definition (public) ("seq" "n") #f #f 1843 20 1843 36 ("1" "cardinality" "-" "element" "n" "seq")}
      {Lisp-Entry "iterate" definition (public) ("seq" "proc" "<procedure>") #f #f 1847 20 1847 27 ("in-sequence" "obj" "for" "loop" "procedure" "<procedure>" "proc" "seq")}
      {Lisp-Entry "iterate-sequences" definition (public) ("proc" "<procedure>" "." "seqs") #f #f 1852 20 1852 37 ("unspecified" "get-next" "get-next~" "apply" "not" "when" "done?~" "done?" "loop" "iterate-sequence" "map" "iterators" "let" "cdr" "car" "or" "pair?" "and" "lst" "any?" "define" "seqs" "procedure" "<procedure>" "proc")}
      {Lisp-Entry "accumulate" definition (public) ("seq" "proc" "<procedure>" "(type #f)") #f #f 1867 20 1867 30 ("coerce" "not" "if" "collect" "in-sequence" "obj" "for" "loop" "lst" "let" "type" "procedure" "<procedure>" "proc" "seq")}
      {Lisp-Entry "apply-key" definition (private inline) ("key" "<Object>" "object" "<Object>") #f #f 1876 28 1876 37 ("not" "if" "object" "Object" "<Object>" "key")}
      {Lisp-Entry "apply-test" definition (private inline) ("test" "<Object>" "x" "<Object>" "y" "<Object>") #f #f 1882 28 1882 38 ("eqv?" "not" "if" "y" "x" "Object" "<Object>" "test")}
      {Lisp-Entry "gather" definition (public) ("iterable" "<Object>" "(type: type List)") #f #f 1888 20 1888 26 ("collect" "in-sequence" "obj" "for" "loop" "coerce" "List" "type" "type:" "Object" "<Object>" "iterable")}
      {Lisp-Entry "collect" definition (public) ("proc" "<procedure>" "seq" "<Object>" "(key: key #f)" "(type: type #f)") #f #f 1894 20 1894 27 ("class-of" "or" "collect" "when" "apply-key" "=" "val" "in-sequence" "obj" "for" "loop" "coerce" "type" "type:" "key" "key:" "Object" "<Object>" "seq" "procedure" "<procedure>" "proc")}
      {Lisp-Entry "collect-if" definition (public) ("predicate" "<procedure>" "seq" "<Object>" "(key: key #f)") #f #f 1902 20 1902 30 ("class-of" "collect" "apply-key" "when" "in-sequence" "obj" "for" "loop" "coerce" "key" "key:" "Object" "<Object>" "seq" "procedure" "<procedure>" "predicate")}
      {Lisp-Entry "collect-type" definition (public) ("type" "seq" "<Object>" "(key: key #f)") #f #f 1909 20 1909 32 ("class-of" "collect" "apply-key" "is?" "when" "in-sequence" "obj" "for" "loop" "coerce" "key" "key:" "Object" "<Object>" "seq" "type")}
      {Lisp-Entry "collect-sections" definition (public) ("lst" "(separator: separator #f)" "(test: test #f)") #f #f 1916 20 1916 36 ("reset" "reset~" "get-output" "get-output~" "put" "put~" "begin" "apply-test" "if" "value" "lambda" "for-each" "section" "List-Factory" "new" "sections" "let" "test" "test:" "separator" "separator:" "lst")}
      {Lisp-Entry "count" definition (public) ("target" "<Object>" "seq" "<Object>" "(key: key #f)" "(test: test #f)") #f #f 1930 20 1930 25 ("increase!" "apply-key" "apply-test" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "test" "test:" "key" "key:" "seq" "Object" "<Object>" "target")}
      {Lisp-Entry "count-if" definition (public) ("predicate" "<procedure>" "seq" "(key: key #f)") #f #f 1938 20 1938 28 ("increase!" "apply-key" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "key" "key:" "seq" "procedure" "<procedure>" "predicate")}
      {Lisp-Entry "count-type" definition (public) ("type" "seq" "<Object>" "(key: key #f)") #f #f 1946 20 1946 30 ("increase!" "apply-key" "is?" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "key" "key:" "Object" "<Object>" "seq" "type")}
      {Lisp-Entry "find" definition (public) ("seq" "target" "(key: key #f)" "(test: test #f)" "(start: start #f)" "(reversed?: reversed? #f)" "(return: return 'position)") #f #f 1954 20 1954 24 ("error" "else" "1" "-" "get-position" "get-position~" "item" "case" "continuation-return" "apply-key" "apply-test" "object" "iterate" "exit" "lambda" "continuation-capture" "set-position" "set-position~" "when" "iterate-sequence" "backward" "direction:" "explore" "Iterator" "<Iterator>" "iterator" "let" "0" "or" "list-find" "not" "null/pair?" "and" "if" "position" "return" "return:" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "target" "seq")}
      {Lisp-Entry "list-find" definition () ("list" "target" "key" "test" "start" "return") #f #f 1972 13 1972 22 ("1" "+" "cdr" "else" "item" "case" "car" "null?" "cond" "fx" "<fx>" "rank" "tail" "rest" "iter" "eqv?" "x" "lambda" "not" "if" "let" "return" "start" "test" "key" "target" "list")}
      {Lisp-Entry "find-object" definition (public) ("proc" "<procedure>" "seq" "<Object>" "(key: key #f)") #f #f 1985 20 1985 31 ("finally" "return" "when" "apply-key" "=" "val" "in-sequence" "obj" "for" "loop" "key" "key:" "Object" "<Object>" "seq" "procedure" "<procedure>" "proc")}
      {Lisp-Entry "find-in" definition (public) ("seq" "target" "(key: key #f)" "(test: test #f)" "(start: start #f)" "(reversed?: reversed? #f)") #f #f 1993 20 1993 27 ("continuation-return" "apply-key" "apply-test" "object" "iterate" "exit" "continuation-capture" "set-position" "set-position~" "when" "iterate-sequence" "backward" "direction:" "explore" "Iterator" "<Iterator>" "iterator" "null/pair?" "and" "1" "+" "cdr" "else" "car" "null?" "cond" "fx" "<fx>" "rank" "tail" "rest" "iter" "0" "or" "eqv?" "x" "lambda" "not" "if" "list" "let" "find-in-list" "define" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "target" "seq")}
      {Lisp-Entry "find-balanced" definition (public) ("open" "close" "seq" "(key: key #f)" "(test: test #f)" "(start: start #f)" "(reversed?: reversed? #f)" "(return: return 'item)") #f #f 2020 20 2020 33 ("error" "else" "1" "-" "get-position" "get-position~" "position" "continuation-return" "case" "<" "decrease!" "increase!" "apply-key" "apply-test" "cond" "object" "iterate" "exit" "lambda" "continuation-capture" "set-position" "set-position~" "when" "0" "count" "iterate-sequence" "backward" "direction:" "explore" "if" "Iterator" "<Iterator>" "iterator" "let" "item" "return" "return:" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "seq" "close" "open")}
      {Lisp-Entry "find-if" definition (public) ("predicate" "<procedure>" "seq" "<Object>" "(key: key #f)" "(start: start #f)" "(reversed?: reversed? #f)" "(return: return 'item)") #f #f 2041 20 2041 27 ("error" "else" "1" "-" "get-position" "get-position~" "position" "case" "continuation-return" "apply-key" "object" "iterate" "set-position" "set-position~" "when" "iterate-sequence" "backward" "direction:" "explore" "Iterator" "<Iterator>" "iterator" "let" "exit" "lambda" "continuation-capture" "0" "or" "find-if-list" "not" "null/pair?" "and" "if" "item" "return" "return:" "reversed?" "reversed?:" "start" "start:" "key" "key:" "Object" "<Object>" "seq" "procedure" "<procedure>" "predicate")}
      {Lisp-Entry "get-rank" definition (public) ("target" "<Object>" "seq" "<Object>" "(key: key #f)" "(test: test #f)" "(start: start #f)" "(reversed?: reversed? #f)") #f #f 2059 20 2059 28 ("1" "-" "get-position" "get-position~" "continuation-return" "apply-key" "apply-test" "object" "iterate" "set-position" "set-position~" "when" "iterate-sequence" "backward" "direction:" "explore" "Iterator" "<Iterator>" "iterator" "let" "exit" "lambda" "continuation-capture" "string-find" "string?" "0" "or" "list-find" "not" "null/pair?" "and" "if" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "seq" "Object" "<Object>" "target")}
      {Lisp-Entry "skip" definition (public) ("predicate" "<procedure>" "seq" "<Object>" "(key: key #f)" "(start: start 0)") #f #f 2076 20 2076 24 ("1" "get-position" "get-position~" "-" "continuation-return" "apply-key" "not" "when" "object" "iterate" "set-position" "set-position~" "iterate-sequence" "iterator" "let" "return" "lambda" "continuation-capture" "0" "start" "start:" "key" "key:" "Object" "<Object>" "seq" "procedure" "<procedure>" "predicate")}
      {Lisp-Entry "append-map" definition (public) ("proc" "<procedure>" "list1" "." "lists") #f #f 2088 20 2088 30 ("map" "append" "apply" "lists" "list1" "procedure" "<procedure>" "proc")}
      {Lisp-Entry "zip" definition (public) ("list1" "." "lists") #f #f 2092 20 2092 23 ("list" "map" "apply" "lists" "list1")}
      {Lisp-Entry "iota" definition (public) ("count" "(start 0)" "(step 1)") #f #f 2096 20 2096 24 ("+" "-" "iota" "cons" "zero?" "if" "1" "step" "0" "start" "count")}
      {Lisp-Entry "fold-left" definition (public) ("kcons" "knil" "lst") #f #f 2102 20 2102 29 ("cdr" "car" "fold-left" "null?" "if" "lst" "knil" "kcons")}
      {Lisp-Entry "fold-right" definition (public) ("kcons" "knil" "lst") #f #f 2108 20 2108 30 ("cdr" "fold-right" "car" "null?" "if" "lst" "knil" "kcons")}
      {Lisp-Entry "unfold-right" definition (public) ("stop?" "<procedure>" "seed->elem" "<procedure>" "next" "<procedure>" "seed" "(tail '())") #f #f 2114 20 2114 32 ("cons" "if" "lis" "loop" "let" "tail" "seed" "next" "seed->elem" "procedure" "<procedure>" "stop?")}
      {Lisp-Entry "some?" definition (public) ("predicate" "<procedure>" "(key: key #f)" "." "seqs") #f #f 2122 20 2122 25 ("continuation-return" "apply-key" "when" "object" "iterate-sequence" "iterate" "return" "lambda" "continuation-capture" "car" "seq" "let" "seqs" "key" "key:" "procedure" "<procedure>" "predicate")}
      {Lisp-Entry "every?" definition (public) ("predicate" "<procedure>" "(key: key #f)" "." "seqs") #f #f 2134 20 2134 26 ("continuation-return" "apply-key" "object" "map" "or" "objs" "iterate-sequences" "apply" "return" "lambda" "continuation-capture" "seqs" "key" "key:" "procedure" "<procedure>" "predicate")}
      {Lisp-Entry "concatenate" definition (public) ("." "rest") #f #f 2147 20 2147 31 ("class-of" "coerce" "not" "get-output" "get-output~" "output" "put-sequence" "put-sequence~" "sequence" "lambda" "for-each" "null/pair?" "list?" "car" "first" "let*" "List-Factory" "new" "fact" "let" "null?" "if" "rest")}
      {Lisp-Entry "concatenate!" definition (public) ("." "rest") #f #f 2162 20 2162 32 ("concatenate" "apply" "rest")}
      {Lisp-Entry "subset?" definition (public) ("set1" "set2") #f #f 2166 20 2166 27 ("memv?" "element" "lambda" "every?" "null?" "or" "set2" "set1")}
      {Lisp-Entry "union" definition (public) ("(key: key #f)" "(test: test #f)" "." "lists") #f #f 2173 20 2173 25 ("class-of" "coerce" "cdr" "put" "put~" "get-output" "get-output~" "apply-key" "member?" "not" "when" "object" "iterate-sequence" "iterate" "set" "lambda" "for-each" "put-sequence" "put-sequence~" "List-Factory" "new" "dst" "car" "first" "let" "null?" "if" "lists" "test" "test:" "key" "key:")}
      {Lisp-Entry "intersection" definition (public) ("(test: test #f)" "." "lists") #f #f 2188 20 2188 32 ("class-of" "get-output" "get-output~" "coerce" "put" "put~" "member?" "set" "every?" "when" "object" "lambda" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "cdr" "car" "first" "let" "null?" "if" "lists" "test" "test:")}
      {Lisp-Entry "difference" definition (public) ("x" "<Object>" "y" "<Object>" "(test: test eqv?)") #f #f 2203 20 2203 30 ("class-of" "get-output" "get-output~" "coerce" "put" "put~" "member?" "not" "when" "object" "lambda" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "null?" "if" "eqv?" "test" "test:" "y" "Object" "<Object>" "x")}
      {Lisp-Entry "set-xor" definition (public) ("x" "<Object>" "y" "<Object>" "(test: test eqv?)") #f #f 2214 20 2214 27 ("difference" "union" "eqv?" "test" "test:" "y" "Object" "<Object>" "x")}
      {Lisp-Entry "remove" definition (public) ("target" "<Object>" "seq" "<Object>" "(test: test eqv?)") #f #f 2219 20 2219 26 ("class-of" "get-output" "get-output~" "coerce" "put" "put~" "apply-test" "not" "when" "object" "lambda" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "eqv?" "test" "test:" "seq" "Object" "<Object>" "target")}
      {Lisp-Entry "string-remove" specialize () () #f #f 2228 15 2228 28 ()}
      {Lisp-Entry "remove" specialize () ("target" "<char>" "str" "<string>") ("string-remove") #f 2228 30 2228 36 ("get-output-string" "write-char" "eqv?" "not" "when" "element" "c" "cardinality" "below" "0" "from" "n" "for" "loop" "open-output-string" "output" "let" "string" "<string>" "str" "char" "<char>" "target")}
      {Lisp-Entry "extract-trailer" definition (public) ("seq" "<Object>" "predicate" "<procedure>") #f #f 2237 20 2237 35 ("cons" "obj" "class-of" "coerce" "element" "not" "0" "<" "or" "if" "trailer" "1" "cardinality" "-" "n" "iterate" "let" "procedure" "<procedure>" "predicate" "Object" "<Object>" "seq")}
      {Lisp-Entry "remove-leading" definition (public) ("target" "<Object>" "seq" "<Object>" "(test: test eqv?)") #f #f 2247 20 2247 34 ("subseq" "increase!" "element" "apply-test" "<" "and" "while" "tail" "head" "cardinality" "end" "0" "start" "let*" "eqv?" "test" "test:" "seq" "Object" "<Object>" "target")}
      {Lisp-Entry "remove-trailing" definition (public) ("target" "<Object>" "seq" "<Object>" "(test: test eqv?)") #f #f 2257 20 2257 35 ("subseq" "decrease!" "1" "-" "element" "apply-test" ">" "and" "while" "tail" "head" "cardinality" "end" "0" "start" "let*" "eqv?" "test" "test:" "seq" "Object" "<Object>" "target")}
      {Lisp-Entry "remove-enclosing" definition (public) ("target" "<Object>" "seq" "<Object>" "(test: test eqv?)") #f #f 2267 20 2267 36 ("subseq" "decrease!" "1" "-" ">" "increase!" "element" "apply-test" "<" "and" "while" "tail" "head" "cardinality" "end" "0" "start" "let*" "eqv?" "test" "test:" "seq" "Object" "<Object>" "target")}
      {Lisp-Entry "remove-duplicates" definition (public) ("seq" "<Object>" "(key: key #f)" "(test: test eqv?)") #f #f 2279 20 2279 37 ("class-of" "coerce" "put" "put~" "get-output" "get-output~" "apply-key" "member?" "not" "when" "object" "lambda" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "eqv?" "test" "test:" "key" "key:" "Object" "<Object>" "seq")}
      {Lisp-Entry "remove-false" definition (public) ("seq" "<Object>") #f #f 2288 20 2288 32 ("identity" "collect-if" "Object" "<Object>" "seq")}
      {Lisp-Entry "remove-empty" definition (public) ("seq" "<Object>") #f #f 2292 20 2292 32 ("empty?" "not" "obj" "lambda" "collect-if" "Object" "<Object>" "seq")}
      {Lisp-Entry "trim-spaces" definition (public) ("seq") #f #f 2298 20 2298 31 ("remove-enclosing" "seq")}
      {Lisp-Entry "trim-whitespace" definition (public) ("seq") #f #f 2302 20 2302 35 ("whitespace?" "ignore" "c" "lambda" "test:" "remove-enclosing" "seq")}
      {Lisp-Entry "mismatch" definition (public) ("target" "<Object>" "seq" "<Object>" "(test: test equal?)") #f #f 2308 20 2308 28 ("if" "increase!" "continuation-return" "get-next" "get-next~" "or" "when" "done?" "done?~" "not" "while" "0" "pos" "targ" "iterate-sequence" "srce" "let" "return" "lambda" "continuation-capture" "equal?" "test" "test:" "seq" "Object" "<Object>" "target")}
      {Lisp-Entry "prefix" definition (public) ("sequences" "<Object>" "(test: test equal?)") #f #f 2323 20 2323 26 ("0" "subseq" "cdr" "set!" "<" "not" "or" "and" "when" "mismatch" "n" "object" "lambda" "for-each" "min" "car" "ref" "let" "null?" "if" "equal?" "test" "test:" "Object" "<Object>" "sequences")}
      {Lisp-Entry "prefix?" definition (public) ("target" "<Object>" "seq" "<Object>") #f #f 2338 20 2338 27 ("continuation-return" "get-next" "get-next~" "nu/=?" "when" "done?" "done?~" "not" "and" "while" "iter" "iterate-sequence" "targ" "let" "return" "lambda" "continuation-capture" "seq" "Object" "<Object>" "target")}
      {Lisp-Entry "copy-into!" definition (public) ("seq1" "seq2") #f #f 2349 20 2349 30 ("cardinality" "0" "naturals" "set-element!" "rank" "element" "lambda" "for-each" "seq2" "seq1")}
      {Lisp-Entry "Search-Context" class (package) ((extends . "Object")) #f #f 2356 15 2356 29 ("Object")
        {Lisp-Entry "target" slot () ((accessors . "generate")) #f "<Sequence>" 2359 8 2359 14 ("Sequence" "<Sequence>")}
        {Lisp-Entry "get-target" accessor () () #f #f 2359 49 2359 57 ()}
        {Lisp-Entry "set-target" accessor () () #f #f 2359 49 2359 57 ()}
        {Lisp-Entry "whole-words?" slot () ((accessors . "generate")) #f "<bool>" 2360 8 2360 20 ("bool" "<bool>")}
        {Lisp-Entry "get-whole-words?" accessor () () #f #f 2360 49 2360 57 ()}
        {Lisp-Entry "set-whole-words?" accessor () () #f #f 2360 49 2360 57 ()}
        {Lisp-Entry "ignore-case?" slot () ((accessors . "generate")) #f "<bool>" 2361 8 2361 20 ("bool" "<bool>")}
        {Lisp-Entry "get-ignore-case?" accessor () () #f #f 2361 49 2361 57 ()}
        {Lisp-Entry "set-ignore-case?" accessor () () #f #f 2361 49 2361 57 ()}
        {Lisp-Entry "ignore-diacritic?" slot () ((accessors . "generate")) #f "<bool>" 2362 8 2362 25 ("bool" "<bool>")}
        {Lisp-Entry "get-ignore-diacritic?" accessor () () #f #f 2362 49 2362 57 ()}
        {Lisp-Entry "set-ignore-diacritic?" accessor () () #f #f 2362 49 2362 57 ()}
        {Lisp-Entry "regexp?" slot () ((accessors . "generate")) #f "<bool>" 2363 8 2363 15 ("bool" "<bool>")}
        {Lisp-Entry "get-regexp?" accessor () () #f #f 2363 49 2363 57 ()}
        {Lisp-Entry "set-regexp?" accessor () () #f #f 2363 49 2363 57 ()}
        {Lisp-Entry "match-test" slot () ((accessors . "generate")) #f "<procedure+>" 2364 8 2364 18 ("procedure+" "<procedure+>")}
        {Lisp-Entry "get-match-test" accessor () () #f #f 2364 49 2364 57 ()}
        {Lisp-Entry "set-match-test" accessor () () #f #f 2364 49 2364 57 ()}
        {Lisp-Entry "constituent-test" slot () ((accessors . "generate")) #f "<procedure+>" 2365 8 2365 24 ("procedure+" "<procedure+>")}
        {Lisp-Entry "get-constituent-test" accessor () () #f #f 2365 49 2365 57 ()}
        {Lisp-Entry "set-constituent-test" accessor () () #f #f 2365 49 2365 57 ()}
        {Lisp-Entry "regexp" slot () ((accessors . "generate")) #f "<any>" 2366 8 2366 14 ("any" "<any>")}
        {Lisp-Entry "get-regexp" accessor () () #f #f 2366 49 2366 57 ()}
        {Lisp-Entry "set-regexp" accessor () () #f #f 2366 49 2366 57 ()}
        {Lisp-Entry "user-data" slot () ((accessors . "generate")) #f "<any>" 2367 8 2367 17 ("any" "<any>")}
        {Lisp-Entry "get-user-data" accessor () () #f #f 2367 49 2367 57 ()}
        {Lisp-Entry "set-user-data" accessor () () #f #f 2367 49 2367 57 ()}
        {Lisp-Entry "print" method (override) ("output" "detail") #f #f 2370 20 2370 25 ("target" "system-format" "lambda" "self" "print-unreadable" "detail" "output")}}
      {Lisp-Entry "Search-Set" class (package) ((extends . "Object")) #f #f 2376 15 2376 25 ("Object")
        {Lisp-Entry "regexp" slot () ((accessors . "generate")) #f "<any>" 2379 8 2379 14 ("any" "<any>")}
        {Lisp-Entry "get-regexp" accessor () () #f #f 2379 48 2379 56 ()}
        {Lisp-Entry "set-regexp" accessor () () #f #f 2379 48 2379 56 ()}
        {Lisp-Entry "contexts" slot () ((accessors . "generate")) #f "<list>" 2380 8 2380 16 ("list" "<list>")}
        {Lisp-Entry "get-contexts" accessor () () #f #f 2380 48 2380 56 ()}
        {Lisp-Entry "set-contexts" accessor () () #f #f 2380 48 2380 56 ()}}
      {Lisp-Entry "->search-context" definition (public) ("obj") #f #f 2383 20 2383 36 ("error" "else" "make-search-context" "string?" "get-contexts" "get-contexts~" "car" "Search-Set" "Search-Context" "is?" "cond" "obj")}
      {Lisp-Entry "make-search-context" definition (public) ("target" "(whole-words?: whole-words? #f)" "(ignore-case?: ignore-case? #f)" "(ignore-diacritic?: ignore-diacritic? #f)" "(regexp?: regexp? #f)" "(match-test: match-test #f)" "(constituent-test: constituent-test #f)" "(user-data: user-data #f)") #f #f 2389 20 2389 39 ("allocate-search-context" "user-data" "user-data:" "constituent-test" "constituent-test:" "match-test" "match-test:" "regexp?" "regexp?:" "ignore-diacritic?" "ignore-diacritic?:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "target")}
      {Lisp-Entry "allocate-search-context" definition (inline) ("target" "whole-words?" "ignore-case?" "ignore-diacritic?" "regexp?" "match-test" "constituent-test" "user-data") #f #f 2399 20 2399 43 ("Search-Context" "allocate" "user-data" "constituent-test" "match-test" "regexp?" "ignore-diacritic?" "ignore-case?" "whole-words?" "target")}
      {Lisp-Entry "->search-set" definition (public) ("obj") #f #f 2403 20 2403 32 ("error" "else" "search-context->sre" "or" "cons" "sre->irregex" "map" "contexts" "let" "list?" "->search-context" "->search-set" "string?" "list" "search-context-regexp" "allocate-search-set" "Search-Context" "Search-Set" "is?" "cond" "obj")}
      {Lisp-Entry "allocate-search-set" definition (public) ("regexp" "contexts") #f #f 2413 20 2413 39 ("Search-Set" "allocate" "contexts" "regexp")}
      {Lisp-Entry "->diacritic-ignoring-sre" definition () ("string") #f #f 2417 13 2417 37 ("Diacritic-Equivalences" "assq" "or" "if" "Diacritic-Table" "table-ref" "equivalent" "c" "lambda" "map" "seq" "cons" "string->list" "char-list" "let" "string")}
      {Lisp-Entry "search-context->sre" definition () ("context" "<Search-Context>") #f #f 2427 13 2427 32 ("w/nocase" "list" "get-ignore-case?" "get-ignore-case?~" "if" "else" "->diacritic-ignoring-sre" "get-ignore-diacritic?" "get-ignore-diacritic?~" ",target" "posix-string" "get-regexp?" "get-regexp?~" "cond" "get-target" "get-target~" "target" "seq" "let" "Search-Context" "<Search-Context>" "context")}
      {Lisp-Entry "search-context-regexp" definition (public) ("context" "<Search-Context>") #f #f 2438 20 2438 41 ("set-regexp" "set-regexp~" "search-context->sre" "sre->irregex" "rx" "let" "get-regexp" "get-regexp~" "or" "Search-Context" "<Search-Context>" "context")}
      {Lisp-Entry "regular-search-impl" definition () ("seq" "<Sequence>" "target" "<any>" "match-test" "<procedure+>" "constituent-test" "<procedure+>" "start" "<fx+>" "end" "<fx+>" "reversed?" "<bool>") #f #f 2445 13 2445 32 ("else" "+" "cons" "res" "after" "1" "-" "element" "and" "before" ">" "<" "cond" "irregex-match-end-index" "to" "irregex-match-start-index" "from" "not" "irregex-search" "match" "best" "i" "lp" "let" "0" "if" "cardinality" "card" "get-regexp" "get-regexp~" "regexp" "word-constituent?" "get-constituent-test" "get-constituent-test~" "get-match-test" "get-match-test~" "or" "get-whole-words?" "get-whole-words?~" "whole-words?" "get-contexts" "get-contexts~" "car" "first-context" "->search-set" "search-set" "let*" "bool" "<bool>" "reversed?" "end" "fx+" "<fx+>" "start" "constituent-test" "procedure+" "<procedure+>" "match-test" "any" "<any>" "target" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "regular-search" definition (public) ("seq" "<Sequence>" "target" "<any>" "(start: start #f)" "(end: end #f)" "(reversed?: reversed? #f)" "(match-test: match-test #f)" "(constituent-test: constituent-test #f)") #f #f 2477 20 2477 34 ("regular-search-impl" "constituent-test" "constituent-test:" "match-test" "match-test:" "reversed?" "reversed?:" "end" "end:" "start" "start:" "any" "<any>" "target" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "regular-search-all" definition (public) ("seq" "<Sequence>" "target" "<any>" "(start: start #f)" "(end: end #f)" "(reversed?: reversed? #f)" "(match-test: match-test #f)" "(constituent-test: constituent-test #f)") #f #f 2486 20 2486 38 ("queue-list" "cdr" "car" "enqueue" "begin" "regular-search-impl" "found" "0" "if" "or" "fx" "<fx>" "pos" "iter" "->search-set" "search-set" "new-queue" "queue" "cardinality" "len" "let" "constituent-test" "constituent-test:" "match-test" "match-test:" "reversed?" "reversed?:" "end" "end:" "start" "start:" "any" "<any>" "target" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "search" definition (public) ("seq" "<Sequence>" "target" "<Object>" "(start: start #f)" "(end: end #f)" "(reversed?: reversed? #f)" "(whole-words?: whole-words? #f)" "(ignore-case?: ignore-case? #f)" "(ignore-diacritic?: ignore-diacritic? #f)" "(regexp?: regexp? #f)" "(match-test: match-test #f)" "(constituent-test: constituent-test #f)") #f "<int+>" 2504 20 2504 26 ("car" "regular-search-impl" "found" "allocate-search-context" "string?" "if" "->search-set" "search-set" "let" "int+" "<int+>" "constituent-test" "constituent-test:" "match-test" "match-test:" "regexp?" "regexp?:" "ignore-diacritic?" "ignore-diacritic?:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "reversed?" "reversed?:" "end" "end:" "start" "start:" "Object" "<Object>" "target" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "search-all" definition (public) ("seq" "<Sequence>" "target" "<Object>" "(start: start #f)" "(end: end #f)" "(reversed?: reversed? #f)" "(whole-words?: whole-words? #f)" "(ignore-case?: ignore-case? #f)" "(ignore-diacritic?: ignore-diacritic? #f)" "(regexp?: regexp? #f)" "(match-test: match-test #f)" "(constituent-test: constituent-test #f)") #f "<list>" 2523 20 2523 30 ("regular-search-all" "car" "map" "allocate-search-context" "string?" "if" "->search-set" "search-set" "let" "list" "<list>" "constituent-test" "constituent-test:" "match-test" "match-test:" "regexp?" "regexp?:" "ignore-diacritic?" "ignore-diacritic?:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "reversed?" "reversed?:" "end" "end:" "start" "start:" "Object" "<Object>" "target" "Sequence" "<Sequence>" "seq")}
      {Lisp-Entry "split" definition (public) ("seq" "<Object>" "separator" "<Object>") #f "<list>" 2544 20 2544 25 ("when" "search" "iterate" "incr" "else" "get-output" "get-output~" "1" "+" "subseq" "put" "put~" "set!" "if" "position" "return:" "start:" "find-if" "pos" "not" "while" "done?" "List-Factory" "new" "result" "0" "previous" "let" "procedure?" "cardinality" "zero?" "cond" "list" "<list>" "separator" "Object" "<Object>" "seq")}
      {Lisp-Entry "split-justified" definition (public) ("seq" "<Object>" "width" "separators" "<Object>" "(column: column 0)") #f #f 2573 20 2573 35 ("get-output" "get-output~" "increase!" "+" "set!" "subseq" "put" "put~" "begin" "<=" "if" "-" "effective-width" "not" "while" "done?" "List-Factory" "new" "result" "cardinality" "size" "pos" "let" "0" "column" "column:" "separators" "width" "Object" "<Object>" "seq")}
      {Lisp-Entry "join" definition (public) ("sequences" "<Object>" "separator" "<Object>") #f #f 2590 20 2590 24 ("get-output" "get-output~" "concatenate" "apply" "seq" "lambda" "for-each" "put" "put~" "List-Factory" "new" "dst" "join-strings" "string?" "if" "first" "let" "else" "car" "cdr" "null?" "cond" "separator" "Object" "<Object>" "sequences")}
      {Lisp-Entry "join-symbols" definition (public) ("symbols" "separator") #f #f 2609 20 2609 32 ("symbol->string" "map" "join" "string->symbol" "separator" "symbols")}
      {Lisp-Entry "inject" definition (public) ("sequence" "inserted") #f #f 2613 20 2613 26 ("get-output" "get-output~" "put" "put~" "put-sequence" "put-sequence~" "set!" "if" "element" "lambda" "for-each" "first?" "List-Factory" "new" "fact" "let" "inserted" "sequence")}
      {Lisp-Entry "substitute" definition (public) ("old-value" "<Object>" "new-value" "<Object>" "seq" "<Object>" "(key: key #f)" "(test: test #f)" "(sequence?: sequence? #f)") #f #f 2625 20 2625 30 ("class-of" "get-output" "get-output~" "coerce" "put-sequence" "put-sequence~" "put" "put~" "apply-key" "apply-test" "if" "get-next" "get-next~" "object" "done?" "done?~" "not" "while" "List-Factory" "new" "dst" "iterate-sequence" "src" "let" "sequence?" "sequence?:" "test" "test:" "key" "key:" "seq" "new-value" "Object" "<Object>" "old-value")}
      {Lisp-Entry "substitute-alist" definition (public) ("replacements" "<Object>" "seq" "<Object>" "(key: key #f)" "(test: test #f)") #f #f 2638 20 2638 36 ("class-of" "get-output" "get-output~" "coerce" "put" "put~" "set!" "put-sequence" "put-sequence~" "apply-key" "apply-test" "when" "old" "bind" "unless" "replacement" "lambda" "for-each" "found?" "get-next" "get-next~" "object" "done?" "done?~" "not" "while" "List-Factory" "new" "dst" "iterate-sequence" "src" "let" "test" "test:" "key" "key:" "seq" "Object" "<Object>" "replacements")}
      {Lisp-Entry "fill!" definition (public) ("seq" "object" "(start: start #f)") #f #f 2656 20 2656 25 ("next" "next~" "put" "put~" "done?" "done?~" "not" "while" "set-position" "set-position~" "when" "iterate-sequence" "src" "let" "start" "start:" "object" "seq")}
      {Lisp-Entry "replace!" definition (public) ("seq" "replacement" "(start: start #f)") #f #f 2666 20 2666 28 ("next" "next~" "get-next" "get-next~" "put" "put~" "done?" "done?~" "not" "and" "while" "set-position" "set-position~" "when" "rep" "iterate-sequence" "src" "let" "start" "start:" "replacement" "seq")}
      {Lisp-Entry "ordered-position" definition (public) ("object" "seq" "(key: key #f)" "(test: test <=)") #f #f 2677 20 2677 36 ("find" "<=" "test" "test:" "key" "key:" "seq" "object")}
      {Lisp-Entry "insert-ordered!" definition (public) ("object" "seq" "(key: key #f)" "(test: test <=)") #f #f 2681 20 2681 35 ("cardinality" "or" "insert!" "apply-key" "ordered-position" "n" "let" "<=" "test" "test:" "key" "key:" "seq" "object")}
      {Lisp-Entry "merge-ordered" definition (public) ("proc" "x" "y" "(key: key #f)" "(left-key: left-key key)" "(right-key: right-key key)" "(test: test #f)" "(case-insensitive?: case-insensitive? #f)") #f #f 2686 20 2686 33 ("get-next" "get-next~" "expr" "error" "else" ":right" ":greater" ":left" ":less" "next" "next~" ":same" ":equal" "case" "ky" "apply-key" "kx" "ey" "peek" "peek~" "ex" "let*" "done?" "done?~" "not" "and" "while" "compare" "ci-compare" "if" "or" "compare-proc" "iy" "iterate-sequence" "ix" "let" "case-insensitive?" "case-insensitive?:" "test" "test:" "right-key" "right-key:" "left-key" "left-key:" "key" "key:" "y" "x" "proc")}
      {Lisp-Entry "merge" definition (public) ("proc" "lists" "(key: key #f)" "(compare: compare compare)") #f #f 2712 20 2712 25 ("get-output" "get-output~" "cdr" "set-car!" "put" "put~" ":equal" "neq?" "not" "or" "if" "object" "list" "pair" "lambda" "for-each-pair" "List-Factory" "new" "res" "apply-key" "min-key" ":compare" "remove-false" "car" "map" "minimum" "min" "let*" "identity" "some?" "while" "copy" "scan" "let" "compare" "compare:" "key" "key:" "lists" "proc")}
      {Lisp-Entry "next-element" definition (public) ("seq" "elem" "(cycle?: cycle? #t)") #f #f 2730 20 2730 32 ("-" "min" "modulo" "1" "+" "next" "0" "not" "if" "element" "cardinality" "card" "find" "rank" "let" "cycle?" "cycle?:" "elem" "seq")}
      {Lisp-Entry "previous-element" definition (public) ("seq" "elem" "(cycle?: cycle? #t)") #f #f 2742 20 2742 36 ("0" "max" "modulo" "previous" "1" "-" "not" "if" "element" "cardinality" "card" "find" "rank" "let" "cycle?" "cycle?:" "elem" "seq")}
      {Lisp-Entry "random-element" definition (public) ("seq") #f #f 2754 20 2754 34 ("cardinality" "random" "element" "seq")}
      {Lisp-Entry "partition" definition (public) ("sequence" "(key: key identity)" "(test: test #f)") #f #f 2758 20 2758 29 ("elements" "bind" "partition" "map" "reverse!" "cdr" "set-cdr!" "list" "cons" "set!" "not" "if" "associate" "pair" "category" "let*" "element" "lambda" "for-each" "result" "let" "test" "test:" "identity" "key" "key:" "sequence")}
      {Lisp-Entry "partition-binary" definition (public) ("lst" "predicate") #f #f 2773 20 2773 36 ("values" "cons" "set!" "if" "elem" "lambda" "for-each" "no" "yes" "let" "predicate" "lst")}
      {Lisp-Entry "starts-with?" definition (public) ("seq" "target" "(test: test #f)" "(ignore-case?: ignore-case? #f)") #f "<bool>" 2784 20 2784 32 ("0" "subseq" ">=" "and" "string=?" "string-ci=?" "if" "or" "tl" "cardinality" "sl" "let" "bool" "<bool>" "ignore-case?" "ignore-case?:" "test" "test:" "target" "seq")}
      {Lisp-Entry "ends-with?" definition (public) ("seq" "target" "(test: test #f)" "(ignore-case?: ignore-case? #f)") #f "<bool>" 2794 20 2794 30 ("-" "subseq" ">=" "and" "string=?" "string-ci=?" "if" "or" "tl" "cardinality" "sl" "let" "bool" "<bool>" "ignore-case?" "ignore-case?:" "test" "test:" "target" "seq")}
      {Lisp-Entry "for-each-reversed" definition (public) ("proc" "lst") #f #f 2804 20 2804 37 ("car" "cdr" "pair?" "when" "iterate" "let" "lst" "proc")}
      {Lisp-Entry "find-if-list" definition () ("predicate" "list" "key" "start" "returned") #f #f 2811 13 2811 25 ("1" "+" "cdr" "error" "else" "item" "position" "eq?" "car" "null?" "cond" "fx" "<fx>" "rank" "tail" "rest" "iter" "x" "lambda" "not" "if" "let" "returned" "start" "key" "list" "predicate")}
      {Lisp-Entry "insert-sequence!" definition (public inline) ("sequence" "pos" "seq") #f #f 2823 27 2823 43 ("replace-subseq!" "seq" "pos" "sequence")}
      {Lisp-Entry "Sequence-Explorer" class (package) ((extends . "Explorer")) #f #f 2832 15 2832 32 ("Explorer")
        {Lisp-Entry "sequence" slot () () #f "<Sequence>" 2835 8 2835 16 ("Sequence" "<Sequence>")}
        {Lisp-Entry "sequence-cardinality" slot () () #f "<fx>" 2836 8 2836 28 ("fx" "<fx>")}
        {Lisp-Entry "current" slot () () #f "<fx>" 2837 8 2837 15 ("fx" "<fx>")}
        {Lisp-Entry "initialize" method (override) ("seq" "(direction: direction 'forward)" "(start: start #f)") #f #f 2840 20 2840 30 ("current" "goto-end" "backward" "goto-beginning" "case" "not" "if" "set-direction" "cardinality" "sequence-cardinality" "sequence" "set!" "nextmethod" "start" "start:" "forward" "direction" "direction:" "seq")}
        {Lisp-Entry "peek-forward" method (override) () #f #f 2852 20 2852 32 ("current" "sequence" "element")}
        {Lisp-Entry "peek-backward" method (override) () #f #f 2856 20 2856 33 ("1" "current" "-" "sequence" "element")}
        {Lisp-Entry "goto-beginning" method (override) () #f #f 2860 20 2860 34 ("0" "current" "set!")}
        {Lisp-Entry "goto-end" method (override) () #f #f 2864 20 2864 28 ("sequence-cardinality" "current" "set!")}
        {Lisp-Entry "forward" method (override) () #f #f 2868 20 2868 27 ("1" "current" "increase!")}
        {Lisp-Entry "backward" method (override) () #f #f 2872 20 2872 28 ("1" "current" "decrease!")}
        {Lisp-Entry "done-forward?" method (override) () #f #f 2876 20 2876 33 ("sequence-cardinality" "current" ">=")}
        {Lisp-Entry "done-backward?" method (override) () #f #f 2880 20 2880 34 ("0" "current" "=")}
        {Lisp-Entry "put-forward" method (override) ("object" "<Object>") #f #f 2884 20 2884 31 ("current" "sequence" "set-element!" "Object" "<Object>" "object")}
        {Lisp-Entry "put-backward" method (override) ("object" "<Object>") #f #f 2888 20 2888 32 ("1" "current" "-" "sequence" "set-element!" "Object" "<Object>" "object")}
        {Lisp-Entry "get-position" method (override) () #f #f 2892 20 2892 32 ("current")}
        {Lisp-Entry "set-position" method (override) ("pos" "<fx>") #f #f 2896 20 2896 32 ("sequence-cardinality" "0" "between" "current" "set!" "fx" "<fx>" "pos")}
        {Lisp-Entry "get-state" method (override) () #f #f 2900 20 2900 29 ("current")}
        {Lisp-Entry "reset-state" method (override) ("state" "<fx>") #f #f 2904 20 2904 31 ("current" "set!" "fx" "<fx>" "state")}}
      {Lisp-Entry "List-Class" class () ((extends . "Sequence-Class")) #f #f 2913 7 2913 17 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 2916 20 2916 33 ("make-list" "len")}
        {Lisp-Entry "coerce-object" method (override) ("seq") #f #f 2920 20 2920 33 ("queue-list" "enqueue" "object" "lambda" "iterate" "new-queue" "queue" "let" "seq")}}
      {Lisp-Entry "List" class (primitive) ((metaclass . "List-Class") (extends . "Sequence")) #f #f 2928 17 2928 21 ("Sequence" "List-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 2931 20 2931 30 ("native-class" "rest")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 2935 20 2935 31 ("self" "subcopy" "if" "x" "lambda" "map" "deep?")}
        {Lisp-Entry "iterate-object" method (override) () #f #f 2943 20 2943 34 ("self" "List-Iterator" "new")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f "<any>" 2947 20 2947 36 ("self" "list-ref" "any" "<any>" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "<fx>" "obj" "<any>") #f "<void>" 2951 20 2951 41 ("self" "list-set!" "void" "<void>" "any" "<any>" "obj" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f "<fx>" 2955 20 2955 40 ("self" "length" "fx" "<fx>")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 2959 20 2959 33 ("1" "-" "cdr" "tail" "0" "=" "self" "null?" "or" "if" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 2965 20 2965 33 ("last" "car" "self" "cdr" "null?" "if")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 2971 20 2971 36 ("butlast" "car" "cons" "cdr" "self" "null?" "or" "if")}
        {Lisp-Entry "sequence-subseq!" method (override) ("start" "end") #f #f 2977 20 2977 36 ("subseq" "self" "-1" "0" "=" "or" "if" "end" "start")}
        {Lisp-Entry "replace-subseq!" method () ("start" "end" "seq") #f #f 2983 11 2983 26 ("+" "after" "1" "-" "before" "let*" "self" "tail" "last-tail" "set-cdr!" "begin" "0" "=" "if" "seq" "end" "start")}}
      {Lisp-Entry "Null-Class" class () ((extends . "List-Class")) #f #f 2995 7 2995 17 ("List-Class")}
      {Lisp-Entry "Null" class (primitive) ((metaclass . "Null-Class") (extends . "List")) #f #f 2998 17 2998 21 ("List" "Null-Class")
        {Lisp-Entry "compare-object" method (override) ("obj") #f #f 3001 20 3001 34 (":not-equal" ":equal" "null?" "if" "obj")}
        {Lisp-Entry "di-compare-object" method (override) ("obj") #f #f 3007 20 3007 37 (":not-equal" ":equal" "null?" "if" "obj")}}
      {Lisp-Entry "Pair-Class" class () ((extends . "List-Class")) #f #f 3013 7 3013 17 ("List-Class")}
      {Lisp-Entry "Pair" class (primitive) ((metaclass . "Pair-Class") (extends . "List")) #f #f 3016 17 3016 21 ("List" "Pair-Class")
        {Lisp-Entry "compare-object" method (override) ("obj") #f #f 3019 20 3019 34 (":not-equal" "else" "null?" "and" "cond" "right" "cdr" "left" "let" ":equal" ":greater" ":less" "self" "car" "compare" "case" "pair?" "if" "obj")}
        {Lisp-Entry "di-compare-object" method (override) ("obj") #f #f 3039 20 3039 37 (":not-equal" "else" "null?" "and" "cond" "right" "cdr" "left" "let" ":equal" ":greater" ":less" "self" "car" "di-compare" "case" "pair?" "if" "obj")}
        {Lisp-Entry "walk-references" method (override) ("proc") #f #f 3059 20 3059 35 ("cdr" "self" "car" "walk-references" "walk-references~" "proc")}
        {Lisp-Entry "setup-context" method (override) ("context") #f #f 3064 20 3064 33 ("cdr" "self" "car" "setup-context" "setup-context~" "context")}}
      {Lisp-Entry "element" specialize (inline) ("list" "<list>" "n") #f #f 3069 20 3069 27 ("int" "<int>" "cast" "list-ref" "any" "<any>" "n" "<list>" "list")}
      {Lisp-Entry "cardinality" specialize (inline) ("list" "<list>") #f #f 3073 20 3073 31 ("length" "int" "<int>" "<list>" "list")}
      {Lisp-Entry "insert!" definition (public) ("seq" "pos" "obj") #f #f 3077 20 3077 27 ("class-of" "list" "coerce" "cardinality" "or" "insert-sequence!" "obj" "pos" "seq")}
      {Lisp-Entry "atom?" definition (public) ("value") #f #f 3081 20 3081 25 ("number?" "keyword?" "symbol?" "string?" "char?" "boolean?" "null?" "or" "value")}
      {Lisp-Entry "null/pair?" definition (public inline) ("obj") #f #f 3091 27 3091 37 ("pair?" "null?" "or" "obj")}
      {Lisp-Entry "one-element?" definition (public inline) ("obj") #f #f 3095 27 3095 39 ("cdr" "null?" "pair?" "and" "obj")}
      {Lisp-Entry "last-tail" definition (public) ("lst") #f #f 3099 20 3099 29 ("cdr" "pair?" "cur" "iter" "let" "null?" "if" "lst")}
      {Lisp-Entry "make-list" definition (public) ("n" "." "rest") #f #f 3108 20 3108 29 ("1" "-" "cons" "set!" "0" ">" "while" "list" "car" "null?" "if" "fill" "let" "rest" "n")}
      {Lisp-Entry "list-set!" definition (public inline) ("list" "n" "value") #f #f 3117 27 3117 36 ("list-tail" "set-car!" "value" "n" "list")}
      {Lisp-Entry "set-cadr!" definition (public inline) ("pair" "value") #f #f 3121 27 3121 36 ("cdr" "set-car!" "value" "pair")}
      {Lisp-Entry "append!" definition (public) ("." "rest") #f #f 3125 20 3125 27 ("queue-list" "enqueue-list" "lst" "lambda" "for-each" "new-queue" "queue" "let" "rest")}
      {Lisp-Entry "position" definition (public) ("element" "lst") #f #f 3133 20 3133 28 ("0" "1" "+" "cdr" "else" "car" "eqv?" "null?" "cond" "pos" "position" "define" "lst" "element")}
      {Lisp-Entry "copy-tree" definition (public) ("tree") #f #f 3145 20 3145 29 ("cdr" "car" "copy-tree" "cons" "pair?" "if" "tree")}
      {Lisp-Entry "position-of" definition (public) ("obj" "lst") #f #f 3152 20 3152 31 ("1" "+" "cdr" "car" "eq?" "null?" "if" "0" "fx" "<fx>" "i" "rst" "iter" "let" "lst" "obj")}
      {Lisp-Entry "proper-list?" definition (public) ("lst") #f #f 3161 20 3161 32 ("cdr" "proper-list?" "else" "pair?" "not" "null?" "cond" "lst")}
      {Lisp-Entry "proper-length" definition (public) ("l") #f #f 3167 20 3167 33 ("0" "1" "+" "cdr" "pair?" "if" "n" "length" "define" "l")}
      {Lisp-Entry "last-cdr" definition (public) ("lst") #f #f 3176 20 3176 28 ("cdr" "last-cdr" "pair?" "if" "lst")}
      {Lisp-Entry "butlast-cdr" definition (public) ("lst") #f #f 3182 20 3182 31 ("cdr" "butlast-cdr" "car" "cons" "pair?" "if" "lst")}
      {Lisp-Entry "move-to-head!" definition (public) ("target" "lst") #f #f 3188 20 3188 33 ("else" "cons" "set-cdr!" "cond" "cdr" "scan" "previous" "iter" "let" "car" "eq?" "null?" "or" "if" "lst" "target")}
      {Lisp-Entry "move-to-tail!" definition (public) ("target" "lst") #f #f 3199 20 3199 33 ("begin" "if" "scan" "previous" "iter" "let" "else" "cdr" "cons" "last-tail" "set-cdr!" "car" "eq?" "null?" "cond" "lst" "target")}
      {Lisp-Entry "augment" definition (public) ("." "rest") #f #f 3218 20 3218 27 ("get-output" "get-output~" "set!" "put" "put~" "car" "put-sequence" "put-sequence~" "cdr" "null?" "if" "not-null?" "while" "scan" "List-Factory" "new" "fact" "let" "rest")}
      {Lisp-Entry "memq?" definition (public inline) ("target" "<Object>" "list" "<Object>") #f #f 3229 27 3229 32 ("memq" "boolean" "list" "Object" "<Object>" "target")}
      {Lisp-Entry "memv?" definition (public inline) ("target" "<Object>" "list" "<Object>") #f #f 3233 27 3233 32 ("memv" "boolean" "list" "Object" "<Object>" "target")}
      {Lisp-Entry "member?" definition (public) ("target" "<Object>" "list" "<Object>" "(key: key #f)" "(test: test equal?)") #f #f 3237 20 3237 27 ("cdr" "else" "car" "apply-key" "apply-test" "null?" "cond" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "Object" "<Object>" "target")}
      {Lisp-Entry "assq-value" definition (public) ("key" "list" "default-value") #f #f 3247 20 3247 30 ("cdr" "if" "assq" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "assv-value" definition (public) ("key" "list" "default-value") #f #f 3254 20 3254 30 ("cdr" "if" "assv" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "assoc-value" definition (public) ("key" "list" "default-value") #f #f 3261 20 3261 31 ("cdr" "if" "assoc" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "associate" definition (public) ("target" "<Object>" "list" "<Object>" "(key: key #f)" "(test: test equal?)") #f #f 3268 20 3268 29 ("cdr" "apply-key" "apply-test" "car" "pair" "null?" "if" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "Object" "<Object>" "target")}
      {Lisp-Entry "rassociate" definition (public) ("target" "<Object>" "list" "<Object>" "(key: key #f)" "(test: test equal?)") #f #f 3278 20 3278 30 ("cdr" "apply-key" "apply-test" "car" "pair" "null?" "if" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "Object" "<Object>" "target")}
      {Lisp-Entry "find-pair" definition (public) ("target" "<Object>" "list" "<Object>") #f #f 3288 20 3288 29 ("cdr" "else" "car" "eq?" "null?" "cond" "scan" "iter" "let" "list" "Object" "<Object>" "target")}
      {Lisp-Entry "reverse!" definition (public) ("list" "<Object>") #f #f 3298 20 3298 28 ("set-cdr!" "cdr" "set!" "not-null?" "while" "ptr" "res" "let" "Object" "<Object>" "list")}
      {Lisp-Entry "remove!" definition (public) ("target" "<Object>" "list" "<Object>" "(key: key #f)" "(test: test eqv?)") #f #f 3309 20 3309 27 ("set-cdr!" "begin" "scan" "previous" "let" "null?" "if" "cdr" "set!" "car" "apply-key" "not-null?" "and" "while" "eqv?" "test" "test:" "key" "key:" "list" "Object" "<Object>" "target")}
      {Lisp-Entry "getprop" definition (public) ("plist" "<Object>" "target" "<Object>" "(key: key #f)") #f #f 3326 20 3326 27 ("cddr" "else" "car" "apply-key" "eqv?" "null?" "cond" "scan" "iter" "let" "key" "key:" "target" "Object" "<Object>" "plist")}
      {Lisp-Entry "getf" definition (public) ("plist" "<Object>" "target" "<Object>" "(key: key #f)" "(not-found: not-found #f)") #f #f 3336 20 3336 24 ("cadr" "not" "if" "getprop" "pair" "let" "not-found" "not-found:" "key" "key:" "target" "Object" "<Object>" "plist")}
      {Lisp-Entry "setf" definition (public) ("plist" "<Object>" "target" "<Object>" "value" "<Object>") #f #f 3343 20 3343 24 ("getprop" "set-second!" "value" "target" "Object" "<Object>" "plist")}
      {Lisp-Entry "addf" definition (public) ("plist" "<Object>" "target" "<Object>" "value" "<Object>") #f #f 3347 20 3347 24 ("set-second!" "list" "append!" "not" "if" "getprop" "pair" "let" "value" "target" "Object" "<Object>" "plist")}
      {Lisp-Entry "for-each-pair" definition (public) ("proc" "lst") #f #f 3355 20 3355 33 ("cdr" "not-null?" "when" "iterate" "let" "lst" "proc")}
      {Lisp-Entry "for-each-property" definition (public) ("proc" "lst") #f #f 3362 20 3362 37 ("cddr" "cadr" "car" "not-null?" "when" "iterate" "let" "lst" "proc")}
      {Lisp-Entry "map-property" definition (public) ("proc" "lst") #f #f 3369 20 3369 32 ("queue-list" "enqueue" "value" "property" "lambda" "for-each-property" "new-queue" "queue" "let" "lst" "proc")}
      {Lisp-Entry "flatten" definition (public) ("llist") #f #f 3377 20 3377 27 ("append" "apply" "llist")}
      {Lisp-Entry "uniform" definition (public) ("lst" "(key: key #f)" "(test: test #f)") #f #f 3381 20 3381 27 ("cdr" "continuation-return" "apply-test" "unless" "value" "object" "for-each" "car" "apply-key" "first" "let" "return" "lambda" "continuation-capture" "null?" "if" "test" "test:" "key" "key:" "lst")}
      {Lisp-Entry "sort-property-list" definition (public) ("prop-list" "<Object>") #f #f 3395 20 3395 38 ("append" "apply" "car" "key:" "<" "sort" "sorted" "get-output" "get-output~" "for-each-property" "begin" "alist" "list" "put" "put~" "value" "property" "lambda" "proc" "List-Factory" "new" "factory" "let*" "Object" "<Object>" "prop-list")}
      {Lisp-Entry "plist->alist" definition (public) ("ls") #f #f 3406 20 3406 32 ("cadr" "car" "cons" "cddr" "reverse" "null?" "if" "res" "lp" "let" "ls")}
      {Lisp-Entry "alist->plist" definition (public) ("ls") #f #f 3413 20 3413 32 ("caar" "cdar" "cons" "cdr" "reverse" "null?" "if" "res" "lp" "let" "ls")}
      {Lisp-Entry "List-Iterator" class (package) ((extends . "Iterator")) #f #f 3425 15 3425 28 ("Iterator")
        {Lisp-Entry "current" slot () () #f #f 3428 8 3428 15 ()}
        {Lisp-Entry "position" slot () () #f #f 3429 8 3429 16 ()}
        {Lisp-Entry "initialize" method (override) ("list" "<list>") #f #f 3432 20 3432 30 ("0" "position" "current" "set!" "nextmethod" "<list>" "list")}
        {Lisp-Entry "get-next!" method (override) () #f #f 3438 20 3438 29 ("1" "+" "position" "cdr" "set!" "car" "prog1" "eof-object" "current" "null?" "if")}
        {Lisp-Entry "done?" method (override) () #f #f 3446 20 3446 25 ("Empty" "peeked" "eq?" "current" "null?" "and")}
        {Lisp-Entry "put" method (override) ("object") #f #f 3450 20 3450 23 ("current" "set-car!" "object")}
        {Lisp-Entry "get-position" method (override) () #f #f 3454 20 3454 32 ("position")}
        {Lisp-Entry "set-position" method (override) ("pos") #f #f 3458 20 3458 32 ("tail" "current" "set!" ">" "error" "0" "<" "cond" "position" "-" "delta" "let" "pos")}
        {Lisp-Entry "get-state" method (override) () #f #f 3466 20 3466 29 ("position" "current" "cons")}
        {Lisp-Entry "reset-state" method (override) ("state") #f #f 3470 20 3470 31 ("cdr" "position" "car" "current" "set!" "state")}
        {Lisp-Entry "get-list" method (public) () #f #f 3475 18 3475 26 ("current")}}
      {Lisp-Entry "List-Factory" class () ((extends . "Object")) #f #f 3484 7 3484 19 ("0" "Object")
        {Lisp-Entry "list" slot () ((initialize . "'()") (getter . "generate")) #f #f 3487 8 3487 12 ()}
        {Lisp-Entry "get-list" accessor () () #f #f 3487 46 3487 54 ()}
        {Lisp-Entry "last-list" slot () ((initialize . "#f")) #f #f 3488 8 3488 17 ()}
        {Lisp-Entry "last-anchor" slot () ((initialize . "#f")) #f #f 3489 8 3489 19 ()}
        {Lisp-Entry "current" slot () ((initialize . "'()")) #f #f 3490 8 3490 15 ()}
        {Lisp-Entry "size" slot () ((initialize . "0") (getter . "generate")) #f "<fx>" 3491 8 3491 12 ("fx" "<fx>")}
        {Lisp-Entry "get-size" accessor () () #f #f 3491 46 3491 54 ()}
        {Lisp-Entry "put" method () ("object" "<Object>") #f #f 3494 11 3494 14 ("increase!" "size" "prog1" "cdr" "set-cdr!" "copy-last-list" "last-list" "when" "else" "list" "cons" "set!" "current" "null?" "cond" "Object" "<Object>" "object")}
        {Lisp-Entry "put-unique" method () ("object" "(test: test eqv?)") #f #f 3507 11 3507 21 ("put" "list" "member?" "unless" "eqv?" "test" "test:" "object")}
        {Lisp-Entry "put-sequence" method () ("seq" "<Object>") #f #f 3512 11 3512 23 ("cardinality" "increase!" "size" "prog1" "set-cdr!" "last-anchor" "copy-last-list" "else" "list" "last-list" "set!" "current" "null?" "cond" "put" "iterate" "pair?" "not" "if" "when" "Object" "<Object>" "seq")}
        {Lisp-Entry "is-empty?" method (public) () #f #f 3530 18 3530 27 ("current" "null?")}
        {Lisp-Entry "get-last-element" method (public) () #f #f 3534 18 3534 34 ("current" "car")}
        {Lisp-Entry "get-output" method () () #f #f 3538 11 3538 21 ("list")}
        {Lisp-Entry "reset" method (public) () #f #f 3542 18 3542 23 ("0" "size" "current" "last-anchor" "last-list" "list" "set!")}
        {Lisp-Entry "copy-last-list" method (private) () #f #f 3550 19 3550 33 ("set-cdr!" "else" "last-tail" "current" "last-list" "copy" "list" "set!" "last-anchor" "not" "cond")}}
      {Lisp-Entry "Table" class (primitive) ((extends . "Object")) #f #f 3566 17 3566 22 ("Object")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 3569 20 3569 30 ("native-class" "rest")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 3573 20 3573 25 ("table-length" "system-format" "lambda" "self" "print-unreadable" "readably" "output")}}
      {Lisp-Entry "table-add" definition (public) ("table" "<Table>" "key" "value") #f #f 3580 20 3580 29 ("table-ref" "cons" "table-set!" "value" "key" "Table" "<Table>" "table")}
      {Lisp-Entry "table-remove!" definition (public) ("table" "<Table>" "name" "value") #f #f 3584 20 3584 33 ("table-ref" "remove!" "table-set!" "value" "name" "Table" "<Table>" "table")}
      {Lisp-Entry "empty-table" definition (public) ("table") #f #f 3588 20 3588 31 ("table-clear" "v" "k" "lambda" "iterate-table" "table")}
      {Lisp-Entry "table-keys" definition (public) ("table") #f #f 3594 20 3594 30 ("cons" "set!" "value" "key" "lambda" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-values" definition (public) ("table") #f #f 3602 20 3602 32 ("cons" "set!" "value" "key" "lambda" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-keys/values" definition (public) ("table") #f #f 3610 20 3610 37 ("cons" "set!" "value" "key" "lambda" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-find" definition (public) ("table" "value" "(test: test eqv?)") #f #f 3618 20 3618 30 ("continuation-return" "when" "v" "k" "iterate-table" "return" "lambda" "continuation-capture" "eqv?" "test" "test:" "value" "table")}
      {Lisp-Entry "table-load" definition (public) ("table" "input" "error-on-duplicates?") #f #f 3628 20 3628 30 ("table-set!" "error" "table-ref" "if" "eof-object?" "not" "and" "when" "object" "read" "name" "iterate" "let" "error-on-duplicates?" "input" "table")}
      {Lisp-Entry "Slot" class () ((extends . "Field")) #f #f 3645 7 3645 11 ("Field")
        {Lisp-Entry "offset" slot () ((getter . "generate")) #f #f 3648 8 3648 14 ()}
        {Lisp-Entry "get-offset" accessor () () #f #f 3648 26 3648 34 ()}
        {Lisp-Entry "initialize" slot () ((getter . "generate")) #f #f 3649 8 3649 18 ()}
        {Lisp-Entry "get-initialize" accessor () () #f #f 3649 26 3649 34 ()}}
      {Lisp-Entry "Property" class () ((extends . "Slot")) #f #f 3657 7 3657 15 ("Slot")
        {Lisp-Entry "getter" slot () ((getter . "generate")) #f #f 3660 8 3660 14 ()}
        {Lisp-Entry "get-getter" accessor () () #f #f 3660 22 3660 30 ()}
        {Lisp-Entry "setter" slot () ((getter . "generate")) #f #f 3661 8 3661 14 ()}
        {Lisp-Entry "get-setter" accessor () () #f #f 3661 22 3661 30 ()}}
      {Lisp-Entry "property?" definition (public inline) ("obj") #f #f 3664 27 3664 36 ("Property" "is?" "obj")}
      {Lisp-Entry "symbolize-property" definition (public) ("property" "<Object>") #f #f 3668 20 3668 38 ("else" "keyword->symbol" "keyword?" "get-name" "get-name~" "field?" "cond" "Object" "<Object>" "property")}
      {Lisp-Entry "symbolize-properties" definition (public) ("properties" "<Object>") #f #f 3674 20 3674 40 ("get-output" "get-output~" "symbolize-property" "put" "put~" "value" "property" "lambda" "for-each-property" "List-Factory" "new" "fact" "let" "Object" "<Object>" "properties")}
      {Lisp-Entry "keywordize-property" definition (public) ("property" "<Object>") #f #f 3684 20 3684 39 ("else" "keyword?" "field-name" "symbol->keyword" "field?" "cond" "Object" "<Object>" "property")}
      {Lisp-Entry "keywordize-properties" definition (public) ("properties" "<Object>") #f #f 3690 20 3690 41 ("get-output" "get-output~" "keywordize-property" "put" "put~" "value" "property" "lambda" "for-each-property" "List-Factory" "new" "fact" "let" "Object" "<Object>" "properties")}
      {Lisp-Entry "read-property" definition (public) ("object" "<Object>" "expr" "<Object>") #f #f 3700 20 3700 33 ("error" "if" "class-of" "property-field" "property-getter" "getter" "let" "expr" "Object" "<Object>" "object")}
      {Lisp-Entry "write-property" definition (public) ("object" "<Object>" "expr" "<Object>" "value" "<Object>") #f #f 3707 20 3707 34 ("error" "if" "class-of" "property-field" "property-setter" "setter" "let" "value" "expr" "Object" "<Object>" "object")}
      {Lisp-Entry "property-field" definition (public) ("class" "<Class>" "expr" "<Object>") #f #f 3714 20 3714 34 ("error" "category-field" "field" "let" "property?" "if" "else" "enumerator->symbol" "enumerator?" "keyword->symbol" "keyword?" "cond" "property->symbol" "define" "Object" "<Object>" "expr" "Class" "<Class>" "class")}
      {Lisp-Entry "property-field?" definition (public) ("class" "<Class>" "symbol" "<symbol>") #f #f 3728 20 3728 35 ("category-field" "boolean" "<symbol>" "symbol" "Class" "<Class>" "class")}
      {Lisp-Entry "String-Class" class () ((extends . "Sequence-Class")) #f #f 3737 7 3737 19 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 3740 20 3740 33 ("make-string" "len")}
        {Lisp-Entry "coerce-object" method (override) ("obj" "<Object>") #f #f 3744 20 3744 33 ("coerce-string" "coerce-string~" "Object" "<Object>" "obj")}}
      {Lisp-Entry "String" class (primitive) ((metaclass . "String-Class") (extends . "Sequence")) #f #f 3748 17 3748 23 ("Sequence" "String-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 3751 20 3751 30 ("native-class" "rest")}
        {Lisp-Entry "coerce-string" method (override) () #f #f 3755 20 3755 33 ("self")}
        {Lisp-Entry "compare-object" method (override) ("obj") #f #f 3759 20 3759 34 (":incompatible" ":greater" "else" ":less" "string<?" ":equal" "self" "string=?" "cond" "string?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" method (override) ("obj") #f #f 3771 20 3771 37 (":incompatible" ":greater" "else" ":less" "string-ci<?" ":equal" "self" "string-ci=?" "cond" "string?" "if" "obj")}
        {Lisp-Entry "sequence-element" method (override) ("n" "<fx>") #f "<any>" 3783 20 3783 36 ("self" "string-ref" "any" "<any>" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "<fx>" "obj" "<any>") #f "<void>" 3787 20 3787 41 ("self" "string-set!" "void" "<void>" "any" "<any>" "obj" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f "<fx>" 3791 20 3791 40 ("self" "string-length" "fx" "<fx>")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 3795 20 3795 33 ("substring" ">=" "if" "self" "cardinality" "lgt" "let" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 3802 20 3802 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 3806 20 3806 36 ("1" "cardinality" "-" "0" "self" "substring")}}
      {Lisp-Entry "=" specialize (inline) ("s1" "<string>" "s2" "<string>") #f #f 3810 20 3810 21 ("string=?" "bool" "<bool>" "s2" "string" "<string>" "s1")}
      {Lisp-Entry "element" specialize (inline) ("string" "<string>" "n") #f #f 3814 20 3814 27 ("int" "<int>" "cast" "string-ref" "char" "<char>" "n" "<string>" "string")}
      {Lisp-Entry "set-element!" specialize (inline) ("string" "<string>" "n" "c") #f #f 3818 20 3818 32 ("char" "<char>" "int" "<int>" "cast" "string-set!" "void" "<void>" "c" "n" "<string>" "string")}
      {Lisp-Entry "cardinality" specialize (inline) ("string" "<string>") #f #f 3822 20 3822 31 ("string-length" "int" "<int>" "<string>" "string")}
      {Lisp-Entry "subseq" specialize (inline) ("string" "<string>" "start" "end") #f #f 3826 20 3826 26 ("int" "<int>" "cast" "substring" "end" "start" "<string>" "string")}
      {Lisp-Entry "replace-subseq!" specialize () ("string" "<string>" "start" "end" "replacement") #f #f 3830 13 3830 28 ("cardinality" "int" "<int>" "cast" "0" "subseq" "string-append" "replacement" "end" "start" "<string>" "string")}
      {Lisp-Entry "empty-string?" definition (public) ("object") #f #f 3845 20 3845 33 ("string-length" "zero?" "string?" "and" "object")}
      {Lisp-Entry "->string" definition (public) ("expr" "(detail :human)") #f #f 3850 20 3850 28 ("get-output-string" "print" "open-output-string" "output" "let" "eq?" "string?" "and" "if" ":human" "detail" "expr")}
      {Lisp-Entry "remove-trailing-char" definition (public) ("string" "c") #f #f 3858 20 3858 40 ("subseq" "1" "-" "element" "eqv?" "0" ">" "and" "if" "cardinality" "len" "let" "c" "string")}
      {Lisp-Entry "value-string?" definition (public) ("object" "<Object>") #f #f 3866 20 3866 33 ("empty-string?" "not" "string?" "and" "Object" "<Object>" "object")}
      {Lisp-Entry "wi=" definition (public) ("s1" "<Object>" "s2" "<Object>") #f #f 3871 20 3871 23 ("else" "eqv?" "eq?" "continuation-return" "cond" "when" ">=" "increase!" "element" "whitechar?" "and" "set!" "not" "or" "while" "d2?" "=" "d1?" "w2?" "w1?" "bool" "<bool>" "s?" "l2" "cardinality" "l1" "n2" "0" "fx" "<fx>" "n1" "let*" "return" "lambda" "continuation-capture" "s2" "Object" "<Object>" "s1")}
      {Lisp-Entry "unique-domain-name" definition (public) ("name" "domain" "(separator: separator #f)") #f #f 3911 20 3911 38 ("increase!" "->string" "set!" "iterate" "let" "suffix" "1" "n" "subseq" "starts-with?" "when" "string" "lambda" "collect" "suffixes" "cardinality" "common-length" "concatenate" "common-prefix" "let*" "member?" "not" "if" "separator" "separator:" "domain" "name")}
      {Lisp-Entry "remove-numeric-suffix" definition (public) ("string") #f #f 3931 20 3931 41 ("1" "+" "0" "subseq" "if" "position" "return:" "reversed?:" "numeric?" "not" "c" "lambda" "find-if" "pos" "let" "string")}
      {Lisp-Entry "compare-n" definition (public) ("x" "y" "max" "(test: test eqv?)") #f #f 3938 20 3938 29 ("1" "+" "string-ref" "not" "or" ">=" "if" "0" "n" "iter" "ylen" "string-length" "xlen" "let" "eqv?" "test" "test:" "max" "y" "x")}
      {Lisp-Entry "string-checksum" definition (public) ("str") #f #f 3949 20 3949 35 ("1" "+" "string-ref" "char->integer" "increase!" "<" "when" "n" "iter" "string-length" "len" "0" "sum" "let" "str")}
      {Lisp-Entry "split-lines" definition (public) ("string") #f #f 3959 20 3959 31 ("read-lines" "call-with-input-string" "string")}
      {Lisp-Entry "join-lines" definition (public) ("lines") #f #f 3964 20 3964 30 ("join" "lines")}
      {Lisp-Entry "seconds->milliseconds" definition (public) ("x") #f #f 3973 20 3973 41 ("1000" "*" "fxround" "x")}
      {Lisp-Entry "milliseconds->seconds" definition (public) ("x") #f #f 3976 20 3976 41 ("1000." "/" "x")}
      {Lisp-Entry "seconds->microseconds" definition (public) ("x") #f #f 3980 20 3980 41 ("1000000" "*" "fxround" "x")}
      {Lisp-Entry "microseconds->seconds" definition (public) ("x") #f #f 3983 20 3983 41 ("1000000." "/" "x")}
      {Lisp-Entry "primordial-thread-object" definition () () #f #f 3992 12 3992 36 ("current-thread")}
      {Lisp-Entry "primordial-thread" definition (public) () #f #f 3996 20 3996 37 ("primordial-thread-object")}
      {Lisp-Entry "primordial-thread?" definition (public) () #f #f 4000 20 4000 38 ("primordial-thread" "current-thread" "eq?")}
      {Lisp-Entry "new-thread" definition (public) ("thunk" "." "rest") #f #f 4004 20 4004 30 ("make-root-thread" "apply" "rest" "thunk")}
      {Lisp-Entry "top-threads" definition (public) () #f #f 4010 20 4010 31 ("primordial-thread" "thread-thread-group" "thread-group->thread-list")}
      {Lisp-Entry "present-thread-name" definition (public) ("name") #f #f 4014 20 4014 39 ("->string" "else" "unspecified?" "not" "or" "cond" "name")}
      {Lisp-Entry "present-thread-state" definition (public) ("state") #f #f 4019 20 4019 40 ("get-output-string" "else" "when" "write" "thread-state-active-timeout" "thread-state-active-waiting-for" "wf" "thread-state-active?" "thread-state-abnormally-terminated?" "thread-state-normally-terminated?" "thread-state-initialized?" "system-format" "thread-state-uninitialized?" "cond" "10." "*" "round" "/" "current-systime" "systime->seconds" "-" "expiry" "display" "to" "write-timeout" "define" "open-output-string" "port" "let" "state")}
      {Lisp-Entry "safe-present-object" definition (public) ("object" "(max-width #f)") #f #f 4057 20 4057 39 ("object->string" "if" "object->serial" "number->string" "class-of" "category-name" "symbol->string" "string-append" "class-string" "let" "exc" "lambda" "with-exception-catcher" "max-width" "object")}
      {Lisp-Entry "safe-present-property" definition (public) ("object" "slot") #f #f 4074 20 4074 41 ("read-property" "exc" "lambda" "with-exception-catcher" "slot" "object")}
      {Lisp-Entry "thread-loop?" definition (package) ("thread") #f #f 4082 21 4082 33 ("thread-specific" "thread")}
      {Lisp-Entry "thread-start-loop" definition (package) ("thread") #f #f 4085 21 4085 38 ("thread-specific-set!" "thread")}
      {Lisp-Entry "thread-stop-loop" definition (package) ("thread") #f #f 4088 21 4088 37 ("thread-specific-set!" "thread")}
      {Lisp-Entry "thread-loop" definition (package) () #f #f 4092 21 4092 32 ("current-thread" "thread-loop?" "when" "thread-read" "thunk" "loop" "let")}
      {Lisp-Entry "start-loop-thread" definition (public) ("." "rest") #f #f 4100 20 4100 37 ("thread-start!" "thread-start-loop" "thread-loop" "new-thread" "apply" "thread" "let" "rest")}
      {Lisp-Entry "thread-ports" definition () () #f #f 4107 12 4107 24 ("weak-keys:" "eq?" "test:" "make-table")}
      {Lisp-Entry "thread-ports-mutex" definition () () #f #f 4110 12 4110 30 ("thread-ports" "make-mutex")}
      {Lisp-Entry "thread-has-port?" definition (package) ("thread") #f #f 4114 21 4114 37 ("thread-ports" "table-ref" "boolean" "thread")}
      {Lisp-Entry "get-thread-port" definition () ("thread") #f #f 4118 13 4118 28 ("mutex-unlock!" "table-set!" "open-vector" "port" "let" "thread-ports" "table-ref" "or" "prog1" "thread-ports-mutex" "mutex-lock!" "thread")}
      {Lisp-Entry "thread-write" definition (package) ("thread" "value") #f #f 4127 21 4127 33 ("force-output" "write" "get-thread-port" "thread-port" "let" "value" "thread")}
      {Lisp-Entry "thread-read" definition (package) ("(timeout: timeout +infinity)") #f #f 4133 21 4133 32 ("read" "input-port-timeout-set!" "current-thread" "get-thread-port" "thread-port" "let" "+infinity" "timeout" "timeout:")}
      {Lisp-Entry "thread-read-non-blocking" definition (package) () #f #f 4139 21 4139 45 ("read" "0" "input-port-timeout-set!" "current-thread" "get-thread-port" "thread-port" "let")}
      {Lisp-Entry "thread-post" definition (public) ("thread" "name" "thunk") #f #f 4145 20 4145 31 ("thread-write" "current-thread" "eq?" "if" "thunk" "name" "thread")}
      {Lisp-Entry "thread-execute" definition (public) ("thread" "name" "thunk") #f #f 4151 20 4151 34 ("mutex-unlock!" "unwind-protect" "lambda" "thread-write" "mutex-lock!" "make-mutex" "mutex" "let" "current-thread" "eq?" "if" "thunk" "name" "thread")}
      {Lisp-Entry "thread-call-noresult" definition () () #f #f 4164 12 4164 32 ("thread-call-noresult" "list")}
      {Lisp-Entry "thread-call-result?" definition (package) ("result") #f #f 4168 21 4168 40 ("thread-call-noresult" "neq?" "result")}
      {Lisp-Entry "thread-call" definition (public) ("thread" "name" "thunk") #f #f 4172 20 4172 31 ("mutex-specific" "mutex-unlock!" "unwind-protect" "lambda" "thread-write" "thread-call-noresult" "mutex-specific-set!" "mutex-lock!" "make-mutex" "mutex" "eq?" "if" "current-thread" "delegator" "let" "thunk" "name" "thread")}
      {Lisp-Entry "thread-exit" definition (public) () #f #f 4188 20 4188 31 ("pristine-thread-continuation" "continuation-return")}
      {Lisp-Entry "sleep" definition (public) ("delay") #f #f 4192 20 4192 25 ("thread-sleep!" "delay")}
      {Lisp-Entry "is-not?" definition (public inline) ("object" "type") #f #f 4201 27 4201 34 ("is?" "not" "type" "object")}
      {Lisp-Entry "category-identifier" definition (public) () #f #f 4205 19 4205 38 ("get-category-identifier")}
      {Lisp-Entry "category-descendants" definition (public) () #f #f 4208 19 4208 39 ("get-category-descendants")}
      {Lisp-Entry "class-ascendant" definition (public) () #f #f 4211 19 4211 34 ("get-class-ascendant")}
      {Lisp-Entry "category-name" definition (public inline) ("category") #f #f 4215 27 4215 40 ("category-identifier" "reference-name" "category")}
      {Lisp-Entry "category-unit" definition (public inline) ("category") #f #f 4219 27 4219 40 ("category-identifier" "reference-unit" "category")}
      {Lisp-Entry "either" definition (public) ("." "rest") #f #f 4229 20 4229 26 ("unspecified" "continuation-return" "specified?" "when" "value" "for-each" "return" "lambda" "continuation-capture" "rest")}
      {Lisp-Entry "Vector-Class" class () ((extends . "Sequence-Class")) #f #f 4244 7 4244 19 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 4247 20 4247 33 ("make-vector" "len")}}
      {Lisp-Entry "Vector" class (primitive) ((metaclass . "Vector-Class") (extends . "Sequence")) #f #f 4251 17 4251 23 ("Sequence" "Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 4254 20 4254 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 4259 11 4259 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 4265 20 4265 36 ("self" "vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 4269 20 4269 41 ("self" "vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 4273 20 4273 40 ("self" "vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 4277 20 4277 33 ("self" "vector->list" "tail" "list->vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 4281 20 4281 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 4285 20 4285 36 ("self" "vector->list" "butlast" "list->vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<vector>" "n") #f #f 4289 20 4289 27 ("int" "<int>" "cast" "vector-ref" "object" "<object>" "n" "<vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<vector>" "n" "obj") #f #f 4293 20 4293 32 ("int" "<int>" "cast" "vector-set!" "void" "<void>" "obj" "n" "<vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<vector>") #f #f 4297 20 4297 31 ("vector-length" "int" "<int>" "<vector>" "vector")}
      {Lisp-Entry "AXIS_MIN_SIZE" definition () () #f #f 4306 12 4306 25 ("8")}
      {Lisp-Entry "AXIS_GOLDEN_RATIO" definition () () #f #f 4307 12 4307 29 ("1.6")}
      {Lisp-Entry "Axis-Class" class () ((extends . "Sequence-Class")) #f #f 4310 7 4310 17 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 4313 20 4313 33 ("Axis" "new" "len")}}
      {Lisp-Entry "Axis" class () ((metaclass . "Axis-Class") (extends . "Sequence")) #f #f 4317 7 4317 11 ("Sequence" "Axis-Class")
        {Lisp-Entry "size" slot () ((accessors . "generate")) #f "<fx>" 4320 8 4320 12 ("fx" "<fx>")}
        {Lisp-Entry "get-size" accessor () () #f #f 4320 35 4320 43 ()}
        {Lisp-Entry "set-size" accessor () () #f #f 4320 35 4320 43 ()}
        {Lisp-Entry "content" slot () ((accessors . "generate")) #f "<vector>" 4321 8 4321 15 ("vector" "<vector>")}
        {Lisp-Entry "get-content" accessor () () #f #f 4321 35 4321 43 ()}
        {Lisp-Entry "set-content" accessor () () #f #f 4321 35 4321 43 ()}
        {Lisp-Entry "initialize" method (override) ("s" "<fx>") #f #f 4324 20 4324 30 ("make-vector" "content" "size" "set!" "fx" "<fx>" "s")}
        {Lisp-Entry "print" method (override) ("output" "detail") #f #f 4329 20 4329 25 ("content" "size" "system-format" "lambda" "self" "print-unreadable" "detail" "output")}
        {Lisp-Entry "sequence-element" method (override) ("n" "<fx>") #f "<any>" 4335 20 4335 36 ("self" "element" "any" "<any>" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "<fx>" "obj" "<any>") #f "<void>" 4339 20 4339 41 ("self" "set-element!" "void" "<void>" "any" "<any>" "obj" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f "<fx>" 4343 20 4343 40 ("self" "cardinality" "fx" "<fx>")}
        {Lisp-Entry "sequence-tail" method (override) ("n" "<fx>") #f "<Axis>" 4347 20 4347 33 ("self" "tail" "Axis" "<Axis>" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f "<any>" 4351 20 4351 33 ("self" "last" "any" "<any>")}}
      {Lisp-Entry "axis" definition (public) ("." "rest") #f #f 4355 20 4355 24 ("Axis" "coerce" "rest")}
      {Lisp-Entry "element" specialize (inline) ("axis" "<Axis>" "n") #f #f 4359 20 4359 27 ("fx" "<fx>" "cast" "get-content" "get-content~" "vector-ref" "any" "<any>" "n" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "set-element!" specialize (inline) ("axis" "<Axis>" "n" "obj") #f #f 4363 20 4363 32 ("fx" "<fx>" "cast" "get-content" "get-content~" "vector-set!" "void" "<void>" "obj" "n" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "cardinality" specialize (inline) ("axis" "<Axis>") #f #f 4367 20 4367 31 ("get-size" "get-size~" "fx" "<fx>" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "tail" specialize () ("axis" "<Axis>" "n") #f #f 4371 13 4371 17 ("1" "+" "element" "set-element!" ">=" "if" "0" "i" "iter" "get-size" "get-size~" "-" "offset" "new" "new-axis" "fx" "<fx>" "cast" "let" "n" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "last" specialize () ("axis" "<Axis>") #f #f 4382 13 4382 17 ("1" "get-size" "get-size~" "-" "element" "any" "<any>" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "insert!" specialize () ("axis" "<Axis>" "pos" "obj") #f #f 4386 13 4386 20 ("list" "replace-subseq!" "fx" "<fx>" "cast" "let" "obj" "pos" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "replace-subseq!" specialize () ("axis" "<Axis>" "start" "end" "replacement") #f #f 4391 13 4391 28 ("axis-grow" "1" "element" "set-element!" "0" ">" "when" "dst" "src" "n" "iter" "<" "cond" "+" "new-size" "get-size" "get-size~" "old-size" "delta" "cardinality" "after" "-" "before" "let*" "list" "<list>" "fx" "<fx>" "cast" "let" "replacement" "end" "start" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "axis-remove!" definition (public) ("axis" "<Axis>" "element" "<any>") #f "<void>" 4424 20 4424 32 ("replace-subseq!" "1" "+" "end" "fx" "<fx>" "start" "let*" "when" "find" "n" "let" "void" "<void>" "any" "<any>" "element" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "axis-grow" definition (public) ("axis" "<Axis>" "n" "<fx>") #f #f 4432 20 4432 29 ("1" "+" "element" "set-element!" "begin" "<" "when" "i" "iter" "AXIS_GOLDEN_RATIO" "*" "fxround" "old-content" "old-real-size" "let" "else" "AXIS_MIN_SIZE" "make-vector" "set-content" "set-content~" "0" "get-size" "get-size~" "=" "set-size" "set-size~" "get-content" "get-content~" "cardinality" "<=" "cond" "fx" "<fx>" "n" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "axis-add" definition (public) ("axis" "<Axis>" "obj") #f #f 4450 20 4450 28 ("set-element!" "1" "+" "axis-grow" "cardinality" "size" "let" "obj" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "allocate-axis" definition (public inline) ("size" "<fx>") #f #f 4456 27 4456 40 ("make-vector" "Axis" "allocate" "fx" "<fx>" "size")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Axis>>" "size") #f #f 4459 20 4459 23 ("allocate-axis" "Axis" "<Axis>" "size" "category<Axis>" "<category<Axis>>" "class")}
      {Lisp-Entry "axis-ref" specialize (inline) () #f #f 4463 22 4463 30 ()}
      {Lisp-Entry "element" specialize (inline) ("axis" "<Axis>" "n") ("axis-ref") #f 4463 32 4463 39 ("fx" "<fx>" "cast" "get-content" "get-content~" "vector-ref" "object" "<object>" "n" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "axis-set!" specialize (inline) () #f #f 4467 22 4467 31 ()}
      {Lisp-Entry "set-element!" specialize (inline) ("axis" "<Axis>" "n" "obj") ("axis-set!") #f 4467 33 4467 45 ("fx" "<fx>" "cast" "get-content" "get-content~" "vector-set!" "void" "<void>" "obj" "n" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "axis-cardinality" specialize (inline) () #f #f 4471 22 4471 38 ()}
      {Lisp-Entry "cardinality" specialize (inline) ("axis" "<Axis>") ("axis-cardinality") #f 4471 40 4471 51 ("get-size" "get-size~" "int" "<int>" "Axis" "<Axis>" "axis")}
      {Lisp-Entry "dispatch?" definition (public) ("expr") #f #f 4485 20 4485 29 ("symbol->string" "dispatch-string?" "symbol?" "and" "expr")}
      {Lisp-Entry "dispatch-string?" definition (public) ("str") #f #f 4490 20 4490 36 ("string=?" "not" "ends-with?" "and" "str")}
      {Lisp-Entry "dispatch->name" definition (public) ("dispatch") #f #f 4495 20 4495 34 ("symbol->string" "string->symbol" "string?" "if" "1" "cardinality" "-" "0" "subseq" "str" "extract" "define" "dispatch")}
      {Lisp-Entry "Enumeration" class () ((extends . "Class")) #f #f 4509 7 4509 18 ("Class")
        {Lisp-Entry "members" slot () ((initialize . "'()") (accessors . "generate")) #f #f 4512 8 4512 15 ()}
        {Lisp-Entry "get-members" accessor () () #f #f 4512 41 4512 49 ()}
        {Lisp-Entry "set-members" accessor () () #f #f 4512 41 4512 49 ()}
        {Lisp-Entry "add-member" method () ("member") #f #f 4515 11 4515 21 ("list" "append!" "members" "set!" "member")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 4519 20 4519 25 ("members" "system-format" "lambda" "self" "print-unreadable" "readably" "output")}
        {Lisp-Entry "name->member" method () ("name") #f #f 4525 11 4525 23 ("self" "error" "eq?" "test:" "get-name" "get-name~" "key:" "members" "find-in" "or" "name")}
        {Lisp-Entry "value->member" method () ("value") #f #f 4530 11 4530 24 ("self" "error" "eqv?" "test:" "get-value" "get-value~" "key:" "members" "find-in" "or" "value")}
        {Lisp-Entry "name->value" method (public) ("name") #f #f 4535 18 4535 29 ("name->member" "get-value" "get-value~" "name")}
        {Lisp-Entry "value->name" method (public) ("value") #f #f 4539 18 4539 29 ("value->member" "get-name" "get-name~" "value")}
        {Lisp-Entry "bits->names" method (public) ("bits") #f #f 4543 18 4543 29 ("get-output" "get-output~" "members" "get-name" "get-name~" "put" "put~" "get-value" "get-value~" "mask-bit-set?" "when" "member" "lambda" "for-each" "List-Factory" "new" "fact" "let" "bits")}}
      {Lisp-Entry "Enumeration-Member" class () ((metaclass . "Enumeration") (extends . "Object")) #f #f 4552 7 4552 25 ("Object" "Enumeration")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 4555 8 4555 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 4555 20 4555 28 ()}
        {Lisp-Entry "initialize" method (override) ("name") #f #f 4558 20 4558 30 ("class-of" "add-member" "add-member~" "self" "name~self" "set!" "nextmethod" "name")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 4564 20 4564 25 ("name" "system-format" "lambda" "self" "print-unreadable" "readably" "output")}
        {Lisp-Entry "get-value" method (protected virtual) () #f #f 4570 29 4570 38 ()}}
      {Lisp-Entry "enumeration?" definition (public) ("obj") #f #f 4574 20 4574 32 ("Enumeration" "is?" "obj")}
      {Lisp-Entry "reference-string?" definition (public) ("str") #f #f 4583 20 4583 37 ("string-ends-with?" "string-starts-with?" "not" "string-find-reversed" "and" "str")}
      {Lisp-Entry "reference->name" definition (public) ("str") #f #f 4589 20 4589 35 ("string-length" "1" "+" "substring" "not" "if" "string-find-reversed" "pos" "let" "str")}
      {Lisp-Entry "parse-file" definition (inline) ("file") #f #f 4601 20 4601 30 ("parse" "parse~" "string?" "if" "file")}
      {Lisp-Entry "make-u8-content" definition (public undocumented) ("size" "content") #f #f 4607 33 4607 48 ("cons" "content" "size")}
      {Lisp-Entry "u8-content-size" definition (public undocumented) ("content") #f #f 4610 33 4610 48 ("car" "content")}
      {Lisp-Entry "iterate-u8-content" definition (public undocumented) ("content" "proc") #f #f 4613 33 4613 51 ("cdr" "size" "u8vector" "bind" "chunk" "lambda" "for-each" "proc" "content")}
      {Lisp-Entry "read-u8-content" definition (public undocumented) ("port") #f #f 4620 33 4620 48 ("cons" "put" "put~" "increase!" "get-output" "get-output~" "make-u8-content" "=" "if" "read-subu8vector" "read" "make-u8vector" "u8vector" "loop" "List-Factory" "new" "fact" "0" "size" "let" "1024" "chunk-size" "define" "port")}
      {Lisp-Entry "write-u8-content" definition (public undocumented) ("content" "port") #f #f 4636 33 4636 49 ("0" "write-subu8vector" "size" "u8vector" "lambda" "iterate-u8-content" "port" "content")}
      {Lisp-Entry "start-pump" definition (public undocumented) ("port" "proc") #f #f 4642 33 4642 43 ("substring" ">" "if" "1" "0" "read-substring" "n" "iterate" "make-string" "buffer" "1000" "size" "let" "proper-tail-calls" "declare" "proc" "port")}
      {Lisp-Entry "read-until" definition (public) ("test" "input") #f #f 4660 20 4660 30 ("enqueue" "queue-list" "if" "read" "expr" "iterate" "new-queue" "queue" "let" "input" "test")}
      {Lisp-Entry "read-string-element" definition (public) ("string") #f #f 4670 20 4670 39 ("read" "call-with-input-string" "string")}
      {Lisp-Entry "read-string-content" definition (public) ("string") #f #f 4675 20 4675 39 ("eof-object?" "read-until" "input" "lambda" "call-with-input-string" "string")}
      {Lisp-Entry "read-delimited-string" definition (public) ("string" "char") #f #f 4681 20 4681 41 ("get-output" "get-output~" "peek-char" "eof-object?" "if" "skip-whites" "put" "put~" "read-delimited" "lst" "iterate" "List-Factory" "new" "fact" "let" "input" "lambda" "call-with-input-string" "char" "string")}
      {Lisp-Entry "require-char" definition (public) ("input") #f #f 4694 20 4694 32 ("error" "eof-object?" "if" "read-char" "c" "let" "input")}
      {Lisp-Entry "skip-line" definition (public) ("input") #f #f 4701 20 4701 29 ("eqv?" "eof-object?" "not" "and" "if" "read-char" "c" "iterate" "let" "input")}
      {Lisp-Entry "skip-whites" definition (public) ("input") #f #f 4712 20 4712 31 ("read-char" "whitespace?" "when" "skip-line" "eqv?" "if" "eof-object?" "unless" "peek-char" "c" "iterate" "let" "input")}
      {Lisp-Entry "read-delimited" definition (public) ("input" "kind" "delimiter" "(allow-eof? #f)") #f #f 4723 20 4723 34 ("enqueue" "else" "read" "enqueue-list" "read-char" "eqv?" "error" "queue-list" "if" "eof-object?" "cond" "peek-char" "c" "skip-whites" "iterate" "new-queue" "queue" "let" "allow-eof?" "delimiter" "kind" "input")}
      {Lisp-Entry "string-delimiter?" definition (public inline) ("c") #f #f 4743 27 4743 44 ("eqv?" "c")}
      {Lisp-Entry "read-lines" definition (public) ("input") #f #f 4747 20 4747 30 ("queue-list" "when" "enqueue" "begin" "if" "read-proper-line" "proper?" "line" "receive" "last-proper?" "iterate" "new-queue" "queue" "let" "proper-tail-calls" "declare" "input")}
      {Lisp-Entry "read-lines-chunked" definition (public) ("input" "chunk-size" "proc") #f #f 4761 20 4761 38 ("unspecified" ">" "when" "queue-list" "<" "not" "or" "1" "+" "enqueue" "begin" "if" "read-proper-line" "proper?" "line" "receive" "last-proper?" "new-queue" "queue" "0" "count" "iterate" "let" "proper-tail-calls" "declare" "proc" "chunk-size" "input")}
      {Lisp-Entry "read-content-string" definition (public) ("input") #f #f 4780 20 4780 39 ("eof-object?" "if" "read-line" "line" "let" "input")}
      {Lisp-Entry "pipe" definition (public) ("input" "output") #f #f 4789 20 4789 24 ("write-char" "begin" "eof-object?" "not" "if" "read-char" "c" "iterate" "let" "output" "input")}
      {Lisp-Entry "textual" definition (public) ("expr" "(output (current-output-port))") #f #f 4803 20 4803 27 (":text" "print" "print~" "write" "current-output-port" "output" "expr")}
      {Lisp-Entry "describe" definition (public) ("expr" "(output (current-output-port))") #f #f 4809 20 4809 28 (":describe" "print" "print~" "current-output-port" "output" "expr")}
      {Lisp-Entry "fresh-line" definition (public) ("(output (current-output-port))") #f #f 4813 20 4813 30 ("newline" "at-fresh-line?" "unless" "current-output-port" "output")}
      {Lisp-Entry "at-fresh-line?" definition (public) ("(output (current-output-port))") #f #f 4818 20 4818 34 ("current-output-port" "output")}
      {Lisp-Entry "*printers*" definition () () #f #f 4828 12 4828 22 ("eq?" "test:" "make-table")}
      {Lisp-Entry "register-printer" definition (package) ("name" "proc") #f #f 4832 21 4832 37 ("*printers*" "table-set!" "proc" "name")}
      {Lisp-Entry "with-printer" definition (public) ("printer" "proc") #f #f 4836 20 4836 32 ("*printers*" "table-ref" "printer-proc" "get-output-string" "open-output-string" "output" "let" ":string" "eq?" "if" "proc" "printer")}
      {Lisp-Entry "pp" definition (public) () #f #f 4856 19 4856 21 ("pretty-print")}
      {Lisp-Entry "present-reference" definition (public) ("reference") #f #f 4860 20 4860 37 ("string-find-reversed" "->string" "referee-name" "not" "break-reference" "referee" "receive" "0" "1" "element" "system-format" "reverse!" "reversed" "car" "cdr" "null?" "if" "symbol->string" "split" "names" "let" "identifier" "present-identifier" "define" "reference")}
      {Lisp-Entry "write-line" definition (public) ("line" "." "rest") #f #f 4877 20 4877 30 ("newline" "display" "car" "null?" "if" "port" "let" "rest" "line")}
      {Lisp-Entry "write-lines" definition (public) ("output" "lines") #f #f 4883 20 4883 31 ("newline" "null?" "unless" "display" "do" "remain" "remainder" "in" "line" "for" "loop" "lines" "output")}
      {Lisp-Entry "identity" definition (public inline) ("x") #f #f 4895 27 4895 35 ("x")}
      {Lisp-Entry "const" definition (public inline) ("x") #f #f 4899 27 4899 32 ("args" "lambda" "x")}
      {Lisp-Entry "compose" definition (public inline) ("f" "g") #f #f 4903 27 4903 34 ("x" "lambda" "g" "f")}
      {Lisp-Entry "compose*" definition (public) ("." "fns") #f #f 4908 20 4908 28 ("x" "lambda" "cdr" "compose*" "apply" "g" "car" "f" "let" "identity" "null?" "if" "fns")}
      {Lisp-Entry "Subseq-Class" class () ((extends . "Sequence-Class")) #f #f 4922 7 4922 19 ("Sequence-Class")}
      {Lisp-Entry "Subseq" class () ((metaclass . "Subseq-Class") (extends . "Sequence")) #f #f 4925 7 4925 13 ("Sequence" "Subseq-Class")
        {Lisp-Entry "sequence" slot () ((getter . "generate")) #f #f 4928 8 4928 16 ()}
        {Lisp-Entry "get-sequence" accessor () () #f #f 4928 32 4928 40 ()}
        {Lisp-Entry "start" slot () ((accessors . "generate")) #f "<fx>" 4929 8 4929 13 ("fx" "<fx>")}
        {Lisp-Entry "get-start" accessor () () #f #f 4929 32 4929 40 ()}
        {Lisp-Entry "set-start" accessor () () #f #f 4929 32 4929 40 ()}
        {Lisp-Entry "size" slot () ((accessors . "generate")) #f "<fx>" 4930 8 4930 12 ("fx" "<fx>")}
        {Lisp-Entry "get-size" accessor () () #f #f 4930 32 4930 40 ()}
        {Lisp-Entry "set-size" accessor () () #f #f 4930 32 4930 40 ()}
        {Lisp-Entry "initialize" method (override) ("sequence" "start" "<fx>" "size" "<fx>") #f #f 4933 20 4933 30 ("size~self" "start~self" "self" "sequence~self" "set!" "nextmethod" "size" "fx" "<fx>" "start" "sequence")}
        {Lisp-Entry "print" method (override) ("output" "detail") #f #f 4940 20 4940 25 ("system-format" "lambda" "self" "print-unreadable" "string-ref" "write-char" "do" "size" "+" "below" "start" "from" "n" "for" "loop" "sequence" "string?" "if" "detail" "output")}
        {Lisp-Entry "coerce-string" method (override) () #f #f 4950 20 4950 33 ("error" "size" "+" "start" "substring" "sequence" "string?" "if")}
        {Lisp-Entry "sequence-element" method (override) ("n" "<fx>") #f "<any>" 4956 20 4956 36 ("start" "+" "sequence" "element" "any" "<any>" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "<fx>" "obj" "<any>") #f "<void>" 4960 20 4960 41 ("start" "+" "sequence" "set-element!" "void" "<void>" "any" "<any>" "obj" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f "<int>" 4964 20 4964 40 ("size" "int" "<int>")}
        {Lisp-Entry "sequence-subseq!" method (override) ("s" "<fx>" "e" "<fx>") #f "<Subseq>" 4968 20 4968 36 ("cardinality" "-" "start" "+" "sequence" "new" "self" "-1" "0" "=" "or" "if" "Subseq" "<Subseq>" "e" "fx" "<fx>" "s")}}
      {Lisp-Entry "allocate-subseq" definition (public inline) ("sequence" "<string>" "start" "<fx>" "size" "<fx>") #f #f 4974 27 4974 42 ("Subseq" "allocate" "size" "fx" "<fx>" "start" "string" "<string>" "sequence")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Subseq>>" "sequence" "start" "size") #f #f 4977 20 4977 23 ("allocate-subseq" "Subseq" "<Subseq>" "size" "start" "sequence" "category<Subseq>" "<category<Subseq>>" "class")}
      {Lisp-Entry "offset-subseq!" definition (public) ("subseq" "<Subseq>" "offset" "<fx>") #f "<void>" 4981 20 4981 34 ("get-start" "get-start~" "+" "set-start" "set-start~" "void" "<void>" "fx" "<fx>" "offset" "Subseq" "<Subseq>" "subseq")}
      {Lisp-Entry "grow-subseq!" definition (public) ("subseq" "<Subseq>" "n" "<fx>") #f "<void>" 4985 20 4985 32 ("get-size" "get-size~" "+" "set-size" "set-size~" "void" "<void>" "fx" "<fx>" "n" "Subseq" "<Subseq>" "subseq")}
      {Lisp-Entry "subseq-ref" specialize (inline) () #f #f 4989 22 4989 32 ()}
      {Lisp-Entry "element" specialize (inline) ("subseq" "<Subseq>" "n") ("subseq-ref") #f 4989 34 4989 41 ("fx" "<fx>" "cast" "get-start" "get-start~" "+" "get-sequence" "get-sequence~" "element" "object" "<object>" "n" "Subseq" "<Subseq>" "subseq")}
      {Lisp-Entry "subseq-set!" specialize (inline) () #f #f 4993 22 4993 33 ()}
      {Lisp-Entry "set-element!" specialize (inline) ("subseq" "<Subseq>" "n" "obj") ("subseq-set!") #f 4993 35 4993 47 ("fx" "<fx>" "cast" "get-start" "get-start~" "+" "get-sequence" "get-sequence~" "set-element!" "void" "<void>" "obj" "n" "Subseq" "<Subseq>" "subseq")}
      {Lisp-Entry "subseq-cardinality" specialize (inline) () #f #f 4997 22 4997 40 ()}
      {Lisp-Entry "cardinality" specialize (inline) ("subseq" "<Subseq>") ("subseq-cardinality") #f 4997 42 4997 53 ("get-size" "get-size~" "int" "<int>" "Subseq" "<Subseq>" "subseq")}
      {Lisp-Entry "Subseq$string$-Class" class () ((extends . "Sequence-Class")) #f #f 5006 7 5006 27 ("Sequence-Class")}
      {Lisp-Entry "Subseq$string$" class () ((metaclass . "Subseq$string$-Class") (extends . "Sequence")) #f #f 5009 7 5009 21 ("Sequence" "Subseq$string$-Class")
        {Lisp-Entry "sequence" slot () ((getter . "generate")) #f "<string>" 5012 8 5012 16 ("string" "<string>")}
        {Lisp-Entry "get-sequence" accessor () () #f #f 5012 36 5012 44 ()}
        {Lisp-Entry "start" slot () ((accessors . "generate")) #f "<fx>" 5013 8 5013 13 ("fx" "<fx>")}
        {Lisp-Entry "get-start" accessor () () #f #f 5013 36 5013 44 ()}
        {Lisp-Entry "set-start" accessor () () #f #f 5013 36 5013 44 ()}
        {Lisp-Entry "size" slot () ((accessors . "generate")) #f "<fx>" 5014 8 5014 12 ("fx" "<fx>")}
        {Lisp-Entry "get-size" accessor () () #f #f 5014 36 5014 44 ()}
        {Lisp-Entry "set-size" accessor () () #f #f 5014 36 5014 44 ()}
        {Lisp-Entry "initialize" method (override) ("sequence" "<string>" "start" "<fx>" "size" "<fx>") #f #f 5017 20 5017 30 ("size~self" "start~self" "self" "sequence~self" "set!" "nextmethod" "size" "fx" "<fx>" "start" "string" "<string>" "sequence")}
        {Lisp-Entry "print" method (override) ("output" "detail") #f #f 5024 20 5024 25 ("system-format" "lambda" "self" "print-unreadable" "print" "print~" ":human" "eq?" "if" "size" "+" "start" "sequence" "substring" "str" "let" "detail" "output")}
        {Lisp-Entry "print-content" method (public) ("output") #f #f 5033 18 5033 31 ("size" "+" "start" "sequence" "substring" "display" "output")}
        {Lisp-Entry "sequence-element" method (override) ("n" "<fx>") #f "<any>" 5037 20 5037 36 ("start" "+" "sequence" "element" "any" "<any>" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "<fx>" "obj" "<any>") #f "<void>" 5041 20 5041 41 ("start" "+" "sequence" "set-element!" "void" "<void>" "any" "<any>" "obj" "fx" "<fx>" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f "<int>" 5045 20 5045 40 ("size" "int" "<int>")}
        {Lisp-Entry "sequence-subseq!" method (override) ("s" "<fx>" "e" "<fx>") #f "<Subseq$string$>" 5049 20 5049 36 ("cardinality" "-" "start" "+" "sequence" "new" "self" "-1" "0" "=" "and" "if" "Subseq$string$" "<Subseq$string$>" "e" "fx" "<fx>" "s")}}
      {Lisp-Entry "allocate-subseq$string$" definition (public inline) ("sequence" "<string>" "start" "<fx>" "size" "<fx>") #f #f 5055 27 5055 50 ("Subseq$string$" "allocate" "size" "fx" "<fx>" "start" "string" "<string>" "sequence")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Subseq$string$>>" "sequence" "start" "size") #f #f 5058 20 5058 23 ("allocate-subseq$string$" "Subseq$string$" "<Subseq$string$>" "size" "start" "sequence" "category<Subseq$string$>" "<category<Subseq$string$>>" "class")}
      {Lisp-Entry "element" specialize (inline) ("subseq" "<Subseq$string$>" "n") #f #f 5062 20 5062 27 ("fx" "<fx>" "cast" "get-start" "get-start~" "+" "get-sequence" "get-sequence~" "element" "char" "<char>" "n" "Subseq$string$" "<Subseq$string$>" "subseq")}
      {Lisp-Entry "set-element!" specialize (inline) ("subseq" "<Subseq$string$>" "n" "obj") #f #f 5066 20 5066 32 ("char" "<char>" "fx" "<fx>" "cast" "get-start" "get-start~" "+" "get-sequence" "get-sequence~" "set-element!" "void" "<void>" "obj" "n" "Subseq$string$" "<Subseq$string$>" "subseq")}
      {Lisp-Entry "cardinality" specialize (inline) ("subseq" "<Subseq$string$>") #f #f 5070 20 5070 31 ("get-size" "get-size~" "fx" "<fx>" "Subseq$string$" "<Subseq$string$>" "subseq")}
      {Lisp-Entry "subseq!" specialize () ("seq" "<string>" "s" "e") #f #f 5074 13 5074 20 ("-" "new" "fx" "<fx>" "cast" "let" "Subseq$string$" "<Subseq$string$>" "e" "s" "string" "<string>" "seq")}
      {Lisp-Entry "subseq!" specialize () ("subseq" "<Subseq$string$>" "s" "e") #f #f 5080 13 5080 20 ("-" "get-start" "get-start~" "+" "get-sequence" "get-sequence~" "new" "fx" "<fx>" "cast" "let" "e" "s" "Subseq$string$" "<Subseq$string$>" "subseq")}
      {Lisp-Entry "offset-subseq!" specialize () ("subseq" "<Subseq$string$>" "offset") #f #f 5086 13 5086 27 ("fx" "<fx>" "cast" "get-start" "get-start~" "+" "set-start" "set-start~" "void" "<void>" "offset" "Subseq$string$" "<Subseq$string$>" "subseq")}
      {Lisp-Entry "grow-subseq!" specialize () ("subseq" "<Subseq$string$>" "n") #f #f 5090 13 5090 25 ("fx" "<fx>" "cast" "get-size" "get-size~" "+" "set-size" "set-size~" "void" "<void>" "n" "Subseq$string$" "<Subseq$string$>" "subseq")}}})
"geometry"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "geometry.jazz"} 246662659. jazz
    {Lisp-Entry "jazz.dialect.language.geometry" module (protected) () #f #f 37 18 37 48 ("jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("jazz.dialect.language.object" "jazz.dialect.language.functional" "jazz.dialect.language.format" "jazz.dialect.kernel")}
      {Lisp-Entry "error" native (private) () ("native") #f 49 16 49 26 ()}
      {Lisp-Entry "Cell" class () ((extends . "Numeric")) #f #f 57 7 57 11 ("Numeric")
        {Lisp-Entry "line" slot () ((accessors . "generate")) #f "<fx>" 60 8 60 12 ("fx" "<fx>")}
        {Lisp-Entry "get-line" accessor () () #f #f 60 28 60 36 ()}
        {Lisp-Entry "set-line" accessor () () #f #f 60 28 60 36 ()}
        {Lisp-Entry "col" slot () ((accessors . "generate")) #f "<fx>" 61 8 61 11 ("fx" "<fx>")}
        {Lisp-Entry "get-col" accessor () () #f #f 61 28 61 36 ()}
        {Lisp-Entry "set-col" accessor () () #f #f 61 28 61 36 ()}
        {Lisp-Entry "initialize" method (override) ("l" "<fx>" "c" "<fx>") #f #f 64 20 64 30 ("col" "line" "set!" "c" "fx" "<fx>" "l")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 69 20 69 31 ("col" "line" "Cell" "new" "deep?")}
        {Lisp-Entry "compare-object" method (override) ("target") #f #f 73 20 73 34 ("get-col" "get-col~" "col" ":equal" "eq?" "not" "get-line" "get-line~" "line" "compare" "compared" "let" ":incompatible" "Cell" "is-not?" "if" "target")}
        {Lisp-Entry "di-compare-object" method (override) ("target") #f #f 82 20 82 37 ("get-col" "get-col~" "col" ":equal" "eq?" "not" "get-line" "get-line~" "line" "di-compare" "compared" "let" ":incompatible" "Cell" "is-not?" "if" "target")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 91 20 91 25 ("col" "line" "self" "class-of" "category-name" "format" "readably" "output")}
        {Lisp-Entry "numeric-norm" method (override) () #f #f 98 20 98 32 ("self" "error")}
        {Lisp-Entry "numeric-add" method (override) ("n") #f #f 102 20 102 31 ("self" "error" "else" "integer?" "get-col" "get-col~" "col" "get-line" "get-line~" "line" "+" "new" "Cell" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" method (override) () #f #f 108 20 108 34 ("col" "line" "-" "Cell" "new")}
        {Lisp-Entry "numeric-multiply" method (override) ("n") #f #f 112 20 112 36 ("self" "error" "col" "line" "*" "Cell" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" method (override) () #f #f 118 20 118 35 ("self" "error")}
        {Lisp-Entry "increase-line" method (public) ("(delta <fx> 1)") #f #f 122 18 122 31 ("+" "line" "set!" "1" "fx" "<fx>" "delta")}
        {Lisp-Entry "increase-col" method (public) ("(delta <fx> 1)") #f #f 126 18 126 30 ("+" "col" "set!" "1" "fx" "<fx>" "delta")}
        {Lisp-Entry "get-enabled?" method (public) () #f #f 131 18 131 30 ()}}
      {Lisp-Entry "allocate-cell" definition (public inline) ("line" "<fx>" "col" "<fx>") #f #f 135 27 135 40 ("Cell" "allocate" "col" "fx" "<fx>" "line")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Cell>>" "line" "col") #f #f 138 20 138 23 ("allocate-cell" "Cell" "<Cell>" "col" "line" "category<Cell>" "<category<Cell>>" "class")}
      {Lisp-Entry "copy-cell" specialize (inline) () #f #f 142 22 142 31 ()}
      {Lisp-Entry "copy" specialize (inline) ("c" "<Cell>") ("copy-cell") #f 142 33 142 37 ("get-col" "get-col~" "get-line" "get-line~" "new" "Cell" "<Cell>" "c")}
      {Lisp-Entry "cell=?" specialize (inline) () #f #f 146 22 146 28 ()}
      {Lisp-Entry "=" specialize (inline) ("c1" "<Cell>" "c2" "<Cell>") ("cell=?") #f 146 30 146 31 ("get-col" "get-col~" "get-line" "get-line~" "=" "and" "bool" "<bool>" "c2" "Cell" "<Cell>" "c1")}
      {Lisp-Entry "cell<?" specialize () () #f #f 151 15 151 21 ()}
      {Lisp-Entry "<" specialize () ("c1" "<Cell>" "c2" "<Cell>") ("cell<?") #f 151 23 151 24 ("get-col" "get-col~" "=" "and" "<" "or" "l2" "get-line" "get-line~" "l1" "let" "bool" "<bool>" "c2" "Cell" "<Cell>" "c1")}
      {Lisp-Entry "cell<=?" specialize () () #f #f 159 15 159 22 ()}
      {Lisp-Entry "<=" specialize () ("c1" "<Cell>" "c2" "<Cell>") ("cell<=?") #f 159 24 159 26 ("get-col" "get-col~" "<=" "=" "and" "<" "or" "l2" "get-line" "get-line~" "l1" "let" "bool" "<bool>" "c2" "Cell" "<Cell>" "c1")}
      {Lisp-Entry "cell>?" specialize () () #f #f 167 15 167 21 ()}
      {Lisp-Entry ">" specialize () ("c1" "<Cell>" "c2" "<Cell>") ("cell>?") #f 167 23 167 24 ("get-col" "get-col~" "=" "and" ">" "or" "l2" "get-line" "get-line~" "l1" "let" "bool" "<bool>" "c2" "Cell" "<Cell>" "c1")}
      {Lisp-Entry "cell>=?" specialize () () #f #f 175 15 175 22 ()}
      {Lisp-Entry ">=" specialize () ("c1" "<Cell>" "c2" "<Cell>") ("cell>=?") #f 175 24 175 26 ("get-col" "get-col~" ">=" "=" "and" ">" "or" "l2" "get-line" "get-line~" "l1" "let" "bool" "<bool>" "c2" "Cell" "<Cell>" "c1")}
      {Lisp-Entry "cell+" specialize (inline) () #f #f 183 22 183 27 ()}
      {Lisp-Entry "+" specialize (inline) ("c1" "<Cell>" "c2" "<Cell>") ("cell+") #f 183 29 183 30 ("get-col" "get-col~" "get-line" "get-line~" "+" "new" "c2" "Cell" "<Cell>" "c1")}
      {Lisp-Entry "+" specialize (inline) ("c" "<Cell>" "n" "<int>") #f #f 189 20 189 21 ("get-col" "get-col~" "+" "get-line" "get-line~" "new" "int" "<int>" "n" "Cell" "<Cell>" "c")}
      {Lisp-Entry "cell-" specialize (inline) () #f #f 195 22 195 27 ()}
      {Lisp-Entry "-" specialize (inline) ("c1" "<Cell>" "c2" "<Cell>") ("cell-") #f 195 29 195 30 ("get-col" "get-col~" "get-line" "get-line~" "-" "new" "c2" "Cell" "<Cell>" "c1")}
      {Lisp-Entry "-" specialize (inline) ("c" "<Cell>" "n" "<int>") #f #f 201 20 201 21 ("get-col" "get-col~" "-" "get-line" "get-line~" "new" "int" "<int>" "n" "Cell" "<Cell>" "c")}
      {Lisp-Entry "cell-hash" definition (public) ("c" "<Cell>") #f #f 207 20 207 29 ("get-col" "get-col~" "get-line" "get-line~" "eqv?-hash" "fxwrap+" "Cell" "<Cell>" "c")}
      {Lisp-Entry "Range" class () ((extends . "Object")) #f #f 217 7 217 12 ("Object")
        {Lisp-Entry "start" slot () () #f #f 220 8 220 13 ()}
        {Lisp-Entry "end" slot () () #f #f 221 8 221 11 ()}
        {Lisp-Entry "initialize" method (override) ("s" "e") #f #f 224 20 224 30 ("end" "start" "set!" "nextmethod" "e" "s")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 230 20 230 31 ("end" "start" "Range" "new" "deep?")}
        {Lisp-Entry "compare-object" method (override) ("target") #f #f 234 20 234 34 (":not-equal" "else" ":equal" "get-end" "get-end~" "end" "get-start" "get-start~" "start" "=" "and" ":incompatible" "Range" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 243 20 243 25 ("end" "start" "self" "class-of" "category-name" "format" "readably" "output")}
        {Lisp-Entry "get-start" method (public inline) () #f #f 250 25 250 34 ("start")}
        {Lisp-Entry "get-end" method (public inline) () #f #f 254 25 254 32 ("end")}
        {Lisp-Entry "extent" method (public virtual) () #f #f 258 26 258 32 ("start" "end" "-")}
        {Lisp-Entry "extended?" method (public virtual) () #f #f 262 26 262 35 ("end" "start" "=" "not")}
        {Lisp-Entry "empty?" method (public virtual) () #f #f 266 26 266 32 ("end" "start" "=")}
        {Lisp-Entry "inside?" method (public) ("n") #f #f 270 18 270 25 ("end" "<" "start" ">=" "and" "n")}
        {Lisp-Entry "before?" method (public) ("n") #f #f 275 18 275 25 ("start" "<" "n")}
        {Lisp-Entry "after?" method (public) ("n") #f #f 279 18 279 24 ("end" ">" "n")}
        {Lisp-Entry "intersect?" method (public) ("range") #f #f 283 18 283 28 ("start" "get-end" "get-end~" ">=" "end" "get-start" "get-start~" "<" "and" "range")}
        {Lisp-Entry "intersect" method (public) ("range") #f #f 288 18 288 27 ("get-end" "get-end~" "end" "min" "get-start" "get-start~" "start" "max" "self" "class-of" "new" "intersect?" "when" "range")}}
      {Lisp-Entry "allocate-range" definition (public inline) ("start" "end") #f #f 293 27 293 41 ("Range" "allocate" "end" "start")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Range>>" "start" "end") #f #f 296 20 296 23 ("allocate-range" "Range" "<Range>" "end" "start" "category<Range>" "<category<Range>>" "class")}
      {Lisp-Entry "range=?" specialize (inline) () #f #f 300 22 300 29 ()}
      {Lisp-Entry "=" specialize (inline) ("r1" "<Range>" "r2" "<Range>") ("range=?") #f 300 31 300 32 ("get-end" "get-end~" "get-start" "get-start~" "=" "and" "bool" "<bool>" "r2" "Range" "<Range>" "r1")}
      {Lisp-Entry "Range$Cell$" class () ((extends . "Object")) #f #f 310 7 310 18 ("Object")
        {Lisp-Entry "start" slot () ((getter . "generate")) #f "<Cell>" 313 8 313 13 ("Cell" "<Cell>")}
        {Lisp-Entry "get-start" accessor () () #f #f 313 28 313 36 ()}
        {Lisp-Entry "end" slot () ((getter . "generate")) #f "<Cell>" 314 8 314 11 ("Cell" "<Cell>")}
        {Lisp-Entry "get-end" accessor () () #f #f 314 28 314 36 ()}
        {Lisp-Entry "initialize" method (override) ("s" "<Cell>" "e" "<Cell>") #f #f 317 20 317 30 ("end" "start" "set!" "nextmethod" "e" "Cell" "<Cell>" "s")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 323 20 323 31 ("end" "start" "Range$Cell$" "new" "deep?")}
        {Lisp-Entry "compare-object" method (override) ("target") #f #f 327 20 327 34 (":not-equal" "else" ":equal" "get-end" "get-end~" "end" "get-start" "get-start~" "start" "=" "and" ":incompatible" "Range$Cell$" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 336 20 336 25 ("end" "start" "self" "class-of" "category-name" "format" "readably" "output")}
        {Lisp-Entry "extent" method (public virtual) () #f "<Cell>" 343 26 343 32 ("start" "end" "-" "Cell" "<Cell>")}
        {Lisp-Entry "extended?" method (public virtual) () #f #f 347 26 347 35 ("end" "start" "=" "not")}
        {Lisp-Entry "empty?" method (public virtual) () #f #f 351 26 351 32 ("end" "start" "=")}
        {Lisp-Entry "inside?" method (public) ("n" "<Cell>") #f "<bool>" 355 18 355 25 ("end" "<" "start" ">=" "and" "bool" "<bool>" "Cell" "<Cell>" "n")}
        {Lisp-Entry "before?" method (public) ("n" "<Cell>") #f "<bool>" 360 18 360 25 ("start" "<" "bool" "<bool>" "Cell" "<Cell>" "n")}
        {Lisp-Entry "after?" method (public) ("n" "<Cell>") #f "<bool>" 364 18 364 24 ("end" ">" "bool" "<bool>" "Cell" "<Cell>" "n")}
        {Lisp-Entry "intersect?" method (public) ("range" "<Range$Cell$>") #f "<bool>" 368 18 368 28 ("start" "get-end" "get-end~" ">=" "end" "get-start" "get-start~" "<" "and" "bool" "<bool>" "Range$Cell$" "<Range$Cell$>" "range")}
        {Lisp-Entry "intersect" method (public) ("range" "<Range$Cell$>") #f #f 373 18 373 27 ("get-end" "get-end~" "end" "min" "get-start" "get-start~" "start" "max" "self" "class-of" "new" "intersect?" "when" "Range$Cell$" "<Range$Cell$>" "range")}}
      {Lisp-Entry "allocate-range$Cell$" definition (public inline) ("start" "<Cell>" "end" "<Cell>") #f #f 378 27 378 47 ("Range$Cell$" "allocate" "end" "Cell" "<Cell>" "start")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Range$Cell$>>" "start" "end") #f #f 381 20 381 23 ("allocate-range$Cell$" "Range$Cell$" "<Range$Cell$>" "end" "start" "category<Range$Cell$>" "<category<Range$Cell$>>" "class")}
      {Lisp-Entry "=" specialize (inline) ("r1" "<Range$Cell$>" "r2" "<Range$Cell$>") #f #f 385 20 385 21 ("get-end" "get-end~" "get-start" "get-start~" "=" "and" "bool" "<bool>" "r2" "Range$Cell$" "<Range$Cell$>" "r1")}
      {Lisp-Entry "Point" class () ((extends . "Numeric")) #f #f 395 7 395 12 ("Numeric")
        {Lisp-Entry "h" slot () ((getter . "generate")) #f "<fx>" 398 8 398 9 ("fx" "<fx>")}
        {Lisp-Entry "get-h" accessor () () #f #f 398 22 398 30 ()}
        {Lisp-Entry "v" slot () ((getter . "generate")) #f "<fx>" 399 8 399 9 ("fx" "<fx>")}
        {Lisp-Entry "get-v" accessor () () #f #f 399 22 399 30 ()}
        {Lisp-Entry "initialize" method (override) ("h" "<fx>" "v" "<fx>") #f #f 402 20 402 30 ("v~self" "self" "h~self" "set!" "nextmethod" "v" "fx" "<fx>" "h")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 408 20 408 31 ("v" "h" "Point" "new" "deep?")}
        {Lisp-Entry "compare-object" method (override) ("target") #f #f 412 20 412 34 (":not-equal" "else" ":equal" "get-v" "get-v~" "v" "get-h" "get-h~" "h" "=" "and" "<Point>" "target-point" "let" ":incompatible" "Point" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 422 20 422 25 ("v" "h" "format" "readably" "output")}
        {Lisp-Entry "numeric-norm" method (override) () #f #f 428 20 428 32 ("v" "2" "h" "expt" "+" "sqrt")}
        {Lisp-Entry "numeric-add" method (override) ("n") #f #f 432 20 432 31 ("self" "error" "else" "integer?" "get-height" "get-height~" "get-width" "get-width~" "Dimension" "get-y" "get-y~" "get-x" "get-x~" "Distance" "get-v" "get-v~" "v" "get-h" "get-h~" "h" "+" "new" "Point" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" method (override) () #f #f 440 20 440 34 ("v" "h" "-" "Point" "new")}
        {Lisp-Entry "numeric-multiply" method (override) ("n") #f #f 444 20 444 36 ("self" "error" "v" "h" "*" "Point" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" method (override) () #f #f 450 20 450 35 ("self" "error")}}
      {Lisp-Entry "allocate-point" definition (public inline) ("h" "<fx>" "v" "<fx>") #f #f 454 27 454 41 ("Point" "allocate" "v" "fx" "<fx>" "h")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Point>>" "h" "v") #f #f 457 20 457 23 ("allocate-point" "Point" "<Point>" "v" "h" "category<Point>" "<category<Point>>" "class")}
      {Lisp-Entry "point=?" specialize (inline) () #f #f 461 22 461 29 ()}
      {Lisp-Entry "=" specialize (inline) ("p1" "<Point>" "p2" "<Point>") ("point=?") #f 461 31 461 32 ("get-v" "get-v~" "get-h" "get-h~" "=" "and" "bool" "<bool>" "p2" "Point" "<Point>" "p1")}
      {Lisp-Entry "point+" specialize (inline) () #f #f 466 22 466 28 ()}
      {Lisp-Entry "+" specialize (inline) ("p1" "<Point>" "p2" "<Point>") ("point+") #f 466 30 466 31 ("get-v" "get-v~" "get-h" "get-h~" "+" "new" "p2" "Point" "<Point>" "p1")}
      {Lisp-Entry "+" specialize (inline) ("p" "<Point>" "n" "<int>") #f #f 472 20 472 21 ("get-v" "get-v~" "get-h" "get-h~" "+" "new" "int" "<int>" "n" "Point" "<Point>" "p")}
      {Lisp-Entry "point-" specialize (inline) () #f #f 478 22 478 28 ()}
      {Lisp-Entry "-" specialize (inline) ("p1" "<Point>" "p2" "<Point>") ("point-") #f 478 30 478 31 ("get-v" "get-v~" "get-h" "get-h~" "-" "new" "p2" "Point" "<Point>" "p1")}
      {Lisp-Entry "-" specialize (inline) ("p" "<Point>" "n" "<int>") #f #f 484 20 484 21 ("get-v" "get-v~" "get-h" "get-h~" "-" "new" "int" "<int>" "n" "Point" "<Point>" "p")}
      {Lisp-Entry "-" specialize (inline) ("p" "<Point>") #f #f 490 20 490 21 ("get-v" "get-v~" "get-h" "get-h~" "-" "new" "Point" "<Point>" "p")}
      {Lisp-Entry "point*" specialize (inline) () #f #f 496 22 496 28 ()}
      {Lisp-Entry "*" specialize (inline) ("p" "<Point>" "n" "<int>") ("point*") #f 496 30 496 31 ("get-v" "get-v~" "get-h" "get-h~" "*" "new" "int" "<int>" "n" "Point" "<Point>" "p")}
      {Lisp-Entry "Distance" class () ((extends . "Numeric")) #f #f 507 7 507 15 ("Numeric")
        {Lisp-Entry "x" slot () ((getter . "generate")) #f "<fx>" 510 8 510 9 ("fx" "<fx>")}
        {Lisp-Entry "get-x" accessor () () #f #f 510 22 510 30 ()}
        {Lisp-Entry "y" slot () ((getter . "generate")) #f "<fx>" 511 8 511 9 ("fx" "<fx>")}
        {Lisp-Entry "get-y" accessor () () #f #f 511 22 511 30 ()}
        {Lisp-Entry "initialize" method (override) ("x" "<fx>" "y" "<fx>") #f #f 514 20 514 30 ("y~self" "self" "x~self" "set!" "nextmethod" "y" "fx" "<fx>" "x")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 520 20 520 31 ("y" "x" "Distance" "new" "deep?")}
        {Lisp-Entry "compare-object" method (override) ("target") #f #f 524 20 524 34 ("get-y" "get-y~" "y" ":equal" "neq?" "get-x" "get-x~" "x" "compare" "compared" "let" ":incompatible" "Distance" "is-not?" "if" "target")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 533 20 533 25 ("y" "x" "format" "readably" "output")}
        {Lisp-Entry "numeric-norm" method (override) () #f #f 539 20 539 32 ("self" "error")}
        {Lisp-Entry "numeric-add" method (override) ("n") #f #f 543 20 543 31 ("self" "error" "else" "integer?" "get-v" "get-v~" "get-h" "get-h~" "Point" "get-y" "get-y~" "y" "get-x" "get-x~" "x" "+" "new" "Distance" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" method (override) () #f #f 550 20 550 34 ("y" "x" "-" "Distance" "new")}
        {Lisp-Entry "numeric-multiply" method (override) ("n") #f #f 554 20 554 36 ("self" "error" "y" "x" "*" "Distance" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" method (override) () #f #f 560 20 560 35 ("self" "error")}}
      {Lisp-Entry "allocate-distance" definition (public inline) ("x" "<fx>" "y" "<fx>") #f #f 564 27 564 44 ("Distance" "allocate" "y" "fx" "<fx>" "x")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Distance>>" "x" "y") #f #f 567 20 567 23 ("allocate-distance" "Distance" "<Distance>" "y" "x" "category<Distance>" "<category<Distance>>" "class")}
      {Lisp-Entry "distance=?" specialize (inline) () #f #f 571 22 571 32 ()}
      {Lisp-Entry "=" specialize (inline) ("d1" "<Distance>" "d2" "<Distance>") ("distance=?") #f 571 34 571 35 ("get-y" "get-y~" "get-x" "get-x~" "=" "and" "bool" "<bool>" "d2" "Distance" "<Distance>" "d1")}
      {Lisp-Entry "distance+" specialize (inline) () #f #f 576 22 576 31 ()}
      {Lisp-Entry "+" specialize (inline) ("d1" "<Distance>" "d2" "<Distance>") ("distance+") #f 576 33 576 34 ("get-y" "get-y~" "get-x" "get-x~" "+" "new" "d2" "Distance" "<Distance>" "d1")}
      {Lisp-Entry "distance-" specialize (inline) () #f #f 582 22 582 31 ()}
      {Lisp-Entry "-" specialize (inline) ("d1" "<Distance>" "d2" "<Distance>") ("distance-") #f 582 33 582 34 ("get-y" "get-y~" "get-x" "get-x~" "-" "new" "d2" "Distance" "<Distance>" "d1")}
      {Lisp-Entry "-" specialize (inline) ("d" "<Distance>") #f #f 588 20 588 21 ("get-y" "get-y~" "get-x" "get-x~" "-" "new" "Distance" "<Distance>" "d")}
      {Lisp-Entry "distance*" specialize (inline) () #f #f 594 22 594 31 ()}
      {Lisp-Entry "*" specialize (inline) ("d" "<Distance>" "n" "<int>") ("distance*") #f 594 33 594 34 ("get-y" "get-y~" "get-x" "get-x~" "*" "new" "int" "<int>" "n" "Distance" "<Distance>" "d")}
      {Lisp-Entry "distance-min" definition (public) ("d1" "<Distance>" "d2" "<Distance>") #f "<Distance>" 600 20 600 32 ("get-y" "get-y~" "get-x" "get-x~" "min" "new" "d2" "Distance" "<Distance>" "d1")}
      {Lisp-Entry "distance-max" definition (public) ("d1" "<Distance>" "d2" "<Distance>") #f "<Distance>" 606 20 606 32 ("get-y" "get-y~" "get-x" "get-x~" "max" "new" "d2" "Distance" "<Distance>" "d1")}
      {Lisp-Entry "Dimension" class () ((extends . "Numeric")) #f #f 617 7 617 16 ("Numeric")
        {Lisp-Entry "width" slot () ((getter . "generate")) #f "<fx>" 620 8 620 13 ("fx" "<fx>")}
        {Lisp-Entry "get-width" accessor () () #f #f 620 27 620 35 ()}
        {Lisp-Entry "height" slot () ((getter . "generate")) #f "<fx>" 621 8 621 14 ("fx" "<fx>")}
        {Lisp-Entry "get-height" accessor () () #f #f 621 27 621 35 ()}
        {Lisp-Entry "initialize" method (override) ("w" "<fx>" "h" "<fx>") #f #f 624 20 624 30 ("height" "width" "set!" "nextmethod" "h" "fx" "<fx>" "w")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 630 20 630 31 ("height" "width" "Dimension" "new" "deep?")}
        {Lisp-Entry "compare-object" method (override) ("target") #f #f 634 20 634 34 ("get-height" "get-height~" "height" ":equal" "neq?" "get-width" "get-width~" "width" "compare" "compared" "let" ":incompatible" "Dimension" "is-not?" "if" "target")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 643 20 643 25 ("height" "width" "format" "readably" "output")}
        {Lisp-Entry "numeric-norm" method (override) () #f #f 649 20 649 32 ("self" "error")}
        {Lisp-Entry "numeric-add" method (override) ("n") #f #f 653 20 653 31 ("self" "error" "else" "integer?" "get-v" "get-v~" "get-h" "get-h~" "Point" "get-height" "get-height~" "height" "get-width" "get-width~" "width" "+" "new" "Dimension" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" method (override) () #f #f 660 20 660 34 ("height" "width" "-" "Dimension" "new")}
        {Lisp-Entry "numeric-multiply" method (override) ("n") #f #f 664 20 664 36 ("self" "error" "height" "width" "*" "Dimension" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" method (override) () #f #f 670 20 670 35 ("self" "error")}}
      {Lisp-Entry "allocate-dimension" definition (public inline) ("width" "<fx>" "height" "<fx>") #f #f 674 27 674 45 ("Dimension" "allocate" "height" "fx" "<fx>" "width")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Dimension>>" "width" "height") #f #f 677 20 677 23 ("allocate-dimension" "Dimension" "<Dimension>" "height" "width" "category<Dimension>" "<category<Dimension>>" "class")}
      {Lisp-Entry "dimension=?" specialize (inline) () #f #f 681 22 681 33 ()}
      {Lisp-Entry "=" specialize (inline) ("d1" "<Dimension>" "d2" "<Dimension>") ("dimension=?") #f 681 35 681 36 ("get-height" "get-height~" "get-width" "get-width~" "=" "and" "bool" "<bool>" "d2" "Dimension" "<Dimension>" "d1")}
      {Lisp-Entry "dimension+" specialize (inline) () #f #f 686 22 686 32 ()}
      {Lisp-Entry "+" specialize (inline) ("d1" "<Dimension>" "d2" "<Dimension>") ("dimension+") #f 686 34 686 35 ("get-height" "get-height~" "get-width" "get-width~" "+" "new" "d2" "Dimension" "<Dimension>" "d1")}
      {Lisp-Entry "dimension-" specialize (inline) () #f #f 692 22 692 32 ()}
      {Lisp-Entry "-" specialize (inline) ("d1" "<Dimension>" "d2" "<Dimension>") ("dimension-") #f 692 34 692 35 ("get-height" "get-height~" "get-width" "get-width~" "-" "new" "d2" "Dimension" "<Dimension>" "d1")}
      {Lisp-Entry "dimension*" specialize (inline) () #f #f 698 22 698 32 ()}
      {Lisp-Entry "*" specialize (inline) ("d" "<Dimension>" "n" "<int>") ("dimension*") #f 698 34 698 35 ("get-height" "get-height~" "get-width" "get-width~" "*" "new" "int" "<int>" "n" "Dimension" "<Dimension>" "d")}
      {Lisp-Entry "dimension-min" definition (public) ("d1" "<Dimension>" "d2" "<Dimension>") #f "<Dimension>" 704 20 704 33 ("get-height" "get-height~" "get-width" "get-width~" "min" "new" "d2" "Dimension" "<Dimension>" "d1")}
      {Lisp-Entry "dimension-max" definition (public) ("d1" "<Dimension>" "d2" "<Dimension>") #f "<Dimension>" 710 20 710 33 ("get-height" "get-height~" "get-width" "get-width~" "max" "new" "d2" "Dimension" "<Dimension>" "d1")}
      {Lisp-Entry "Rect-Class" class () ((extends . "Class")) #f #f 721 7 721 17 ("Class")
        {Lisp-Entry "coerce-object" method (override) ("object") #f #f 724 20 724 33 ("nextmethod" "else" "0" "get-v" "get-v~" "get-h" "get-h~" "Rect" "new" "Point" "typecase" "object")}}
      {Lisp-Entry "Rect" class () ((metaclass . "Rect-Class") (extends . "Object")) #f #f 730 7 730 11 ("Object" "Rect-Class")
        {Lisp-Entry "left" slot () ((accessors . "generate")) #f "<fx>" 733 8 733 12 ("fx" "<fx>")}
        {Lisp-Entry "get-left" accessor () () #f #f 733 30 733 38 ()}
        {Lisp-Entry "set-left" accessor () () #f #f 733 30 733 38 ()}
        {Lisp-Entry "top" slot () ((accessors . "generate")) #f "<fx>" 734 8 734 11 ("fx" "<fx>")}
        {Lisp-Entry "get-top" accessor () () #f #f 734 30 734 38 ()}
        {Lisp-Entry "set-top" accessor () () #f #f 734 30 734 38 ()}
        {Lisp-Entry "right" slot () ((accessors . "generate")) #f "<fx>" 735 8 735 13 ("fx" "<fx>")}
        {Lisp-Entry "get-right" accessor () () #f #f 735 30 735 38 ()}
        {Lisp-Entry "set-right" accessor () () #f #f 735 30 735 38 ()}
        {Lisp-Entry "bottom" slot () ((accessors . "generate")) #f "<fx>" 736 8 736 14 ("fx" "<fx>")}
        {Lisp-Entry "get-bottom" accessor () () #f #f 736 30 736 38 ()}
        {Lisp-Entry "set-bottom" accessor () () #f #f 736 30 736 38 ()}
        {Lisp-Entry "initialize" method (override) ("l" "<fx>" "t" "<fx>" "r" "<fx>" "b" "<fx>") #f #f 739 20 739 30 ("bottom" "right" "top" "left" "set!" "nextmethod" "b" "r" "t" "fx" "<fx>" "l")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 747 20 747 31 ("bottom" "right" "top" "left" "Rect" "new" "deep?")}
        {Lisp-Entry "compare-object" method (override) ("target") #f #f 751 20 751 34 (":not-equal" "else" ":equal" "get-bottom" "get-bottom~" "bottom" "get-right" "get-right~" "right" "get-top" "get-top~" "top" "get-left" "get-left~" "left" "=" "and" ":incompatible" "Rect" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 760 20 760 25 ("bottom" "right" "top" "left" "self" "class-of" "category-name" "format" "readably" "output")}}
      {Lisp-Entry "rect?" definition (public inline) ("obj") #f #f 769 27 769 32 ("Rect" "is?" "obj")}
      {Lisp-Entry "allocate-rect" definition (public inline) ("left" "<fx>" "top" "<fx>" "right" "<fx>" "bottom" "<fx>") #f #f 773 27 773 40 ("Rect" "allocate" "bottom" "right" "top" "fx" "<fx>" "left")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Rect>>" "left" "top" "right" "bottom") #f #f 776 20 776 23 ("allocate-rect" "Rect" "<Rect>" "bottom" "right" "top" "left" "category<Rect>" "<category<Rect>>" "class")}
      {Lisp-Entry "rect=?" specialize (inline) () #f #f 780 22 780 28 ()}
      {Lisp-Entry "=" specialize (inline) ("r1" "<Rect>" "r2" "<Rect>") ("rect=?") #f 780 30 780 31 ("get-bottom" "get-bottom~" "get-right" "get-right~" "get-top" "get-top~" "get-left" "get-left~" "=" "and" "bool" "<bool>" "r2" "Rect" "<Rect>" "r1")}
      {Lisp-Entry "empty-rect?" definition (public inline) ("rect") #f #f 787 27 787 38 ("get-bottom" "get-bottom~" "get-right" "get-right~" "get-top" "get-top~" "0" "get-left" "get-left~" "=" "and" "rect")}
      {Lisp-Entry "Rect$fl$-Class" class () ((extends . "Class")) #f #f 799 7 799 21 ("Class")
        {Lisp-Entry "coerce-object" method (override) ("object") #f #f 802 20 802 33 ("nextmethod" "else" "0" "get-v" "get-v~" "get-h" "get-h~" "Rect$fl$" "new" "Point" "typecase" "object")}}
      {Lisp-Entry "Rect$fl$" class () ((metaclass . "Rect$fl$-Class") (extends . "Object")) #f #f 808 7 808 15 ("Object" "Rect$fl$-Class")
        {Lisp-Entry "left" slot () ((accessors . "generate")) #f "<fl>" 811 8 811 12 ("fl" "<fl>")}
        {Lisp-Entry "get-left" accessor () () #f #f 811 30 811 38 ()}
        {Lisp-Entry "set-left" accessor () () #f #f 811 30 811 38 ()}
        {Lisp-Entry "top" slot () ((accessors . "generate")) #f "<fl>" 812 8 812 11 ("fl" "<fl>")}
        {Lisp-Entry "get-top" accessor () () #f #f 812 30 812 38 ()}
        {Lisp-Entry "set-top" accessor () () #f #f 812 30 812 38 ()}
        {Lisp-Entry "right" slot () ((accessors . "generate")) #f "<fl>" 813 8 813 13 ("fl" "<fl>")}
        {Lisp-Entry "get-right" accessor () () #f #f 813 30 813 38 ()}
        {Lisp-Entry "set-right" accessor () () #f #f 813 30 813 38 ()}
        {Lisp-Entry "bottom" slot () ((accessors . "generate")) #f "<fl>" 814 8 814 14 ("fl" "<fl>")}
        {Lisp-Entry "get-bottom" accessor () () #f #f 814 30 814 38 ()}
        {Lisp-Entry "set-bottom" accessor () () #f #f 814 30 814 38 ()}
        {Lisp-Entry "initialize" method (override) ("l" "<fl>" "t" "<fl>" "r" "<fl>" "b" "<fl>") #f #f 817 20 817 30 ("bottom" "right" "top" "left" "set!" "nextmethod" "b" "r" "t" "fl" "<fl>" "l")}
        {Lisp-Entry "copy-object" method (override) ("deep?") #f #f 825 20 825 31 ("bottom" "right" "top" "left" "Rect$fl$" "new" "deep?")}
        {Lisp-Entry "compare-object" method (override) ("target") #f #f 829 20 829 34 (":not-equal" "else" ":equal" "get-bottom" "get-bottom~" "bottom" "get-right" "get-right~" "right" "get-top" "get-top~" "top" "get-left" "get-left~" "left" "=" "and" ":incompatible" "Rect$fl$" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method (override) ("output" "readably") #f #f 838 20 838 25 ("bottom" "right" "top" "left" "self" "class-of" "category-name" "format" "readably" "output")}}
      {Lisp-Entry "rect$fl$?" definition (public inline) ("obj") #f #f 847 27 847 36 ("Rect$fl$" "is?" "obj")}
      {Lisp-Entry "allocate-rect$fl$" definition (public inline) ("left" "<fl>" "top" "<fl>" "right" "<fl>" "bottom" "<fl>") #f #f 851 27 851 44 ("Rect$fl$" "allocate" "bottom" "right" "top" "fl" "<fl>" "left")}
      {Lisp-Entry "new" specialize (inline) ("class" "<category<Rect$fl$>>" "left" "top" "right" "bottom") #f #f 854 20 854 23 ("allocate-rect$fl$" "Rect$fl$" "<Rect$fl$>" "bottom" "right" "top" "left" "category<Rect$fl$>" "<category<Rect$fl$>>" "class")}
      {Lisp-Entry "rect$fl$=?" specialize (inline) () #f #f 858 22 858 32 ()}
      {Lisp-Entry "=" specialize (inline) ("r1" "<Rect$fl$>" "r2" "<Rect$fl$>") ("rect$fl$=?") #f 858 34 858 35 ("get-bottom" "get-bottom~" "get-right" "get-right~" "get-top" "get-top~" "get-left" "get-left~" "=" "and" "bool" "<bool>" "r2" "Rect$fl$" "<Rect$fl$>" "r1")}
      {Lisp-Entry "point->distance" definition (public) ("pt" "<Point>") #f "<Distance>" 870 20 870 35 ("get-v" "get-v~" "get-h" "get-h~" "new" "Distance" "<Distance>" "Point" "<Point>" "pt")}
      {Lisp-Entry "point->dimension" definition (public) ("pt" "<Point>") #f "<Dimension>" 874 20 874 36 ("get-v" "get-v~" "get-h" "get-h~" "new" "Dimension" "<Dimension>" "Point" "<Point>" "pt")}
      {Lisp-Entry "distance->point" definition (public) ("dist" "<Distance>") #f "<Point>" 878 20 878 35 ("get-y" "get-y~" "get-x" "get-x~" "new" "Point" "<Point>" "Distance" "<Distance>" "dist")}
      {Lisp-Entry "distance->dimension" definition (public) ("dist" "<Distance>") #f "<Dimension>" 882 20 882 39 ("get-y" "get-y~" "get-x" "get-x~" "new" "Dimension" "<Dimension>" "Distance" "<Distance>" "dist")}
      {Lisp-Entry "dimension->point" definition (public) ("dim" "<Dimension>") #f "<Point>" 886 20 886 36 ("get-height" "get-height~" "get-width" "get-width~" "new" "Point" "<Point>" "Dimension" "<Dimension>" "dim")}
      {Lisp-Entry "dimension->distance" definition (public) ("dim" "<Dimension>") #f "<Distance>" 890 20 890 39 ("get-height" "get-height~" "get-width" "get-width~" "new" "Distance" "<Distance>" "Dimension" "<Dimension>" "dim")}}})
"homogeneous"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "homogeneous.jazz"} 246662659. jazz
    {Lisp-Entry "jazz.dialect.language.homogeneous" module (protected) () #f #f 37 18 37 51 ("jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("jazz.dialect.language.object" "jazz.dialect.language.functional" "jazz.dialect.kernel")}
      {Lisp-Entry "S8Vector-Class" class () ((extends . "Sequence-Class")) #f #f 53 7 53 21 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 56 20 56 33 ("make-s8vector" "len")}}
      {Lisp-Entry "S8Vector" class (primitive) ((metaclass . "S8Vector-Class") (extends . "Sequence")) #f #f 60 17 60 25 ("Sequence" "S8Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 63 20 63 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 68 11 68 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 74 20 74 36 ("self" "s8vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 78 20 78 41 ("self" "s8vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 82 20 82 40 ("self" "s8vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 86 20 86 33 ("self" "s8vector->list" "tail" "list->s8vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 90 20 90 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 94 20 94 36 ("self" "s8vector->list" "butlast" "list->s8vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<s8vector>" "n") #f #f 98 20 98 27 ("s8vector-ref" "object" "<object>" "n" "s8vector" "<s8vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<s8vector>" "n" "obj") #f #f 102 20 102 32 ("s8vector-set!" "void" "<void>" "obj" "n" "s8vector" "<s8vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<s8vector>") #f #f 106 20 106 31 ("s8vector-length" "int" "<int>" "s8vector" "<s8vector>" "vector")}
      {Lisp-Entry "U8Vector-Class" class () ((extends . "Sequence-Class")) #f #f 115 7 115 21 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 118 20 118 33 ("make-u8vector" "len")}}
      {Lisp-Entry "U8Vector" class (primitive) ((metaclass . "U8Vector-Class") (extends . "Sequence")) #f #f 122 17 122 25 ("Sequence" "U8Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 125 20 125 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 130 11 130 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 136 20 136 36 ("self" "u8vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 140 20 140 41 ("self" "u8vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 144 20 144 40 ("self" "u8vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 148 20 148 33 ("self" "u8vector->list" "tail" "list->u8vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 152 20 152 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 156 20 156 36 ("self" "u8vector->list" "butlast" "list->u8vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<u8vector>" "n") #f #f 160 20 160 27 ("u8vector-ref" "object" "<object>" "n" "u8vector" "<u8vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<u8vector>" "n" "obj") #f #f 164 20 164 32 ("u8vector-set!" "void" "<void>" "obj" "n" "u8vector" "<u8vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<u8vector>") #f #f 168 20 168 31 ("u8vector-length" "int" "<int>" "u8vector" "<u8vector>" "vector")}
      {Lisp-Entry "S16Vector-Class" class () ((extends . "Sequence-Class")) #f #f 177 7 177 22 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 180 20 180 33 ("make-s16vector" "len")}}
      {Lisp-Entry "S16Vector" class (primitive) ((metaclass . "S16Vector-Class") (extends . "Sequence")) #f #f 184 17 184 26 ("Sequence" "S16Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 187 20 187 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 192 11 192 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 198 20 198 36 ("self" "s16vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 202 20 202 41 ("self" "s16vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 206 20 206 40 ("self" "s16vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 210 20 210 33 ("self" "s16vector->list" "tail" "list->s16vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 214 20 214 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 218 20 218 36 ("self" "s16vector->list" "butlast" "list->s16vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<s16vector>" "n") #f #f 222 20 222 27 ("s16vector-ref" "object" "<object>" "n" "s16vector" "<s16vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<s16vector>" "n" "obj") #f #f 226 20 226 32 ("s16vector-set!" "void" "<void>" "obj" "n" "s16vector" "<s16vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<s16vector>") #f #f 230 20 230 31 ("s16vector-length" "int" "<int>" "s16vector" "<s16vector>" "vector")}
      {Lisp-Entry "U16Vector-Class" class () ((extends . "Sequence-Class")) #f #f 239 7 239 22 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 242 20 242 33 ("make-u16vector" "len")}}
      {Lisp-Entry "U16Vector" class (primitive) ((metaclass . "U16Vector-Class") (extends . "Sequence")) #f #f 246 17 246 26 ("Sequence" "U16Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 249 20 249 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 254 11 254 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 260 20 260 36 ("self" "u16vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 264 20 264 41 ("self" "u16vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 268 20 268 40 ("self" "u16vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 272 20 272 33 ("self" "u16vector->list" "tail" "list->u16vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 276 20 276 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 280 20 280 36 ("self" "u16vector->list" "butlast" "list->u16vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<u16vector>" "n") #f #f 284 20 284 27 ("u16vector-ref" "object" "<object>" "n" "u16vector" "<u16vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<u16vector>" "n" "obj") #f #f 288 20 288 32 ("u16vector-set!" "void" "<void>" "obj" "n" "u16vector" "<u16vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<u16vector>") #f #f 292 20 292 31 ("u16vector-length" "int" "<int>" "u16vector" "<u16vector>" "vector")}
      {Lisp-Entry "S32Vector-Class" class () ((extends . "Sequence-Class")) #f #f 301 7 301 22 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 304 20 304 33 ("make-s32vector" "len")}}
      {Lisp-Entry "S32Vector" class (primitive) ((metaclass . "S32Vector-Class") (extends . "Sequence")) #f #f 308 17 308 26 ("Sequence" "S32Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 311 20 311 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 316 11 316 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 322 20 322 36 ("self" "s32vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 326 20 326 41 ("self" "s32vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 330 20 330 40 ("self" "s32vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 334 20 334 33 ("self" "s32vector->list" "tail" "list->s32vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 338 20 338 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 342 20 342 36 ("self" "s32vector->list" "butlast" "list->s32vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<s32vector>" "n") #f #f 346 20 346 27 ("s32vector-ref" "object" "<object>" "n" "s32vector" "<s32vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<s32vector>" "n" "obj") #f #f 350 20 350 32 ("s32vector-set!" "void" "<void>" "obj" "n" "s32vector" "<s32vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<s32vector>") #f #f 354 20 354 31 ("s32vector-length" "int" "<int>" "s32vector" "<s32vector>" "vector")}
      {Lisp-Entry "U32Vector-Class" class () ((extends . "Sequence-Class")) #f #f 363 7 363 22 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 366 20 366 33 ("make-u32vector" "len")}}
      {Lisp-Entry "U32Vector" class (primitive) ((metaclass . "U32Vector-Class") (extends . "Sequence")) #f #f 370 17 370 26 ("Sequence" "U32Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 373 20 373 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 378 11 378 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 384 20 384 36 ("self" "u32vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 388 20 388 41 ("self" "u32vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 392 20 392 40 ("self" "u32vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 396 20 396 33 ("self" "u32vector->list" "tail" "list->u32vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 400 20 400 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 404 20 404 36 ("self" "u32vector->list" "butlast" "list->u32vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<u32vector>" "n") #f #f 408 20 408 27 ("u32vector-ref" "object" "<object>" "n" "u32vector" "<u32vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<u32vector>" "n" "obj") #f #f 412 20 412 32 ("u32vector-set!" "void" "<void>" "obj" "n" "u32vector" "<u32vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<u32vector>") #f #f 416 20 416 31 ("u32vector-length" "int" "<int>" "u32vector" "<u32vector>" "vector")}
      {Lisp-Entry "S64Vector-Class" class () ((extends . "Sequence-Class")) #f #f 425 7 425 22 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 428 20 428 33 ("make-s64vector" "len")}}
      {Lisp-Entry "S64Vector" class (primitive) ((metaclass . "S64Vector-Class") (extends . "Sequence")) #f #f 432 17 432 26 ("Sequence" "S64Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 435 20 435 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 440 11 440 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 446 20 446 36 ("self" "s64vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 450 20 450 41 ("self" "s64vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 454 20 454 40 ("self" "s64vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 458 20 458 33 ("self" "s64vector->list" "tail" "list->s64vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 462 20 462 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 466 20 466 36 ("self" "s64vector->list" "butlast" "list->s64vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<s64vector>" "n") #f #f 470 20 470 27 ("s64vector-ref" "object" "<object>" "n" "s64vector" "<s64vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<s64vector>" "n" "obj") #f #f 474 20 474 32 ("s64vector-set!" "void" "<void>" "obj" "n" "s64vector" "<s64vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<s64vector>") #f #f 478 20 478 31 ("s64vector-length" "int" "<int>" "s64vector" "<s64vector>" "vector")}
      {Lisp-Entry "U64Vector-Class" class () ((extends . "Sequence-Class")) #f #f 487 7 487 22 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 490 20 490 33 ("make-u64vector" "len")}}
      {Lisp-Entry "U64Vector" class (primitive) ((metaclass . "U64Vector-Class") (extends . "Sequence")) #f #f 494 17 494 26 ("Sequence" "U64Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 497 20 497 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 502 11 502 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 508 20 508 36 ("self" "u64vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 512 20 512 41 ("self" "u64vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 516 20 516 40 ("self" "u64vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 520 20 520 33 ("self" "u64vector->list" "tail" "list->u64vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 524 20 524 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 528 20 528 36 ("self" "u64vector->list" "butlast" "list->u64vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<u64vector>" "n") #f #f 532 20 532 27 ("u64vector-ref" "object" "<object>" "n" "u64vector" "<u64vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<u64vector>" "n" "obj") #f #f 536 20 536 32 ("u64vector-set!" "void" "<void>" "obj" "n" "u64vector" "<u64vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<u64vector>") #f #f 540 20 540 31 ("u64vector-length" "int" "<int>" "u64vector" "<u64vector>" "vector")}
      {Lisp-Entry "F32Vector-Class" class () ((extends . "Sequence-Class")) #f #f 549 7 549 22 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 552 20 552 33 ("make-f32vector" "len")}}
      {Lisp-Entry "F32Vector" class (primitive) ((metaclass . "F32Vector-Class") (extends . "Sequence")) #f #f 556 17 556 26 ("Sequence" "F32Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 559 20 559 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 564 11 564 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 570 20 570 36 ("self" "f32vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 574 20 574 41 ("self" "f32vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 578 20 578 40 ("self" "f32vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 582 20 582 33 ("self" "f32vector->list" "tail" "list->f32vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 586 20 586 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 590 20 590 36 ("self" "f32vector->list" "butlast" "list->f32vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<f32vector>" "n") #f #f 594 20 594 27 ("f32vector-ref" "object" "<object>" "n" "f32vector" "<f32vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<f32vector>" "n" "obj") #f #f 598 20 598 32 ("f32vector-set!" "void" "<void>" "obj" "n" "f32vector" "<f32vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<f32vector>") #f #f 602 20 602 31 ("f32vector-length" "int" "<int>" "f32vector" "<f32vector>" "vector")}
      {Lisp-Entry "F64Vector-Class" class () ((extends . "Sequence-Class")) #f #f 611 7 611 22 ("Sequence-Class")
        {Lisp-Entry "make-sequence" method (override) ("len") #f #f 614 20 614 33 ("make-f64vector" "len")}}
      {Lisp-Entry "F64Vector" class (primitive) ((metaclass . "F64Vector-Class") (extends . "Sequence")) #f #f 618 17 618 26 ("Sequence" "F64Vector-Class")
        {Lisp-Entry "initialize" method (override) ("." "rest") #f #f 621 20 621 30 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method () ("object") #f #f 626 11 626 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method (override) ("n") #f #f 632 20 632 36 ("self" "f64vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method (override) ("n" "obj") #f #f 636 20 636 41 ("self" "f64vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method (override) () #f #f 640 20 640 40 ("self" "f64vector-length")}
        {Lisp-Entry "sequence-tail" method (override) ("n") #f #f 644 20 644 33 ("self" "f64vector->list" "tail" "list->f64vector" "n")}
        {Lisp-Entry "sequence-last" method (override) () #f #f 648 20 648 33 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method (override) () #f #f 652 20 652 36 ("self" "f64vector->list" "butlast" "list->f64vector")}}
      {Lisp-Entry "element" specialize (inline) ("vector" "<f64vector>" "n") #f #f 656 20 656 27 ("f64vector-ref" "object" "<object>" "n" "f64vector" "<f64vector>" "vector")}
      {Lisp-Entry "set-element!" specialize (inline) ("vector" "<f64vector>" "n" "obj") #f #f 660 20 660 32 ("f64vector-set!" "void" "<void>" "obj" "n" "f64vector" "<f64vector>" "vector")}
      {Lisp-Entry "cardinality" specialize (inline) ("vector" "<f64vector>") #f #f 664 20 664 31 ("f64vector-length" "int" "<int>" "f64vector" "<f64vector>" "vector")}}})
"increase"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "increase.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.syntax.increase" module (protected) () #f #f 37 18 37 46 ("scheme")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "increase!" macro (public) ("form-src") ("syntax") #f 46 16 46 25 (",increment" "+" ",location" "set!" "car" "1" "null?" "if" "increment" "cddr" "rest" "source-code" "cadr" "location" "let" "form-src")}
      {Lisp-Entry "decrease!" macro (public) ("form-src") ("syntax") #f 56 16 56 25 (",increment" "-" ",location" "set!" "car" "1" "null?" "if" "increment" "cddr" "rest" "source-code" "cadr" "location" "let" "form-src")}}})
"install"
 ({Lisp-File-Entry {File :context "src" "jazz" "install.scm"} 244260910. scheme
    {Lisp-Entry "jazz.install" unit () () #f #f 37 6 37 18 ("jazz-readtable" "jazz:jazz-readtable" "global-ref" "jazz:global-ref" "jazz.dialect" "load-unit" "jazz:load-unit" "load-foundation" "jazz:load-foundation" "lambda" "register-reader-extension" "jazz:register-reader-extension")
      {Lisp-Entry "Point" define () () ("literal") #f 45 21 45 26 ("construct-point" "jazz.literals" "jazz.literals:construct-point")}
      {Lisp-Entry "Distance" define () () ("literal") #f 46 21 46 29 ("construct-distance" "jazz.literals" "jazz.literals:construct-distance")}
      {Lisp-Entry "Dimension" define () () ("literal") #f 47 21 47 30 ("construct-dimension" "jazz.literals" "jazz.literals:construct-dimension")}
      {Lisp-Entry "Cell" define () () ("literal") #f 48 21 48 25 ("construct-cell" "jazz.literals" "jazz.literals:construct-cell")}
      {Lisp-Entry "Rect" define () () ("literal") #f 49 21 49 25 ("construct-rect" "jazz.literals" "jazz.literals:construct-rect")}
      {Lisp-Entry "Range" define () () ("literal") #f 50 21 50 26 ("construct-range" "jazz.literals" "jazz.literals:construct-range")}
      {Lisp-Entry "Exception-Detail" define () () ("literal") #f 51 21 51 37 ("construct-exception-detail" "jazz.literals" "jazz.literals:construct-exception-detail")}
      {Lisp-Entry "Walk-Location" define () () ("literal") #f 52 21 52 34 ("construct-walk-location" "jazz.literals" "jazz.literals:construct-walk-location")}}})
"jazz"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "walker" "jazz.jazz"} 246662659. jazz
    {Lisp-Entry "jazz.dialect.walker.jazz" module (protected) () #f #f 37 18 37 42 ("jazz.dialect")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("jazz.dialect.walker.scheme")}
      {Lisp-Entry "import" import () () #f #f 41 1 41 7 ("jazz.dialect.walker.scheme")}
      {Lisp-Entry "Definition-Declaration" class () ((extends . "Declaration")) #f #f 49 7 49 29 ("Declaration")
        {Lisp-Entry "expansion" slot () ((getter . "generate")) #f #f 52 8 52 17 ()}
        {Lisp-Entry "get-expansion" accessor () () #f #f 52 25 52 33 ()}
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 53 8 53 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 53 25 53 33 ()}
        {Lisp-Entry "value" slot () ((getter . "generate")) #f #f 54 8 54 13 ()}
        {Lisp-Entry "get-value" accessor () () #f #f 54 25 54 33 ()}}
      {Lisp-Entry "Specialize" class () ((extends . "Expression")) #f #f 62 7 62 17 ("Expression")}
      {Lisp-Entry "Generic-Declaration" class () ((extends . "Declaration")) #f #f 70 7 70 26 ("Declaration")
        {Lisp-Entry "dispatch-types" slot () ((getter . "generate")) #f #f 73 8 73 22 ()}
        {Lisp-Entry "get-dispatch-types" accessor () () #f #f 73 30 73 38 ()}
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 74 8 74 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 74 30 74 38 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 75 8 75 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 75 30 75 38 ()}}
      {Lisp-Entry "Specific-Declaration" class () ((extends . "Declaration")) #f #f 83 7 83 27 ("Declaration")
        {Lisp-Entry "generic" slot () ((getter . "generate")) #f #f 86 8 86 15 ()}
        {Lisp-Entry "get-generic" accessor () () #f #f 86 25 86 33 ()}
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 87 8 87 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 87 25 87 33 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 88 8 88 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 88 25 88 33 ()}
        {Lisp-Entry "root?" slot () ((getter . "generate")) #f #f 89 8 89 13 ()}
        {Lisp-Entry "get-root?" accessor () () #f #f 89 25 89 33 ()}}
      {Lisp-Entry "Category-Declaration" class () ((extends . "Namespace-Declaration")) #f #f 97 7 97 27 ("Namespace-Declaration")
        {Lisp-Entry "implementor" slot () ((getter . "generate")) #f #f 100 8 100 19 ()}
        {Lisp-Entry "get-implementor" accessor () () #f #f 100 27 100 35 ()}
        {Lisp-Entry "metaclass" slot () ((getter . "generate")) #f #f 101 8 101 17 ()}
        {Lisp-Entry "get-metaclass" accessor () () #f #f 101 27 101 35 ()}}
      {Lisp-Entry "Class-Declaration" class () ((extends . "Category-Declaration")) #f #f 109 7 109 24 ("Category-Declaration")
        {Lisp-Entry "ascendant" slot () ((getter . "generate")) #f #f 112 8 112 17 ()}
        {Lisp-Entry "get-ascendant" accessor () () #f #f 112 34 112 42 ()}
        {Lisp-Entry "ascendant-relation" slot () ((getter . "generate")) #f #f 113 8 113 26 ()}
        {Lisp-Entry "get-ascendant-relation" accessor () () #f #f 113 34 113 42 ()}
        {Lisp-Entry "ascendant-base" slot () ((getter . "generate")) #f #f 114 8 114 22 ()}
        {Lisp-Entry "get-ascendant-base" accessor () () #f #f 114 34 114 42 ()}
        {Lisp-Entry "interfaces" slot () ((getter . "generate")) #f #f 115 8 115 18 ()}
        {Lisp-Entry "get-interfaces" accessor () () #f #f 115 34 115 42 ()}}
      {Lisp-Entry "Interface-Declaration" class () ((extends . "Category-Declaration")) #f #f 123 7 123 28 ("Category-Declaration")
        {Lisp-Entry "ascendants" slot () ((getter . "generate")) #f #f 126 8 126 18 ()}
        {Lisp-Entry "get-ascendants" accessor () () #f #f 126 26 126 34 ()}}
      {Lisp-Entry "Field-Declaration" class () ((extends . "Declaration")) #f #f 134 7 134 24 ("Declaration")}
      {Lisp-Entry "Slot-Declaration" class () ((extends . "Field-Declaration")) #f #f 142 7 142 23 ("Field-Declaration")
        {Lisp-Entry "initialize" slot () ((getter . "generate")) #f #f 145 8 145 18 ()}
        {Lisp-Entry "get-initialize" accessor () () #f #f 145 27 145 35 ()}
        {Lisp-Entry "getter-name" slot () ((getter . "generate")) #f #f 146 8 146 19 ()}
        {Lisp-Entry "get-getter-name" accessor () () #f #f 146 27 146 35 ()}
        {Lisp-Entry "setter-name" slot () ((getter . "generate")) #f #f 147 8 147 19 ()}
        {Lisp-Entry "get-setter-name" accessor () () #f #f 147 27 147 35 ()}}
      {Lisp-Entry "Property-Declaration" class () ((extends . "Slot-Declaration")) #f #f 155 7 155 27 ("Slot-Declaration")
        {Lisp-Entry "getter" slot () ((getter . "generate")) #f #f 158 8 158 14 ()}
        {Lisp-Entry "get-getter" accessor () () #f #f 158 22 158 30 ()}
        {Lisp-Entry "setter" slot () ((getter . "generate")) #f #f 159 8 159 14 ()}
        {Lisp-Entry "get-setter" accessor () () #f #f 159 22 159 30 ()}}
      {Lisp-Entry "Method-Declaration" class () ((extends . "Field-Declaration")) #f #f 167 7 167 25 ("Field-Declaration")
        {Lisp-Entry "root" slot () ((getter . "generate")) #f #f 170 8 170 12 ()}
        {Lisp-Entry "get-root" accessor () () #f #f 170 28 170 36 ()}
        {Lisp-Entry "propagation" slot () ((getter . "generate")) #f #f 171 8 171 19 ()}
        {Lisp-Entry "get-propagation" accessor () () #f #f 171 28 171 36 ()}
        {Lisp-Entry "abstraction" slot () ((getter . "generate")) #f #f 172 8 172 19 ()}
        {Lisp-Entry "get-abstraction" accessor () () #f #f 172 28 172 36 ()}
        {Lisp-Entry "expansion" slot () ((getter . "generate")) #f #f 173 8 173 17 ()}
        {Lisp-Entry "get-expansion" accessor () () #f #f 173 28 173 36 ()}
        {Lisp-Entry "remote" slot () ((getter . "generate")) #f #f 174 8 174 14 ()}
        {Lisp-Entry "get-remote" accessor () () #f #f 174 28 174 36 ()}
        {Lisp-Entry "synchronized" slot () ((getter . "generate")) #f #f 175 8 175 20 ()}
        {Lisp-Entry "get-synchronized" accessor () () #f #f 175 28 175 36 ()}
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 176 8 176 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 176 28 176 36 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 177 8 177 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 177 28 177 36 ()}}
      {Lisp-Entry "With-Self" class () ((extends . "Expression")) #f #f 185 7 185 16 ("Expression")
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 188 8 188 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 188 20 188 28 ()}}
      {Lisp-Entry "With-Dynamic-Self" class () ((extends . "Expression")) #f #f 196 7 196 24 ("Expression")
        {Lisp-Entry "code" slot () ((getter . "generate")) #f #f 199 8 199 12 ()}
        {Lisp-Entry "get-code" accessor () () #f #f 199 20 199 28 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 200 8 200 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 200 20 200 28 ()}}
      {Lisp-Entry "Cast" class () ((extends . "Expression")) #f #f 208 7 208 11 ("Expression")
        {Lisp-Entry "expression" slot () ((getter . "generate")) #f #f 211 8 211 18 ()}
        {Lisp-Entry "get-expression" accessor () () #f #f 211 26 211 34 ()}}
      {Lisp-Entry "Allocate" class () ((extends . "Expression")) #f #f 219 7 219 15 ("Expression")
        {Lisp-Entry "class" slot () ((getter . "generate")) #f #f 222 8 222 13 ()}
        {Lisp-Entry "get-class" accessor () () #f #f 222 22 222 30 ()}
        {Lisp-Entry "values" slot () ((getter . "generate")) #f #f 223 8 223 14 ()}
        {Lisp-Entry "get-values" accessor () () #f #f 223 22 223 30 ()}}
      {Lisp-Entry "Dispatch" class () ((extends . "Expression")) #f #f 231 7 231 15 ("Expression")
        {Lisp-Entry "name" slot () ((getter . "generate")) #f #f 234 8 234 12 ()}
        {Lisp-Entry "get-name" accessor () () #f #f 234 25 234 33 ()}
        {Lisp-Entry "arguments" slot () ((getter . "generate")) #f #f 235 8 235 17 ()}
        {Lisp-Entry "get-arguments" accessor () () #f #f 235 25 235 33 ()}}
      {Lisp-Entry "Jazz-Dialect" class () ((extends . "Dialect")) #f #f 243 7 243 19 ("Dialect")}
      {Lisp-Entry "Jazz-Walker" class () ((extends . "Scheme-Walker")) #f #f 251 7 251 18 ("Scheme-Walker")}}})
"list"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "list.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.list" unit (protected) () #f #f 37 16 37 38 ()
      {Lisp-Entry "proper-list" define () ("lst") #f #f 40 9 40 25 ("queue-list" "jazz:queue-list" "%%cdr" "set!" "%%car" "enqueue" "jazz:enqueue" "%%pair?" "%%while" "new-queue" "jazz:new-queue" "proper" "let" "lst")}}})
"literals"
 ({Lisp-File-Entry {File :context "src" "jazz" "literals.jazz"} 244260910. jazz
    {Lisp-Entry "jazz.literals" module () () #f #f 37 8 37 21 ("jazz")
      {Lisp-Entry "construct-point" definition (package) ("h" "v") #f #f 45 21 45 36 ("Point" "new" "v" "h")}
      {Lisp-Entry "construct-distance" definition (package) ("x" "y") #f #f 49 21 49 39 ("Distance" "new" "y" "x")}
      {Lisp-Entry "construct-dimension" definition (package) ("width" "height") #f #f 53 21 53 40 ("Dimension" "new" "height" "width")}
      {Lisp-Entry "construct-cell" definition (package) ("line" "col") #f #f 57 21 57 35 ("Cell" "new" "col" "line")}
      {Lisp-Entry "construct-rect" definition (package) ("left" "top" "right" "bottom") #f #f 61 21 61 35 ("Rect" "new" "bottom" "right" "top" "left")}
      {Lisp-Entry "construct-range" definition (package) ("start" "end") #f #f 65 21 65 36 ("Range" "new" "end" "start")}
      {Lisp-Entry "construct-exception-detail" definition (package) ("icon" "title" "location" "children") #f #f 74 21 74 47 ("Exception-Detail" "new" "children" "location" "title" "icon")}
      {Lisp-Entry "construct-walk-location" definition (package) ("unit-locator" "declaration-locator" "locat" "path") #f #f 83 21 83 44 ("Walk-Location" "new" "path" "locat" "declaration-locator" "unit-locator")}}})
"loop"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "loop.scm"} 231466232. scheme
    {Lisp-Entry "jazz.dialect.syntax.loop" module (protected) () #f #f 37 18 37 42 ("scheme")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.dialect.syntax.macros" "jazz.dialect.syntax.bind" "syntax" "phase" "jazz.dialect.syntax.increase" "jazz.dialect.kernel")}
      {Lisp-Entry "->string" native (private) () ("native") #f 46 16 46 29 ()}
      {Lisp-Entry "error" native (private) () ("native") #f 47 16 47 26 ()}
      {Lisp-Entry "loop" macro (public) ("form-src") ("syntax") #f 134 16 134 20 ("expand-loop" "sourcify-if" "source-code" "cdr" "clauses" "let" "form-src")}
      {Lisp-Entry "noobject" define () () #f #f 141 8 141 16 ("noobject" "list")}
      {Lisp-Entry "expand-loop" define () ("clauses") #f #f 145 9 145 20 ("set-cdr!" "list+" "<list+>" "<list>" "cns" "ptr" ",@unless-actions" "unless-actions" ",@when-actions" ",test" "when-actions" "body" "res" "what" ">" "rpt" "count" "specifier?" "=" "then" "then-key" "first" "symbol?" "end" "decrease!" ">=" "downto" "below" "cddr" "<=" "cadr" "scan" "by" "update" "to" "from" "in-properties" "get-next~" "done?~" "iterate-sequence" "is?" "Iterator" "<Iterator>" "itr" "val" "iterator" "in-sequence" "1" "+" "element" "<" "length" "fx" "<fx>" "<vector>" "len" "vec" "vector" "in-vector" "error" "remainder" "keyword" "or" "Object" "<Object>" "in" "parse-for" "receive" "equal" "lst" "set-finally" "expr" "add-epilogue" "after" "add-after" "enqueue-list" "action-list" "add-actions" "action" "before" "add-before" "test" "add-test" "exit-safe" "values" "add-initial-test" "bool" "<bool>" "Object+" "<Object+>" "ext" "ret" "get-return/exit" "add-with" "list" "binding" "null?" "value" "type" "variable" "add-binding" "cons" "Unbound" "increase!" "->string" "string-append" "string->symbol" "symbol" "prefix" "unique" ",@finally" "begin" ",return" ",exit" "eq?" ",@epilogue" ",@afters" ",@actions" ",@befores" ",@tests" "and" "append" "let*" "queue-list" "cdr" "else" "process-finally" "process-return" "process-collect" "collect" "process-sum" "sum" "process-do" "do" "process-unless" "unless" "process-when" "when" "process-every" "every" "process-some" "some" "process-repeat" "repeat" "process-for" "for" "process-with" "with" "case" "rest" "key" "bind" "add-action" "source-code" "pair?" "not" "if" "car" "clause" "not-null?" "while" "new-queue" "expand-loop" "process-clauses" "set!" "expand" "define" "0" "unique-rank" "finally" "epilogue" "afters" "actions" "befores" "withs" "tests" "exit" "noobject" "return" "bindings" "let" "clauses")}}})
"macros"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "macros.scm"} 231466232. scheme
    {Lisp-Entry "jazz.dialect.syntax.macros" module (protected) () #f #f 37 18 37 44 ("scheme")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("syntax" "phase" "scheme.syntax-rules" "jazz.dialect.kernel")}
      {Lisp-Entry "->string" native (private) () ("native") #f 44 16 44 29 ()}
      {Lisp-Entry "error" native (private) () ("native") #f 45 16 45 26 ()}
      {Lisp-Entry "submodule" macro (public) ("name" "." "body") ("macro") #f 48 15 48 24 (",@body" "begin" "body" "name")}
      {Lisp-Entry "constant" macro (public) ("form-src") ("syntax") #f 53 16 53 24 (",value" ",name" "public" "definition" "sourcify-if" "caddr" "value" "source-code" "cadr" "name" "let" "form-src")}
      {Lisp-Entry "expand-body" define-macro (package) () #f #f 61 23 61 34 ("begin" "..." "expr" "unspecified" "_" "syntax-rules")}
      {Lisp-Entry "when" define-macro (public) () #f #f 83 22 83 26 ("expand-body" "if" "..." "expr" "test" "when" "syntax-rules")}
      {Lisp-Entry "unless" define-macro (public) () #f #f 102 22 102 28 ("not" "when" "..." "expr" "test" "unless" "syntax-rules")}
      {Lisp-Entry "prog1" define-macro (public) () #f #f 120 22 120 27 ("expand-body" "value" "let" "..." "expr" "returned" "prog1" "syntax-rules")}
      {Lisp-Entry "while" define-macro (public) () #f #f 142 22 142 27 ("begin" "if" "iterate" "let" "..." "expr" "test" "while" "syntax-rules")}
      {Lisp-Entry "unwind-protect" define-macro (public) () #f #f 163 22 163 36 ("lambda" "dynamic-wind" "..." "protection" "body" "unwind-protect" "syntax-rules")}
      {Lisp-Entry "catch" macro (public) ("form-src") ("syntax") #f 174 16 174 21 ("desourcify" "else" "car" "pair?" ",@body" "exc" "lambda" ",predicate/type" "call-with-catch" "symbol?" "cond" "sourcify-if" "cddr" "body" "source-code" "cadr" "predicate/type" "let" "error" "unwrap-syntactic-closure" "cdr" "null?" "if" "form-src")}
      {Lisp-Entry "~" macro (public) ("form-src") ("syntax") #f 193 16 193 17 (",name" ",obj" "class-of" "dispatch" "apply" "rest" "obj" "lambda" "with-uniqueness" "sourcify-if" "cddr" "car" "object" "cadr" "source-code" "name" "let" "form-src")}
      {Lisp-Entry "expand-push!" define () ("location" "value") #f #f 206 9 206 21 ("cons" "set!" "list" "value" "location")}
      {Lisp-Entry "expand-pop!" define () ("location") #f #f 212 9 212 20 ("cdr" "set!" "list" "location")}
      {Lisp-Entry "expand-assert" define () ("first" "rest") #f #f 216 9 216 22 ("proc" "car" "error" "unless" "list" ":text" "->string" "string-append" "message" "expr" "let*" "null?" "if" "rest" "first")}
      {Lisp-Entry "expand-assert-type" define () ("expr" "type") #f #f 227 9 227 27 ("category-identifier" "error" "is-not?" "when" "list" "let*" "cons" "generate-symbol" "value" "let" "type" "expr")}
      {Lisp-Entry "expand-error?" define () ("body") #f #f 235 9 235 22 ("begin" "cons" "Error" "catch" "list" "generate-symbol" "err" "let" "body")}
      {Lisp-Entry "c-constant" macro (public) ("form-src") ("syntax") #f 248 16 248 26 (",value" ",name" "public" "definition" "sourcify-if" "caddr" "value" "source-code" "cadr" "name" "let" "form-src")}
      {Lisp-Entry "c-enumeration" macro (public) ("form-src") ("syntax") #f 256 16 256 29 (",@definitions" "begin" "public" "definition" "declaration" "lambda" "map" "definitions" "sourcify-if" "cddr" "declarations" "source-code" "cadr" "name" "let" "form-src")}}})
"memory"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "memory.scm"} 246587394. scheme
    {Lisp-Entry "jazz.dialect.core.memory" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "gc" define () () #f #f 40 9 40 16 ("%%gc")}
      {Lisp-Entry "gc-report-set!" define () ("flag") #f #f 44 9 44 28 ("gc-report-set!" "flag")}
      {Lisp-Entry "gc-count" define () () #f #f 48 9 48 22 ("6" "##process-statistics" "f64vector-ref" "%%flonum->fixnum")}
      {Lisp-Entry "process-memory" define () () #f #f 57 9 57 28 ("%%flonum->fixnum" "values" "19" "nonmovable" "18" "movable" "17" "live" "16" "alloc" "15" "f64vector-ref" "heap" "##process-statistics" "vec" "let")}
      {Lisp-Entry "symbols-memory" define () () #f #f 71 9 71 28 ("values" "##symbol-table" "%%vector->list" "%%reverse" "%%cons" "2" "%%vector-ref" "%%symbol?" "if" "loop" "map" "%%symbol->string" "%%string-length" "s" "%%length" "%%fx+" "set!" "lst" "lambda" "for-each" "chars" "0" "count" "let")}
      {Lisp-Entry "classes-statistics" define () () #f #f 93 9 93 32 ("values" "Object" "jazz:Object" "method" "slot" "for-each" "process-method" "Method" "jazz:Method" "process-slot" "Slot" "jazz:Slot" "is?" "jazz:is?" "cond" "field" "name" "lambda" "iterate-table" "jazz:iterate-table" "%%get-class-interface-table" "%%get-class-class-table" "vector-vector-size" "jazz:vector-vector-size" "%%get-class-core-vtable" "%%get-class-instance-slots" "%%get-class-interfaces" "%%get-category-descendants" "list-size" "jazz:list-size" "%%get-category-ancestors" "%%get-category-fields" "table-size" "jazz:table-size" "vector-size" "jazz:vector-size" "fx+" "1" "%%fx+" "set!" "class" "process-class" "define" "sz-methods" "nb-methods" "sz-slots" "nb-slots" "sz-interfaces" "nb-interfaces" "sz-classes" "0" "nb-classes" "let")}
      {Lisp-Entry "word-bytes" define () () #f #f 137 8 137 23 ("4")}
      {Lisp-Entry "f64-bytes" define () () #f #f 138 8 138 22 ("8")}
      {Lisp-Entry "pair-bytes" define () () #f #f 139 8 139 23 ("12")}
      {Lisp-Entry "table-bytes" define () () #f #f 140 8 140 24 ("32")}
      {Lisp-Entry "vector-size" define () ("v") #f #f 143 9 143 25 ("%%vector-length" "%%fx*" "word-bytes" "jazz:word-bytes" "%%fx+" "v")}
      {Lisp-Entry "safe-vector-size" define () ("v") #f #f 146 9 146 30 ("0" "vector-size" "jazz:vector-size" "%%vector?" "if" "v")}
      {Lisp-Entry "f64vector-size" define () ("v") #f #f 151 9 151 28 ("f64vector-length" "f64-bytes" "jazz:f64-bytes" "%%fx*" "word-bytes" "jazz:word-bytes" "%%fx+" "v")}
      {Lisp-Entry "vector-vector-size" define () ("v") #f #f 154 9 154 32 ("1" "%%vector-ref" "%%vector-length" "%%fx<" "size" "n" "iter" "let" "vector-size" "jazz:vector-size" "%%fx+" "0" "%%not" "if" "v")}
      {Lisp-Entry "list-size" define () ("l") #f #f 164 9 164 23 ("%%length" "pair-bytes" "jazz:pair-bytes" "%%fx*" "l")}
      {Lisp-Entry "table-size" define () ("t") #f #f 167 9 167 24 ("0" "%%fx+" "##gc-hash-table?" "if" "%%vector-length" "1" "fx+" "word-bytes" "jazz:word-bytes" "%%fx*" "4" "floats" "5" "gcht2" "3" "%%vector-ref" "gcht1" "let" "t")}}})
"network"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "network.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.network" unit (protected) () #f #f 37 16 37 41 ()
      {Lisp-Entry "open-tcp-client" define () () #f #f 42 12 42 32 ("open-tcp-client")}
      {Lisp-Entry "open-tcp-server" define () () #f #f 43 12 43 32 ("open-tcp-server")}
      {Lisp-Entry "tcp-server-socket-info" define () () #f #f 44 12 44 39 ("tcp-server-socket-info")}
      {Lisp-Entry "call-with-tcp-client" define () ("settings" "proc") #f #f 46 13 46 38 ("close-port" "if" "open-tcp-client" "set!" "lambda" "dynamic-wind" "port" "let" "proc" "settings")}
      {Lisp-Entry "socket-info-address" define () () #f #f 57 12 57 36 ("socket-info-address")}
      {Lisp-Entry "socket-info-port-number" define () () #f #f 58 12 58 40 ("socket-info-port-number")}}})
"number"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "number.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.number" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "fixnum->flonum" define () ("n") #f #f 47 9 47 28 ("Fixnum" "jazz:Fixnum" "type-error" "jazz:type-error" "##fixnum->flonum" "%%fixnum?" "if" "n")}
      {Lisp-Entry "flonum->fixnum" define () ("n") #f #f 52 9 52 28 ("Flonum" "jazz:Flonum" "type-error" "jazz:type-error" "##flonum->fixnum" "%%flonum?" "if" "n")}
      {Lisp-Entry "sharp/sharp/fl+" define () () #f #f 63 8 63 28 ("##fl+")}
      {Lisp-Entry "sharp/sharp/fl-" define () () #f #f 64 8 64 28 ("##fl-")}
      {Lisp-Entry "sharp/sharp/fl*" define () () #f #f 65 8 65 28 ("##fl*")}
      {Lisp-Entry "sharp/sharp/fl/" define () () #f #f 66 8 66 28 ("##fl/")}
      {Lisp-Entry "+infinity" define () () #f #f 74 8 74 22 ("+inf.0")}
      {Lisp-Entry "-infinity" define () () #f #f 77 8 77 22 ("-inf.0")}
      {Lisp-Entry "random-integer" define () () #f #f 88 12 88 31 ("random-integer")}
      {Lisp-Entry "random-real" define () () #f #f 89 12 89 28 ("random-real")}
      {Lisp-Entry "random-source-randomize!" define () () #f #f 90 12 90 41 ("random-source-randomize!")}
      {Lisp-Entry "random-source-pseudo-randomize!" define () () #f #f 91 12 91 48 ("random-source-pseudo-randomize!")}
      {Lisp-Entry "default-random-source" define () () #f #f 92 12 92 38 ("default-random-source")}}})
"object"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "object.jazz"} 231466232. jazz
    {Lisp-Entry "jazz.dialect.language.object" module (protected) () #f #f 37 18 37 46 ("jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "error" native (private) () ("native") #f 46 16 46 26 ()}
      {Lisp-Entry "Object" class (primitive) ((metaclass . "Object-Class")) #f #f 54 17 54 23 ("Object-Class")
        {Lisp-Entry "initialize" method (chained) () #f #f 57 19 57 29 ()}
        {Lisp-Entry "destroy" method (chained) () #f #f 61 19 61 26 ("self" "*destroy-mandatory-objects*" "table-set!")}
        {Lisp-Entry "call-print" method (public virtual) ("output" "detail") #f #f 65 26 65 36 ("print" "detail" "output")}
        {Lisp-Entry "print" method (public virtual) ("output" "detail") #f #f 69 26 69 31 ("print-detail" "lambda" "print-unreadable" "self" "object?" "if" "detail" "output")}
        {Lisp-Entry "print-detail" method (protected) ("output" "detail") #f #f 77 21 77 33 ("write" "self" "display" ":human" "eq?" "if" "detail" "output")}
        {Lisp-Entry "class-actions" method (public virtual) () #f #f 83 26 83 39 ()}
        {Lisp-Entry "focus-actions" method (public virtual) () #f #f 87 26 87 39 ()}
        {Lisp-Entry "guest-actions" method (public virtual) () #f #f 91 26 91 39 ()}
        {Lisp-Entry "hash-object" method (public virtual) () #f #f 95 26 95 37 ("self" "error")}
        {Lisp-Entry "copy-object" method (protected virtual) ("deep?") #f #f 99 29 99 40 ("self" "error" "deep?")}
        {Lisp-Entry "compare-object" method (protected virtual) ("object") #f #f 103 29 103 43 (":incompatible" "object")}
        {Lisp-Entry "ci-compare-object" method (protected virtual) ("object") #f #f 107 29 107 46 (":incompatible" "object")}
        {Lisp-Entry "di-compare-object" method (protected virtual) ("object") #f #f 111 29 111 46 (":incompatible" "object")}
        {Lisp-Entry "describe-object" method (protected virtual) ("output") #f #f 115 29 115 44 ("print" "output")}
        {Lisp-Entry "initialized?" method (public virtual) () #f #f 119 26 119 38 ()}
        {Lisp-Entry "close" method (public virtual) () #f #f 124 26 124 31 ("destroy")}
        {Lisp-Entry "destroy-mandatory" method (protected virtual) ("(info #t)") #f #f 128 29 128 46 ("leaked-object" "when" "table-ref" "let" "obj" "lambda" "make-will" "self" "*destroy-mandatory-objects*" "table-set!" "info")}
        {Lisp-Entry "destroying?" method (public virtual) () #f #f 137 26 137 37 ()}
        {Lisp-Entry "destroyed?" method (public virtual) () #f #f 142 26 142 36 ()}
        {Lisp-Entry "walk-references" method (public virtual) ("proc") #f #f 147 26 147 41 ("proc")}
        {Lisp-Entry "setup-context" method (public virtual) ("context") #f #f 151 26 151 39 ("context")}
        {Lisp-Entry "get-sort-value" method (public virtual) () #f #f 155 26 155 40 ()}
        {Lisp-Entry "coerce-string" method (protected virtual) () #f #f 159 29 159 42 ("self" "error")}
        {Lisp-Entry "iterate-object" method (protected virtual) () #f #f 163 29 163 43 ("self" "error")}
        {Lisp-Entry "object-similar?" method (protected virtual) ("object") #f #f 172 29 172 44 ("self" "eq?" "object")}
        {Lisp-Entry "object-alphabetic?" method (protected virtual) () #f #f 176 29 176 47 ("self" "error")}
        {Lisp-Entry "object-numeric?" method (protected virtual) () #f #f 180 29 180 44 ("self" "error")}
        {Lisp-Entry "object-alphanumeric?" method (protected virtual) () #f #f 184 29 184 49 ("self" "error")}
        {Lisp-Entry "object-whitespace?" method (protected virtual) () #f #f 188 29 188 47 ("self" "error")}
        {Lisp-Entry "object-upper-case?" method (protected virtual) () #f #f 192 29 192 47 ("self" "error")}
        {Lisp-Entry "object-lower-case?" method (protected virtual) () #f #f 196 29 196 47 ("self" "error")}
        {Lisp-Entry "object-upcase" method (protected virtual) () #f #f 200 29 200 42 ("self" "error")}
        {Lisp-Entry "object-downcase" method (protected virtual) () #f #f 204 29 204 44 ("self" "error")}
        {Lisp-Entry "object-capitalize" method (protected virtual) () #f #f 208 29 208 46 ("self" "error")}}
      {Lisp-Entry "compare" definition (public inline) ("a" "<Object>" "b" "<Object>") #f #f 212 27 212 34 ("compare-object" "compare-object~" ":equal" "eqv?" "if" "b" "Object" "<Object>" "a")}
      {Lisp-Entry "ci-compare" definition (public inline) ("a" "<Object>" "b" "<Object>") #f #f 218 27 218 37 ("ci-compare-object" "ci-compare-object~" ":equal" "eqv?" "if" "b" "Object" "<Object>" "a")}
      {Lisp-Entry "di-compare" definition (public inline) ("a" "<Object>" "b" "<Object>") #f #f 224 27 224 37 ("di-compare-object" "di-compare-object~" ":equal" "eqv?" "if" "b" "Object" "<Object>" "a")}
      {Lisp-Entry "copy" definition (public) ("obj" "<Object>") #f #f 230 20 230 24 ("subcopy" "Object" "<Object>" "obj")}
      {Lisp-Entry "subcopy" definition (public) ("obj" "<Object>" "deep?" "<bool>") #f #f 234 20 234 27 ("copy-object" "copy-object~" "bool" "<bool>" "deep?" "Object" "<Object>" "obj")}
      {Lisp-Entry "print-unreadable" definition (public) ("object" "<Object>" "output" "proc") #f #f 238 20 238 36 ("string=?" "unless" "display" "object->serial" "serial" "get-output-string" "open-output-string" "string" "class-of" "get-name" "get-name~" "reference-name" "class-name" "let" "proc" "output" "Object" "<Object>" "object")}
      {Lisp-Entry "native-class" definition (package) ("name") #f #f 254 21 254 33 ("error" "name")}
      {Lisp-Entry "hash" definition (public) ("obj" "<Object>") #f #f 258 20 258 24 ("hash-object" "hash-object~" "Object" "<Object>" "obj")}
      {Lisp-Entry "*destroy-mandatory-objects*" definition (public) () #f #f 267 19 267 46 ("eq?" "test:" "weak-keys:" "make-table")}
      {Lisp-Entry "*leaked-objects-mutex*" definition () () #f #f 270 12 270 34 ("make-mutex")}
      {Lisp-Entry "*leaked-objects*" definition () () #f #f 273 12 273 28 ()}
      {Lisp-Entry "get-leaked-objects" definition (public) () #f #f 276 20 276 38 ("*leaked-objects*")}
      {Lisp-Entry "leaked-object" definition () ("obj" "info") #f #f 279 13 279 26 ("mutex-unlock!" "cons" "*leaked-objects*" "set!" "*leaked-objects-mutex*" "mutex-lock!" "info" "obj")}}})
"parse"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "parse.jazz"} 229929916. jazz
    {Lisp-Entry "jazz.dialect.language.parse" module (protected) () #f #f 37 18 37 45 ("jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("jazz.dialect.language.functional" "jazz.dialect.language.format" "jazz.dialect.language.exception" "jazz.dialect.kernel")}
      {Lisp-Entry "parse-integer" definition (public) ("string") #f #f 49 20 49 33 ("type:" "object:" "Conversion-Error" "new" "signal" "read-string-element" "numeric?" "empty-string?" "not" "and" "if" "string")}
      {Lisp-Entry "parse-hexadecimal" definition (public) ("string") #f #f 55 20 55 37 ("format" "read-string-element" "string")}
      {Lisp-Entry "parse-boolean" definition (public) ("string") #f #f 59 20 59 33 ("type:" "object:" "Conversion-Error" "new" "signal" "else" "ci=?" "or" "not" "cond" "string")}
      {Lisp-Entry "parse-strings" definition (public) ("string" "(separator: separator \",\")") #f #f 66 20 66 33 ("split" "trim-spaces" "lambda" "map" "string=?" "empty-string?" "or" "if" "separator" "separator:" "string")}
      {Lisp-Entry "parse-delimited-string" definition (public) ("string" "(separator: separator \",\")") #f #f 74 20 74 42 ("parse-strings" "lambda" "map" "separator" "separator:" "string")}}})
"pathname"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "pathname.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.pathname" unit (protected) () #f #f 37 16 37 42 ()
      {Lisp-Entry "pathname-expand" define () () #f #f 42 12 42 32 ("path-expand")}
      {Lisp-Entry "file-rename" define () () #f #f 43 12 43 28 ("rename-file")}
      {Lisp-Entry "directory-delete" define () () #f #f 44 12 44 33 ("delete-directory")}
      {Lisp-Entry "current-directory" define () () #f #f 46 13 46 35 ("pathname-exists?" "jazz:pathname-exists?" "if" "pathname-normalize" "jazz:pathname-normalize" "current-directory" "dir" "let")}
      {Lisp-Entry "current-directory-set!" define () ("dir") #f #f 53 13 53 40 ("current-directory" "dir")}
      {Lisp-Entry "with-current-directory" define () ("dir" "thunk") #f #f 56 13 56 40 ("current-directory" "parameterize" "thunk" "dir")}}})
"platform"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "language" "platform.jazz"} 246587394. jazz
    {Lisp-Entry "jazz.dialect.language.platform" module (protected) () #f #f 37 18 37 48 ("jazz.dialect")
      {Lisp-Entry "proclaim" proclaim () () #f #f 40 1 40 9 ("optimizations" "warn")}
      {Lisp-Entry "import" import () () #f #f 43 1 43 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "bell" definition (public) ("." "rest") #f #f 51 20 51 24 ("bell-internal" "jazz.platform" "module-ref" "apply" "rest")}}})
"port"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "port.scm"} 233391358. scheme
    {Lisp-Entry "jazz.dialect.core.port" unit (protected) () #f #f 37 16 37 38 ("jazz.dialect.language.debug.get-console-port" "set!")
      {Lisp-Entry "system-format" define () () #f #f 45 8 45 26 ("format" "jazz:format")}
      {Lisp-Entry "close-port" define () () #f #f 56 12 56 27 ("close-port")}
      {Lisp-Entry "input-port-timeout-set!" define () () #f #f 57 12 57 40 ("input-port-timeout-set!")}
      {Lisp-Entry "output-port-timeout-set!" define () () #f #f 58 12 58 41 ("output-port-timeout-set!")}
      {Lisp-Entry "jazz.dialect.language.debug.get-console-port" define () () #f #f 68 8 68 52 ()}
      {Lisp-Entry "get-console-port" define () () #f #f 74 9 74 30 ("jazz.dialect.language.debug.get-console-port" "if")}}})
"product"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "product.scm"} 243057373. scheme
    {Lisp-Entry "build-test" define () ("descriptor" "#!key" "(unit #f)" "(force? #f)") #f #f 37 9 37 24 ("build-product-descriptor" "jazz:build-product-descriptor" "force?:" "unit:" "custom-compile/build" "jazz:custom-compile/build" "ld-options:" "cc-options:" "jazz.test" "unit-specs" "let" "force?" "unit" "#!key" "descriptor")}})
"reader"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "reader.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.reader" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "make-jazz-readtable" define () () #f #f 47 13 47 37 ("jazzify-readtable!" "jazz:jazzify-readtable!" "%%make-standard-readtable" "readtable-max-unescaped-char-set" "readtable" "let")}
      {Lisp-Entry "jazzify-readtable!" define () ("readtable") #f #f 53 13 53 36 ("read-delimited-string" "jazz:read-delimited-string" "%%readtable-char-sharp-handler-set!" "read-comment" "jazz:read-comment" "read-literal" "jazz:read-literal" "%%readtable-char-class-set!" "named-chars" "jazz:named-chars" "readtable-named-char-table" "jazz:readtable-named-char-table" "%%append" "readtable-named-char-table-set!" "jazz:readtable-named-char-table-set!" "readtable")}
      {Lisp-Entry "named-chars" define () () #f #f 60 12 60 28 ()}
      {Lisp-Entry "in-expression-comment?" define () () #f #f 108 12 108 39 ("make-parameter")}
      {Lisp-Entry "read-literal-hook" define () () #f #f 112 12 112 34 ("make-parameter")}
      {Lisp-Entry "read-literal" define () ("re" "c") #f #f 116 13 116 30 ("construct-literal" "jazz:construct-literal" "and" "read-literal-hook" "jazz:read-literal-hook" "hook" "arguments" "name" "else" "%%cdr" "%%car" "new-literal" "jazz:new-literal" "walk-for" "jazz:walk-for" "%%unspecified" "%%null?" "in-expression-comment?" "jazz:in-expression-comment?" "read-literals?" "jazz:read-literals?" "%%not" "or" "cond" "readenv-wrap" "jazz:readenv-wrap" "%%build-list" "lst" "error" "jazz:error" "peek-char" "%%eqv?" "if" "read-char" "%%readenv-current-filepos" "start-pos" "readenv-port" "jazz:readenv-port" "port" "let" "c" "re")}
      {Lisp-Entry "read-comment" define () ("re" "c") #f #f 142 13 142 30 ("%%read-datum-or-label-or-none-or-dot" "read" "read-char" "in-expression-comment?" "jazz:in-expression-comment?" "parameterize" "readenv-port" "jazz:readenv-port" "port" "let" "c" "re")}
      {Lisp-Entry "read-delimited-string" define () ("re" "next" "start-pos") #f #f 151 13 151 39 ("get-output-string" "readenv-wrap" "jazz:readenv-wrap" "peek-char" "and" "else" "write-char" "case" "escaped" "%%eqv?" "%%eof-object?" "cond" "c" "iter" "open-output-string" "output" "read-char" "readenv-port" "jazz:readenv-port" "port" "let" "start-pos" "next" "re")}
      {Lisp-Entry "jazz-readtable" define () () #f #f 180 12 180 31 ("make-jazz-readtable" "jazz:make-jazz-readtable")}
      {Lisp-Entry "with-jazz-readtable" define () ("thunk") #f #f 184 13 184 37 ("jazz-readtable" "jazz:jazz-readtable" "current-readtable" "parameterize" "thunk")}
      {Lisp-Entry "char-symbol" define () ("char") #f #f 189 13 189 29 ("%%car" "and" "rassq" "jazz:rassq" "res" "jazz-readtable" "jazz:jazz-readtable" "readtable-named-char-table" "jazz:readtable-named-char-table" "table" "let" "char")}
      {Lisp-Entry "readtable?" define () ("obj") #f #f 203 9 203 24 ("%%readtable?" "obj")}
      {Lisp-Entry "make-standard-readtable" define () () #f #f 206 9 206 37 ("%%make-standard-readtable")}
      {Lisp-Entry "readtable-copy" define () ("readtable") #f #f 209 9 209 28 ("%%readtable-copy" "readtable")}
      {Lisp-Entry "readtable-char-delimiter?" define () ("readtable" "c") #f #f 212 9 212 39 ("%%readtable-char-delimiter?" "c" "readtable")}
      {Lisp-Entry "readtable-char-delimiter?-set!" define () ("readtable" "c" "delimiter?") #f #f 215 9 215 44 ("%%readtable-char-delimiter?-set!" "delimiter?" "c" "readtable")}
      {Lisp-Entry "readtable-char-handler" define () ("readtable" "c") #f #f 218 9 218 36 ("%%readtable-char-handler" "c" "readtable")}
      {Lisp-Entry "readtable-char-handler-set!" define () ("readtable" "c" "handler") #f #f 221 9 221 41 ("%%readtable-char-handler-set!" "handler" "c" "readtable")}
      {Lisp-Entry "readtable-char-sharp-handler" define () ("readtable" "c") #f #f 224 9 224 42 ("%%readtable-char-sharp-handler" "c" "readtable")}
      {Lisp-Entry "readtable-char-sharp-handler-set!" define () ("readtable" "c" "handler") #f #f 227 9 227 47 ("%%readtable-char-sharp-handler-set!" "handler" "c" "readtable")}
      {Lisp-Entry "readtable-char-class-set!" define () ("readtable" "c" "delimiter?" "handler") #f #f 230 9 230 39 ("%%readtable-char-class-set!" "handler" "delimiter?" "c" "readtable")}
      {Lisp-Entry "eof-object" define () () #f #f 241 13 241 28 ("#!eof")}
      {Lisp-Entry "read-u8" define () () #f #f 244 12 244 24 ("read-u8")}
      {Lisp-Entry "write-u8" define () () #f #f 245 12 245 25 ("write-u8")}
      {Lisp-Entry "read-subu8vector" define () () #f #f 246 12 246 33 ("read-subu8vector")}
      {Lisp-Entry "write-subu8vector" define () () #f #f 247 12 247 34 ("write-subu8vector")}
      {Lisp-Entry "read-line" define () () #f #f 249 12 249 26 ("read-line")}
      {Lisp-Entry "read-proper-line" define () ("port") #f #f 252 13 252 34 ("%%string-shrink!" "1" "%%fx-" "%%string-ref" "%%eqv?" "0" "%%fx>" "and" "%%string-length" "len" "values" "eof-object?" "if" "read-line" "line" "let" "port")}
      {Lisp-Entry "read-all" define () () #f #f 261 12 261 25 ("read-all")}
      {Lisp-Entry "with-readtable" define () ("readtable" "thunk") #f #f 264 13 264 32 ("current-readtable" "parameterize" "thunk" "readtable")}
      {Lisp-Entry "skip-whitespace" define () ("port") #f #f 271 9 271 29 ("read-char" "peek-char" "char-whitespace?" "%%while" "port")}
      {Lisp-Entry "read-delimited" define () ("port" "delimiter") #f #f 276 9 276 28 ("queue-list" "jazz:queue-list" "read-char" "read" "enqueue" "jazz:enqueue" "peek-char" "%%eqv?" "%%not" "%%while" "skip-whitespace" "jazz:skip-whitespace" "new-queue" "jazz:new-queue" "queue" "let" "delimiter" "port")}
      {Lisp-Entry "read-until" define () ("test" "port") #f #f 286 9 286 24 ("queue-list" "jazz:queue-list" "enqueue" "jazz:enqueue" "set!" "if" "read" "%%not" "%%while" "done?" "new-queue" "jazz:new-queue" "queue" "expr" "let" "port" "test")}
      {Lisp-Entry "read-content" define () ("port") #f #f 298 9 298 26 ("eof-object?" "read-until" "jazz:read-until" "port")}}})
"repository"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "repository.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.repository" unit (protected) () #f #f 37 16 37 44 ()
      {Lisp-Entry "repository-name" define () ("repository") #f #f 45 9 45 29 ("%%repository-name" "repository")}
      {Lisp-Entry "repository-title" define () ("repository") #f #f 48 9 48 30 ("%%repository-name" "%%symbol->string" "repository")}
      {Lisp-Entry "repository-directory" define () ("repository") #f #f 51 9 51 34 ("%%repository-directory" "repository")}
      {Lisp-Entry "repository-library-root" define () ("repository") #f #f 54 9 54 37 ("%%repository-library-root" "repository")}
      {Lisp-Entry "repository-library-directory" define () ("repository") #f #f 57 9 57 42 ("%%repository-library-directory" "repository")}
      {Lisp-Entry "repository-binary?" define () ("repository") #f #f 60 9 60 32 ("%%repository-binary?" "repository")}
      {Lisp-Entry "package-repository" define () ("package") #f #f 69 9 69 32 ("%%package-repository" "package")}
      {Lisp-Entry "package-name" define () ("package") #f #f 72 9 72 26 ("%%package-name" "package")}
      {Lisp-Entry "package-directory" define () ("package") #f #f 75 9 75 31 ("package-root-pathname" "jazz:package-root-pathname" "package")}
      {Lisp-Entry "package-products" define () ("package") #f #f 78 9 78 30 ("%%package-products" "package")}
      {Lisp-Entry "package-profiles" define () ("package") #f #f 81 9 81 30 ("%%package-profiles" "package")}
      {Lisp-Entry "package-profiles-set!" define () ("package" "profiles") #f #f 84 9 84 35 ("%%package-profiles-set!" "profiles" "package")}
      {Lisp-Entry "package-project" define () ("package") #f #f 87 9 87 29 ("%%package-project" "package")}}})
"run"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "run.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.test.run" module () () #f #f 37 8 37 21 ("run" "jazz.test" "load-unit" "descriptor" "lambda" "test" "register-product-run" "jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.test")}}}
  {Lisp-File-Entry {File :context "src" "jazz" "validate" "run.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.validate.run" module () () #f #f 37 8 37 25 ("Classes" "test:" "Validation-Suite" "new" "validate" "validate~" "jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.validation" "jazz.validate")}
      {Lisp-Entry "Classes" definition () () #f #f 44 12 44 19 ("Vector-Tester" "Variable-Tester" "Values-Tester" "Trait-Tester" "Thread-Tester" "Table-Tester" "Syntax-Tester" "Symbol-Tester" "Structure-Tester" "String-Tester" "Sequence-Tester" "Scheme-Tester" "Reader-Tester" "Pathname-Tester" "Object-Tester" "Number-Tester" "List-Tester" "Language-Tester" "Iterator-Tester" "Function-Tester" "Format-Tester" "Form-Tester" "Explorer-Tester" "Error-Tester" "Enumeration-Tester" "Designer-Tester" "Debugger-Tester" "Control-Tester" "Component-Tester" "Collector-Tester" "Char-Tester" "Catalog-Tester" "Boolean-Tester" "Binding-Tester" "Array-Tester" "list")}}})
"runtime"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "runtime.scm"} 231466232. scheme
    {Lisp-Entry "jazz.dialect.runtime" unit (protected) () #f #f 37 16 37 36 ("Definition" "jazz:Definition" "encapsulate-class" "jazz:encapsulate-class")
      {Lisp-Entry "Definition" define-class () () ("class runtime") #f 45 27 45 42 ()}
      {Lisp-Entry "new-definition" define () ("name" "locator") #f #f 48 9 48 28 ("Definition" "jazz:Definition" "allocate-definition" "jazz:allocate-definition" "locator" "name")}
      {Lisp-Entry "register-definition" define () ("module-name" "name" "locator") #f #f 55 9 55 33 ("new-definition" "jazz:new-definition" "register-module-entry" "jazz:register-module-entry" "locator" "name" "module-name")}}})
"runtime-classes"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "runtime-classes.scm"} 231466232. scheme
    {Lisp-Entry "jazz.dialect.runtime-classes" unit (protected) () #f #f 37 16 37 44 ()
      {Lisp-Entry "Definition" define-class () () ("class syntax") #f 45 19 45 34 ("%%get-definition-locator" "locator" "allocate-definition" "jazz:allocate-definition" "Object-Class" "jazz:Object-Class" "name" "Field" "jazz:Field")}}})
"scheme"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "walker" "scheme.jazz"} 229929916. jazz
    {Lisp-Entry "jazz.dialect.walker.scheme" module (protected) () #f #f 37 18 37 44 ("jazz.dialect")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("jazz.dialect.walker.core")}
      {Lisp-Entry "import" import () () #f #f 41 1 41 7 ("jazz.dialect.walker.core")}
      {Lisp-Entry "Define-Declaration" class () ((extends . "Declaration")) #f #f 49 7 49 25 ("Declaration")
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 52 8 52 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 52 25 52 33 ()}
        {Lisp-Entry "value" slot () ((getter . "generate")) #f #f 53 8 53 13 ()}
        {Lisp-Entry "get-value" accessor () () #f #f 53 25 53 33 ()}}
      {Lisp-Entry "Define-Special-Form-Declaration" class () ((extends . "Declaration")) #f #f 61 7 61 38 ("Declaration")
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 64 8 64 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 64 25 64 33 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 65 8 65 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 65 25 65 33 ()}}
      {Lisp-Entry "Define-Macro-Declaration" class () ((extends . "Declaration")) #f #f 73 7 73 31 ("Declaration")
        {Lisp-Entry "signature" slot () ((getter . "generate")) #f #f 76 8 76 17 ()}
        {Lisp-Entry "get-signature" accessor () () #f #f 76 25 76 33 ()}
        {Lisp-Entry "body" slot () ((getter . "generate")) #f #f 77 8 77 12 ()}
        {Lisp-Entry "get-body" accessor () () #f #f 77 25 77 33 ()}}
      {Lisp-Entry "Scheme-Dialect" class () ((extends . "Dialect")) #f #f 85 7 85 21 ("Dialect")}
      {Lisp-Entry "Scheme-Walker" class () ((extends . "Walker")) #f #f 93 7 93 20 ("Walker")}}})
"stack"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "stack.scm"} 233651586. scheme
    {Lisp-Entry "jazz.dialect.core.stack" unit (protected) () #f #f 37 16 37 39 ()
      {Lisp-Entry "procedure-name" define () ("procedure") #f #f 47 13 47 32 ("%%procedure-name" "procedure")}
      {Lisp-Entry "procedure-name-set!" define () ("proc") #f #f 50 13 50 37 ("procedure-name" "jazz:procedure-name" "set!" "proc")}
      {Lisp-Entry "procedure-locat" define () ("procedure") #f #f 53 13 53 33 ("%%procedure-locat" "procedure")}
      {Lisp-Entry "closure?" define () ("obj") #f #f 57 13 57 26 ("%%closure?" "obj")}
      {Lisp-Entry "closure-code" define () ("closure") #f #f 60 13 60 30 ("%%closure-code" "closure")}
      {Lisp-Entry "hidden-frames" define () () #f #f 64 12 64 30 ("##thread-start-action!" "##dynamic-env-bind" "%%list")}
      {Lisp-Entry "hidden-frame?" define () ("frame") #f #f 69 13 69 31 ("hidden-frames" "jazz:hidden-frames" "%%memq" "frame")}
      {Lisp-Entry "hidden-frame?-set!" define () ("predicate") #f #f 72 13 72 36 ("hidden-frame?" "jazz:hidden-frame?" "set!" "predicate")}
      {Lisp-Entry "get-continuation-stack" define () ("cont" "depth") #f #f 76 13 76 40 ("queue-list" "jazz:queue-list" "%%continuation-next-frame" "1" "%%fx+" "enqueue" "jazz:enqueue" "begin" "and" "%%fx<" "%%not" "or" "if" "0" "d" "iter" "new-queue" "jazz:new-queue" "queue" "let" "depth" "cont")}
      {Lisp-Entry "collect-var-val" define () ("var" "val-or-box" "cte" "queue") #f #f 89 13 89 33 ("else" "##unbox" "##var-c-name" "##var-c-boxed?" "##var-i-name" "collect-var-val-aux" "jazz:collect-var-val-aux" "##var-i?" "cond" "queue" "cte" "val-or-box" "var")}
      {Lisp-Entry "collect-var-val-aux" define () ("var" "val" "mutable?" "cte" "queue") #f #f 110 13 110 37 ("else" "##cte-parent-cte" "##inverse-eval-in-env" "##cte-top?" "##procedure?" "unbound" "<unbound>" "unbound-object?" "jazz:unbound-object?" "absent" "<absent>" "absent-object?" "jazz:absent-object?" "cond" "##object->string" "%%list" "enqueue" "jazz:enqueue" "##cadr" "##cdr" "##null?" "##not" "quote" "##car" "eq?" "pair?" "and" "if" "remove-quote" "define" "queue" "cte" "mutable?" "val" "var")}
      {Lisp-Entry "get-continuation-dynamic-environment" define () ("cont") #f #f 135 13 135 54 ("queue-list" "jazz:queue-list" "##interaction-cte" "code-cte" "jazz:code-cte" "##interp-continuation-code" "$code" "%%interp-continuation?" "continuation-denv" "jazz:continuation-denv" "##dynamic-env->list" "and" "new-queue" "jazz:new-queue" "%%list" "collect-var-val-aux" "jazz:collect-var-val-aux" "##inverse-eval-in-env" "x" "##hidden-parameter?" "%%not" "%%cdr" "val" "param" "%%car" "param-val" "let*" "%%pair?" "if" "iter" "let" "queue" "cte" "lst" "collect-parameters" "define" "cont")}
      {Lisp-Entry "get-continuation-lexical-environment" define () ("cont") #f #f 161 13 161 54 ("queue-list" "jazz:queue-list" "##interaction-cte" "%%continuation-locals" "begin" "code-cte" "jazz:code-cte" "##interp-continuation-rte" "##interp-continuation-code" "$code" "%%interp-continuation?" "new-queue" "jazz:new-queue" "and" "collect-locals" "val" "var-val" "let*" "iter" "lst" "collect-vars" "else" "rte-up" "jazz:rte-up" "##cte-parent-cte" "collect-var-val" "jazz:collect-var-val" "##hidden-local-var?" "%%not" "%%car" "var" "%%pair?" "if" "%%vector->list" "%%cdr" "vals" "##cte-frame-vars" "vars" "loop2" "##cte-frame?" "##cte-top?" "cond" "r" "c" "loop1" "let" "queue" "rte" "cte" "collect-rte" "define" "cont")}
      {Lisp-Entry "get-continuation-location" define () ("cont") #f #f 208 13 208 43 ("%%continuation-locat" "locat->container/line/col" "jazz:locat->container/line/col" "cont")}
      {Lisp-Entry "interpreted-continuation?" define () ("cont") #f #f 212 13 212 43 ("%%interp-continuation?" "cont")}
      {Lisp-Entry "with-repl-context" define () ("cont" "thunk") #f #f 216 13 216 35 ("repl-context-bind" "jazz:repl-context-bind" "0" "1" "repl-context-level" "jazz:repl-context-level" "%%fx+" "make-repl-context" "jazz:make-repl-context" "context" "%%thread-repl-context-get!" "prev-context" "let" "thunk" "cont")}
      {Lisp-Entry "repl" define () () #f #f 232 13 232 22 ("%%repl" "begin")}
      {Lisp-Entry "eval-within-no-winding" define () ("runner" "src" "cont" "repl-context" "receiver") #f #f 244 13 244 35 ("##cdr" "##car" "##map" "##cte-top-cte" "##cte-frame" "##continuation-locals" "locals" "else" "##interaction-cte" "##compile-top" "##with-no-result-expected-toplevel-continuation?" "##compile-inner" "##interp-continuation-rte" "code-cte" "jazz:code-cte" "cte" "##interp-continuation-code" "$code" "let*" "##interp-continuation?" "cond" "##make-source" "##sourcify" "src2" ",lst" ",rte" "##cons" "##list->vector" "lst" "macro-make-rte-from-list" "##define-macro" "code-run" "jazz:code-run" "let" "repl-context-bind" "jazz:repl-context-bind" "lambda" "%%continuation-graft-no-winding" "rte" "c" "run" "define" "receiver" "repl-context" "cont" "src" "runner")}
      {Lisp-Entry "eval-within-no-winding" define () ("runner" "expr" "cont") #f #f 278 13 278 40 ("%%car" "%%continuation-return-no-winding" "call-with-values" "results" "current-repl-context" "jazz:current-repl-context" "eval-within-no-winding" "return" "lambda" "continuation-capture" "cont" "expr" "runner")}
      {Lisp-Entry "repl-result-history-add" define () ("result") #f #f 294 13 294 41 ("%%repl-channel-result-history-add" "%%current-thread" "%%thread-repl-channel-get!" "channel" "let" "result")}
      {Lisp-Entry "inspect-repl-context" define () ("context") #f #f 304 13 304 38 ("repl-context-prev-depth" "jazz:repl-context-prev-depth" "repl-context-prev-level" "jazz:repl-context-prev-level" "repl-context-initial-cont" "jazz:repl-context-initial-cont" "repl-context-cont" "jazz:repl-context-cont" "repl-context-depth" "jazz:repl-context-depth" "repl-context-level" "jazz:repl-context-level" ":repl-context" "context")}}})
"step"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "step.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.core.step" unit (protected) () #f #f 37 16 37 38 ()
      {Lisp-Entry "install-step-handler" define () ("proc") #f #f 43 9 43 29 ("void" "vector" "0" "vector-set!" "##current-stepper" "cs" "let" "##cons" "##apply" "lambda" "process-step" "##step-off" "other" "execute-body" "rte" "$code" "leapable?" "handler" "define" "proc")}
      {Lisp-Entry "process-step" define () ("proc" "$code" "execute") #f #f 57 9 57 21 ("continue" "result" "let" "leap" "##step-on" "step" "case" "cmd" "lambda" "##code-locat" "execute" "$code" "proc")}}})
"structure"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "structure.scm"} 233396604. scheme
    {Lisp-Entry "jazz.dialect.core.structure" unit (protected) () #f #f 37 16 37 43 ()
      {Lisp-Entry "kind?" define () ("obj") #f #f 40 9 40 19 ("##type?" "obj")}
      {Lisp-Entry "kind-id" define () ("type") #f #f 43 9 43 21 ("##type-id" "type")}
      {Lisp-Entry "kind-name" define () ("type") #f #f 46 9 46 23 ("##type-name" "type")}
      {Lisp-Entry "kind-flags" define () ("type") #f #f 49 9 49 24 ("##type-flags" "type")}
      {Lisp-Entry "kind-super" define () ("type") #f #f 52 9 52 24 ("##type-super" "type")}
      {Lisp-Entry "kind-length" define () ("type") #f #f 55 9 55 25 ("##type-field-count" "type")}
      {Lisp-Entry "kind-fields" define () ("type") #f #f 58 9 58 25 ("reverse!" "jazz:reverse!" "%%list" "%%cons" "%%fx+" "val" "options" "%%cdr" "rest" "%%car" "name" "let*" "%%pair?" "if" "alist" "##type-all-fields" "fields" "1" "index" "loop" "let" "type")}
      {Lisp-Entry "structure?" define () ("obj") #f #f 76 9 76 24 ("##structure?" "obj")}
      {Lisp-Entry "structure-kind" define () ("obj") #f #f 79 9 79 28 ("##structure-type" "obj")}
      {Lisp-Entry "structure-ref" define () ("obj" "i" "type") #f #f 82 9 82 27 ("##structure-ref" "type" "i" "obj")}
      {Lisp-Entry "structure-set!" define () ("obj" "val" "i" "type") #f #f 85 9 85 28 ("##structure-set!" "type" "i" "val" "obj")}}})
"syntax"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "syntax.scm"} 231466232. scheme
    {Lisp-Entry "test.performance.syntax" unit () () #f #f 0 6 0 29 ("W" "Z")
      {Lisp-Entry "Z" define-class () () ("class syntax") #f 3 19 3 20 ("allocate-z" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "f-vtable" generic/specific () ("n") ("Z~virtual") #f 7 22 7 30 ("n")}
      {Lisp-Entry "g-vtable" generic/specific () ("n") ("Z~virtual") #f 8 22 8 30 ("n")}
      {Lisp-Entry "W" define-class () () ("class syntax") #f 11 19 11 20 ("allocate-w" "Object-Class" "jazz:Object-Class" "Z")}
      {Lisp-Entry "h" generic/specific () () ("W~virtual") #f 15 22 15 23 ()}}})
"system"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "system.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.system" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "open-process" define () () #f #f 42 12 42 29 ("open-process")}
      {Lisp-Entry "process-status" define () () #f #f 43 12 43 31 ("process-status")}
      {Lisp-Entry "exit" define () () #f #f 44 12 44 21 ("exit")}
      {Lisp-Entry "add-exit-job!" define () () #f #f 45 12 45 30 ("##add-exit-job!")}
      {Lisp-Entry "switch?" define () ("arg") #f #f 50 9 50 21 ("%%string-ref" "%%eqv?" "0" "%%string-length" "%%fx>" "and" "arg")}
      {Lisp-Entry "switch-name" define () ("arg") #f #f 55 9 55 25 ("1" "0" "%%substring" "%%equal?" "2" "%%fx>=" "and" "if" "start" "%%string-length" "len" "let" "arg")}
      {Lisp-Entry "kernel-runtime-options-with-no-args" define () () #f #f 63 8 63 48 ()}
      {Lisp-Entry "command-argument" define () ("name") #f #f 67 9 67 30 ("%%cddr" "else" "%%cadr" "%%equal?" "error" "jazz:error" "switch?" "jazz:switch?" "%%not" "or" "kernel-runtime-options-with-no-args" "jazz:kernel-runtime-options-with-no-args" "switch-name" "jazz:switch-name" "%%member" "cond" "%%car" "arg" "%%null?" "arguments" "iter" "command-line" "%%cdr" "all" "let" "executable" "image" "jazz:image" "eq?" "if" "name")}
      {Lisp-Entry "command-argument?" define () ("name") #f #f 86 9 86 31 ("switch-name" "jazz:switch-name" "%%equal?" "switch?" "jazz:switch?" "and" "%%car" "arg" "%%null?" "arguments" "iter" "command-line" "%%cdr" "all" "let" "executable" "image" "jazz:image" "eq?" "if" "name")}}})
"table"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "table.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.table" unit (protected) () #f #f 37 16 37 39 ()
      {Lisp-Entry "table-clear" define () ("table" "key") #f #f 40 9 40 25 ("%%table-clear" "%%table?" "%%debug-assert" "key" "table")}
      {Lisp-Entry "table-keys" define () ("table") #f #f 45 9 45 24 ("%%table-keys" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "table-length" define () ("table") #f #f 50 9 50 26 ("%%table-length" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "map-table" define () ("table" "proc") #f #f 55 9 55 23 ("queue-list" "jazz:queue-list" "enqueue" "jazz:enqueue" "value" "key" "lambda" "iterate-table" "jazz:iterate-table" "new-queue" "jazz:new-queue" "queue" "let" "%%table?" "%%debug-assert" "proc" "table")}
      {Lisp-Entry "list->table" define () ("alist" "#!key" "(test equal?)") #f #f 64 9 64 25 ("test:" "%%list->table" "equal?" "test" "#!key" "alist")}
      {Lisp-Entry "table->list" define () ("table") #f #f 68 9 68 25 ("%%table->list" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "table-entries" define () ("table") #f #f 73 9 73 27 ("%%table-entries" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "eq?-hash" define () () #f #f 80 12 80 25 ("eq?-hash")}
      {Lisp-Entry "eqv?-hash" define () () #f #f 81 12 81 26 ("eqv?-hash")}
      {Lisp-Entry "equal?-hash" define () () #f #f 82 12 82 28 ("equal?-hash")}
      {Lisp-Entry "string=?-hash" define () () #f #f 83 12 83 30 ("string=?-hash")}
      {Lisp-Entry "string-ci=?-hash" define () () #f #f 84 12 84 33 ("string-ci=?-hash")}}})
"template"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "template.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.syntax.template" module (protected) () #f #f 37 18 37 46 ("scheme")}})
"templates"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "templates.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.syntax.templates" module (protected) () #f #f 37 18 37 47 ("scheme")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ()}
      {Lisp-Entry "instantiate-for-each" macro (public) ("name" "T") ("macro") #f 44 15 44 35 ("+" "element" "<=" "when" "0" "n" "iterate" "1" "cardinality" "-" "end" "let" ",T" "seq" "proc" "for-each" ",name" "as" "specialize" "T" "name")}
      {Lisp-Entry "instantiate-butlast" macro (public) ("T") ("macro") #f 53 15 53 34 ("1" "cardinality" "-" "0" "subseq" ",T" "seq" "butlast" "specialize" "T")}
      {Lisp-Entry "instantiate-find" macro (public) ("name" "T") ("macro") #f 60 15 60 31 ("element" "obj" "n" "iterate" "1" "0" "fx" "<fx>" "-" "+" "next" ">=" "<=" "not" "if" "inside" "eqv?" "or" "cardinality" "len" "let" "int+" "<int+>" "reversed?" "reversed?:" "end" "end:" "start" "start:" "test" "test:" "key" "key:" "target" ",T" "seq" "find" ",name" "as" "specialize" "T" "name")}
      {Lisp-Entry "instantiate-find-in" macro (public) ("name" "T") ("macro") #f 79 15 79 34 ("element" "obj" "n" "iterate" "1" "0" "fx" "<fx>" "-" "+" "next" ">=" "<=" "not" "if" "inside" "eqv?" "or" "cardinality" "len" "let" "reversed?" "reversed?:" "end" "end:" "start" "start:" "test" "test:" "key" "key:" "target" ",T" "seq" "find-in" ",name" "as" "specialize" "T" "name")}
      {Lisp-Entry "instantiate-starts-with?" macro (public) ("T") ("macro") #f 96 15 96 39 ("0" "subseq" "=" ">=" "and" "tlen" "cardinality" "slen" "let" "bool" "<bool>" "target" ",T" "seq" "starts-with?" "specialize" "T")}
      {Lisp-Entry "instantiate-ends-with?" macro (public) ("T") ("macro") #f 104 15 104 37 ("-" "subseq" "=" ">=" "and" "tlen" "cardinality" "slen" "let" "bool" "<bool>" "target" ",T" "seq" "ends-with?" "specialize" "T")}}})
"thread"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "thread.scm"} 233806804. scheme
    {Lisp-Entry "jazz.dialect.core.thread" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "disable-interrupts!" define () () #f #f 47 12 47 36 ("##disable-interrupts!")}
      {Lisp-Entry "enable-interrupts!" define () () #f #f 48 12 48 35 ("##enable-interrupts!")}
      {Lisp-Entry "current-thread" define () () #f #f 60 12 60 31 ("current-thread")}
      {Lisp-Entry "thread?" define () () #f #f 61 12 61 24 ("thread?")}
      {Lisp-Entry "make-thread" define () () #f #f 62 12 62 28 ("make-thread")}
      {Lisp-Entry "make-root-thread" define () () #f #f 63 12 63 33 ("make-root-thread")}
      {Lisp-Entry "thread-name" define () () #f #f 64 12 64 28 ("thread-name")}
      {Lisp-Entry "thread-specific" define () () #f #f 65 12 65 32 ("thread-specific")}
      {Lisp-Entry "thread-specific-set!" define () () #f #f 66 12 66 37 ("thread-specific-set!")}
      {Lisp-Entry "thread-base-priority" define () () #f #f 67 12 67 37 ("thread-base-priority")}
      {Lisp-Entry "thread-base-priority-set!" define () () #f #f 68 12 68 42 ("thread-base-priority-set!")}
      {Lisp-Entry "thread-priority-boost" define () () #f #f 69 12 69 38 ("thread-priority-boost")}
      {Lisp-Entry "thread-priority-boost-set!" define () () #f #f 70 12 70 43 ("thread-priority-boost-set!")}
      {Lisp-Entry "thread-start!" define () () #f #f 71 12 71 30 ("thread-start!")}
      {Lisp-Entry "thread-yield!" define () () #f #f 72 12 72 30 ("thread-yield!")}
      {Lisp-Entry "thread-sleep!" define () () #f #f 73 12 73 30 ("thread-sleep!")}
      {Lisp-Entry "thread-terminate!" define () () #f #f 74 12 74 34 ("thread-terminate!")}
      {Lisp-Entry "thread-join!" define () () #f #f 75 12 75 29 ("thread-join!")}
      {Lisp-Entry "thread-send" define () () #f #f 76 12 76 28 ("thread-send")}
      {Lisp-Entry "thread-receive" define () () #f #f 77 12 77 31 ("thread-receive")}
      {Lisp-Entry "thread-interrupt!" define () () #f #f 78 12 78 34 ("thread-interrupt!")}
      {Lisp-Entry "thread-thread-group" define () () #f #f 79 12 79 36 ("thread-thread-group")}
      {Lisp-Entry "thread-group->thread-group-list" define () () #f #f 80 12 80 48 ("thread-group->thread-group-list")}
      {Lisp-Entry "thread-group->thread-group-vector" define () () #f #f 81 12 81 50 ("thread-group->thread-group-vector")}
      {Lisp-Entry "thread-group->thread-list" define () () #f #f 82 12 82 42 ("thread-group->thread-list")}
      {Lisp-Entry "thread-group->thread-vector" define () () #f #f 83 12 83 44 ("thread-group->thread-vector")}
      {Lisp-Entry "thread-state" define () () #f #f 84 12 84 29 ("thread-state")}
      {Lisp-Entry "thread-state-abnormally-terminated-reason" define () () #f #f 85 12 85 58 ("thread-state-abnormally-terminated-reason")}
      {Lisp-Entry "thread-state-abnormally-terminated?" define () () #f #f 86 12 86 52 ("thread-state-abnormally-terminated?")}
      {Lisp-Entry "thread-state-active-timeout" define () () #f #f 87 12 87 44 ("thread-state-active-timeout")}
      {Lisp-Entry "thread-state-active-waiting-for" define () () #f #f 88 12 88 48 ("thread-state-active-waiting-for")}
      {Lisp-Entry "thread-state-active?" define () () #f #f 89 12 89 37 ("thread-state-active?")}
      {Lisp-Entry "thread-state-initialized?" define () () #f #f 90 12 90 42 ("thread-state-initialized?")}
      {Lisp-Entry "thread-state-normally-terminated-result" define () () #f #f 91 12 91 56 ("thread-state-normally-terminated-result")}
      {Lisp-Entry "thread-state-normally-terminated?" define () () #f #f 92 12 92 50 ("thread-state-normally-terminated?")}
      {Lisp-Entry "thread-state-uninitialized?" define () () #f #f 93 12 93 44 ("thread-state-uninitialized?")}
      {Lisp-Entry "thread-continuation" define () ("thread") #f #f 96 13 96 37 ("0" "##vector-ref" "%%eqv?" "%%not" "thread-cont" "jazz:thread-cont" "cont" "let" "thread-state" "jazz:thread-state" "thread-state-active?" "jazz:thread-state-active?" "if" "thread")}
      {Lisp-Entry "mutex?" define () () #f #f 115 12 115 23 ("mutex?")}
      {Lisp-Entry "make-mutex" define () () #f #f 116 12 116 27 ("make-mutex")}
      {Lisp-Entry "mutex-name" define () () #f #f 117 12 117 27 ("mutex-name")}
      {Lisp-Entry "mutex-specific" define () () #f #f 118 12 118 31 ("mutex-specific")}
      {Lisp-Entry "mutex-specific-set!" define () () #f #f 119 12 119 36 ("mutex-specific-set!")}
      {Lisp-Entry "mutex-state" define () () #f #f 120 12 120 28 ("mutex-state")}
      {Lisp-Entry "mutex-lock!" define () () #f #f 121 12 121 28 ("mutex-lock!")}
      {Lisp-Entry "mutex-unlock!" define () () #f #f 122 12 122 30 ("mutex-unlock!")}
      {Lisp-Entry "mutex-owner" define () ("mutex") #f #f 124 13 124 29 ("btq-owner" "jazz:btq-owner" "mutex")}
      {Lisp-Entry "mutex-wait" define () ("mutex") #f #f 127 13 127 28 ("mutex-unlock!" "mutex-lock!" "mutex")}
      {Lisp-Entry "condition?" define () () #f #f 141 12 141 27 ("condition-variable?")}
      {Lisp-Entry "make-condition" define () () #f #f 142 12 142 31 ("make-condition-variable")}
      {Lisp-Entry "condition-name" define () () #f #f 143 12 143 31 ("condition-variable-name")}
      {Lisp-Entry "condition-specific" define () () #f #f 144 12 144 35 ("condition-variable-specific")}
      {Lisp-Entry "condition-specific-set!" define () () #f #f 145 12 145 40 ("condition-variable-specific-set!")}
      {Lisp-Entry "condition-signal!" define () () #f #f 146 12 146 34 ("condition-variable-signal!")}
      {Lisp-Entry "condition-broadcast!" define () () #f #f 147 12 147 37 ("condition-variable-broadcast!")}}})
"time"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "time.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.time" unit (protected) () #f #f 37 16 37 38 ()
      {Lisp-Entry "current-systime" define () () #f #f 40 8 40 28 ("current-time")}
      {Lisp-Entry "systime?" define () () #f #f 41 8 41 21 ("time?")}
      {Lisp-Entry "systime->seconds" define () () #f #f 42 8 42 29 ("time->seconds")}
      {Lisp-Entry "seconds->systime" define () () #f #f 43 8 43 29 ("seconds->time")}
      {Lisp-Entry "process-times" define () () #f #f 44 8 44 26 ("process-times")}
      {Lisp-Entry "cpu-time" define () () #f #f 45 8 45 21 ("cpu-time")}
      {Lisp-Entry "real-time" define () () #f #f 46 8 46 22 ("real-time")}}}
  {Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "time.scm"} 222341474. scheme
    {Lisp-Entry "test.performance.time" unit () () #f #f 0 6 0 27 ("new-z" "f-vtable" "f-generic" "f-separate" "iterations" "new-x" "f-module" "time")
      {Lisp-Entry "iterations" define () () #f #f 3 8 3 18 ("100000000")}}})
"typecase"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "typecase.scm"} 231466232. scheme
    {Lisp-Entry "jazz.dialect.syntax.typecase" module (protected) () #f #f 38 18 38 46 ("scheme")
      {Lisp-Entry "import" import () () #f #f 41 1 41 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "error" native (private) () ("native") #f 44 16 44 26 ()}
      {Lisp-Entry "typecase" macro (public) ("form-src") ("syntax") #f 54 16 54 24 ("desourcify" ",value" ",variable" "is?" "value" "or" "pair?" ",@body" "else" "eq?" "body" "car" "selector" "clause" "map" "cond" "variable" "lambda" "with-uniqueness" "sourcify-if" "cddr" "clauses" "cadr" "target" "let" "error" "source-code" "cdr" "null?" "if" "form-src")}}})
"variables"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "variables.scm"} 222341474. scheme
    {Lisp-Entry "SEPARATE" define () () #f #f 4 8 4 16 ("2")}
    {Lisp-Entry "inc-separate" define () ("cnt") #f #f 7 9 7 21 ("-" "1" "+" "SEPARATE" "set!" "begin" "0" ">" "if" "n" "iter" "let" "cnt")}
    {Lisp-Entry "BLOCK" define () () #f #f 19 8 19 13 ("3")}
    {Lisp-Entry "inc-block" define () ("cnt") #f #f 22 9 22 18 ("-" "1" "+" "BLOCK" "set!" "begin" "0" ">" "if" "n" "iter" "let" "cnt")}})
"vb"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "vb.scm"} 222341474. scheme
    {Lisp-Entry "VAR" define () () #f #f 5 8 5 11 ("2")}
    {Lisp-Entry "inc" define () ("cnt") #f #f 8 9 8 12 ("##fixnum.-" "1" "##fixnum.+" "VAR" "set!" "begin" "0" "##fixnum.>" "if" "n" "iter" "let" "cnt")}})
"vector"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "core" "vector.scm"} 231466231. scheme
    {Lisp-Entry "jazz.dialect.core.vector" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "vector-copy" define () () #f #f 45 8 45 24 ("vector-copy")}}})
"vs"
 ({Lisp-File-Entry {File :context "src" "jazz" "test" "performance" "vs.scm"} 222341474. scheme
    {Lisp-Entry "VAR" define () () #f #f 4 8 4 11 ("2")}
    {Lisp-Entry "inc" define () ("cnt") #f #f 7 9 7 12 ("##fixnum.-" "1" "##fixnum.+" "VAR" "set!" "begin" "0" "##fixnum.>" "if" "n" "iter" "let" "cnt")}})
"walk"
 ({Lisp-File-Entry {File :context "src" "jazz" "script" "walk.jazz"} 225349914. jazz
    {Lisp-Entry "jazz.script.walk" module () () #f #f 37 8 37 24 ("walk-run" "descriptor" "lambda" "walk" "register-product-run" "jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.runtime" "jazz.io")}
      {Lisp-Entry "walk-run" definition (public) () #f #f 49 20 49 28 ("walk-problems" "else" "walk-unresolved" "command-argument?" "cond")}
      {Lisp-Entry "walk-problems" define () () #f #f 61 9 61 22 ("format-plural" "format-cardinality" ":console" "walking" "terminal" "feedback:" "iterate-units" "walk-unit" "increase!" "display-exception" "format" "exc" "Walk-Problems" "catch" "unit-name" "walk-with-catch" "define" "0" "count" "let" "port" "lambda" "get-eol-encoding" "eol-encoding:" "path:" "list" "call-with-output-file")}
      {Lisp-Entry "walk-unresolved" define () () #f #f 87 9 87 24 ("table-values" "apply" "remove-duplicates" "table-keys" "pp" "port" "get-eol-encoding" "eol-encoding:" "path:" "list" "call-with-output-file" "walking" "terminal" "feedback:" "iterate-units" "walk-unit" "get-symbol" "get-symbol~" "table-add" "Unresolved-Error" "is?" "when" "problem" "lambda" "for-each" "get-errors" "get-errors~" "get-warnings" "get-warnings~" "append" "problems" "exc" "Walk-Problems" "catch" "unit-name" "walk" "define" "eq?" "test:" "make-table" "unresolved" "let")}}})
"with"
 ({Lisp-File-Entry {File :context "src" "jazz" "dialect" "syntax" "with.scm"} 229929916. scheme
    {Lisp-Entry "jazz.dialect.syntax.with" module (protected) () #f #f 37 18 37 42 ("scheme")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.dialect.kernel")}
      {Lisp-Entry "with" macro (public) ("form-src") ("syntax") #f 45 16 45 20 ("close~" ",@body" "dynamic-wind" "caddr" ",variable" "set!" "if" "variable" ",specifier" "car" "Object" "<Object>" "binding-specifier" "or" "specifier" "binding" "lambda" "map" "sourcify-if" "cddr" "body" "cadr" "source-code" "bindings" "let" "form-src")}}})
