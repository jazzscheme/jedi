"JazzScheme-Server"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "server" "JazzScheme-Server.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.website.server.JazzScheme-Server" module (protected) () #f #f 37 18 37 55 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.network")}
      {Lisp-Entry "JazzScheme-Server" class () ((extends . "Web-Server")) #f #f 43 7 43 24 ("Web-Server")}}})
"JazzScheme-Site"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "server" "JazzScheme-Site.jazz"} 246587394. jazz
    {Lisp-Entry "jazz.website.server.JazzScheme-Site" module (protected) () #f #f 37 18 37 53 ("jazz")
      {Lisp-Entry "JazzScheme-Site" class () ((extends . "Object")) #f #f 40 7 40 22 ("Object")}}})
"JazzWebsite-Transformation"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "transformation" "JazzWebsite-Transformation.jazz"} 231466231. jazz
    {Lisp-Entry "jazz.website.transformation.JazzWebsite-Transformation" module (protected) () #f #f 37 18 37 72 ("jazz")
      {Lisp-Entry "import" import () () #f #f 40 1 40 7 ("jazz.website" "jazz.system" "jazz.library.component" "jazz.jml" "jazz.io" "jazz.doc" "jazz.catalog")}
      {Lisp-Entry "JazzWebsite-Transformation" class () ((extends . "DocToHTML-Transformation")) #f #f 49 7 49 33 ("DocToHTML-Transformation")
        {Lisp-Entry "anchors" slot () () #f #f 52 8 52 15 ()}
        {Lisp-Entry "anchor-names" slot () () #f #f 53 8 53 20 ()}
        {Lisp-Entry "next-section" slot () () #f #f 54 8 54 20 ()}
        {Lisp-Entry "website" method () ("node") ("pattern") #f 62 12 62 19 ("process-website" "user-feedback" "node")}
        {Lisp-Entry "division" method () ("node") ("pattern") #f 67 12 67 20 ("children->jml" "children->jml~" ",title" "b" "<b>" "p" "<p>" "->string" "name:" "a" "<a>" "not" "if" "span" "<span>" "title" "get-property" "get-property~" "name" "let" "node")}
        {Lisp-Entry "screenshot" method () ("node") ("pattern") #f 80 12 80 22 (",label" "align:" "class:" ",preview" "src:" "img" "<img>" ",image" "href:" "a" "<a>" "div" "<div>" "image" "preview" "get-property" "get-property~" "label" "let" "node")}
        {Lisp-Entry "process-website" method () ("website") #f #f 95 11 95 26 ("<website>" "subsection" "subsections" "subsec" "memq?" "b" "<b>" ",path" "class:" "a" "<a>" "selected?" "path" "subsecs" "sec" "bind" "info" "p" "<p>" "manual-output" "navigation-output" "h1" "<h1>" "id:" "div" "<div>" "body" "<body>" ",title" "<title>" "type:" "rel:" "href:" "link" "<link>" "head" "<head>" "<html>" "title" "error" "else" "output-article" "article" "case" "JML-Element" "is?" "if" "for-each" "output" "section-content-output" ",html" "section-path" "format" "path:" "page" "<page>" "manual?" "not" "generate-manual?" "or" "section-output" "html" "get-property" "get-property~" "user-feedback" "next-section" "test:" "make-table" "anchors" "set!" "reset-section" "message-box" "->string" ":bulleted" "list" "message" "not-null?" "get-output" "get-output~" "ambiguities" "put" "put~" "1" "length" ">" "when" "lst" "name" "anchor-names" "iterate-table" "List-Factory" "new" "fact" "let" "validate-anchor-names" "process-section" "pages" "sections" "process-sections" "get-children" "get-children~" "get-tag" "get-tag~" "eq?" "node" "collect-if" "cons" "section" "lambda" "map" "collect-sections" "define" "website")}
        {Lisp-Entry "section-path" definition () ("section") #f #f 204 15 204 27 ("index" "home" "eq?" "if" "get-property" "get-property~" "name" "let" "section")}
        {Lisp-Entry "manual-output" method () ("section") #f #f 216 11 216 24 ("summary-output" "summary" "toc-output" "toc" "index-output" "index?" "if" "index" "manual-content-output" "content" "present-doc-title" "key:" "find-docs" "map" "append" "apply" "string<?" "sort" "project-paths" "get-property" "get-property~" "title" "let*" "add-catalog" "add-catalog~" "Component-Catalog" "catalog" "get-name" "get-name~" "name" "project" "lambda" "for-each" "Cataloguer" "new" "cataloguer" "let" "projects" "new-projects-cataloguer" "define" "section")}
        {Lisp-Entry "manual-content-output" method () ("cataloguer" "projects") #f #f 240 11 240 32 ("get-output" "get-output~" "project" "List-Factory" "new" "length" "0" "naturals" "+" "rank" "present-doc-title" "nu<?" "sort" "sorted" "effective-manual-doc-children" "children" "get-sort?" "get-sort?~" "and" "let*" "key" "sort?" "get-children" "get-children~" ",@rest" "rest" "example" "map" "node" "<node>" "get-examples" "get-examples~" "examples" "put-sequence" "put-sequence~" "form->node" "->jml" "->jml~" "paragraphs" "tag" "bind" "get-description" "get-description~" "description" "virtual" "get-propagation" "get-propagation~" "eq?" "get-parameters" "get-parameters~" "or" "i" "<i>" "b" "<b>" "interface-doc" "get-interfaces" "get-interfaces~" "interfaces" "get-ascendant" "get-ascendant~" "ascendant" "get-name" "get-name~" "href:" "a" "<a>" "set!" "ascendant-doc" "for-each" "first?" "p" "<p>" "not-null?" "when" "get-ascendants" "get-ascendants~" "collect" "ascendants" "get-definition~" "get-definition" "present-text" "present-text~" "output-doc-examples" "span" "<span>" "docterm" "<docterm>" "Category-Doc" "is?" "if" "cons" "child" "lambda" "key:" "sort?:" "h4" "<h4>" "2" ",title" "1" "case" "present-toc-path" "format" "title" "let" "output-manual-doc-children" "output-doc-description" "get-effective-title" "get-effective-title~" "class:" "h3" "<h3>" "put" "put~" "output-anchor" "error" "else" "output-manual-generic" "Generic-Doc" "output-manual-definition" "Definition-Doc" "output-manual-export" "Export-Doc" "output-manual-method" "Method-Doc" "output-manual-property" "Property-Doc" "output-manual-slot" "Slot-Doc" "output-manual-constant" "Constant-Doc" "output-manual-primitive" "Primitive-Doc" "output-manual-syntax" "Syntax-Doc" "output-manual-concept" "Concept-Doc" "output-manual-form" "Form-Doc" "output-manual-class" "Class-Doc" "output-manual-interface" "Interface-Doc" "output-manual-module" "Module-Doc" "output-manual-unit" "Unit-Doc" "output-manual-package" "Package-Doc" "output-manual-section" "Section-Doc" "output-manual-project" "Project-Doc" "typecase" "output" "path" "level" "doc" "output-manual-doc" "define" "projects" "cataloguer")}
        {Lisp-Entry "effective-manual-doc-children" method () ("doc") #f #f 454 11 454 40 ("get-output" "get-output~" "get-children" "get-children~" "put" "put~" "put-sequence" "put-sequence~" "find-docs" "docs" "get-path" "get-path~" "path" "let*" "Doc-Insert" "is?" "if" "child" "lambda" "for-each" "List-Factory" "new" "fact" "let" "doc")}
        {Lisp-Entry "find-docs" method () ("path") #f #f 466 11 466 20 ("get-output" "get-output~" "find-docs" "unimplemented" "else" "get-catalogs" "get-catalogs~" "get-parent-project" "get-parent-project~" "for-each" "get-project" "get-project~" "parent" "*" "equal?" "get-client" "get-client~" "null?" "cond" "assert" "find-catalog" "find-catalog~" "catalog" "read-form" "instantiate" "instantiate~" "put" "put~" "get-extension" "get-extension~" "extension=?" "file" "lambda" "iterate-directory" "iterate-directory~" "exists?" "exists?~" "when" "Jazz" "Directory" "reference-dir" "let" ":reference" "eq?" "list" "symbol?" "if" "rest" "name" "bind" "List-Factory" "new" "docs" "get-documentation-cataloguer" "get-documentation-cataloguer~" "cataloguer" "get-application" "appl" "let*" "path")}
        {Lisp-Entry "output-anchor" method () ("doc" "output") #f #f 493 11 493 24 ("anchor-names" "table-add" "when" ",anchor" "name:" "a" "<a>" "put" "put~" "anchors" "register-anchor" "anchor" "get-name" "get-name~" "name" "let" "output" "doc")}
        {Lisp-Entry "register-anchor" method () ("object" "name" "anchors") #f #f 501 11 501 26 ("table-set!" "increase!" "next-section" "format" "prog1" "->string" "if" "anchor" "let" "anchors" "name" "object")}
        {Lisp-Entry "docterm" method () ("node") ("pattern") #f 507 12 507 19 (",term" "align:" ",body" "td" "<td>" "tr" "<tr>" "width:" "table" "<table>" "second" "body" "first" "term" "get-children" "get-children~" "children" "let" "node")}
        {Lisp-Entry "summary-output" method () ("title" "section" "projects") #f #f 522 11 522 25 ("list" "car" "get-children" "get-children~" "=" "docs" "p" "<p>" "index?" "get-property" "get-property~" ",title" "h3" "<h3>" "style:" "user-feedback" "for-each" "Section-Doc" "set!" "Project-Doc" "typecase" "iter" "has?" "key:" "string<?" "sort" "has-project-descendant?" "collect-if" "effective-manual-doc-children" "let" "length" "0" "naturals" "cons" "1" "+" "rank" "child" "lambda" "map" "null?" "if" ",text" ",anchor" "href:" "a" "<a>" "class:" "div" "<div>" "collect-summary-children" "children" "anchors" "table-ref" "anchor" "present-toc-path" "format" "text" "present-doc-title" "let*" "path" "level" "doc" "doc-summary-output" "define" "projects" "section" "title")}
        {Lisp-Entry "toc-output" method () ("projects") #f #f 572 11 572 21 ("list" "get-children" "get-children~" "docs" "h3" "<h3>" "name:" "user-feedback" "key:" "string<?" "sort" "Category-Doc" "Module-Doc" "Unit-Doc" "Package-Doc" "Section-Doc" "Project-Doc" "is?" "or" "collect-if" "effective-manual-doc-children" "let" "length" "0" "naturals" "cons" "+" "child" "lambda" "map" "null?" ",text" ",anchor" "href:" "a" "<a>" "class:" "div" "<div>" "3" "<=" "1" "=" "and" "if" "toc-prefix" "car" "rank" "collect-toc-children" "children" "anchors" "table-ref" "anchor" "present-toc-path" "format" "text" "present-doc-title" "title" "let*" "path" "level" "doc" "doc-toc-output" "define" "projects")}
        {Lisp-Entry "present-doc-title" definition () ("doc") #f #f 610 15 610 32 ("get-effective-title" "get-effective-title~" "doc")}
        {Lisp-Entry "present-toc-path" definition () ("path") #f #f 614 15 614 31 ("reverse" "->string" "map" "join" "path")}
        {Lisp-Entry "index-output" method () () #f #f 623 11 623 23 ("width:" "table" "<table>" "h3" "<h3>" "eq?" "test:" "make-table" "user-feedback" "alphabetic?" "get-output" "get-output~" "br" "<br>" "not-null?" "b" "<b>" "table-ref" "car" "letter-set" "process-letter-set" "List-Factory" "new" "alpha" "assv-value" "non-alpha" "alphabetic-partition" "let*" "letters" "index-navigator" "nu<?" "sort" "list" "cons" "set!" "get-effective-title" "get-effective-title~" "get-name" "get-name~" "when" "anchors" "iterate-table" "lst" "third" "first" "upcase" "key:" "gather-anchors" "partition" "letters-partition" ",title" "code" "<code>" "href:" "format" "title" "doc" "info" "lambda" "for-each" "string" ",anchor" "name:" "a" "<a>" "class:" "div" "<div>" "colspan:" "td" "<td>" "tr" "<tr>" "put" "put~" "register-anchor" "anchor" "let" "infos" "char" "bind" "output" "letter-anchors" "letter" "output-letter" "define")}
        {Lisp-Entry "output-article" method () ("article" "level" "output") #f #f 691 11 691 25 ("get-children" "get-children~" "error" "+" "output-article" "get-tag" "get-tag~" "JML-Element" "is?" "node" "lambda" "for-each" "children->jml" "children->jml~" "else" "class:" "h4" "<h4>" "2" ",title" "h3" "<h3>" "1" "case" "title" "->string" "name:" "a" "<a>" "not" "if" "get-property" "get-property~" "name" "let" "div" "<div>" "put" "put~" "description" "output-article-description" "define" "output" "level" "article")}}}})
"Website"
 ({Lisp-File-Entry {File :context "src" "profile" "website" "Website.jazz"} 228872865. jazz
    {Lisp-Entry "profile.website.Website" module () () #f #f 8 8 8 31 ("Website" "register-profile-class" "jazz")
      {Lisp-Entry "import" import () () #f #f 11 1 11 7 ("time" "jedi" "jazz.website" "jazz.ui.view" "jazz.ui.dialog" "jazz.ui.clipboard" "jazz.ui" "jazz.system" "jazz.profile" "jazz.platform" "jazz.network" "jazz.library" "jazz.jml" "jazz.io" "jazz.editor.jazz" "irregex")}
      {Lisp-Entry "Website" class () ((extends . "Jedi-Profile")) #f #f 29 7 29 14 ("Jedi-Profile")
        {Lisp-Entry "test" method (override) () #f #f 37 20 37 24 ("extract-doc")}
        {Lisp-Entry "regenerate" method () () #f #f 46 11 46 21 ("regenerate-jazzwebsite" "save" "save~" "Jazz-Text-View" "get-guest" "get-guest~" "guest" "Host-View" "is?" "and" "when" "current-frame" "frame" "let")}
        {Lisp-Entry "test9" method (override) () #f #f 55 20 55 25 ("regenerate" "generate-manual?" "parameterize")}
        {Lisp-Entry "test0" method (override) () #f #f 60 20 60 25 ("regenerate")}}}})
"_website"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "_website.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.website" module () () #f #f 37 8 37 20 ("jazz")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("jazz.website.autoload")}
      {Lisp-Entry "generate-manual?" definition (public) () #f #f 48 19 48 35 ("make-parameter")}}})
"autoload"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "autoload.jazz"} 222341474. jazz
    {Lisp-Entry "jazz.website.autoload" module (protected) () #f #f 37 18 37 39 ("jazz")
      {Lisp-Entry "export" export () () #f #f 40 1 40 7 ("JazzWebsite-Transformation" "jazz.website.transformation.JazzWebsite-Transformation" "JazzScheme-Site" "jazz.website.server.JazzScheme-Site" "JazzScheme-Server" "autoload" "jazz.website.server.JazzScheme-Server")}}})
