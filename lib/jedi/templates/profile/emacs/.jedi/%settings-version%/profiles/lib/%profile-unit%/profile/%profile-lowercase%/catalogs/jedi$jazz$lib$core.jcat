"Dispatcher"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "runtime" "Dispatcher.jazz"} 222341472. jazz
    {Lisp-Entry "Dispatcher" class () ((extends . "Object")) #f #f 47 7 47 17 ("Object")
      {Lisp-Entry "dag-root" property () ((accessors . "generate")) #f #f 50 12 50 20 ()}
      {Lisp-Entry "get-dag-root" accessor () () #f #f 50 31 50 39 ()}
      {Lisp-Entry "set-dag-root" accessor () () #f #f 50 31 50 39 ()}
      {Lisp-Entry "Root-Signature" definition () () #f #f 53 14 53 28 ("root-signature")}
      {Lisp-Entry "initialize" method () () #f #f 57 11 57 21 ("Root-Signature" "Dispatch-Node" "new" "dag-root" "set!" "nextmethod")}
      {Lisp-Entry "insert-signature" method (public) ("symbol" "procedure" "signature" "category") #f #f 62 18 62 34 ("insert-node" "else" "proper-list?" "not" "category-identifier" "error" "locate-node" "cond" "List" "get-type" "get-type~" "and" "get-typeref" "get-typeref~" "typeref" "let" "parameter" "lambda" "accumulate" "standardize-signature" "define" "category" "signature" "procedure" "symbol")}
      {Lisp-Entry "insert-node" method (public) ("procedure" "signature") #f #f 81 18 81 29 ("get-specific-nodes" "get-specific-nodes~" "add-specific-node" "add-specific-node~" "remove-specific-node" "remove-specific-node~" "add-generic-node" "add-generic-node~" "remove-generic-node" "remove-generic-node~" "get-signature" "get-signature~" "can-call-with?" "can-call-with?~" "neq?" "and" "when" "specific" "generic" "lambda" "for-each" "Dispatch-Node" "new" "node" "gather-generics" "generics" "let*" "signature" "procedure")}
      {Lisp-Entry "remove-node" method (public) ("node") #f #f 98 18 98 29 ("remove-generic-node" "remove-generic-node~" "get-generic-nodes" "get-generic-nodes~" "remove-specific-node" "remove-specific-node~" "get-specific-nodes" "get-specific-nodes~" "add-generic-node" "add-generic-node~" "add-specific-node" "add-specific-node~" "specific" "generic" "lambda" "for-each" "node")}
      {Lisp-Entry "locate-node" method (public) ("signature") #f #f 113 18 113 29 ("first" "get-signature" "get-signature~" "equal?" "length" "1" "=" "and" "if" "gather-generics" "matching" "let" "signature")}
      {Lisp-Entry "gather-generics" method (public) ("parameter-types") #f #f 121 18 121 33 ("dag-root" "cons" "memq?" "not" "and" "get-specific-nodes" "get-specific-nodes~" "set!" "can-call-with?" "can-call-with?~" "when" "child-node" "lambda" "for-each" "no-match?" "walk-node" "iter" "define" "generics" "let" "parameter-types")}
      {Lisp-Entry "find-generics" method (public) ("parameter-types") #f #f 137 18 137 31 ("dag-root" "car" "eq?" "if" "gather-generics" "generics" "let" "parameter-types")}}
    {Lisp-Entry "Dispatch-Node" class () ((extends . "Object")) #f #f 149 7 149 20 ("Object")
      {Lisp-Entry "procedure" property () ((initialize . "#f") (accessors . "generate")) #f #f 152 12 152 21 ()}
      {Lisp-Entry "get-procedure" accessor () () #f #f 152 52 152 60 ()}
      {Lisp-Entry "set-procedure" accessor () () #f #f 152 52 152 60 ()}
      {Lisp-Entry "signature" property () ((initialize . "#f") (accessors . "generate")) #f #f 153 12 153 21 ()}
      {Lisp-Entry "get-signature" accessor () () #f #f 153 52 153 60 ()}
      {Lisp-Entry "set-signature" accessor () () #f #f 153 52 153 60 ()}
      {Lisp-Entry "generic-nodes" property () ((initialize . "'()") (accessors . "generate")) #f #f 154 12 154 25 ()}
      {Lisp-Entry "get-generic-nodes" accessor () () #f #f 154 52 154 60 ()}
      {Lisp-Entry "set-generic-nodes" accessor () () #f #f 154 52 154 60 ()}
      {Lisp-Entry "specific-nodes" property () ((initialize . "'()") (accessors . "generate")) #f #f 155 12 155 26 ()}
      {Lisp-Entry "get-specific-nodes" accessor () () #f #f 155 52 155 60 ()}
      {Lisp-Entry "set-specific-nodes" accessor () () #f #f 155 52 155 60 ()}
      {Lisp-Entry "initialize" method () ("proc" "sig" "gen") #f #f 158 11 158 21 ("generic-nodes" "signature" "procedure" "set!" "nextmethod" "gen" "sig" "proc")}
      {Lisp-Entry "print" method () ("output" "readably") #f #f 165 11 165 16 ("category-identifier" "map" "format" "Root-Signature" "signature" "eq?" "if" "lambda" "self" "print-unreadable" "readably" "output")}
      {Lisp-Entry "can-call-with?" method () ("sig") #f #f 173 11 173 25 ("null?" "finally" "return" "Java" "can-cast-into?" "can-cast-into?~" "not" "and" "when" "r2" "parameter-type" "r1" "remainder" "in" "data-type" "for" "loop" "Root-Signature" "signature" "eq?" "if" "sig")}
      {Lisp-Entry "add-generic-node" method () ("node") #f #f 184 11 184 27 ("cons" "set-generic-nodes" "equal?" "generic" "lambda" "generic-nodes" "find-in" "unless" "get-signature" "get-signature~" "sig" "let" "node")}
      {Lisp-Entry "add-specific-node" method () ("node") #f #f 192 11 192 28 ("cons" "set-specific-nodes" "equal?" "specific" "lambda" "specific-nodes" "find-in" "unless" "get-signature" "get-signature~" "sig" "let" "node")}
      {Lisp-Entry "remove-generic-node" method () ("generic") #f #f 200 11 200 30 ("generic-nodes" "remove" "set-generic-nodes" "generic")}
      {Lisp-Entry "remove-specific-node" method () ("specific") #f #f 204 11 204 31 ("specific-nodes" "remove" "set-specific-nodes" "specific")}}})
"_base"
 ({Lisp-File-Entry {File :context "src" "core" "base" "_base.scm"} 222341472. scheme
    {Lisp-Entry "core.base" unit () () #f #f 37 6 37 15 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.base.runtime" "syntax" "phase" "core.base.syntax")}}})
"_builder"
 ({Lisp-File-Entry {File :context "src" "core" "unit" "builder" "_builder.scm"} 231466230. scheme
    {Lisp-Entry "core.unit.builder" unit (protected) () #f #f 38 16 38 33 ()
      {Lisp-Entry "require" require () () #f #f 41 1 41 8 ("core.module" "core.base")}
      {Lisp-Entry "manifest-references-valid?" define () ("bin") #f #f 50 9 50 40 ("%%manifest-references" "references" "%%manifest-version" "manifest" "private" "%%get-declaration-access" "%%neq?" "%%get-declaration-toplevel" "%%get-lexical-binding-name" "else" "find-declaration" "jazz:find-declaration" "cond" "declaration" "symbols" "iter" "%%pair?" "found" "symbol" "every?" "jazz:every?" "error?:" "outline-module" "jazz:outline-module" "module-declaration" "%%not" "%%continuation-return" "%%cdr" "%%memq" "recompile-symbol" "%%car" "%%eq?" "%%symbol?" "recompile-reference" "some?" "jazz:some?" "and" "if" "version-recompile-references" "jazz:version-recompile-references" "recompile-references" "jazz-version" "for-each-higher-jazz-version" "jazz:for-each-higher-jazz-version" "return" "lambda" "%%continuation-capture" "module-references" "module-locator" "recompile-reference?" "lst" "version" "module-references-valid?" "load-manifest" "jazz:load-manifest" "manifest-pathname" "jazz:manifest-pathname" "manifest-filepath" "%%resource-package" "digest-pathname" "jazz:digest-pathname" "digest-filepath" "let" "get-manifest" "define" "bin")}
      {Lisp-Entry "compile-unit-internal" define () ("unit-name" "#!key" "(options #f)" "(cc-options #f)" "(ld-options #f)" "(force? #f)") #f #f 113 9 113 35 ("force?:" "ld-options:" "cc-options:" "options:" "compile-source" "jazz:compile-source" "requested-unit-resource" "jazz:requested-unit-resource" "requested-unit-name" "jazz:requested-unit-name" "parameterize" "manifest" "lib-uptodate?" "bin-uptodate?" "obj-uptodate?" "lib" "bin" "obj" "src" "lambda" "with-unit-resources" "jazz:with-unit-resources" "force?" "ld-options" "cc-options" "options" "#!key" "unit-name")}
      {Lisp-Entry "custom-compile-unit-internal" define () ("unit-name" "#!key" "(force? #f)") #f #f 123 9 123 42 ("compile-unit" "jazz:compile-unit" "force?:" "unit:" "%%product-descriptor" "if" "%%product-build" "and" "build" "find-unit-product" "jazz:find-unit-product" "product" "let" "force?" "#!key" "unit-name")}
      {Lisp-Entry "find-unit-product" define () ("unit-name") #f #f 132 9 132 31 ("continuation-return" "eq?" "if" "phase" "declaration" "sub-unit" "for-each-subunit" "jazz:for-each-subunit" "unit" "ill-formed-field-error" "jazz:ill-formed-field-error" "cond-expand-each" "jazz:cond-expand-each" "update" "product-descriptor-update" "jazz:product-descriptor-update" "update-descriptor" "get-product" "jazz:get-product" "product" "product-descriptor-name" "jazz:product-descriptor-name" "product-name" "let*" "product-descriptor" "for-each" "return" "lambda" "continuation-capture" "%%package-products" "products" "%%resource-package" "package" "find-unit-src" "jazz:find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "wrap-single-host-cc-options" define () () #f #f 155 8 155 40 ("string-append" "debug-user?" "jazz:debug-user?" "or" "if" "str" "lambda" "shell-command" "zero?" "else" "windows" "cond-expand" "gcc-4-2?" "let")}
      {Lisp-Entry "compile-source" define () ("src" "obj" "bin" "obj-uptodate?" "bin-uptodate?" "manifest-name" "#!key" "(options #f)" "(cc-options #f)" "(ld-options #f)" "(force? #f)") #f #f 164 9 164 28 ("unit-name:" "ld-options:" "cc-options:" "options:" "compile-file" "jazz:compile-file" "compile" "walk-for" "jazz:walk-for" "parameterize" "lambda" "%%resource-extension" "with-extension-reader" "jazz:with-extension-reader" "create-directories" "jazz:create-directories" "create-build-package" "jazz:create-build-package" "build-package" "resource-build-dir" "jazz:resource-build-dir" "bindir" "resource-pathname" "jazz:resource-pathname" "pathname" "%%resource-package" "package" "link-objects?" "jazz:link-objects?" "if" "update-bin?" "not" "update-obj?" "wrap-single-host-cc-options" "jazz:wrap-single-host-cc-options" "compile-options" "jazz:compile-options" "manifest-references-valid?" "jazz:manifest-references-valid?" "or" "and" "references-valid?" "let" "force?" "ld-options" "cc-options" "options" "#!key" "manifest-name" "bin-uptodate?" "obj-uptodate?" "bin" "obj" "src")}
      {Lisp-Entry "compile-file" define () ("src" "bin" "update-obj?" "update-bin?" "build-package" "#!key" "(options #f)" "(cc-options #f)" "(ld-options #f)" "(unit-name #f)" "(platform jazz:kernel-platform)") #f #f 183 9 183 26 ("force-output" "newline" "display" "push-changed-units" "jazz:push-changed-units" "%%resource-path" "path" "dry-run?" "jazz:dry-run?" "dry?" "link-libraries?" "jazz:link-libraries?" "will-compile?" "link-objects?" "jazz:link-objects?" "or" "will-link?" "DLL" "obliterate-PE-timestamp" "jazz:obliterate-PE-timestamp" "windows" "case" "=" "resource-build-dir" "jazz:resource-build-dir" "dyn" "##gambc-cc" "exit-status" "warnings?:" "%%list" "link-flat" "linkfile" "bin-o1" "link-o1" "probe-numbered-pathname" "jazz:probe-numbered-pathname" "begin" "single-objects?" "jazz:single-objects?" "determine-o1" "1" "for-each-numbered-pathname" "jazz:for-each-numbered-pathname" "delete-o1-files" "delete-file" "exc" "lambda" "with-exception-catcher" "file" "delete-o1-file" "update-manifest-compile-time" "jazz:update-manifest-compile-time" "else" "Unit-Declaration" "jazz:Unit-Declaration" "generate-reference-list" "jazz:generate-reference-list" "Module-Declaration" "jazz:Module-Declaration" "%%is?" "cond" "get-catalog-entry" "jazz:get-catalog-entry" "module-declaration" "references" "src-filepath" "manifest-pathname" "jazz:manifest-pathname" "manifest-filepath" "digest-pathname" "jazz:digest-pathname" "digest-filepath" "update-manifest" "error" "jazz:error" "cc-options:" "obj" "%%cons" "compile-file" "module-name:" "options:" "output:" "compile-file-to-c" "and" "not" "if" "-1" "##gensym-counter" "set!" "compiled-source" "jazz:compiled-source" "0" "generate-symbol-counter" "jazz:generate-symbol-counter" "generate-symbol-context" "jazz:generate-symbol-context" "generate-symbol-for" "jazz:generate-symbol-for" "parameterize" "string-append" "bin-c" "resource-pathname" "jazz:resource-pathname" "src-pathname" "%%symbol->string" "%%string-append" "unique-module-name" "let" "compile" "binary-with-extension" "jazz:binary-with-extension" "bin-pathname-base" "unit-uniqueness-prefix" "define" "kernel-platform" "jazz:kernel-platform" "platform" "unit-name" "ld-options" "cc-options" "options" "#!key" "build-package" "update-bin?" "update-obj?" "bin" "src")}
      {Lisp-Entry "build-unit-internal" define () ("unit-name") #f #f 282 9 282 33 ("compile-unit" "jazz:compile-unit" "phase" "declaration" "lambda" "for-each-subunit" "jazz:for-each-subunit" "unit-name")}
      {Lisp-Entry "get-subunit-names-internal" define () ("parent-name") #f #f 293 9 293 40 ("for-each-subunit" "jazz:for-each-subunit" "%%cons" "set!" "phase" "declaration" "unit-name" "lambda" "proc" "sub-units" "let*" "parent-name")}
      {Lisp-Entry "for-each-subunit" define () ("parent-name" "proc") #f #f 301 9 301 30 ("%%get-module-declaration-exports" "%%get-module-invoice-phase" "%%get-declaration-reference-name" "name" "%%get-module-invoice-module" "reference" "export" "%%get-module-declaration-requires" "%%get-unit-declaration-requires" "for-each" "Unit-Declaration" "jazz:Unit-Declaration" "is?" "jazz:is?" "error" "jazz:error" "descendant-unit?" "jazz:descendant-unit?" "and" "protected" "%%get-declaration-access" "%%eq?" "or" "outline-unit" "jazz:outline-unit" "declaration" "%%cons" "set!" "begin" "%%memq" "%%not" "if" "feature-requirement" "lambda" "parse-require" "jazz:parse-require" "require" "process-require" "define" "toplevel?" "phase" "unit-name" "iter" "subunits" "let" "proc" "parent-name")}}})
"_class"
 ({Lisp-File-Entry {File :context "src" "core" "class" "_class.scm"} 222341472. scheme
    {Lisp-Entry "core.class" unit () () #f #f 37 6 37 16 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.class.runtime" "syntax" "phase" "core.class.syntax" "core.base")}}})
"_dialect"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "dialect" "_dialect.scm"} 231466230. scheme
    {Lisp-Entry "core.module.syntax.dialect" unit (protected) () #f #f 37 16 37 42 ("encapsulate-class" "jazz:encapsulate-class" "Dialect" "jazz:Dialect")
      {Lisp-Entry "Dialect" define-class () () ("class runtime") #f 40 27 40 39 ()}
      {Lisp-Entry "dialect-name" generic/specific () () ("jazz:Dialect~virtual-runtime") #f 43 30 43 47 ()}
      {Lisp-Entry "dialect-walker" generic/specific () () ("jazz:Dialect~virtual-runtime") #f 44 30 44 49 ()}
      {Lisp-Entry "dialect-name" generic/specific () () ("jazz:Dialect") #f 47 21 47 38 ()}
      {Lisp-Entry "dialect-walker" generic/specific () () ("jazz:Dialect") #f 51 21 51 40 ()}
      {Lisp-Entry "Dialects" define () () #f #f 63 8 63 21 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "get-dialect" define () ("name") #f #f 67 9 67 25 ("Dialects" "jazz:Dialects" "%%table-ref" "name")}
      {Lisp-Entry "require-dialect" define () ("name") #f #f 71 9 71 29 ("error" "jazz:error" "get-dialect" "jazz:get-dialect" "or" "name")}
      {Lisp-Entry "register-dialect" define () ("name" "dialect") #f #f 76 9 76 30 ("Dialects" "jazz:Dialects" "%%table-set!" "dialect" "name")}
      {Lisp-Entry "define-dialect" define-macro () () ("macro") #f 80 20 80 39 (",dialect" ",name" "register-dialect" "jazz:register-dialect" "dialect" "name")}
      {Lisp-Entry "register-binding" define () ("dialect-name" "binding") #f #f 89 9 89 30 ("%%get-dialect-bindings" "%%cons" "%%set-dialect-bindings" "get-dialect" "jazz:get-dialect" "dialect" "let" "binding" "dialect-name")}
      {Lisp-Entry "define-walker-special" define-macro () () ("macro") #f 94 20 94 46 (",method" ",name" "new-special-form" "jazz:new-special-form" ",dialect-name" "register-binding" "jazz:register-binding" "method" "dialect-name" "name")}
      {Lisp-Entry "define-walker-syntax" define-macro () () ("macro") #f 98 20 98 45 (",method" ",name" "new-syntax-form" "jazz:new-syntax-form" ",dialect-name" "register-binding" "jazz:register-binding" "method" "dialect-name" "name")}
      {Lisp-Entry "define-walker-macro" define-macro () () ("macro") #f 102 20 102 44 (",method" ",name" "new-macro-form" "jazz:new-macro-form" ",dialect-name" "register-binding" "jazz:register-binding" "method" "dialect-name" "name")}}})
"_exception"
 ({Lisp-File-Entry {File :context "src" "core" "exception" "_exception.scm"} 222341472. scheme
    {Lisp-Entry "core.exception" unit () () #f #f 37 6 37 20 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.exception.runtime.error" "core.exception.runtime.exception" "core.exception.syntax.classes" "core.class")}}})
"_generic"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "_generic.scm"} 222341472. scheme
    {Lisp-Entry "core.generic" unit () () #f #f 37 6 37 18 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.generic.runtime" "syntax" "phase" "core.generic.syntax" "core.class")}}})
"_module"
 ({Lisp-File-Entry {File :context "src" "core" "module" "_module.scm"} 229929916. scheme
    {Lisp-Entry "core.module" unit () () #f #f 37 6 37 17 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.module.initialize" "core.module.runtime" "core.module.runtime.autoload" "core.module.syntax" "core.exception" "core.generic" "core.class")}}})
"_runtime"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "_runtime.scm"} 222341472. scheme
    {Lisp-Entry "core.base.runtime" unit (protected) () #f #f 37 16 37 33 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.base.runtime.vector" "core.base.runtime.unspecified" "core.base.runtime.syntax" "core.base.runtime.symbol" "core.base.runtime.string" "core.base.runtime.serial" "core.base.runtime.reader" "core.base.runtime.error" "core.base.runtime.exception" "core.base.runtime.list" "core.base.runtime.keyword" "core.base.runtime.boolean")}}}
  {Lisp-File-Entry {File :context "src" "core" "class" "runtime" "_runtime.scm"} 222341472. scheme
    {Lisp-Entry "core.class.runtime" unit (protected) () #f #f 37 16 37 34 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.class.runtime.output" "core.class.runtime.output-hook" "core.class.runtime.runtime")}}}
  {Lisp-File-Entry {File :context "src" "core" "generic" "runtime" "_runtime.scm"} 222341472. scheme
    {Lisp-Entry "core.generic.runtime" unit (protected) () #f #f 37 16 37 36 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.generic.runtime.generic" "core.generic.runtime.specific")}}}
  {Lisp-File-Entry {File :context "src" "core" "module" "runtime" "_runtime.scm"} 231466230. scheme
    {Lisp-Entry "core.module.runtime" unit (protected) () #f #f 37 16 37 35 ("Runtime-Reference" "jazz:Runtime-Reference" "Native" "jazz:Native" "Module" "jazz:Module" "encapsulate-class" "jazz:encapsulate-class")
      {Lisp-Entry "Module" define-class () () ("class syntax") #f 45 19 45 30 ("%%get-module-entries" "entries" "%%get-module-exports" "exports" "%%get-module-access" "access" "%%get-module-name" "name" "allocate-module" "jazz:allocate-module" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Module" define-class () () ("class runtime") #f 52 27 52 38 ()}
      {Lisp-Entry "new-module" define () ("name" "access") #f #f 55 9 55 24 ("eq?" "test:" "%%make-table" "Module" "jazz:Module" "allocate-module" "jazz:allocate-module" "access" "name")}
      {Lisp-Entry "Native" define-class () () ("class syntax") #f 67 19 67 30 ("%%get-native-symbol" "symbol" "allocate-native" "jazz:allocate-native" "Object-Class" "jazz:Object-Class" "name" "Field" "jazz:Field")}
      {Lisp-Entry "Native" define-class () () ("class runtime") #f 71 27 71 38 ()}
      {Lisp-Entry "new-native" define () ("name" "symbol") #f #f 74 9 74 24 ("Native" "jazz:Native" "allocate-native" "jazz:allocate-native" "symbol" "name")}
      {Lisp-Entry "register-native" define () ("module-name" "name" "symbol") #f #f 81 9 81 29 ("new-native" "jazz:new-native" "register-module-entry" "jazz:register-module-entry" "symbol" "name" "module-name")}
      {Lisp-Entry "Runtime-Reference" define-class () () ("class syntax") #f 90 19 90 41 ("%%get-runtime-reference-serialization" "serialization" "%%get-runtime-reference-resolver" "resolver" "allocate-runtime-reference" "jazz:allocate-runtime-reference" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Runtime-Reference" define-class () () ("class runtime") #f 95 27 95 49 ()}
      {Lisp-Entry "new-runtime-reference" define () ("resolver" "serialization") #f #f 98 9 98 35 ("Runtime-Reference" "jazz:Runtime-Reference" "allocate-runtime-reference" "jazz:allocate-runtime-reference" "serialization" "resolver")}
      {Lisp-Entry "resolve-runtime-reference" define () ("runtime-reference") #f #f 105 9 105 39 ("%%get-runtime-reference-resolver" "resolver" "let" "Runtime-Reference" "jazz:Runtime-Reference" "%%is?" "%%debug-assert" "runtime-reference")}
      {Lisp-Entry "serialize-runtime-reference" define () ("runtime-reference") #f #f 111 9 111 41 ("%%get-runtime-reference-serialization" "Runtime-Reference" "jazz:Runtime-Reference" "%%is?" "%%debug-assert" "runtime-reference")}
      {Lisp-Entry "deserialize-runtime-reference" define () ("serialization") #f #f 116 9 116 43 ("error" "jazz:error" "else" "module-public" "module-private" "case" "%%pair?" "if" "or" "module-ref" "jazz:module-ref" "%%cddr" "%%car" "name" "module-name" "deserialize-module-public" "global-ref" "jazz:global-ref" "%%cadr" "locator" "let" "lambda" "new-runtime-reference" "jazz:new-runtime-reference" "deserialize-module-private" "define" "serialization")}
      {Lisp-Entry "Modules" define () () #f #f 144 8 144 20 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "get-modules" define () () #f #f 148 9 148 25 ("Modules" "jazz:Modules")}
      {Lisp-Entry "register-module" define () ("name" "access" "exported-modules" "exported-symbols") #f #f 152 9 152 29 ("Modules" "jazz:Modules" "%%cdr" "%%car" "pair" "%%table-set!" "info" "require-module" "jazz:require-module" "iterate-table" "jazz:iterate-table" "module-name" "lambda" "for-each" "%%get-module-exports" "exports" "new-module" "jazz:new-module" "get-module" "jazz:get-module" "or" "module" "let" "exported-symbols" "exported-modules" "access" "name")}
      {Lisp-Entry "get-module" define () ("name") #f #f 169 9 169 24 ("Modules" "jazz:Modules" "%%table-ref" "name")}
      {Lisp-Entry "require-module" define () ("name") #f #f 173 9 173 28 ("error" "jazz:error" "get-module" "jazz:get-module" "or" "load-unit" "jazz:load-unit" "name")}
      {Lisp-Entry "get-module-entry" define () ("module-name" "entry-name") #f #f 179 9 179 30 ("get-module" "jazz:get-module" "%%get-module-entries" "%%table-ref" "entry-name" "module-name")}
      {Lisp-Entry "set-module-entry" define () ("module-name" "entry-name" "entry") #f #f 182 9 182 30 ("get-module" "jazz:get-module" "%%get-module-entries" "%%table-set!" "entry" "entry-name" "module-name")}
      {Lisp-Entry "register-module-entry" define () ("module-name" "entry-name" "entry") #f #f 185 9 185 35 ("set-module-entry" "jazz:set-module-entry" "entry" "entry-name" "module-name")}
      {Lisp-Entry "module-get" define () ("module-name" "name" "#!key" "(not-found #f)") #f #f 189 9 189 24 ("load-unit" "jazz:load-unit" "locator" "unit-name" "bind" "jazz:bind" "global-ref" "jazz:global-ref" "%%symbol?" "if" "%%get-module-exports" "%%table-ref" "info" "require-module" "jazz:require-module" "module" "let" "not-found" "#!key" "name" "module-name")}
      {Lisp-Entry "module-ref" define () () #f #f 201 8 201 23 ("error" "jazz:error" "%%eq?" "if" "not-found:" "module-get" "jazz:module-get" "obj" "name" "module-name" "lambda" "box" "not-found" "let")}
      {Lisp-Entry "module-set!" define () ("module-name" "name" "value") #f #f 210 9 210 25 ("error" "jazz:error" "load-unit" "jazz:load-unit" "locator" "unit-name" "bind" "jazz:bind" "global-set!" "jazz:global-set!" "%%symbol?" "if" "%%get-module-exports" "%%table-ref" "info" "require-module" "jazz:require-module" "module" "let" "value" "name" "module-name")}
      {Lisp-Entry "type-error" define () ("value" "type") #f #f 227 9 227 24 ("error" "jazz:error" "type" "value")}
      {Lisp-Entry "dispatch-error" define () ("field" "value" "category") #f #f 231 9 231 28 ("%%get-category-identifier" "%%get-field-name" "error" "jazz:error" "category" "value" "field")}}})
"_syntax"
 ({Lisp-File-Entry {File :context "src" "core" "base" "syntax" "_syntax.scm"} 222341472. scheme
    {Lisp-Entry "core.base.syntax" unit (protected) () #f #f 37 16 37 32 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.base.syntax.macros")}}}
  {Lisp-File-Entry {File :context "src" "core" "class" "syntax" "_syntax.scm"} 222341472. scheme
    {Lisp-Entry "core.class.syntax" unit (protected) () #f #f 37 16 37 33 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.class.syntax.classes" "core.class.syntax.define-method" "core.class.syntax.define-method-expander" "core.class.syntax.define-class" "core.class.syntax.class" "core.class.syntax.object" "core.class.syntax.error")}}}
  {Lisp-File-Entry {File :context "src" "core" "generic" "syntax" "_syntax.scm"} 222341472. scheme
    {Lisp-Entry "core.generic.syntax" unit (protected) () #f #f 37 16 37 35 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.generic.syntax.specific" "core.generic.syntax.generic" "core.generic.syntax.expander")}}}
  {Lisp-File-Entry {File :context "src" "core" "module" "syntax" "_syntax.scm"} 231303585. scheme
    {Lisp-Entry "core.module.syntax" unit (protected) () #f #f 37 16 37 34 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.module.syntax.module" "core.module.syntax.walker.register" "core.module.syntax.walker.ffi" "core.module.syntax.walker.expression" "core.module.syntax.walker" "core.module.syntax.dialect" "core.module.syntax.dialect.syntax" "core.module.syntax.classes")}}})
"_unit"
 ({Lisp-File-Entry {File :context "src" "core" "unit" "_unit.scm"} 231282879. scheme
    {Lisp-Entry "core.unit" unit () () #f #f 37 6 37 15 ()
      {Lisp-Entry "require" require () () #f #f 40 1 40 8 ("core.unit.builder")}}})
"_walker"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "walker" "_walker.scm"} 245481198. scheme
    {Lisp-Entry "core.module.syntax.walker" unit (protected) () #f #f 59 16 59 41 ("Core-Walker" "jazz:Core-Walker" "Core-Dialect" "jazz:Core-Dialect" "Analysis-Data" "jazz:Analysis-Data" "Walk-Failed-Special" "jazz:Walk-Failed-Special" "Assignment" "jazz:Assignment" "Constant" "jazz:Constant" "Call" "jazz:Call" "Begin" "jazz:Begin" "Internal-Define" "jazz:Internal-Define" "Body" "jazz:Body" "Reference-Reification" "jazz:Reference-Reification" "Binding-Reference" "jazz:Binding-Reference" "Expression" "jazz:Expression" "Walker" "jazz:Walker" "Code" "jazz:Code" "Annotated-Frame" "jazz:Annotated-Frame" "Restricted-Binding" "jazz:Restricted-Binding" "Annotated-Variable" "jazz:Annotated-Variable" "Syntactic-Closure" "jazz:Syntactic-Closure" "Define-Local-Syntax-Form" "jazz:Define-Local-Syntax-Form" "Define-Syntax-Form" "jazz:Define-Syntax-Form" "Syntax-Form" "jazz:Syntax-Form" "Macro-Form" "jazz:Macro-Form" "Special-Form" "jazz:Special-Form" "Form-Binding" "jazz:Form-Binding" "Macro-Symbol" "jazz:Macro-Symbol" "Local-Variable-Binding" "jazz:Local-Variable-Binding" "Dynamic-Self-Binding" "jazz:Dynamic-Self-Binding" "Self-Binding" "jazz:Self-Binding" "Rest-Parameter" "jazz:Rest-Parameter" "Named-Parameter" "jazz:Named-Parameter" "Optional-Parameter" "jazz:Optional-Parameter" "Dynamic-Parameter" "jazz:Dynamic-Parameter" "Parameter" "jazz:Parameter" "NextMethod-Variable" "jazz:NextMethod-Variable" "Variable" "jazz:Variable" "Symbol-Binding" "jazz:Symbol-Binding" "Signature" "jazz:Signature" "Walk-Frame" "jazz:Walk-Frame" "Unresolved-Error" "jazz:Unresolved-Error" "Walk-Error" "jazz:Walk-Error" "Walk-Warning" "jazz:Walk-Warning" "Walk-Problems" "jazz:Walk-Problems" "Walk-Problem" "jazz:Walk-Problem" "Walk-Location" "jazz:Walk-Location" "Walk-Context" "jazz:Walk-Context" "Define-Local-Syntax-Declaration" "jazz:Define-Local-Syntax-Declaration" "Define-Syntax-Declaration" "jazz:Define-Syntax-Declaration" "Syntax-Declaration" "jazz:Syntax-Declaration" "Local-Macro-Declaration" "jazz:Local-Macro-Declaration" "Macro-Declaration" "jazz:Macro-Declaration" "primitive-declarations" "jazz:primitive-declarations" "void" "Unspecified" "jazz:Unspecified" "unspecified" "EOF" "jazz:EOF" "eof" "Values" "jazz:Values" "values" "Foreign" "jazz:Foreign" "foreign" "Promise" "jazz:Promise" "promise" "Thread" "jazz:Thread" "thread" "Table" "jazz:Table" "table" "F64Vector" "jazz:F64Vector" "f64vector" "F32Vector" "jazz:F32Vector" "f32vector" "U64Vector" "jazz:U64Vector" "u64vector" "S64Vector" "jazz:S64Vector" "s64vector" "U32Vector" "jazz:U32Vector" "u32vector" "S32Vector" "jazz:S32Vector" "s32vector" "U16Vector" "jazz:U16Vector" "u16vector" "S16Vector" "jazz:S16Vector" "s16vector" "U8Vector" "jazz:U8Vector" "u8vector" "S8Vector" "jazz:S8Vector" "s8vector" "Vector" "jazz:Vector" "vector" "Keyword" "jazz:Keyword" "keyword" "Symbol" "jazz:Symbol" "symbol" "String" "jazz:String" "string" "Procedure" "jazz:Procedure" "procedure" "Continuation" "jazz:Continuation" "continuation" "Port" "jazz:Port" "port" "Pair" "jazz:Pair" "pair" "Null" "jazz:Null" "null" "List" "jazz:List" "list" "Flonum" "jazz:Flonum" "fl" "Fixnum" "jazz:Fixnum" "fx" "Integer" "jazz:Integer" "int" "Rational" "jazz:Rational" "rational" "Real" "jazz:Real" "real" "Complex" "jazz:Complex" "complex" "Number" "jazz:Number" "number" "Char" "jazz:Char" "char" "Boolean" "jazz:Boolean" "bool" "Object" "jazz:Object" "object" "any" "primitive-types" "jazz:primitive-types" "%%table-set!" "Any" "jazz:Any" "Any-Class" "jazz:Any-Class" "type" "lambda" "object-declaration?" "jazz:object-declaration?" "set!" "Nillable-Type" "jazz:Nillable-Type" "Template-Type" "jazz:Template-Type" "Union-Type" "jazz:Union-Type" "Complement-Type" "jazz:Complement-Type" "Restriction-Type" "jazz:Restriction-Type" "Values-Type" "jazz:Values-Type" "Category-Type" "jazz:Category-Type" "Function-Type" "jazz:Function-Type" "Rest-Type" "jazz:Rest-Type" "Key-Type" "jazz:Key-Type" "Opt-Type" "jazz:Opt-Type" "Void" "jazz:Void" "Void-Class" "jazz:Void-Class" "Literal" "jazz:Literal" "Autoload-Declaration" "jazz:Autoload-Declaration" "Export-Syntax-Declaration" "jazz:Export-Syntax-Declaration" "Export-Declaration" "jazz:Export-Declaration" "Import-Invoice" "jazz:Import-Invoice" "Export-Invoice" "jazz:Export-Invoice" "Module-Invoice" "jazz:Module-Invoice" "Module-Declaration" "jazz:Module-Declaration" "Namespace-Declaration" "jazz:Namespace-Declaration" "Unit-Declaration" "jazz:Unit-Declaration" "Autoload-Reference" "jazz:Autoload-Reference" "Export-Reference" "jazz:Export-Reference" "Module-Reference" "jazz:Module-Reference" "Declaration-Reference" "jazz:Declaration-Reference" "Declaration" "jazz:Declaration" "Lexical-Binding" "jazz:Lexical-Binding" "encapsulate-class" "jazz:encapsulate-class" "Walk-Binding" "jazz:Walk-Binding")
      {Lisp-Entry "analysis-mode?" define () () #f #f 68 8 68 27 ("make-parameter")}
      {Lisp-Entry "analysis-data" define () () #f #f 73 8 73 26 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "private-access" define () () #f #f 83 8 83 27 ("0")}
      {Lisp-Entry "public-access" define () () #f #f 87 8 87 26 ("1")}
      {Lisp-Entry "protected-access" define () () #f #f 91 8 91 29 ("2")}
      {Lisp-Entry "make-access-lookups" define () ("access-level") #f #f 95 9 95 33 ("eq?" "test:" "%%make-table" "%%vector-set!" "begin" "%%fx<=" "if" "0" "n" "iter" "1" "%%fx+" "%%make-vector" "lookups" "let" "access-level")}
      {Lisp-Entry "Walk-Binding" define-class () () ("class runtime") #f 110 27 110 44 ()}
      {Lisp-Entry "emit-type" generic/specific () ("source-declaration" "environment") ("jazz:Walk-Binding") #f 113 21 113 35 ("type" "emit-binding-reference" "jazz:emit-binding-reference" "sourcified-form" "jazz:sourcified-form" "environment" "source-declaration")}
      {Lisp-Entry "specifiable?" generic/specific () () ("jazz:Walk-Binding") #f 117 21 117 38 ()}
      {Lisp-Entry "walk-binding-lookup" generic/specific () ("symbol" "source-declaration") ("jazz:Walk-Binding~virtual-runtime") #f 121 30 121 54 ("source-declaration" "symbol")}
      {Lisp-Entry "walk-binding-referenced" generic/specific () () ("jazz:Walk-Binding~virtual-runtime") #f 122 30 122 58 ()}
      {Lisp-Entry "emit-binding-symbol" generic/specific () ("source-declaration" "environment") ("jazz:Walk-Binding~virtual-runtime") #f 123 30 123 54 ("environment" "source-declaration")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Walk-Binding~virtual-runtime") #f 124 30 124 57 ("environment" "source-declaration")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Walk-Binding~virtual-runtime") #f 125 30 125 61 ("form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-binding-call" generic/specific () ("binding-src" "arguments" "source-declaration" "environment") ("jazz:Walk-Binding~virtual-runtime") #f 126 30 126 52 ("environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "emit-inlined-binding-call" generic/specific () ("arguments" "call" "source-declaration" "environment") ("jazz:Walk-Binding~virtual-runtime") #f 127 30 127 60 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "walk-binding-validate-assignment" generic/specific () ("walker" "resume" "source-declaration" "symbol-src") ("jazz:Walk-Binding~virtual-runtime") #f 128 30 128 67 ("symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "walk-binding-assignable?" generic/specific () () ("jazz:Walk-Binding~virtual-runtime") #f 129 30 129 59 ()}
      {Lisp-Entry "emit-binding-assignment" generic/specific () ("value" "source-declaration" "environment") ("jazz:Walk-Binding~virtual-runtime") #f 130 30 130 58 ("environment" "source-declaration" "value")}
      {Lisp-Entry "walk-binding-walkable?" generic/specific () () ("jazz:Walk-Binding~virtual-runtime") #f 131 30 131 57 ()}
      {Lisp-Entry "walk-binding-walk-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Walk-Binding~virtual-runtime") #f 132 30 132 57 ("form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Walk-Binding~virtual-runtime") #f 133 30 133 59 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Walk-Binding~virtual-runtime") #f 134 30 134 59 ("form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-binding-lookup" generic/specific () ("symbol" "source-declaration") ("jazz:Walk-Binding") #f 137 21 137 45 ("source-declaration" "symbol")}
      {Lisp-Entry "walk-binding-referenced" generic/specific () () ("jazz:Walk-Binding") #f 141 21 141 49 ("unspecified" "jazz:unspecified")}
      {Lisp-Entry "emit-binding-symbol" generic/specific () ("source-declaration" "environment") ("jazz:Walk-Binding") #f 145 21 145 45 ("binding" "error" "jazz:error" "environment" "source-declaration")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Walk-Binding") #f 149 21 149 48 ("binding" "error" "jazz:error" "environment" "source-declaration")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Walk-Binding") #f 153 21 153 52 ("unspecified" "jazz:unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-binding-call" generic/specific () ("binding-src" "arguments" "source-declaration" "environment") ("jazz:Walk-Binding") #f 157 21 157 43 ("call-return-type" "jazz:call-return-type" "codes-forms" "jazz:codes-forms" "emit-binding-reference" "jazz:emit-binding-reference" "sourcified-form2" "jazz:sourcified-form2" "new-code" "jazz:new-code" "binding" "%%get-lexical-binding-type" "type" "let" "environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "emit-inlined-binding-call" generic/specific () ("arguments" "call" "source-declaration" "environment") ("jazz:Walk-Binding") #f 166 21 166 51 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "walk-binding-validate-assignment" generic/specific () ("walker" "resume" "source-declaration" "symbol-src") ("jazz:Walk-Binding") #f 170 21 170 58 ("%%get-lexical-binding-name" "walk-error" "jazz:walk-error" "binding" "walk-binding-assignable?" "jazz:walk-binding-assignable?" "%%not" "%%when" "symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "walk-binding-assignable?" generic/specific () () ("jazz:Walk-Binding") #f 175 21 175 50 ()}
      {Lisp-Entry "emit-binding-assignment" generic/specific () ("value" "source-declaration" "environment") ("jazz:Walk-Binding") #f 179 21 179 49 ("unspecified" "jazz:unspecified" "environment" "source-declaration" "value")}
      {Lisp-Entry "walk-binding-walkable?" generic/specific () () ("jazz:Walk-Binding") #f 183 21 183 48 ()}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Walk-Binding") #f 187 21 187 50 ()}
      {Lisp-Entry "call-return-type" define () ("operator-type") #f #f 194 9 194 30 ("Any" "jazz:Any" "%%get-function-type-result" "Function-Type" "jazz:Function-Type" "%%is?" "if" "operator-type")}
      {Lisp-Entry "Lexical-Binding" define-class () () ("class runtime") #f 205 27 205 47 ()}
      {Lisp-Entry "resolve-binding" generic/specific () () ("jazz:Lexical-Binding~virtual-runtime") #f 208 30 208 50 ()}
      {Lisp-Entry "resolve-binding" generic/specific () () ("jazz:Lexical-Binding") #f 211 21 211 41 ("binding")}
      {Lisp-Entry "print-object" generic/specific () ("output" "detail") ("jazz:Lexical-Binding") #f 215 21 215 38 ("object->serial" "jazz:object->serial" "%%get-lexical-binding-name" "binding" "%%get-object-class" "%%get-category-identifier" "format" "jazz:format" "detail" "output")}
      {Lisp-Entry "walk-binding-lookup" generic/specific () ("symbol" "source-declaration") ("jazz:Lexical-Binding") #f 222 21 222 45 ("binding" "%%get-lexical-binding-name" "%%eq?" "if" "source-declaration" "symbol")}
      {Lisp-Entry "get-lexical-binding-name" define () ("binding") #f #f 228 9 228 38 ("%%get-lexical-binding-name" "binding")}
      {Lisp-Entry "get-lexical-binding-hits" define () ("binding") #f #f 232 9 232 38 ("%%set-lexical-binding-hits" "eq?" "test:" "%%make-table" "table" "let" "%%get-lexical-binding-hits" "or" "binding")}
      {Lisp-Entry "emit-binding-symbol" generic/specific () ("declaration" "environment") ("jazz:Lexical-Binding") #f 239 21 239 45 ("binding" "%%get-lexical-binding-name" "environment" "declaration")}
      {Lisp-Entry "Declaration" define-class () () ("class runtime") #f 251 27 251 43 ()}
      {Lisp-Entry "setup-declaration" define () ("new-declaration") #f #f 254 9 254 31 ("%%get-declaration-toplevel" "%%set-declaration-toplevel" "%%get-declaration-locator" "%%compose-reference" "%%not" "if" "%%set-declaration-locator" "%%get-lexical-binding-name" "name" "%%get-declaration-parent" "parent" "let" "new-declaration")}
      {Lisp-Entry "get-declaration-path" define () ("declaration") #f #f 261 9 261 34 ("reverse!" "jazz:reverse!" "%%cons" "%%list" "%%not" "if" "%%get-declaration-parent" "parent" "%%get-lexical-binding-name" "name" "let" "iter" "define" "declaration")}
      {Lisp-Entry "walk-binding-lookup" generic/specific () ("symbol" "source-declaration") ("jazz:Declaration") #f 272 21 272 45 ("private-access" "jazz:private-access" "binding" "lookup-declaration" "jazz:lookup-declaration" "source-declaration" "symbol")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Declaration") #f 276 21 276 52 ("declaration" "%%get-lexical-binding-name" "walk-error" "jazz:walk-error" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "lookup-declaration" generic/specific () ("symbol" "access" "source-declaration") ("jazz:Declaration~virtual-runtime") #f 280 30 280 53 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "lookup-declaration" generic/specific () ("symbol" "access" "source-declaration") ("jazz:Declaration") #f 283 21 283 44 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "get-declaration-inclusions" generic/specific () () ("jazz:Declaration~virtual-runtime") #f 287 30 287 61 ()}
      {Lisp-Entry "get-declaration-inclusions" generic/specific () () ("jazz:Declaration") #f 290 21 290 52 ()}
      {Lisp-Entry "get-nextmethod-signature" generic/specific () () ("jazz:Declaration~virtual-runtime") #f 294 30 294 59 ()}
      {Lisp-Entry "get-nextmethod-signature" generic/specific () () ("jazz:Declaration") #f 297 21 297 50 ("declaration" "error" "jazz:error")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Declaration~virtual-runtime") #f 301 30 301 51 ("environment")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Declaration") #f 304 21 304 42 ("declaration" "error" "jazz:error" "environment")}
      {Lisp-Entry "expand-referenced-declaration" generic/specific () () ("jazz:Declaration~virtual-runtime") #f 308 30 308 64 ()}
      {Lisp-Entry "expand-referenced-declaration" generic/specific () () ("jazz:Declaration") #f 311 21 311 55 ()}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Declaration~virtual-runtime") #f 315 30 315 51 ("s" "k" "f")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Declaration") #f 318 21 318 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "declaration-result" define () () #f #f 322 9 322 32 ("unspecified" "jazz:unspecified" "eval" "walk-for" "jazz:walk-for" "%%eq?" "if")}
      {Lisp-Entry "Declaration-Reference" define-class () () ("class runtime") #f 336 27 336 53 ()}
      {Lisp-Entry "resolve-reference" generic/specific () ("module-declaration") ("jazz:Declaration-Reference~virtual-runtime") #f 339 30 339 52 ("module-declaration")}
      {Lisp-Entry "resolve-reference" generic/specific () ("module-declaration") ("jazz:Declaration-Reference") #f 342 21 342 43 ("%%set-declaration-reference-declaration" "uptodate" "public" "new-export-declaration" "jazz:new-export-declaration" "declaration" "let" "%%get-declaration-reference-name" "parse-exported-symbol" "jazz:parse-exported-symbol" "symbol" "name" "receive" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "Module-Reference" define-class () () ("class runtime") #f 358 27 358 48 ()}
      {Lisp-Entry "new-module-reference" define () ("name" "declaration") #f #f 361 9 361 34 ("Module-Reference" "jazz:Module-Reference" "allocate-module-reference" "jazz:allocate-module-reference" "declaration" "name")}
      {Lisp-Entry "resolve-reference" generic/specific () ("module-declaration") ("jazz:Module-Reference") #f 365 21 365 43 ("%%set-declaration-reference-declaration" "%%get-declaration-reference-name" "outline-module" "jazz:outline-module" "declaration" "let" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "Export-Reference" define-class () () ("class runtime") #f 380 27 380 48 ()}
      {Lisp-Entry "new-export-reference" define () ("name" "declaration" "module-reference") #f #f 383 9 383 34 ("Export-Reference" "jazz:Export-Reference" "allocate-export-reference" "jazz:allocate-export-reference" "module-reference" "declaration" "name")}
      {Lisp-Entry "resolve-reference" generic/specific () ("module-declaration") ("jazz:Export-Reference") #f 387 21 387 43 ("%%set-declaration-reference-declaration" "uptodate" "public" "new-export-declaration" "jazz:new-export-declaration" "declaration" "%%get-lexical-binding-name" "compose-reference" "jazz:compose-reference" "locator" "let" "%%get-declaration-reference-name" "parse-exported-symbol" "jazz:parse-exported-symbol" "symbol" "name" "receive" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "parse-exported-symbol" define () ("module-declaration" "name") #f #f 396 9 396 35 ("else" "reference-name" "jazz:reference-name" "composite-reference?" "jazz:composite-reference?" "namespace-name" "jazz:namespace-name" "values" "composite-namespace?" "jazz:composite-namespace?" "cond" "name" "module-declaration")}
      {Lisp-Entry "Autoload-Reference" define-class () () ("class runtime") #f 413 27 413 50 ()}
      {Lisp-Entry "new-autoload-reference" define () ("name" "declaration" "module-reference") #f #f 416 9 416 36 ("Autoload-Reference" "jazz:Autoload-Reference" "allocate-autoload-reference" "jazz:allocate-autoload-reference" "module-reference" "declaration" "name")}
      {Lisp-Entry "resolve-autoload-reference" define () ("declaration-reference" "module-declaration" "exported-module-reference") #f #f 420 9 420 40 ("%%set-declaration-reference-declaration" "%%assert" "new-autoload-declaration" "jazz:new-autoload-declaration" "declaration" "Any" "jazz:Any" "type" "%%get-declaration-reference-name" "name" "let*" "%%get-declaration-reference-declaration" "or" "exported-module-reference" "module-declaration" "declaration-reference")}
      {Lisp-Entry "Unit-Declaration" define-class () () ("class runtime") #f 438 27 438 48 ()}
      {Lisp-Entry "new-unit-declaration" define () ("name" "access" "parent" "requires") #f #f 441 9 441 34 ("setup-declaration" "jazz:setup-declaration" "uptodate" "Unit-Declaration" "jazz:Unit-Declaration" "allocate-unit-declaration" "jazz:allocate-unit-declaration" "new-declaration" "let" "requires" "parent" "access" "name")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Unit-Declaration") #f 447 21 447 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "Namespace-Declaration" define-class () () ("class runtime") #f 459 27 459 53 ()}
      {Lisp-Entry "lookup-declaration" generic/specific () ("symbol" "access" "source-declaration") ("jazz:Namespace-Declaration") #f 462 21 462 44 ("add-to-module-references" "jazz:add-to-module-references" "namespace-declaration" "%%get-access-lookup" "%%table-ref" "found" "get-analysis-data" "jazz:get-analysis-data" "%%set-analysis-data-autoload-reference" "Autoload-Declaration" "jazz:Autoload-Declaration" "%%is?" "%%get-declaration-locator" "%%table-set!" "get-lexical-binding-hits" "jazz:get-lexical-binding-hits" "hits-table" "let" "analysis-mode?" "jazz:analysis-mode?" "and" "%%when" "declaration" "add-to-hits" "define" "source-declaration" "access" "symbol")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Namespace-Declaration") #f 476 21 476 42 ("%%get-namespace-declaration-body" "fold-statements" "jazz:fold-statements" "declaration" "s" "k" "f")}
      {Lisp-Entry "get-private-lookup" define () ("namespace-declaration") #f #f 483 9 483 32 ("private-access" "jazz:private-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "get-public-lookup" define () ("namespace-declaration") #f #f 486 9 486 31 ("public-access" "jazz:public-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "get-protected-lookup" define () ("namespace-declaration") #f #f 489 9 489 34 ("protected-access" "jazz:protected-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "Module-Declaration" define-class () () ("class runtime") #f 499 27 499 50 ()}
      {Lisp-Entry "new-module-declaration" define () ("name" "access" "parent" "walker" "dialect-name" "dialect-invoice") #f #f 502 9 502 36 ("setup-declaration" "jazz:setup-declaration" "eq?" "test:" "%%make-table" "new-queue" "jazz:new-queue" "public-access" "jazz:public-access" "make-access-lookups" "jazz:make-access-lookups" "uptodate" "Module-Declaration" "jazz:Module-Declaration" "allocate-module-declaration" "jazz:allocate-module-declaration" "new-declaration" "let" "dialect-invoice" "dialect-name" "walker" "parent" "access" "name")}
      {Lisp-Entry "add-module-require" define () ("module-declaration" "require") #f #f 508 9 508 32 ("%%list" "%%get-module-declaration-requires" "%%append" "%%set-module-declaration-requires" "load-unit" "jazz:load-unit" "syntax" "%%eq?" "%%when" "phase" "feature-requirement" "unit-name" "lambda" "parse-require" "jazz:parse-require" "require" "module-declaration")}
      {Lisp-Entry "add-module-import" define () ("module-declaration" "module-invoice" "register?") #f #f 516 9 516 31 ("table-merge-reporting-conflicts!" "jazz:table-merge-reporting-conflicts!" "public-access" "jazz:public-access" "imported" "imported-module-declaration" "%%get-module-invoice-only" "only" "private-access" "jazz:private-access" "%%get-access-lookup" "private" "%%list" "%%append" "%%set-module-declaration-imports" "find-module-invoice" "jazz:find-module-invoice" "%%get-module-declaration-imports" "imports" "if" "%%get-lexical-binding-name" "load-unit" "jazz:load-unit" "%%get-module-invoice-module" "let" "syntax" "%%get-module-invoice-phase" "%%eq?" "%%when" "new" "actual" "merge-invoice" "define" "register?" "module-invoice" "module-declaration")}
      {Lisp-Entry "add-module-export" define () ("module-declaration" "module-invoice") #f #f 540 9 540 31 ("key" "table-for-each" "table-merge-reporting-conflicts!" "jazz:table-merge-reporting-conflicts!" "exported-table" "exported-module-declaration" "let*" "else" "resolve-autoload-reference" "jazz:resolve-autoload-reference" "exported-module-reference" "%%get-declaration-reference-name" "reference-name" "jazz:reference-name" "name" "declaration-reference" "lambda" "for-each" "cond" "autoload" "%%get-module-invoice-only" "only" "public-access" "jazz:public-access" "%%get-access-lookup" "public" "%%list" "%%set-module-declaration-exports" "find-module-invoice" "jazz:find-module-invoice" "%%get-module-declaration-exports" "exports" "%%get-lexical-binding-name" "load-unit" "jazz:load-unit" "%%get-module-invoice-module" "resolve-reference" "jazz:resolve-reference" "syntax" "%%get-module-invoice-phase" "%%eq?" "%%get-declaration-locator" "%%table-set!" "%%get-module-declaration-walker-references" "references-table" "%%get-declaration-toplevel" "%%neq?" "and" "declaration" "add-to-module-references" "%%append" "if" "%%set-export-invoice-autoload" "%%when" "new-autoload" "%%get-export-invoice-autoload" "actual-autoload" "let" "new" "actual" "merge-invoice" "define" "module-invoice" "module-declaration")}
      {Lisp-Entry "table-merge-reporting-conflicts!" define () ("module-declaration" "suffix" "table" "add") #f #f 588 9 588 46 ("%%get-lexical-binding-name" "error" "jazz:error" "%%null?" "conflicts" "%%fx+" "%%fx=" "%%not" "%%table-merge!" "add-count" "%%table-length" "table-count" "%%list" "%%cons" "set!" "%%neq?" "%%when" "actual-locator" "value-locator" "%%table-ref" "actual" "value" "key" "lambda" "iterate-table" "jazz:iterate-table" "lst" "let" "find-actual-conflicts" "%%get-declaration-locator" "else" "autoload-declaration-locator-heuristic" "jazz:autoload-declaration-locator-heuristic" "Autoload-Declaration" "jazz:Autoload-Declaration" "%%get-export-declaration-symbol" "Export-Declaration" "jazz:Export-Declaration" "%%is?" "cond" "decl" "effective-declaration-locator" "define" "add" "table" "suffix" "module-declaration")}
      {Lisp-Entry "add-to-module-references" define () ("namespace-declaration" "method-declaration") #f #f 622 9 622 38 ("%%get-declaration-locator" "%%table-set!" "%%get-module-declaration-walker-references" "references-table" "module-declaration" "let*" "%%get-declaration-toplevel" "%%neq?" "and" "%%when" "method-declaration" "namespace-declaration")}
      {Lisp-Entry "generate-reference-list" define () ("module-declaration") #f #f 631 9 631 37 ("%%cdar" "%%pair?" "map" "declarations" "%%caar" "%%get-declaration-locator" "module-locator" "out" "%%table->list" "in" "%%table-ref" "%%table-set!" "%%get-declaration-toplevel" "module" "resolve-binding" "jazz:resolve-binding" "resolved-declaration" "locator" "lambda" "%%get-module-declaration-walker-references" "iterate-table" "jazz:iterate-table" "eq?" "test:" "%%make-table" "partition" "%%get-lexical-binding-name" "%%get-declaration-parent" "%%eq?" "composite-identifier" "iter" "declaration" "root-declaration" "compose-name" "%%cdr" "else" "%%cons" "%%car" "%%list" "cond" "sorted" "item" "merge-sorted" "cdr" "%%string=?" "and" "%%string<?" "string2" "car" "%%symbol->string" "string1" "let" "%%null?" "or" "if" "name2" "name1" "lesser" "define" "module-declaration")}
      {Lisp-Entry "lookup-declaration" generic/specific () ("symbol" "access" "source-declaration") ("jazz:Module-Declaration") #f 676 21 676 44 ("nextmethod" "declaration" "%%get-module-declaration-imports" "%%set-import-invoice-hit?" "%%table-ref" "public-access" "jazz:public-access" "%%get-access-lookup" "imported" "%%get-module-invoice-module" "imported-module-declaration" "let" "module-invoice" "lambda" "for-each" "analysis-mode?" "jazz:analysis-mode?" "%%when" "source-declaration" "access" "symbol")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Module-Declaration") #f 688 21 688 42 (",@body-expansion" ",@variables-expansion" ",@literals-expansion" ",@autoloads-expansion" ",@inclusions-expansion" ",@registration-expansion" "%%get-module-declaration-imports" "%%cadr" "%%symbol->string" "%%string<?" "y" "x" "queue-list" "jazz:queue-list" "sort" "jazz:sort" "enqueue-list" "jazz:enqueue-list" ",symbol-name" ",name" "register-autoload" "jazz:register-autoload" "compose-reference" "jazz:compose-reference" "symbol-name" "reference-name" "jazz:reference-name" "name" "decl" "%%get-declaration-reference-name" "names" "auto" "%%get-module-declaration-exports" "%%get-lexical-binding-name" "syntax" "%%get-module-invoice-phase" "%%get-module-invoice-module" "resolve-reference" "jazz:resolve-reference" "module-declaration" "and" "%%get-export-invoice-autoload" "autoload" "%%get-module-invoice-only" "only" "module-invoice" "%%get-module-declaration-requires" "phase" "feature-requirement" "parse-require" "jazz:parse-require" "spec" "lambda" "for-each" "core" "%%neq?" "%%get-module-declaration-dialect-name" "dialect-name" "core.module" ",unit-name" "load-unit" "jazz:load-unit" "enqueue" "jazz:enqueue" "%%table-set!" "%%table-ref" "%%not" "%%when" "unit-name" "enqueue-load-unit" "define" "eq?" "test:" "%%make-table" "load-units" "new-queue" "jazz:new-queue" "queue" "module" "declares" "jazz:declares" "else" "eval" "walk-for" "jazz:walk-for" "case" "begin" "emit-module-registration" "jazz:emit-module-registration" "registration-expansion" "emit-module-autoloads" "jazz:emit-module-autoloads" "autoloads-expansion" "emit-module-variables" "jazz:emit-module-variables" "variables-expansion" "emit-module-literals" "jazz:emit-module-literals" "literals-expansion" "emit-module-inclusions" "jazz:emit-module-inclusions" "inclusions-expansion" "declaration" "%%get-namespace-declaration-body" "emit-namespace-statements" "jazz:emit-namespace-statements" "body-expansion" "let" "environment")}
      {Lisp-Entry "get-module-proclaim" define () ("module-declaration" "proclaim-name" "default") #f #f 757 9 757 33 ("%%get-module-declaration-proclaims" "%%table-ref" "default" "proclaim-name" "module-declaration")}
      {Lisp-Entry "set-module-proclaim" define () ("module-declaration" "proclaim-name" "value") #f #f 761 9 761 33 ("%%get-module-declaration-proclaims" "%%table-set!" "value" "proclaim-name" "module-declaration")}
      {Lisp-Entry "all-warnings" define () () #f #f 765 8 765 25 ("optimizations")}
      {Lisp-Entry "proclaim" define () ("module-declaration" "clause") #f #f 769 9 769 22 ("remove!" "jazz:remove!" "else" "%%cons" "set-module-proclaim" "jazz:set-module-proclaim" "get-module-proclaim" "jazz:get-module-proclaim" "module-warnings" "error" "jazz:error" "%%memq" "%%not" "cond" "warning" "lambda" "for-each" "all-warnings" "jazz:all-warnings" "%%null?" "warnings" "warn" "case" "receive" "not" "%%eq?" "if" "parse-clause" "values" "%%cdr" "parameters" "%%car" "kind" "let" "%%pair?" "%%assert" "not?" "parse-not" "define" "clause" "module-declaration")}
      {Lisp-Entry "get-module-warn?" define () ("module-declaration" "warning-name") #f #f 802 9 802 30 ("warn" "get-module-proclaim" "jazz:get-module-proclaim" "%%memq" "warning-name" "module-declaration")}
      {Lisp-Entry "Module-Invoice" define-class () () ("class runtime") #f 814 27 814 46 ()}
      {Lisp-Entry "find-module-invoice" define () ("invoices" "target") #f #f 820 9 820 33 ("%%eq?" "and" "invoice" "lambda" "find-if" "jazz:find-if" "%%get-module-invoice-phase" "target-phase" "%%get-module-invoice-name" "target-name" "let" "target" "invoices")}
      {Lisp-Entry "Export-Invoice" define-class () () ("class runtime") #f 834 27 834 46 ()}
      {Lisp-Entry "new-export-invoice" define () ("name" "module" "phase" "version" "only" "autoload") #f #f 837 9 837 32 ("Export-Invoice" "jazz:Export-Invoice" "allocate-export-invoice" "jazz:allocate-export-invoice" "autoload" "only" "version" "phase" "module" "name")}
      {Lisp-Entry "Import-Invoice" define-class () () ("class runtime") #f 849 27 849 46 ()}
      {Lisp-Entry "new-import-invoice" define () ("name" "module" "phase" "version" "only") #f #f 852 9 852 32 ("Import-Invoice" "jazz:Import-Invoice" "allocate-import-invoice" "jazz:allocate-import-invoice" "only" "version" "phase" "module" "name")}
      {Lisp-Entry "Export-Declaration" define-class () () ("class runtime") #f 864 27 864 50 ()}
      {Lisp-Entry "new-export-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "symbol") #f #f 867 9 867 36 ("setup-declaration" "jazz:setup-declaration" "Export-Declaration" "jazz:Export-Declaration" "allocate-export-declaration" "jazz:allocate-export-declaration" "new-declaration" "let" "symbol" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Export-Declaration") #f 873 21 873 52 ("unspecified" "jazz:unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Export-Declaration") #f 877 21 877 42 (",symbol" ",name" "register-native" "jazz:register-native" "Module-Declaration" "jazz:Module-Declaration" "%%is?" "%%assert" "%%get-declaration-parent" "parent" "%%get-export-declaration-symbol" "symbol" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Export-Declaration") #f 885 21 885 48 ("Any" "jazz:Any" "declaration" "%%get-export-declaration-symbol" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Export-Declaration") #f 892 21 892 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "Export-Syntax-Declaration" define-class () () ("class runtime") #f 904 27 904 57 ()}
      {Lisp-Entry "new-export-syntax-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "symbol") #f #f 907 9 907 43 ("setup-declaration" "jazz:setup-declaration" "Export-Syntax-Declaration" "jazz:Export-Syntax-Declaration" "allocate-export-syntax-declaration" "jazz:allocate-export-syntax-declaration" "new-declaration" "let" "symbol" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Export-Syntax-Declaration") #f 913 21 913 52 ("unspecified" "jazz:unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Export-Syntax-Declaration") #f 917 21 917 42 ("begin" "environment")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Export-Syntax-Declaration") #f 921 21 921 48 ("Any" "jazz:Any" "declaration" "%%get-export-syntax-declaration-symbol" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Export-Syntax-Declaration") #f 928 21 928 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "Autoload-Declaration" define-class () () ("class runtime") #f 940 27 940 52 ()}
      {Lisp-Entry "new-autoload-declaration" define () ("name" "type" "parent" "module-declaration" "exported-module") #f #f 943 9 943 38 ("setup-declaration" "jazz:setup-declaration" "uptodate" "public" "Autoload-Declaration" "jazz:Autoload-Declaration" "allocate-autoload-declaration" "jazz:allocate-autoload-declaration" "new-declaration" "let" "exported-module" "module-declaration" "parent" "type" "name")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Autoload-Declaration") #f 949 21 949 37 ("declaration" "resolve-binding" "jazz:resolve-binding" "of-subtype?" "jazz:of-subtype?" "subtype")}
      {Lisp-Entry "specifiable?" generic/specific () () ("jazz:Autoload-Declaration") #f 954 21 954 38 ()}
      {Lisp-Entry "resolve-binding" generic/specific () () ("jazz:Autoload-Declaration") #f 959 21 959 41 ("%%set-autoload-declaration-declaration" "%%get-declaration-locator" "error" "jazz:error" "%%assertion" "public-access" "jazz:public-access" "lookup-declaration" "jazz:lookup-declaration" "decl" "%%get-lexical-binding-name" "name" "%%get-autoload-declaration-module" "%%get-autoload-declaration-exported-module" "resolve-reference" "jazz:resolve-reference" "exported-module" "let*" "declaration" "%%get-autoload-declaration-declaration" "or")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Autoload-Declaration") #f 969 21 969 52 ("declaration" "resolve-binding" "jazz:resolve-binding" "walk-binding-validate-call" "jazz:walk-binding-validate-call" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Autoload-Declaration") #f 973 21 973 48 ("autoload-locator" "jazz:autoload-locator" "new-code" "jazz:new-code" "declaration" "resolve-binding" "jazz:resolve-binding" "referenced-declaration" "let" "environment" "source-declaration")}
      {Lisp-Entry "autoload-declaration-locator-heuristic" define () ("declaration") #f #f 983 9 983 52 ("%%get-lexical-binding-name" "%%get-autoload-declaration-exported-module" "%%get-declaration-reference-name" "compose-reference" "jazz:compose-reference" "declaration")}
      {Lisp-Entry "autoload-locator" define () ("referenced-declaration") #f #f 987 9 987 30 ("%%get-declaration-locator" "%%symbol->string" "%%string-append" "%%string->symbol" "referenced-declaration")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Autoload-Declaration") #f 992 21 992 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "Literal" define-class () () ("class runtime") #f 1004 27 1004 39 ()}
      {Lisp-Entry "new-literal" define () ("name" "arguments") #f #f 1007 9 1007 25 ("Literal" "jazz:Literal" "allocate-literal" "jazz:allocate-literal" "arguments" "name")}
      {Lisp-Entry "Void-Class" define-class () () ("class runtime") #f 1019 27 1019 42 ()}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Void-Class") #f 1022 21 1022 37 ("subtype")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Void-Class") #f 1026 21 1026 40 ("void")}
      {Lisp-Entry "Void" define-class () () ("class runtime") #f 1033 27 1033 36 ()}
      {Lisp-Entry "Opt-Type" define-class () () ("class runtime") #f 1044 27 1044 40 ()}
      {Lisp-Entry "new-opt-type" define () ("type") #f #f 1047 9 1047 26 ("Opt-Type" "jazz:Opt-Type" "allocate-opt-type" "jazz:allocate-opt-type" "type")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Opt-Type") #f 1051 21 1051 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-opt-type-type" "emit-specifier" "jazz:emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "Key-Type" define-class () () ("class runtime") #f 1064 27 1064 40 ()}
      {Lisp-Entry "new-key-type" define () ("key" "type") #f #f 1067 9 1067 26 ("Key-Type" "jazz:Key-Type" "allocate-key-type" "jazz:allocate-key-type" "type" "key")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Key-Type") #f 1071 21 1071 40 ("%%symbol->string" "%%keyword->string" "%%string-append" "%%string->symbol" "%%get-key-type-type" "emit-specifier" "jazz:emit-specifier" "type-specifier" "type" "%%get-key-type-key" "key" "let")}
      {Lisp-Entry "Rest-Type" define-class () () ("class runtime") #f 1085 27 1085 41 ()}
      {Lisp-Entry "new-rest-type" define () ("type") #f #f 1088 9 1088 27 ("Rest-Type" "jazz:Rest-Type" "allocate-rest-type" "jazz:allocate-rest-type" "type")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Rest-Type") #f 1092 21 1092 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-rest-type-type" "emit-specifier" "jazz:emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "Function-Type" define-class () () ("class runtime") #f 1108 27 1108 45 ()}
      {Lisp-Entry "new-function-type" define () ("positional" "optional" "named" "rest" "result") #f #f 1111 9 1111 31 ("Function-Type" "jazz:Function-Type" "allocate-function-type" "jazz:allocate-function-type" "%%length" "mandatory" "let" "result" "rest" "named" "optional" "positional")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Function-Type") #f 1116 21 1116 37 ("Function-Type" "jazz:Function-Type" "%%get-object-class" "%%eq?" "Procedure" "jazz:Procedure" "of-subtype?" "jazz:of-subtype?" "or" "subtype")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Function-Type") #f 1121 21 1121 40 ("get-output-string" "%%string->symbol" "%%get-function-type-result" "%%not" "%%when" "%%get-function-type-rest" "rest" "%%get-function-type-positional" "emit-specifier" "jazz:emit-specifier" "display" "write-char" "set!" "if" "type" "lambda" "for-each" "first?" "open-output-string" "output" "let")}
      {Lisp-Entry "emit-check" generic/specific () ("value" "source-declaration" "environment") ("jazz:Function-Type") #f 1140 21 1140 36 ("Procedure" "jazz:Procedure" "type-error" "jazz:type-error" ",value" "%%procedure?" "%%not" "if" "environment" "source-declaration" "value")}
      {Lisp-Entry "Category-Type" define-class () () ("class runtime") #f 1156 27 1156 45 ()}
      {Lisp-Entry "new-category-type" define () ("declaration") #f #f 1159 9 1159 31 ("Category-Type" "jazz:Category-Type" "allocate-category-type" "jazz:allocate-category-type" "declaration")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Category-Type") #f 1164 21 1164 37 ("subtype")}
      {Lisp-Entry "emit-check" generic/specific () ("value" "source-declaration" "environment") ("jazz:Category-Type") #f 1168 21 1168 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Category-Type") #f 1172 21 1172 40 ("get-output-string" "%%string->symbol" "type" "%%get-category-type-declaration" "emit-specifier" "jazz:emit-specifier" "write-char" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "Values-Type" define-class () () ("class runtime") #f 1189 27 1189 43 ()}
      {Lisp-Entry "new-values-type" define () ("types") #f #f 1192 9 1192 29 ("Values-Type" "jazz:Values-Type" "allocate-values-type" "jazz:allocate-values-type" "types")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Values-Type") #f 1196 21 1196 40 ("get-output-string" "%%string->symbol" "%%get-values-type-types" "emit-specifier" "jazz:emit-specifier" "set!" "if" "type" "lambda" "for-each" "first?" "write-char" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "Restriction-Type" define-class () () ("class runtime") #f 1219 27 1219 48 ()}
      {Lisp-Entry "new-restriction-type" define () ("base" "type") #f #f 1222 9 1222 34 ("Restriction-Type" "jazz:Restriction-Type" "allocate-restriction-type" "jazz:allocate-restriction-type" "type" "base")}
      {Lisp-Entry "Complement-Type" define-class () () ("class runtime") #f 1234 27 1234 47 ()}
      {Lisp-Entry "new-complement-type" define () ("type") #f #f 1237 9 1237 33 ("Complement-Type" "jazz:Complement-Type" "allocate-complement-type" "jazz:allocate-complement-type" "type")}
      {Lisp-Entry "Union-Type" define-class () () ("class runtime") #f 1249 27 1249 42 ()}
      {Lisp-Entry "new-union-type" define () ("types") #f #f 1252 9 1252 28 ("Union-Type" "jazz:Union-Type" "allocate-union-type" "jazz:allocate-union-type" "types")}
      {Lisp-Entry "Template-Type" define-class () () ("class runtime") #f 1267 27 1267 45 ()}
      {Lisp-Entry "new-template-type" define () ("class" "types") #f #f 1270 9 1270 31 ("Template-Type" "jazz:Template-Type" "allocate-template-type" "jazz:allocate-template-type" "types" "class")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Template-Type") #f 1274 21 1274 40 ("get-output-string" "%%string->symbol" "%%get-template-type-types" "set!" "if" "lambda" "for-each" "first?" "write-char" "type" "%%get-template-type-class" "emit-specifier" "jazz:emit-specifier" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "Nillable-Type" define-class () () ("class runtime") #f 1297 27 1297 45 ()}
      {Lisp-Entry "new-nillable-type" define () ("type") #f #f 1300 9 1300 31 ("Nillable-Type" "jazz:Nillable-Type" "allocate-nillable-type" "jazz:allocate-nillable-type" "type")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Nillable-Type") #f 1304 21 1304 37 ("type" "%%get-nillable-type-type" "Boolean" "jazz:Boolean" "of-subtype?" "jazz:of-subtype?" "or" "subtype")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Nillable-Type") #f 1309 21 1309 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-nillable-type-type" "emit-specifier" "jazz:emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "emit-check" generic/specific () ("value" "source-declaration" "environment") ("jazz:Nillable-Type") #f 1314 21 1314 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "object-declaration?" define () () #f #f 1327 8 1327 32 ()}
      {Lisp-Entry "Any-Class" define-class () () ("class runtime") #f 1339 27 1339 41 ()}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Any-Class") #f 1342 21 1342 37 ("subtype")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Any-Class") #f 1346 21 1346 40 ("any")}
      {Lisp-Entry "emit-check" generic/specific () ("value" "source-declaration" "environment") ("jazz:Any-Class") #f 1350 21 1350 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "Any" define-class () () ("class runtime") #f 1357 27 1357 35 ()}
      {Lisp-Entry "emit-type-cast" define () ("code" "type" "source-declaration" "environment") #f #f 1374 13 1374 32 ("%%fixnum->flonum" "%%fixnum?" ",value" "Flonum" "jazz:Flonum" "%%eq?" "generate-symbol" "jazz:generate-symbol" "value" "let" "sourcified-form" "jazz:sourcified-form" "%%get-code-type" "%%subtype?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "emit-type-cast" define () ("code" "type" "source-declaration" "environment") #f #f 1386 12 1386 31 ("emit-check" "jazz:emit-check" "begin" "%%fixnum->flonum" "%%fixnum?" ",value" "Flonum" "jazz:Flonum" "generate-symbol" "jazz:generate-symbol" "value" "let" "sourcified-form" "jazz:sourcified-form" "%%get-code-type" "%%subtype?" "Void" "jazz:Void" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "emit-parameter-cast" define () ("code" "type" "source-declaration" "environment") #f #f 1407 13 1407 37 ("%%fixnum->flonum" "set!" ",parameter" "%%fixnum?" "Flonum" "jazz:Flonum" "sourcified-form" "jazz:sourcified-form" "parameter" "let" "object-declaration?" "jazz:object-declaration?" "%%object-class?" "Any" "jazz:Any" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "emit-parameter-cast" define () ("code" "type" "source-declaration" "environment") #f #f 1417 12 1417 36 ("emit-check" "jazz:emit-check" "%%fixnum->flonum" "set!" ",parameter" "%%fixnum?" "Flonum" "jazz:Flonum" "sourcified-form" "jazz:sourcified-form" "parameter" "let" "object-declaration?" "jazz:object-declaration?" "%%object-class?" "Any" "jazz:Any" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "parse-specifier" define () ("lst" "proc") #f #f 1447 9 1447 29 ("%%cdr" "%%car" "source-code" "jazz:source-code" "specifier?" "jazz:specifier?" "%%pair?" "and" "if" "proc" "lst")}
      {Lisp-Entry "walk-specifier" define () ("walker" "resume" "declaration" "environment" "specifier") #f #f 1453 9 1453 28 ("%%cons" "%%list" "atomic?" "jazz:new-function-type" "rest" "named" "optional" "positional" "lambda" "butlast" "jazz:butlast" "Rest-Type" "jazz:Rest-Type" "%%class-is?" "jazz:last" "last" "%%null?" "proc" "types" "split-parameters" "result" "parameters" "new-function-type" "new-template-type" "jazz:new-template-type" "new-values-type" "jazz:new-values-type" "values" "new-category-type" "jazz:new-category-type" "category" "new-key-type" "jazz:new-key-type" "%%string->keyword" "key" "new-opt-type" "jazz:new-opt-type" "opt" "%%eq?" "new-rest-type" "jazz:new-rest-type" "new-nillable-type" "jazz:new-nillable-type" "case" "parse-atomic" "write-char" "get-output-string" "%%string->symbol" "%%eof-object?" "open-output-string" "output" "parse-name" "else" "cond" "next" "parse" "enqueue" "jazz:enqueue" "queue-list" "jazz:queue-list" "begin" "iter" "new-queue" "jazz:new-queue" "queue" "terminator" "separator" "parse-until" "specifiable?" "jazz:specifiable?" "%%assertion" "lookup-reference" "jazz:lookup-reference" "lookup-primitive-type" "jazz:lookup-primitive-type" "or" "type" "name" "lookup-type" "%%eqv?" "consume" "1" "%%fx+" "set!" "read-char" "c" "readc" "peek-char" "peekc" "walk-error" "jazz:walk-error" "error" "jazz:error" "%%not" "if" "%%substring" "format" "jazz:format" "error-message" "message" "ill-formed" "define" "0" "at" "open-input-string" "input" "%%symbol->string" "string" "let" "specifier" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "specifier->type" define () ("walker" "resume" "declaration" "environment" "specifier") #f #f 1595 9 1595 29 ("walk-specifier" "jazz:walk-specifier" "if" "specifier" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "type->specifier" define () ("type") #f #f 1601 9 1601 29 ("name->specifier" "jazz:name->specifier" "specifier?" "jazz:specifier?" "if" "emit-specifier" "jazz:emit-specifier" "symbol" "let" "type")}
      {Lisp-Entry "primitive-types" define () () #f #f 1613 8 1613 28 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "lookup-primitive-type" define () ("name") #f #f 1658 9 1658 35 ("primitive-types" "jazz:primitive-types" "%%table-ref" "name")}
      {Lisp-Entry "primitive-declarations" define () () #f #f 1662 8 1662 35 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "patch-type-until-unification" define () ("type") #f #f 1706 9 1706 42 ("public-access" "jazz:public-access" "lookup-declaration" "jazz:lookup-declaration" "get-catalog-entry" "jazz:get-catalog-entry" "module-declaration" "jazz.dialect.language.functional" "jazz.dialect.language.object" "Object" "%%eq?" "module-name" "if" "primitive-declarations" "jazz:primitive-declarations" "%%table-ref" "name" "let" "type")}
      {Lisp-Entry "Macro-Declaration" define-class () () ("class runtime") #f 1722 27 1722 49 ()}
      {Lisp-Entry "new-macro-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "signature") #f #f 1725 9 1725 35 ("setup-declaration" "jazz:setup-declaration" "Macro-Declaration" "jazz:Macro-Declaration" "allocate-macro-declaration" "jazz:allocate-macro-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Macro-Declaration") #f 1731 21 1731 50 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Macro-Declaration") #f 1735 21 1735 50 ("%%cdr" "%%apply" "need-macro" "jazz:need-macro" "expander" "load-unit" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "walk-error" "jazz:walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Macro-Declaration") #f 1746 21 1746 42 ("%%get-declaration-source" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "emit-signature" "jazz:emit-signature" "define-macro" "jazz:define-macro" "sourcify-if" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-macro-declaration-body" "body" "%%get-macro-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Macro-Declaration") #f 1759 21 1759 42 ("%%get-macro-declaration-body" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "Local-Macro-Declaration" define-class () () ("class runtime") #f 1773 27 1773 55 ()}
      {Lisp-Entry "new-local-macro-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "signature") #f #f 1776 9 1776 41 ("setup-declaration" "jazz:setup-declaration" "Local-Macro-Declaration" "jazz:Local-Macro-Declaration" "allocate-macro-declaration" "jazz:allocate-macro-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "need-local-macro" define () ("module-declaration" "name") #f #f 1781 9 1781 30 ("error" "jazz:error" "%%get-module-declaration-local-macros" "%%table-ref" "or" "name" "module-declaration")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Local-Macro-Declaration") #f 1785 21 1785 50 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Local-Macro-Declaration") #f 1788 21 1788 50 ("%%cdr" "%%apply" "need-local-macro" "jazz:need-local-macro" "expander" "%%get-declaration-parent" "parent" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Local-Macro-Declaration") #f 1795 21 1795 42 ("begin" "environment")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Local-Macro-Declaration") #f 1799 21 1799 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "Syntax-Declaration" define-class () () ("class runtime") #f 1811 27 1811 50 ()}
      {Lisp-Entry "new-syntax-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "signature") #f #f 1814 9 1814 36 ("setup-declaration" "jazz:setup-declaration" "Syntax-Declaration" "jazz:Syntax-Declaration" "allocate-syntax-declaration" "jazz:allocate-syntax-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Syntax-Declaration") #f 1820 21 1820 50 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Syntax-Declaration") #f 1824 21 1824 50 ("need-macro" "jazz:need-macro" "expander" "load-unit" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "walk-error" "jazz:walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Syntax-Declaration") #f 1834 21 1834 42 ("%%get-declaration-source" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "emit-signature" "jazz:emit-signature" "define-macro" "jazz:define-macro" "sourcify-if" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-syntax-declaration-body" "body" "%%get-syntax-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Syntax-Declaration") #f 1847 21 1847 42 ("%%get-syntax-declaration-body" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "Define-Syntax-Declaration" define-class () () ("class runtime") #f 1861 27 1861 57 ()}
      {Lisp-Entry "new-define-syntax-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "signature" "syntax-form") #f #f 1864 9 1864 43 ("setup-declaration" "jazz:setup-declaration" "Define-Syntax-Declaration" "jazz:Define-Syntax-Declaration" "allocate-define-syntax-declaration" "jazz:allocate-define-syntax-declaration" "new-declaration" "let" "syntax-form" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Define-Syntax-Declaration") #f 1870 21 1870 42 ("%%get-declaration-source" "register-macro" "jazz:register-macro" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "new-define-syntax-form" "jazz:new-define-syntax-form" "tmp" ",current-unit-name" "outline-module" "jazz:outline-module" "else" "cons" "x" "=>" "jazz" "cond" "core" "scheme" "get-dialect" "jazz:get-dialect" "%%get-dialect-bindings" "new-walk-frame" "jazz:new-walk-frame" "%%list" "env" "let*" ",locator" "define" "sourcify-if" "jazz:sourcify-if" "%%get-declaration-toplevel" "current-unit-name" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-syntax-declaration-body" "body" "%%get-syntax-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Define-Syntax-Declaration") #f 1908 21 1908 50 ("%%get-define-syntax-form-environment" "macro-environment" "%%get-syntax-form-expander" "expander" "need-macro" "jazz:need-macro" "define-syntax-form" "let*" "load-unit" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "walk-warning" "jazz:walk-warning" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Define-Local-Syntax-Declaration" define-class () () ("class runtime") #f 1928 27 1928 63 ()}
      {Lisp-Entry "new-define-local-syntax-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "signature" "syntax-form") #f #f 1930 9 1930 49 ("setup-declaration" "jazz:setup-declaration" "Define-Local-Syntax-Declaration" "jazz:Define-Local-Syntax-Declaration" "allocate-define-local-syntax-declaration" "jazz:allocate-define-local-syntax-declaration" "new-declaration" "let" "syntax-form" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Define-Local-Syntax-Declaration") #f 1935 21 1935 50 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Define-Local-Syntax-Declaration") #f 1938 21 1938 50 ("%%get-define-local-syntax-form-environment" "macro-environment" "%%get-syntax-form-expander" "expander" "let" "%%get-declaration-parent" "need-local-macro" "jazz:need-local-macro" "define-local-syntax-form" "binding" "%%get-declaration-locator" "locator" "let*" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Define-Local-Syntax-Declaration") #f 1945 21 1945 42 ("begin" "environment")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Define-Local-Syntax-Declaration") #f 1948 21 1948 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "Walk-Context" define-class () () ("class runtime") #f 1959 27 1959 44 ()}
      {Lisp-Entry "new-walk-context" define () ("policy" "locator" "pathname") #f #f 1962 9 1962 30 ("Walk-Context" "jazz:Walk-Context" "allocate-walk-context" "jazz:allocate-walk-context" "pathname" "locator" "policy")}
      {Lisp-Entry "walk-context" define () () #f #f 1966 8 1966 25 ("make-parameter")}
      {Lisp-Entry "get-walk-context" define () () #f #f 1970 9 1970 30 ("walk-context" "jazz:walk-context")}
      {Lisp-Entry "need-walk-context" define () () #f #f 1974 9 1974 31 ("error" "jazz:error" "walk-context" "jazz:walk-context" "or")}
      {Lisp-Entry "get-walk-policy" define () () #f #f 1979 9 1979 29 ("%%get-walk-context-policy" "%%not" "if" "get-walk-context" "jazz:get-walk-context" "context" "let")}
      {Lisp-Entry "get-walk-locator" define () () #f #f 1986 9 1986 30 ("%%get-walk-context-locator" "%%not" "if" "get-walk-context" "jazz:get-walk-context" "context" "let")}
      {Lisp-Entry "get-walk-pathname" define () () #f #f 1993 9 1993 31 ("%%get-walk-context-pathname" "%%not" "if" "get-walk-context" "jazz:get-walk-context" "context" "let")}
      {Lisp-Entry "Walk-Location" define-class () () ("class runtime") #f 2008 27 2008 45 ()}
      {Lisp-Entry "new-walk-location" define () ("unit-locator" "declaration-locator" "locat" "path") #f #f 2011 9 2011 31 ("Walk-Location" "jazz:Walk-Location" "allocate-walk-location" "jazz:allocate-walk-location" "path" "locat" "declaration-locator" "unit-locator")}
      {Lisp-Entry "walk-location" define () ("walker" "declaration" "locat") #f #f 2015 9 2015 27 ("%%locat-container" "%%container->path" "if" "%%get-declaration-locator" "get-walk-locator" "jazz:get-walk-locator" "new-walk-location" "jazz:new-walk-location" "locat" "declaration" "walker")}
      {Lisp-Entry "Walk-Problem" define-class () () ("class runtime") #f 2031 27 2031 44 ()}
      {Lisp-Entry "Walk-Problems" define-class () () ("class runtime") #f 2042 27 2042 45 ()}
      {Lisp-Entry "new-walk-problems" define () ("message" "warnings" "errors") #f #f 2045 9 2045 31 ("Walk-Problems" "jazz:Walk-Problems" "allocate-walk-problems" "jazz:allocate-walk-problems" "errors" "warnings" "message")}
      {Lisp-Entry "get-detail" generic/specific () () ("jazz:Walk-Problems") #f 2049 21 2049 36 ("partition-walk-problems-unit" "jazz:partition-walk-problems-unit" "partition-walk-problems-declaration" "jazz:partition-walk-problems-declaration" "queue-list" "jazz:queue-list" "declaration-details" "1" "%%fx+" "%%substring" "%%fx=" "declaration-locator" "new-queue" "jazz:new-queue" "unit-details" "or" "%%symbol->string" "%%string-length" "-1" "%%not" "if" "prefix" "unit-locator" "bind" "jazz:bind" "partition" "map" "%%get-walk-problems-errors" "%%get-walk-problems-warnings" "%%append" "all" "let" "%%get-walk-problem-location" "present-exception" "jazz:present-exception" "new-exception-detail" "jazz:new-exception-detail" "enqueue" "jazz:enqueue" "problem" "lambda" "for-each" "queue" "problems" "add-details" "define")}
      {Lisp-Entry "Walk-Warning" define-class () () ("class runtime") #f 2085 27 2085 44 ()}
      {Lisp-Entry "new-walk-warning" define () ("location" "message") #f #f 2088 9 2088 30 ("Walk-Warning" "jazz:Walk-Warning" "allocate-walk-warning" "jazz:allocate-walk-warning" "message" "location")}
      {Lisp-Entry "Walk-Error" define-class () () ("class runtime") #f 2100 27 2100 42 ()}
      {Lisp-Entry "new-walk-error" define () ("location" "message") #f #f 2103 9 2103 28 ("Walk-Error" "jazz:Walk-Error" "allocate-walk-error" "jazz:allocate-walk-error" "message" "location")}
      {Lisp-Entry "Unresolved-Error" define-class () () ("class runtime") #f 2115 27 2115 48 ()}
      {Lisp-Entry "new-unresolved-error" define () ("location" "symbol") #f #f 2118 9 2118 34 ("Unresolved-Error" "jazz:Unresolved-Error" "allocate-unresolved-error" "jazz:allocate-unresolved-error" "symbol" "location")}
      {Lisp-Entry "present-exception" generic/specific () () ("jazz:Unresolved-Error") #f 2122 21 2122 43 ("error" "%%get-unresolved-error-symbol" "format" "jazz:format")}
      {Lisp-Entry "Walk-Frame" define-class () () ("class runtime") #f 2135 27 2135 42 ()}
      {Lisp-Entry "new-walk-frame" define () ("bindings") #f #f 2138 9 2138 28 ("Walk-Frame" "jazz:Walk-Frame" "allocate-walk-frame" "jazz:allocate-walk-frame" "%%table-set!" "%%get-lexical-binding-name" "name" "binding" "lambda" "for-each" "eq?" "test:" "%%make-table" "table" "let" "bindings")}
      {Lisp-Entry "walk-binding-lookup" generic/specific () ("symbol" "source-declaration") ("jazz:Walk-Frame") #f 2147 21 2147 45 ("binding" "%%get-walk-frame-bindings" "%%table-ref" "source-declaration" "symbol")}
      {Lisp-Entry "Signature" define-class () () ("class runtime") #f 2159 27 2159 41 ()}
      {Lisp-Entry "new-signature" define () ("positional" "optional" "named" "rest") #f #f 2162 9 2162 27 ("Signature" "jazz:Signature" "allocate-signature" "jazz:allocate-signature" "%%length" "mandatory" "let" "rest" "named" "optional" "positional")}
      {Lisp-Entry "only-positional?" define () ("signature") #f #f 2167 9 2167 30 ("%%get-signature-rest" "%%not" "%%get-signature-named" "%%get-signature-optional" "%%null?" "and" "signature")}
      {Lisp-Entry "Symbol-Binding" define-class () () ("class runtime") #f 2181 27 2181 46 ()}
      {Lisp-Entry "emit-binding-symbol" generic/specific () ("declaration" "environment") ("jazz:Symbol-Binding") #f 2184 21 2184 45 ("%%get-lexical-binding-name" "unwrap-syntactic-closure" "binding" "%%get-symbol-binding-gensym" "or" "environment" "declaration")}
      {Lisp-Entry "Variable" define-class () () ("class runtime") #f 2197 27 2197 40 ()}
      {Lisp-Entry "new-variable" define () ("name" "type") #f #f 2200 9 2200 26 ("0" "Variable" "jazz:Variable" "allocate-variable" "jazz:allocate-variable" "error" "jazz:error" "variable-name-valid?" "jazz:variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "variable-name-valid?" define () ("name") #f #f 2205 9 2205 34 ("%%get-syntactic-closure-form" "syntactic-closure?" "if" "specifier?" "jazz:specifier?" "%%not" "%%symbol?" "and" "variable-name-valid-symbol?" "define" "name")}
      {Lisp-Entry "walk-binding-referenced" generic/specific () () ("jazz:Variable") #f 2216 21 2216 49 ("1" "%%get-variable-reference-count" "%%fx+" "binding" "%%set-variable-reference-count")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Variable") #f 2220 21 2220 48 ("find-annotated-type" "jazz:find-annotated-type" "binding" "emit-binding-symbol" "jazz:emit-binding-symbol" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "walk-binding-assignable?" generic/specific () () ("jazz:Variable") #f 2227 21 2227 50 ()}
      {Lisp-Entry "emit-binding-assignment" generic/specific () ("value" "source-declaration" "environment") ("jazz:Variable") #f 2231 21 2231 49 ("Any" "jazz:Any" "sourcified-form" "jazz:sourcified-form" "emit-binding-symbol" "jazz:emit-binding-symbol" "set!" "new-code" "jazz:new-code" "%%get-code-type" "extend-annotated-type" "jazz:extend-annotated-type" "Annotated-Variable" "jazz:Annotated-Variable" "%%class-is?" "%%when" "binding" "find-annotated" "jazz:find-annotated" "annotated-type" "annotated-variable" "annotated-frame" "receive" "emit-expression" "jazz:emit-expression" "value-code" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "NextMethod-Variable" define-class () () ("class runtime") #f 2251 27 2251 51 ()}
      {Lisp-Entry "new-nextmethod-variable" define () ("name" "type") #f #f 2254 9 2254 37 ("0" "NextMethod-Variable" "jazz:NextMethod-Variable" "allocate-nextmethod-variable" "jazz:allocate-nextmethod-variable" "error" "jazz:error" "variable-name-valid?" "jazz:variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:NextMethod-Variable") #f 2259 21 2259 48 ("Any" "jazz:Any" "sourcified-form" "jazz:sourcified-form" ",name" "apply" "rest" "lambda" "if" "new-code" "jazz:new-code" "*self*" "jazz:*self*" "self" "binding" "%%get-lexical-binding-name" "name" "let" "environment" "source-declaration")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:NextMethod-Variable") #f 2270 21 2270 52 ("declaration" "validate-arguments" "jazz:validate-arguments" "if" "get-nextmethod-signature" "jazz:get-nextmethod-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-binding-call" generic/specific () ("binding-src" "arguments" "source-declaration" "environment") ("jazz:NextMethod-Variable") #f 2276 21 2276 43 ("call-return-type" "jazz:call-return-type" "codes-forms" "jazz:codes-forms" "sourcified-form" "jazz:sourcified-form" ",name" "new-code" "jazz:new-code" "if" "*self*" "jazz:*self*" "self" "%%get-lexical-binding-type" "type" "binding" "%%get-lexical-binding-name" "name" "let" "environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "Parameter" define-class () () ("class runtime") #f 2302 27 2302 41 ()}
      {Lisp-Entry "new-parameter" define () ("name" "type") #f #f 2305 9 2305 27 ("0" "Parameter" "jazz:Parameter" "allocate-parameter" "jazz:allocate-parameter" "error" "jazz:error" "variable-name-valid?" "jazz:variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "emit-parameter" generic/specific () ("declaration" "environment") ("jazz:Parameter~virtual-runtime") #f 2310 30 2310 49 ("environment" "declaration")}
      {Lisp-Entry "emit-parameter" generic/specific () ("declaration" "environment") ("jazz:Parameter") #f 2313 21 2313 40 ("parameter" "emit-binding-symbol" "jazz:emit-binding-symbol" "environment" "declaration")}
      {Lisp-Entry "Dynamic-Parameter" define-class () () ("class runtime") #f 2325 27 2325 49 ()}
      {Lisp-Entry "new-dynamic-parameter" define () ("name" "type" "class") #f #f 2328 9 2328 35 ("0" "Dynamic-Parameter" "jazz:Dynamic-Parameter" "allocate-dynamic-parameter" "jazz:allocate-dynamic-parameter" "class" "type" "name")}
      {Lisp-Entry "emit-parameter" generic/specific () ("declaration" "environment") ("jazz:Dynamic-Parameter") #f 2332 21 2332 40 ("emit-binding-symbol" "jazz:emit-binding-symbol" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "%%list" "parameter" "%%get-dynamic-parameter-class" "class" "let" "environment" "declaration")}
      {Lisp-Entry "Optional-Parameter" define-class () () ("class runtime") #f 2345 27 2345 50 ()}
      {Lisp-Entry "new-optional-parameter" define () ("name" "type" "default") #f #f 2348 9 2348 36 ("0" "Optional-Parameter" "jazz:Optional-Parameter" "allocate-optional-parameter" "jazz:allocate-optional-parameter" "default" "type" "name")}
      {Lisp-Entry "emit-parameter" generic/specific () ("declaration" "environment") ("jazz:Optional-Parameter") #f 2352 21 2352 40 ("emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "emit-binding-symbol" "jazz:emit-binding-symbol" "%%list" "parameter" "%%get-optional-parameter-default" "default" "let" "environment" "declaration")}
      {Lisp-Entry "Named-Parameter" define-class () () ("class runtime") #f 2365 27 2365 47 ()}
      {Lisp-Entry "new-named-parameter" define () ("name" "type" "default") #f #f 2368 9 2368 33 ("0" "Named-Parameter" "jazz:Named-Parameter" "allocate-named-parameter" "jazz:allocate-named-parameter" "default" "type" "name")}
      {Lisp-Entry "emit-parameter" generic/specific () ("declaration" "environment") ("jazz:Named-Parameter") #f 2372 21 2372 40 ("emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "%%get-lexical-binding-name" "%%list" "parameter" "%%get-named-parameter-default" "default" "let" "environment" "declaration")}
      {Lisp-Entry "emit-binding-symbol" generic/specific () ("declaration" "environment") ("jazz:Named-Parameter") #f 2377 21 2377 45 ("parameter" "%%get-lexical-binding-name" "environment" "declaration")}
      {Lisp-Entry "Rest-Parameter" define-class () () ("class runtime") #f 2389 27 2389 46 ()}
      {Lisp-Entry "new-rest-parameter" define () ("name" "type") #f #f 2392 9 2392 32 ("0" "Rest-Parameter" "jazz:Rest-Parameter" "allocate-rest-parameter" "jazz:allocate-rest-parameter" "type" "name")}
      {Lisp-Entry "emit-parameter" generic/specific () ("declaration" "environment") ("jazz:Rest-Parameter") #f 2396 21 2396 40 ("parameter" "emit-binding-symbol" "jazz:emit-binding-symbol" "environment" "declaration")}
      {Lisp-Entry "Self-Binding" define-class () () ("class runtime") #f 2411 27 2411 44 ()}
      {Lisp-Entry "new-self-binding" define () ("type") #f #f 2414 9 2414 30 ("self" "Self-Binding" "jazz:Self-Binding" "allocate-self-binding" "jazz:allocate-self-binding" "type")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Self-Binding") #f 2418 21 2418 48 ("%%get-declaration-parent" "self" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "Dynamic-Self-Binding" define-class () () ("class runtime") #f 2433 27 2433 52 ()}
      {Lisp-Entry "new-dynamic-self-binding" define () ("type" "code") #f #f 2436 9 2436 38 ("self" "Dynamic-Self-Binding" "jazz:Dynamic-Self-Binding" "allocate-dynamic-self-binding" "jazz:allocate-dynamic-self-binding" "code" "type")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Dynamic-Self-Binding") #f 2440 21 2440 48 ("%%get-declaration-parent" "declaration" "%%get-dynamic-self-binding-code" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "*self*" define () () #f #f 2455 8 2455 19 ("make-parameter")}
      {Lisp-Entry "Local-Variable-Binding" define-class () () ("class runtime") #f 2464 27 2464 54 ()}
      {Lisp-Entry "new-local-variable-binding" define () ("type" "variable") #f #f 2467 9 2467 40 ("Local-Variable-Binding" "jazz:Local-Variable-Binding" "allocate-local-variable-binding" "jazz:allocate-local-variable-binding" "variable" "type")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Local-Variable-Binding") #f 2471 21 2471 48 ("Any" "jazz:Any" "declaration" "%%get-local-variable-binding-variable" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "Macro-Symbol" define-class () () ("class runtime") #f 2486 27 2486 44 ()}
      {Lisp-Entry "new-macro-symbol" define () ("name" "getter" "setter") #f #f 2489 9 2489 30 ("Macro-Symbol" "jazz:Macro-Symbol" "allocate-macro-symbol" "jazz:allocate-macro-symbol" "setter" "getter" "name")}
      {Lisp-Entry "Form-Binding" define-class () () ("class runtime") #f 2518 27 2518 44 ()}
      {Lisp-Entry "special-forms" define () () #f #f 2529 8 2529 26 ()}
      {Lisp-Entry "add-special-form" define () ("symbol" "special-form") #f #f 2533 9 2533 30 ("%%cons" "special-forms" "jazz:special-forms" "set!" "special-form" "symbol")}
      {Lisp-Entry "find-special-form" define () ("symbol") #f #f 2537 9 2537 31 ("symbol")}
      {Lisp-Entry "Special-Form" define-class () () ("class runtime") #f 2544 27 2544 44 ()}
      {Lisp-Entry "new-special-form" define () ("name" "walk") #f #f 2547 9 2547 30 ("Special-Form" "jazz:Special-Form" "allocate-special-form" "jazz:allocate-special-form" "walk" "name")}
      {Lisp-Entry "walk-binding-walkable?" generic/specific () () ("jazz:Special-Form") #f 2551 21 2551 48 ()}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Special-Form") #f 2555 21 2555 48 ("binding" "%%get-lexical-binding-name" "environment" "source-declaration")}
      {Lisp-Entry "walk-binding-walk-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Special-Form") #f 2559 21 2559 48 ("find-special-form" "jazz:find-special-form" "%%symbol?" "if" "walk" "binding" "%%get-special-form-walk" "walk-proc/symbol" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Macro-Form" define-class () () ("class runtime") #f 2576 27 2576 42 ()}
      {Lisp-Entry "new-macro-form" define () ("name" "expander") #f #f 2579 9 2579 28 ("Macro-Form" "jazz:Macro-Form" "allocate-macro-form" "jazz:allocate-macro-form" "expander" "name")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Macro-Form") #f 2583 21 2583 50 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Macro-Form") #f 2587 21 2587 50 ("%%cdr" "apply" "binding" "%%get-macro-form-expander" "expander" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Syntax-Form" define-class () () ("class runtime") #f 2601 27 2601 43 ()}
      {Lisp-Entry "new-syntax-form" define () ("name" "expander") #f #f 2604 9 2604 29 ("Syntax-Form" "jazz:Syntax-Form" "allocate-syntax-form" "jazz:allocate-syntax-form" "expander" "name")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Syntax-Form") #f 2608 21 2608 50 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Syntax-Form") #f 2612 21 2612 50 ("binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Define-Syntax-Form" define-class () () ("class runtime") #f 2625 27 2625 50 ()}
      {Lisp-Entry "new-define-syntax-form" define () ("name" "expander" "environment") #f #f 2628 9 2628 36 ("Define-Syntax-Form" "jazz:Define-Syntax-Form" "allocate-define-syntax-form" "jazz:allocate-define-syntax-form" "environment" "expander" "name")}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Define-Syntax-Form") #f 2632 21 2632 50 ("%%get-define-syntax-form-environment" "macro-environment" "binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Define-Local-Syntax-Form" define-class () () ("class runtime") #f 2646 27 2646 56 ()}
      {Lisp-Entry "new-define-local-syntax-form" define () ("name" "expander" "environment") #f #f 2649 9 2649 42 ("Define-Local-Syntax-Form" "jazz:Define-Local-Syntax-Form" "allocate-define-local-syntax-form" "jazz:allocate-define-local-syntax-form" "environment" "expander" "name")}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form-src") ("jazz:Define-Local-Syntax-Form") #f 2653 21 2653 50 ("%%get-define-local-syntax-form-environment" "macro-environment" "binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Syntactic-Closure" define-class () () ("class runtime") #f 2667 27 2667 49 ()}
      {Lisp-Entry "syntactic-closure?" define () ("x") #f #f 2670 9 2670 27 ("Syntactic-Closure" "jazz:Syntactic-Closure" "%%class-is?" "x")}
      {Lisp-Entry "make-syntactic-closure" define () ("env" "vars" "form") #f #f 2674 9 2674 31 ("Syntactic-Closure" "jazz:Syntactic-Closure" "allocate-syntactic-closure" "jazz:allocate-syntactic-closure" "%%source-code" "%%source?" "and" "%%pair?" "%%symbol?" "or" "if" "form" "vars" "env")}
      {Lisp-Entry "syntactic-closure-form" define () ("sc") #f #f 2683 9 2683 31 ("%%get-syntactic-closure-form" "sc")}
      {Lisp-Entry "unwrap-syntactic-closure" define () ("x") #f #f 2687 9 2687 33 ("else" "%%source-code" "%%source?" "%%get-syntactic-closure-form" "unwrap-syntactic-closure" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "strip-syntactic-closures" define () ("x") #f #f 2695 9 2695 33 ("else" "%%vector->list" "%%list->vector" "%%vector?" "%%cdr" "%%car" "cons" "%%pair?" "%%source-code" "%%source?" "%%get-syntactic-closure-form" "strip-syntactic-closures" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "strip-source-info" define () ("x") #f #f 2708 9 2708 26 ("else" "%%vector->list" "%%list->vector" "%%vector?" "%%cdr" "%%car" "cons" "%%pair?" "%%source-code" "strip-source-info" "%%source?" "cond" "x")}
      {Lisp-Entry "identifier?" define () ("x") #f #f 2718 9 2718 20 ("symbol?" "else" "%%source-code" "%%source?" "syntactic-closure-form" "identifier?" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "identifier=?" define () ("x-env" "x" "y-env" "y") #f #f 2725 9 2725 21 ("not" "and" "y^" "unwrap-syntactic-closure" "x^" "let" "eq?" "or" "%%get-lexical-binding-name" "Lexical-Binding" "jazz:Lexical-Binding" "%%class-is?" "binding-name" "walk-binding-lookup" "jazz:walk-binding-lookup" "binding" "lambda" "find-in" "jazz:find-in" "composite-reference?" "jazz:composite-reference?" "if" "environment" "symbol" "lookup-identifier" "define" "y" "y-env" "x" "x-env")}
      {Lisp-Entry "sc-macro-transformer" define () () #f #f 2747 8 2747 28 ("make-syntactic-closure" "mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "rsc-macro-transformer" define () () #f #f 2753 8 2753 29 ("mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "er-macro-transformer" define () () #f #f 2759 8 2759 28 ("identifier=?" "y" "x" "compare" "cons" "set!" "make-syntactic-closure" "name" "else" "cdr" "=>" "assq" "cond" "identifier" "renames" "rename" "let" "mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "Annotated-Variable" define-class () () ("class runtime") #f 2783 27 2783 50 ()}
      {Lisp-Entry "new-annotated-variable" define () ("variable" "declared-type" "type") #f #f 2786 9 2786 36 ("Annotated-Variable" "jazz:Annotated-Variable" "allocate-annotated-variable" "jazz:allocate-annotated-variable" "type" "declared-type" "variable")}
      {Lisp-Entry "Restricted-Binding" define-class () () ("class runtime") #f 2798 27 2798 50 ()}
      {Lisp-Entry "new-restricted-binding" define () ("binding" "type") #f #f 2801 9 2801 36 ("Restricted-Binding" "jazz:Restricted-Binding" "allocate-restricted-binding" "jazz:allocate-restricted-binding" "type" "binding")}
      {Lisp-Entry "Annotated-Frame" define-class () () ("class runtime") #f 2813 27 2813 47 ()}
      {Lisp-Entry "new-annotated-frame" define () ("variables" "reset") #f #f 2816 9 2816 33 ("Annotated-Frame" "jazz:Annotated-Frame" "allocate-annotated-frame" "jazz:allocate-annotated-frame" "reset" "variables")}
      {Lisp-Entry "inspect-annotated-variable" define () ("variable") #f #f 2824 9 2824 40 ("%%get-annotated-variable-type" "%%get-annotated-variable-variable" ":variable" "%%get-restricted-binding-type" "%%get-restricted-binding-binding" "%%get-lexical-binding-name" ":restricted" "Restricted-Binding" "jazz:Restricted-Binding" "%%class-is?" "if" "object->serial-symbol" "jazz:object->serial-symbol" "serial" "let" "variable")}
      {Lisp-Entry "inspect-annotated-frame" define () ("frame") #f #f 2835 9 2835 37 ("%%get-annotated-frame-variables" "inspect-annotated-variable" "jazz:inspect-annotated-variable" "map" ":frame" "frame")}
      {Lisp-Entry "inspect-annotated-environment" define () ("environment") #f #f 2840 9 2840 43 ("inspect-annotated-frame" "jazz:inspect-annotated-frame" "map" ":environment" "environment")}
      {Lisp-Entry "Code" define-class () () ("class runtime") #f 2850 27 2850 36 ()}
      {Lisp-Entry "new-code" define () ("form" "type" "source") #f #f 2853 9 2853 22 ("Code" "jazz:Code" "allocate-code" "jazz:allocate-code" "source" "type" "form")}
      {Lisp-Entry "codes-forms" define () ("codes") #f #f 2860 9 2860 25 ("sourcified-form" "jazz:sourcified-form" "code" "lambda" "map" "codes")}
      {Lisp-Entry "codes-types" define () ("codes") #f #f 2866 9 2866 25 ("%%get-code-type" "code" "lambda" "map" "codes")}
      {Lisp-Entry "sourcify-code" define () ("code" "src") #f #f 2873 9 2873 27 ("%%get-code-type" "%%get-code-form" "new-code" "jazz:new-code" "%%source?" "%%not" "or" "if" "src" "code")}
      {Lisp-Entry "sourcified-form" define () ("code") #f #f 2882 9 2882 29 ("sourcify-if" "jazz:sourcify-if" "%%get-code-source" "src" "%%get-code-form" "form" "let" "code")}
      {Lisp-Entry "sourcified-form2" define () ("code" "src") #f #f 2889 9 2889 30 ("sourcify-if" "jazz:sourcify-if" "%%get-code-form" "form" "let" "src" "code")}
      {Lisp-Entry "annotate-signature" define () ("signature") #f #f 2899 9 2899 32 ("queue-list" "jazz:queue-list" "%%when" "for-each" "new-annotated-variable" "jazz:new-annotated-variable" "enqueue" "jazz:enqueue" "Any" "jazz:Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "parameter" "annotate" "define" "new-queue" "jazz:new-queue" "queue" "%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "let" "signature")}
      {Lisp-Entry "annotate-inlined-signature" define () ("signature" "arguments") #f #f 2918 9 2918 40 ("queue-list" "jazz:queue-list" "new-annotated-variable" "jazz:new-annotated-variable" "enqueue" "jazz:enqueue" "%%get-code-type" "or" "type" "%%get-lexical-binding-type" "declared-type" "argument" "parameter" "lambda" "for-each" "new-queue" "jazz:new-queue" "queue" "%%get-signature-positional" "positional" "let" "arguments" "signature")}
      {Lisp-Entry "annotate-bindings" define () ("bindings") #f #f 2930 9 2930 31 ("new-annotated-variable" "jazz:new-annotated-variable" "Void" "jazz:Void" "or" "type" "%%get-lexical-binding-type" "declared-type" "%%cdr" "value" "%%car" "variable" "let" "binding" "lambda" "map" "bindings")}
      {Lisp-Entry "annotate-receive" define () ("parameters") #f #f 2940 9 2940 30 ("new-annotated-variable" "jazz:new-annotated-variable" "Any" "jazz:Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "let" "parameter" "lambda" "map" "parameters")}
      {Lisp-Entry "annotate-internal-defines" define () ("internal-defines") #f #f 2948 9 2948 39 ("new-annotated-variable" "jazz:new-annotated-variable" "Any" "jazz:Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "%%get-internal-define-variable" "variable" "let" "internal-define" "lambda" "map" "internal-defines")}
      {Lisp-Entry "with-annotated-frame" define () ("variables" "proc") #f #f 2957 9 2957 34 ("new-annotated-frame" "jazz:new-annotated-frame" "set!" "k" "lambda" "continuation-capture" "reset" "let" "proc" "variables")}
      {Lisp-Entry "find-annotated" define () ("variable" "environment") #f #f 2965 9 2965 28 ("%%get-annotated-variable-type" "%%get-annotated-variable-variable" "%%cdr" "set!" "%%not" "begin" "%%get-restricted-binding-type" "values" "%%eq?" "Declaration" "jazz:Declaration" "and" "%%get-restricted-binding-binding" "binding" "Restricted-Binding" "jazz:Restricted-Binding" "annotated-variable" "else" "list" "Variable" "jazz:Variable" "%%get-annotated-frame-variables" "Annotated-Frame" "jazz:Annotated-Frame" "%%class-is?" "cond" "variables" "iter-variables" "or" "%%car" "annotated-frame" "%%null?" "if" "frames" "iter-frames" "type" "let" "environment" "variable")}
      {Lisp-Entry "find-annotated-type" define () ("binding" "environment") #f #f 2997 9 2997 33 ("%%get-lexical-binding-type" "info" "let" "find-annotated" "jazz:find-annotated" "type" "variable" "frame" "receive" "Variable" "jazz:Variable" "%%class-is?" "if" "environment" "binding")}
      {Lisp-Entry "extend-annotated-type" define () ("frame" "variable" "new-type") #f #f 3010 9 3010 35 ("continuation-return" "%%get-annotated-frame-reset" "reset" "Any" "jazz:Any" "extended-type" "%%subtype?" "%%not" "%%when" "%%set-annotated-variable-type" "Void" "jazz:Void" "%%eq?" "if" "%%get-annotated-variable-type" "actual-type" "%%get-annotated-variable-declared-type" "declared-type" "let" "new-type" "variable" "frame")}
      {Lisp-Entry "extend-type" define () ("type1" "type2") #f #f 3033 9 3033 25 ("else" "%%subtype?" "Void" "jazz:Void" "%%eq?" "Any" "jazz:Any" "%%not" "or" "cond" "type2" "type1")}
      {Lisp-Entry "extend-types" define () ("types") #f #f 3047 9 3047 26 ("%%cdr" "extend-types" "jazz:extend-types" "%%car" "extend-type" "jazz:extend-type" "Void" "jazz:Void" "%%null?" "if" "types")}
      {Lisp-Entry "type-union" define () ("types") #f #f 3053 9 3053 24 ("new-union-type" "jazz:new-union-type" "types")}
      {Lisp-Entry "type-difference" define () ("type1" "type2") #f #f 3057 9 3057 29 ("type2" "type1")}
      {Lisp-Entry "Walker" define-class () () ("class runtime") #f 3066 27 3066 38 ()}
      {Lisp-Entry "*raise-walk-problems?*" define () () #f #f 3074 8 3074 35 ("make-parameter")}
      {Lisp-Entry "walk-warning" define () ("walker" "declaration" "src" "fmt-string" "." "rest") #f #f 3078 9 3078 26 ("new-walk-warning" "jazz:new-walk-warning" "walker-warning" "jazz:walker-warning" "format" "jazz:format" "apply" "message" "source-locat" "jazz:source-locat" "walk-location" "jazz:walk-location" "location" "let" "rest" "fmt-string" "src" "declaration" "walker")}
      {Lisp-Entry "walk-error" define () ("walker" "resume" "declaration" "src" "fmt-string" "." "rest") #f #f 3084 9 3084 24 ("new-walk-error" "jazz:new-walk-error" "walker-error" "jazz:walker-error" "format" "jazz:format" "apply" "message" "source-locat" "jazz:source-locat" "walk-location" "jazz:walk-location" "location" "let" "rest" "fmt-string" "src" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-unresolved" define () ("walker" "resume" "declaration" "symbol-src") #f #f 3090 9 3090 29 ("source-code" "jazz:source-code" "new-unresolved-error" "jazz:new-unresolved-error" "walker-error" "jazz:walker-error" "source-locat" "jazz:source-locat" "walk-location" "jazz:walk-location" "location" "let" "symbol-src" "declaration" "resume" "walker")}
      {Lisp-Entry "walker-warning" define () ("walker" "warning") #f #f 3095 9 3095 28 ("%%list" "%%get-walker-warnings" "%%append" "%%set-walker-warnings" "warnings?" "jazz:warnings?" "raise" "*raise-walk-problems?*" "jazz:*raise-walk-problems?*" "cond" "warning" "walker")}
      {Lisp-Entry "walker-error" define () ("walker" "resume" "error") #f #f 3102 9 3102 26 ("validate-walk-problems" "jazz:validate-walk-problems" "unspecified" "jazz:unspecified" "continuation-return" "delay-reporting?" "jazz:delay-reporting?" "and" "if" "%%list" "%%get-walker-errors" "%%append" "%%set-walker-errors" "else" "raise" "*raise-walk-problems?*" "jazz:*raise-walk-problems?*" "cond" "error" "resume" "walker")}
      {Lisp-Entry "validate-walk-problems" define () ("walker") #f #f 3112 9 3112 36 ("new-walk-problems" "jazz:new-walk-problems" "raise" "get-output-string" "message" "partition-walk-problems-unit" "jazz:partition-walk-problems-unit" "partition-walk-problems-declaration" "jazz:partition-walk-problems-declaration" "present-exception" "jazz:present-exception" "problem" "1" "%%fx+" "%%substring" "%%fx=" "toplevel?" "declaration-locator" "%%symbol->string" "%%string-length" "-1" "%%not" "if" "prefix" "problems" "unit-locator" "bind" "jazz:bind" "partition" "lambda" "for-each" "format" "jazz:format" "%%append" "all" "open-output-string" "output" "%%not-null?" "or" "%%when" "%%get-walker-errors" "errors" "%%get-walker-warnings" "warnings" "let" "walker")}
      {Lisp-Entry "partition-walk-problems-unit" define () ("problems") #f #f 3140 9 3140 42 ("assv" "%%get-walk-problem-location" "%%get-walk-location-unit-locator" "problem" "lambda" "partition" "jazz:partition" "problems")}
      {Lisp-Entry "partition-walk-problems-declaration" define () ("problems") #f #f 3147 9 3147 49 ("assoc" "%%get-walk-problem-location" "%%get-walk-location-declaration-locator" "%%symbol->string" "problem" "lambda" "partition" "jazz:partition" "problems")}
      {Lisp-Entry "parse-modifiers" define () ("walker" "resume" "declaration" "infos" "rest") #f #f 3159 9 3159 29 ("%%cdar" "%%cons" "%%reverse" "values" "%%apply" "res" "lp" "modifiers" "let" "walk-error" "jazz:walk-error" "lambda" "=>" "%%eq?" "to" "from" "names" "get-modifier" "%%car" "source-code" "jazz:source-code" "%%pair?" "and" "if" "ls" "skip-modifiers" "%%cdr" "else" "%%caar" "%%memq" "%%null?" "cond" "x" "is-modifier?" "define" "rest" "infos" "declaration" "resume" "walker")}
      {Lisp-Entry "parse-unit-declaration" define () ("partial-form") #f #f 3193 9 3193 36 ("new-unit-declaration" "jazz:new-unit-declaration" "error" "jazz:error" "%%neq?" "requested-unit-name" "jazz:requested-unit-name" "access" "name" "%%desourcify" "filter-features" "jazz:filter-features" "listify" "jazz:listify" "map" "append" "set!" "require" "%%eq?" "%%pair?" "and" "expr" "lambda" "for-each" "requires" "body" "collect-requires" "%%cdr" "%%cddr" "%%cadr" "public" "protected" "%%memq" "if" "%%car" "source-code" "jazz:source-code" "first" "let" "proc" "rest" "parse" "define" "partial-form")}
      {Lisp-Entry "parse-module" define () ("partial-form") #f #f 3222 9 3222 26 ("%%symbol?" "%%assert" "%%cddr" "body" "%%cadr" "dialect-name" "name" "access" "receive" "%%cdr" "values" "public" "protected" "%%memq" "if" "%%car" "source-code" "jazz:source-code" "first" "let" "rest" "parse-modifiers" "define" "partial-form")}
      {Lisp-Entry "parse-script" define () ("partial-form") #f #f 3240 9 3240 26 ("values" "%%cdr" "body" "%%car" "source-code" "jazz:source-code" "dialect-name" "let" "partial-form")}
      {Lisp-Entry "parse-module-invoice" define () ("specification") #f #f 3247 9 3247 34 ("%%reverse" "values" "%%cdar" "begin" "%%caar" "%%eq?" "if" "%%cons" "set!" "%%not" "and" "%%while" "autoload" "only" "phase" "load" "version" "%%cdr" "scan" "%%car" "name" "let" "error" "jazz:error" "%%pair?" "%%assertion" "specification")}
      {Lisp-Entry "parse-module-declaration" define () ("partial-form") #f #f 3287 9 3287 38 ("walk-module-declaration" "jazz:walk-module-declaration" "dialect-walker" "jazz:dialect-walker" "walker" "require-dialect" "jazz:require-dialect" "dialect" "load-dialect-invoice" "jazz:load-dialect-invoice" "dialect-invoice" "let*" "new-walk-context" "jazz:new-walk-context" "walk-context" "jazz:walk-context" "parameterize" "error" "jazz:error" "%%neq?" "requested-unit-name" "jazz:requested-unit-name" "and" "if" "parse-module" "jazz:parse-module" "body" "dialect-name" "access" "name" "receive" "partial-form")}
      {Lisp-Entry "walk-module-declaration" define () ("walker" "actual" "name" "access" "dialect-name" "dialect-invoice" "body") #f #f 3298 9 3298 37 ("validate-walk-problems" "jazz:validate-walk-problems" "walker-environment" "jazz:walker-environment" "%%cons" "walk-declarations" "jazz:walk-declarations" "%%set-module-declaration-walker" "add-module-import" "jazz:add-module-import" "%%when" "new-module-declaration" "jazz:new-module-declaration" "or" "declaration" "let" "body" "dialect-invoice" "dialect-name" "access" "name" "actual" "walker")}
      {Lisp-Entry "walk-module-export" define () ("walker" "export") #f #f 3309 9 3309 32 ("new-autoload-reference" "jazz:new-autoload-reference" "new-export-reference" "jazz:new-export-reference" "symbol" "lambda" "map" "%%not" "if" "new-export-invoice" "jazz:new-export-invoice" "new-module-reference" "jazz:new-module-reference" "module-reference" "let" "parse-module-invoice" "jazz:parse-module-invoice" "module-autoload" "module-only" "module-version" "module-phase" "module-load" "module-name" "receive" "export" "walker")}
      {Lisp-Entry "expand-module-source" define () ("partial-form") #f #f 3328 9 3328 34 ("walk-module" "jazz:walk-module" "emit-declaration" "jazz:emit-declaration" "partial-form")}
      {Lisp-Entry "expand-script-source" define () ("partial-form") #f #f 3332 9 3332 34 ("walk-script" "jazz:walk-script" "emit-declaration" "jazz:emit-declaration" "partial-form")}
      {Lisp-Entry "rename-identifier-conflicts" define () ("expressions" "environment") #f #f 3336 9 3336 41 ("list" "or" "%%cdr" "symbol->string" "generate-symbol" "jazz:generate-symbol" "%%set-symbol-binding-gensym" "%%get-symbol-binding-gensym" "Variable" "jazz:Variable" "not" "and" "eq?" "same?" "binding" "found?" "%%car" "ls" "lp2" "pair?" "e" "lp1" "let" "%%get-lexical-binding-name" "unwrap-syntactic-closure" "sym" "%%get-reference-binding" "var" "let*" "Binding-Reference" "jazz:Binding-Reference" "%%is?" "cond" "child-seed" "env" "seed" "x" "lambda" "tree-fold-list" "jazz:tree-fold-list" "environment" "expressions")}
      {Lisp-Entry "walk-module" define () ("partial-form") #f #f 3374 9 3374 25 ("%%set-namespace-declaration-body" "rename-identifier-conflicts" "jazz:rename-identifier-conflicts" "validate-walk-problems" "jazz:validate-walk-problems" "walk-namespace" "jazz:walk-namespace" "walker-environment" "jazz:walker-environment" "%%cons" "environment" "set-catalog-entry" "jazz:set-catalog-entry" "walk-module-declaration" "jazz:walk-module-declaration" "let" "lambda" "call-with-catalog-entry-lock" "jazz:call-with-catalog-entry-lock" "declaration" "valid-catalog-entry" "jazz:valid-catalog-entry" "actual" "resume" "dialect-walker" "jazz:dialect-walker" "walker" "require-dialect" "jazz:require-dialect" "dialect" "load-dialect-invoice" "jazz:load-dialect-invoice" "dialect-invoice" "let*" "new-walk-context" "jazz:new-walk-context" "walk-context" "jazz:walk-context" "parameterize" "error" "jazz:error" "%%neq?" "requested-unit-name" "jazz:requested-unit-name" "and" "if" "parse-module" "jazz:parse-module" "body" "dialect-name" "access" "name" "receive" "partial-form")}
      {Lisp-Entry "walk-script" define () ("partial-form") #f #f 3397 9 3397 25 ("%%set-namespace-declaration-body" "rename-identifier-conflicts" "jazz:rename-identifier-conflicts" "validate-walk-problems" "jazz:validate-walk-problems" "walk-namespace" "jazz:walk-namespace" "walker-environment" "jazz:walker-environment" "%%cons" "environment" "public" "walk-module-declaration" "jazz:walk-module-declaration" "declaration" "resume" "dialect-walker" "jazz:dialect-walker" "walker" "require-dialect" "jazz:require-dialect" "dialect" "load-dialect-invoice" "jazz:load-dialect-invoice" "dialect-invoice" "let*" "new-walk-context" "jazz:new-walk-context" "walk-context" "jazz:walk-context" "parameterize" "parse-script" "jazz:parse-script" "body" "dialect-name" "receive" "script" "gensym" "name" "let" "partial-form")}
      {Lisp-Entry "cond-expand" define () ("form-src" "cont") #f #f 3414 9 3414 25 ("begin" "else" "feature-satisfied?" "jazz:feature-satisfied?" "feature-requirement" "%%desourcify" "%%symbol?" "%%not" "or" "clause" "error" "jazz:error" "%%null?" "%%cdr" "scan" "iter" "let" "cond-expand" "%%car" "%%eq?" "source-code" "jazz:source-code" "%%pair?" "and" "if" "cont" "form-src")}
      {Lisp-Entry "walk-namespace" define () ("walker" "resume" "declaration" "environment" "form-list") #f #f 3434 9 3434 28 ("queue-list" "jazz:queue-list" "walk" "jazz:walk" "enqueue" "jazz:enqueue" "%%when" "expr?" "expr-src" "cond-expand" "jazz:cond-expand" "continuation-capture" "form-src" "lambda" "for-each" "new-queue" "jazz:new-queue" "queue" "let" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "load-dialect-invoice" define () ("dialect-name") #f #f 3447 9 3447 34 ("syntax" "outline-module" "jazz:outline-module" "new-import-invoice" "jazz:new-import-invoice" "core" "%%eq?" "error" "jazz:error" "%%symbol?" "%%not" "if" "dialect-name")}
      {Lisp-Entry "emit-module-inclusions" define () ("module-declaration") #f #f 3460 9 3460 36 ("expand-referenced-declaration" "jazz:expand-referenced-declaration" "lambda" "map" "%%get-module-declaration-inclusions" "enqueue" "jazz:enqueue" "queue-list" "jazz:queue-list" "%%not" "%%when" "get-declaration-inclusions" "jazz:get-declaration-inclusions" "for-each" "declaration" "collect-declarations" "new-queue" "jazz:new-queue" "queue" "let" "%%cdr" "%%car" "%%get-lexical-binding-name" "%%eq?" "%%null?" "if" "lst" "name" "find-name" "define" "module-declaration")}
      {Lisp-Entry "emit-module-literals" define () ("module-declaration") #f #f 3484 9 3484 34 ("%%get-module-declaration-walker-literals" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" ",name" "define" "%%cdr" "value" "%%car" "name" "let" "info" "lambda" "map" "module-declaration")}
      {Lisp-Entry "emit-module-variables" define () ("module-declaration") #f #f 3492 9 3492 35 ("%%get-module-declaration-walker-variables" "queue-list" "jazz:queue-list" ",value" ",symbol" "define-variable" "jazz:define-variable" "%%cdr" "value" "%%car" "symbol" "let" "variable" "lambda" "map" "module-declaration")}
      {Lisp-Entry "emit-module-autoloads" define () ("module-declaration" "environment") #f #f 3500 9 3500 35 ("%%cadr" "%%symbol->string" "%%string<?" "y" "x" "queue-list" "jazz:queue-list" "sort" "jazz:sort" "%%get-module-declaration-walker-autoloads" "emit-binding-reference" "jazz:emit-binding-reference" "sourcified-form" "jazz:sourcified-form" "set!" "%%get-declaration-toplevel" "%%get-declaration-locator" "load-unit" "jazz:load-unit" "begin" "if" "loaded?" ",locator" "define" "enqueue" "jazz:enqueue" "%%table-set!" "%%table-ref" "%%not" "%%when" "autoload-locator" "jazz:autoload-locator" "locator" "resolve-binding" "jazz:resolve-binding" "referenced-declaration" "autoload-declaration" "lambda" "for-each" "eq?" "test:" "%%make-table" "locators" "new-queue" "jazz:new-queue" "queue" "let" "environment" "module-declaration")}
      {Lisp-Entry "emit-module-registration" define () ("declaration" "environment") #f #f 3521 9 3521 38 ("%%car" "%%cons" "if" "runtime-export" "jazz:runtime-export" "export" "Autoload-Declaration" "jazz:Autoload-Declaration" "%%is?" "%%get-declaration-toplevel" "%%eq?" "or" "decl" "name" "public-access" "jazz:public-access" "%%get-access-lookup" "iterate-table-safe" "jazz:iterate-table-safe" "%%get-module-declaration-walker" "walker" "%%symbol->string" "%%string<?" "y" "x" "queue-list" "jazz:queue-list" "sort" "jazz:sort" "%%get-module-declaration-exports" "%%get-module-invoice-name" "enqueue" "jazz:enqueue" "%%not" "and" "%%get-export-invoice-autoload" "autoload" "%%get-module-invoice-only" "only" "syntax" "%%get-module-invoice-phase" "%%neq?" "%%when" "module-invoice" "lambda" "for-each" "new-queue" "jazz:new-queue" "queue" "let" "%%get-declaration-access" "%%get-lexical-binding-name" "register-module" "jazz:register-module" "environment" "declaration")}
      {Lisp-Entry "runtime-export" generic/specific () ("declaration") ("jazz:Walker~virtual-runtime") #f 3545 30 3545 49 ("declaration")}
      {Lisp-Entry "runtime-export" generic/specific () ("declaration") ("jazz:Walker") #f 3548 21 3548 40 ("else" "%%get-declaration-toplevel" "%%cons" "resolve-binding" "jazz:resolve-binding" "referenced-declaration" "let" "Autoload-Declaration" "jazz:Autoload-Declaration" "%%get-declaration-locator" "Export-Declaration" "jazz:Export-Declaration" "%%is?" "cond" "declaration")}
      {Lisp-Entry "walker-bindings" generic/specific () () ("jazz:Walker~virtual-runtime") #f 3564 30 3564 50 ()}
      {Lisp-Entry "walker-bindings" generic/specific () () ("jazz:Walker") #f 3567 21 3567 41 ("core" "get-dialect" "jazz:get-dialect" "%%get-dialect-bindings")}
      {Lisp-Entry "walker-environment" generic/specific () () ("jazz:Walker~virtual-runtime") #f 3571 30 3571 53 ()}
      {Lisp-Entry "walker-environment" generic/specific () () ("jazz:Walker") #f 3574 21 3574 44 ("walker" "walker-bindings" "jazz:walker-bindings" "new-walk-frame" "jazz:new-walk-frame" "%%list")}
      {Lisp-Entry "walk-declaration" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Walker~virtual-runtime") #f 3589 30 3589 51 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-declaration" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Walker") #f 3592 21 3592 42 ("else" "walk-define-local-syntax-declaration" "jazz:walk-define-local-syntax-declaration" "define-local-syntax" "walk-define-syntax-declaration" "jazz:walk-define-syntax-declaration" "define-syntax" "walk-syntax-declaration" "jazz:walk-syntax-declaration" "syntax" "walk-local-macro-declaration" "jazz:walk-local-macro-declaration" "local-macro" "walk-macro-declaration" "jazz:walk-macro-declaration" "macro" "walk-native-syntax-declaration" "jazz:walk-native-syntax-declaration" "native-syntax" "walk-native-declaration" "jazz:walk-native-declaration" "native" "walk-import-declaration" "jazz:walk-import-declaration" "import" "walk-export-declaration" "jazz:walk-export-declaration" "export" "walker" "walk-require-declaration" "jazz:walk-require-declaration" "require" "case" "%%car" "first" "let" "source-code" "jazz:source-code" "%%pair?" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-declarations" define () ("walker" "resume" "declaration" "environment" "forms") #f #f 3610 9 3610 31 ("walk-declaration" "jazz:walk-declaration" "source-code" "jazz:source-code" "%%cdr" "begin-form?" "jazz:begin-form?" "if" "expand-macros" "jazz:expand-macros" "expansion" "let" "%%when" "expr?" "expr" "cond-expand" "jazz:cond-expand" "continuation-capture" "form-src" "lambda" "for-each" "walk" "define" "forms" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "add-declaration-child" define () ("walker" "resume" "namespace-declaration" "child") #f #f 3627 9 3627 35 ("public-access" "jazz:public-access" "private" "%%get-declaration-access" "%%neq?" "private-access" "jazz:private-access" "%%get-access-lookup" "%%table-set!" "%%get-namespace-declaration-children" "enqueue" "jazz:enqueue" "find-child-declaration" "jazz:find-child-declaration" "%%not" "%%when" "%%get-lexical-binding-name" "name" "let" "child" "namespace-declaration" "resume" "walker")}
      {Lisp-Entry "require-declaration" define () ("namespace-declaration" "name") #f #f 3653 9 3653 33 ("error" "jazz:error" "%%assertion" "find-declaration" "jazz:find-declaration" "declaration" "let" "name" "namespace-declaration")}
      {Lisp-Entry "find-declaration" define () ("namespace-declaration" "name") #f #f 3659 9 3659 30 ("private-access" "jazz:private-access" "%%get-access-lookup" "%%table-ref" "name" "namespace-declaration")}
      {Lisp-Entry "find-child-declaration" define () ("namespace-declaration" "name") #f #f 3663 9 3663 36 ("%%get-namespace-declaration-children" "queue-list" "jazz:queue-list" "%%get-lexical-binding-name" "%%eq?" "decl" "lambda" "find-if" "jazz:find-if" "name" "namespace-declaration")}
      {Lisp-Entry "begin-form?" define () ("form") #f #f 3669 9 3669 25 ("begin" "%%car" "%%eq?" "source-code" "jazz:source-code" "%%pair?" "and" "form")}
      {Lisp-Entry "define-form?" define () ("form") #f #f 3674 9 3674 26 ("define" "%%car" "%%eq?" "source-code" "jazz:source-code" "%%pair?" "and" "form")}
      {Lisp-Entry "register-autoload-declaration" define () ("module-declaration" "autoload-declaration") #f #f 3684 9 3684 43 ("%%cons" "%%set-module-declaration-walker-autoloads" "%%memq" "%%not" "%%when" "%%get-module-declaration-walker-autoloads" "declarations" "let" "autoload-declaration" "module-declaration")}
      {Lisp-Entry "lookup-reference" define () ("walker" "resume" "declaration" "environment" "symbol") #f #f 3695 9 3695 30 ("walk-unresolved" "jazz:walk-unresolved" "lookup-symbol" "jazz:lookup-symbol" "or" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Expression" define-class () () ("class runtime") #f 3705 27 3705 42 ()}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Expression~virtual-runtime") #f 3708 30 3708 50 ("environment" "declaration")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Expression") #f 3711 21 3711 41 ("expression" "error" "jazz:error" "environment" "declaration")}
      {Lisp-Entry "emit-call" generic/specific () ("arguments" "declaration" "environment") ("jazz:Expression~virtual-runtime") #f 3715 30 3715 44 ("environment" "declaration" "arguments")}
      {Lisp-Entry "emit-call" generic/specific () ("arguments" "declaration" "environment") ("jazz:Expression") #f 3718 21 3718 35 ("Any" "jazz:Any" "codes-forms" "jazz:codes-forms" "expression" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "new-code" "jazz:new-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Expression~virtual-runtime") #f 3725 30 3725 50 ("s" "k" "f")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Expression") #f 3728 21 3728 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "emit-expressions" define () ("expressions" "declaration" "environment") #f #f 3732 9 3732 30 ("emit-expression" "jazz:emit-expression" "expression" "lambda" "map" "environment" "declaration" "expressions")}
      {Lisp-Entry "fold-expressions" define () ("expressions" "f" "k" "s" "seed") #f #f 3738 9 3738 30 ("%%cdr" "fold-expressions" "jazz:fold-expressions" "%%car" "fold-expression" "jazz:fold-expression" "%%null?" "if" "seed" "s" "k" "f" "expressions")}
      {Lisp-Entry "tree-fold-list" define () ("ls" "down" "up" "here" "seed" "environment") #f #f 3745 9 3745 28 ("car" "tree-fold" "jazz:tree-fold" "cdr" "tree-fold-list" "jazz:tree-fold-list" "null?" "if" "environment" "seed" "here" "up" "down" "ls")}
      {Lisp-Entry "Binding-Reference" define-class () () ("class runtime") #f 3759 27 3759 49 ()}
      {Lisp-Entry "new-binding-reference" define () ("symbol-src" "binding") #f #f 3762 9 3762 35 ("Binding-Reference" "jazz:Binding-Reference" "allocate-binding-reference" "jazz:allocate-binding-reference" "binding" "symbol-src")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Binding-Reference") #f 3766 21 3766 41 ("%%get-expression-source" "expression" "%%get-reference-binding" "emit-binding-reference" "jazz:emit-binding-reference" "sourcify-code" "jazz:sourcify-code" "environment" "declaration")}
      {Lisp-Entry "emit-call" generic/specific () ("arguments" "declaration" "environment") ("jazz:Binding-Reference") #f 3771 21 3771 35 ("%%get-expression-source" "expression" "%%get-reference-binding" "emit-binding-call" "jazz:emit-binding-call" "sourcify-code" "jazz:sourcify-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Binding-Reference") #f 3776 21 3776 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "Reference-Reification" define-class () () ("class runtime") #f 3788 27 3788 53 ()}
      {Lisp-Entry "new-reference-reification" define () ("source" "reference" "resolver") #f #f 3791 9 3791 39 ("Reference-Reification" "jazz:Reference-Reification" "allocate-reference-reification" "jazz:allocate-reference-reification" "resolver" "reference" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Reference-Reification") #f 3795 21 3795 41 ("Any" "jazz:Any" ",serialization" "emit-expression" "jazz:emit-expression" "%%get-code-form" "new-runtime-reference" "jazz:new-runtime-reference" "new-code" "jazz:new-code" "serialization" "Binding-Reference" "jazz:Binding-Reference" "%%assert" "%%get-lambda-body" "%%get-body-expressions" "%%get-reference-reification-resolver" "resolver" "%%cdr" "%%table-ref" "public-access" "jazz:public-access" "%%get-access-lookup" "imported" "%%get-module-invoice-module" "imported-module-declaration" "%%car" "module-invoice" "%%null?" "%%get-module-declaration-imports" "scan" "iter" "symbol" ",import" "find-import" "import" "%%get-lexical-binding-name" "%%get-declaration-locator" "module-private" "%%eq?" "Declaration" "jazz:Declaration" "%%is?" "%%get-reference-binding" "binding" "%%get-declaration-toplevel" "module" ",name" ",module-name" "module-public" "break-reference" "jazz:break-reference" "name" "module-name" "receive" "composite-reference?" "jazz:composite-reference?" "if" "expression" "%%get-reference-reification-reference" "reified-reference" "let" "reference" "determine-serialization" "define" "environment" "declaration")}
      {Lisp-Entry "Body" define-class () () ("class runtime") #f 3844 27 3844 36 ()}
      {Lisp-Entry "new-body" define () ("internal-defines" "expressions") #f #f 3847 9 3847 22 ("Body" "jazz:Body" "allocate-body" "jazz:allocate-body" "expressions" "internal-defines")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Body") #f 3851 21 3851 41 ("Any" "jazz:Any" "emit-expressions" "jazz:emit-expressions" "codes-forms" "jazz:codes-forms" "%%append" "new-code" "jazz:new-code" "%%cons" "augmented-environment" "frame" "lambda" "annotate-internal-defines" "jazz:annotate-internal-defines" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-body-expressions" "expressions" "expression" "%%get-body-internal-defines" "internal-defines" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Body") #f 3864 21 3864 41 ("%%get-body-expressions" "%%get-body-internal-defines" "fold-statements" "jazz:fold-statements" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Body") #f 3870 21 3870 35 ("%%get-body-internal-defines" "%%get-body-expressions" "tree-fold-list" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Internal-Define" define-class () () ("class runtime") #f 3891 27 3891 47 ()}
      {Lisp-Entry "new-internal-define" define () ("variable" "value") #f #f 3894 9 3894 33 ("Internal-Define" "jazz:Internal-Define" "allocate-internal-define" "jazz:allocate-internal-define" "value" "variable")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Internal-Define") #f 3898 21 3898 41 ("Any" "jazz:Any" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "emit-binding-symbol" "jazz:emit-binding-symbol" "define" "new-code" "jazz:new-code" "%%get-internal-define-value" "value" "expression" "%%get-internal-define-variable" "variable" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Internal-Define") #f 3908 21 3908 41 ("%%get-internal-define-value" "fold-statement" "jazz:fold-statement" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Internal-Define") #f 3914 21 3914 35 ("%%get-internal-define-value" "tree-fold" "jazz:tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Begin" define-class () () ("class runtime") #f 3932 27 3932 37 ()}
      {Lisp-Entry "new-begin" define () ("source" "expressions") #f #f 3935 9 3935 23 ("Begin" "jazz:Begin" "allocate-begin" "jazz:allocate-begin" "expressions" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Begin") #f 3939 21 3939 41 ("%%get-expression-source" "%%get-code-type" "sourcified-form" "jazz:sourcified-form" "begin" "new-code" "jazz:new-code" "emit-statements-code" "jazz:emit-statements-code" "code" "expression" "%%get-begin-expressions" "expressions" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Begin") #f 3948 21 3948 41 ("%%get-begin-expressions" "fold-statements" "jazz:fold-statements" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Begin") #f 3953 21 3953 35 ("%%get-begin-expressions" "tree-fold-list" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "emit-specialized-call" define-macro () () ("variable") #f 3971 22 3971 48 ()}
      {Lisp-Entry "emit-primitive-new-call" define-macro () () ("variable") #f 3972 22 3972 50 ()}
      {Lisp-Entry "emit-primitive-call" define-macro () () ("variable") #f 3973 22 3973 46 ()}
      {Lisp-Entry "emit-inlined-call" define-macro () () ("variable") #f 3974 22 3974 44 ()}
      {Lisp-Entry "Call" define-class () () ("class runtime") #f 3977 27 3977 36 ()}
      {Lisp-Entry "new-call" define () ("source" "operator" "arguments") #f #f 3980 9 3980 22 ("Call" "jazz:Call" "allocate-call" "jazz:allocate-call" "arguments" "operator" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Call") #f 3984 21 3984 41 ("%%get-expression-source" "emit-call" "jazz:emit-call" "emit-inlined-call" "jazz:emit-inlined-call" "emit-primitive-call" "jazz:emit-primitive-call" "emit-primitive-new-call" "jazz:emit-primitive-new-call" "emit-specialized-call" "jazz:emit-specialized-call" "or" "sourcify-code" "jazz:sourcify-code" "emit-expressions" "jazz:emit-expressions" "arguments-codes" "%%get-declaration-locator" "Declaration" "jazz:Declaration" "%%get-reference-binding" "binding" "Binding-Reference" "jazz:Binding-Reference" "%%class-is?" "if" "locator" "%%get-call-arguments" "arguments" "expression" "%%get-call-operator" "operator" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Call") #f 4003 21 4003 41 ("%%get-call-arguments" "fold-expressions" "jazz:fold-expressions" "%%get-call-operator" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Call") #f 4009 21 4009 35 ("%%get-call-arguments" "%%get-call-operator" "cons" "tree-fold-list" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Constant" define-class () () ("class runtime") #f 4028 27 4028 40 ()}
      {Lisp-Entry "new-constant" define () ("expansion" "type") #f #f 4031 9 4031 26 ("Constant" "jazz:Constant" "allocate-constant" "jazz:allocate-constant" "type" "expansion")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Constant") #f 4035 21 4035 41 ("%%get-expression-type" "expression" "%%get-constant-expansion" "new-code" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Constant") #f 4042 21 4042 41 ("%%get-constant-expansion" "expression" "s" "k" "f")}
      {Lisp-Entry "Assignment" define-class () () ("class runtime") #f 4056 27 4056 42 ()}
      {Lisp-Entry "new-assignment" define () ("binding" "value") #f #f 4059 9 4059 28 ("Assignment" "jazz:Assignment" "allocate-assignment" "jazz:allocate-assignment" "value" "binding")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Assignment") #f 4063 21 4063 41 ("%%get-assignment-value" "expression" "%%get-assignment-binding" "emit-binding-assignment" "jazz:emit-binding-assignment" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Assignment") #f 4067 21 4067 41 ("%%get-assignment-value" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Assignment") #f 4073 21 4073 35 ("%%get-assignment-value" "tree-fold" "jazz:tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Walk-Failed-Special" define-class () () ("class runtime") #f 4088 27 4088 51 ()}
      {Lisp-Entry "new-walk-failed-special" define () ("answer") #f #f 4091 9 4091 37 ("Walk-Failed-Special" "jazz:Walk-Failed-Special" "allocate-walk-failed" "jazz:allocate-walk-failed" "answer")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Walk-Failed-Special") #f 4095 21 4095 41 ("Boolean" "jazz:Boolean" "new-code" "jazz:new-code" "expression" "%%get-walk-failed-special-answer" "answer" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Walk-Failed-Special") #f 4103 21 4103 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "Analysis-Data" define-class () () ("class runtime") #f 4115 27 4115 45 ()}
      {Lisp-Entry "new-analysis-data" define () () #f #f 4118 9 4118 31 ("Analysis-Data" "jazz:Analysis-Data" "allocate-analysis-data" "jazz:allocate-analysis-data")}
      {Lisp-Entry "get-analysis-data" define () ("locator") #f #f 4125 9 4125 31 ("%%table-set!" "new-analysis-data" "jazz:new-analysis-data" "data" "let" "analysis-data" "jazz:analysis-data" "%%table-ref" "or" "locator")}
      {Lisp-Entry "emit-namespace-statements" define () ("statements" "declaration" "environment") #f #f 4137 9 4137 39 ("queue-list" "jazz:queue-list" "sourcified-form" "jazz:sourcified-form" "emit-expression" "jazz:emit-expression" "code" "emit-declaration" "jazz:emit-declaration" "enqueue" "jazz:enqueue" "Declaration" "jazz:Declaration" "%%class-is?" "if" "statement" "lambda" "for-each" "new-queue" "jazz:new-queue" "queue" "let" "environment" "declaration" "statements")}
      {Lisp-Entry "emit-statements-code" define () ("statements" "declaration" "environment") #f #f 4149 9 4149 34 ("new-code" "jazz:new-code" "sourcified-form" "jazz:sourcified-form" "%%get-code-type" "set!" "emit-expression" "jazz:emit-expression" "code" "emit-declaration" "jazz:emit-declaration" "Declaration" "jazz:Declaration" "%%class-is?" "if" "statement" "lambda" "map" "emited" "last-type" "let" "environment" "declaration" "statements")}
      {Lisp-Entry "fold-statement" define () ("statement" "f" "k" "s") #f #f 4162 9 4162 28 ("fold-expression" "jazz:fold-expression" "fold-declaration" "jazz:fold-declaration" "Declaration" "jazz:Declaration" "%%class-is?" "if" "s" "k" "f" "statement")}
      {Lisp-Entry "fold-statements" define () ("statements" "f" "k" "s" "seed") #f #f 4168 9 4168 29 ("%%cdr" "fold-statements" "jazz:fold-statements" "%%car" "fold-statement" "jazz:fold-statement" "%%null?" "if" "seed" "s" "k" "f" "statements")}
      {Lisp-Entry "walk" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4180 9 4180 18 ("walk-constant" "jazz:walk-constant" "else" "%%get-syntactic-closure-form" "%%get-syntactic-closure-environment" "append" "walk" "jazz:walk" "syntactic-closure?" "walk-form" "jazz:walk-form" "%%pair?" "walk-error" "jazz:walk-error" "%%null?" "walk-symbol" "jazz:walk-symbol" "identifier?" "cond" "source-code" "jazz:source-code" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-list" define () ("walker" "resume" "declaration" "environment" "form-list") #f #f 4194 9 4194 23 ("queue-list" "jazz:queue-list" "walk" "jazz:walk" "enqueue" "jazz:enqueue" "continuation-capture" "form" "lambda" "for-each" "new-queue" "jazz:new-queue" "queue" "let" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-body" define () ("walker" "resume" "declaration" "environment" "form-list") #f #f 4204 9 4204 23 ("queue-list" "jazz:queue-list" "map" "enqueue" "jazz:enqueue" "new-variable" "jazz:new-variable" "%%symbol?" "signature" "walk-error" "jazz:walk-error" "%%pair?" "%%assertion" "%%desourcify" "internal-body" "internal-define" "augmented-environment" "new-queue" "jazz:new-queue" "variables" "walk-list" "jazz:walk-list" "new-body" "jazz:new-body" "%%car" "%%eq?" "%%null?" "or" "scan" "iter" "expressions" "else" "defines" "%%cons" "define-form?" "jazz:define-form?" "error" "jazz:error" "%%neq?" "set!" "%%not" "substate" "sub" "lambda" "for-each" "state" "begin-form?" "jazz:begin-form?" "cond" "form" "process" "internal-defines" "walk" "jazz:walk" "new-internal-define" "jazz:new-internal-define" "Any" "jazz:Any" "walk-specifier" "jazz:walk-specifier" "if" "type" "let" "source-code" "jazz:source-code" "%%cdr" "parse-define" "jazz:parse-define" "parameters" "value" "specifier" "name" "receive" "variable" "form-src" "walk-internal-define" "define" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "parse-define" define () ("walker" "resume" "declaration" "rest") #f #f 4254 9 4254 26 (",@body" ",@specifier-list" ",parameters" "%%list" "specifier-list" "body" "%%desourcify" "parameters" "values" "specifier" "lambda" "%%cdr" "parse-specifier" "jazz:parse-specifier" "name" "let" "%%car" "source-code" "jazz:source-code" "%%symbol?" "if" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-quote" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4273 9 4273 24 ("walk-constant" "jazz:walk-constant" "Null" "jazz:Null" "quote" "new-constant" "jazz:new-constant" "%%null?" "if" "%%cadr" "expression" "strip-syntactic-closures" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-keyword" define () ("walker" "keyword") #f #f 4281 9 4281 26 ("Keyword" "jazz:Keyword" "new-constant" "jazz:new-constant" "keyword" "walker")}
      {Lisp-Entry "walk-enumerator" define () ("walker" "enumerator") #f #f 4285 9 4285 29 ("Symbol" "jazz:Symbol" "quote" "%%list" "new-constant" "jazz:new-constant" "enumerator" "walker")}
      {Lisp-Entry "walk-constant" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4289 9 4289 27 ("walk-literal/constant" "jazz:walk-literal/constant" "else" "Pair" "jazz:Pair" "scheme-pair-literal?" "jazz:scheme-pair-literal?" "Any" "jazz:Any" "#!void" "#!rest" "#!key" "#!optional" "%%eq?" "%%box?" "or" "Null" "jazz:Null" "%%null?" "Values" "jazz:Values" "%%values?" "F64Vector" "jazz:F64Vector" "%%f64vector?" "F32Vector" "jazz:F32Vector" "%%f32vector?" "U64Vector" "jazz:U64Vector" "%%u64vector?" "S64Vector" "jazz:S64Vector" "%%s64vector?" "U32Vector" "jazz:U32Vector" "%%u32vector?" "S32Vector" "jazz:S32Vector" "%%s32vector?" "U16Vector" "jazz:U16Vector" "%%u16vector?" "S16Vector" "jazz:S16Vector" "%%s16vector?" "U8Vector" "jazz:U8Vector" "%%u8vector?" "S8Vector" "jazz:S8Vector" "%%s8vector?" "Vector" "jazz:Vector" "%%vector?" "Symbol" "jazz:Symbol" ",form-src" "quote" "%%symbol?" "Number" "jazz:Number" "%%number?" "Flonum" "jazz:Flonum" "%%flonum?" "Fixnum" "jazz:Fixnum" "%%fixnum?" "Keyword" "jazz:Keyword" "%%keyword?" "String" "jazz:String" "%%string?" "Char" "jazz:Char" "%%char?" "Boolean" "jazz:Boolean" "new-constant" "jazz:new-constant" "%%boolean?" "cond" "source-code" "jazz:source-code" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "scheme-pair-literal?" define () ("form") #f #f 4345 9 4345 34 ("%%cdr" "%%car" "%%pair?" "and" "%%vector?" "%%symbol?" "%%number?" "%%keyword?" "%%string?" "%%char?" "%%boolean?" "%%null?" "or" "expr" "scheme-data?" "define" "form")}
      {Lisp-Entry "walk-literal/constant" define () ("walker" "resume" "declaration" "environment" "literal/constant") #f #f 4367 9 4367 35 ("lookup-reference" "jazz:lookup-reference" "new-constant" "jazz:new-constant" "identifier-name" "jazz:identifier-name" "reference-name" "jazz:reference-name" "composite-reference?" "jazz:composite-reference?" "class-of" "jazz:class-of" "%%get-category-identifier" "if" "literal-type" "%%set-cdr!" "%%get-module-declaration-walker-literals" "%%set-module-declaration-walker-literals" "info" "generate-global-symbol" "jazz:generate-global-symbol" "locator" "walk-error" "jazz:walk-error" "else" "%%cdr" "cons" "%%pair?" ",arg" "quote" "arg" "lambda" "map" ",constructor-reference" "%%desourcify" "require-literal-constructor" "jazz:require-literal-constructor" "%%car" "constructor-reference" "%%get-literal-arguments" "arguments" "%%get-literal-name" "name" "cond" "walk" "jazz:walk" "walker-environment" "jazz:walker-environment" "%%cons" "walk-literal/constant" "define" "Literal" "jazz:Literal" "%%is?" "literal?" "%%get-declaration-toplevel" "module-declaration" "let" "literal/constant" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "make-symbolic-chars" define () ("alist") #f #f 4402 9 4402 33 ("eq?" "test:" "%%cdr" "integer->char" "%%car" "%%cons" "pair" "lambda" "map" "%%list->table" "alist")}
      {Lisp-Entry "Symbolic-Chars" define () () #f #f 4410 8 4410 27 ("#xA9" "copyright" "#x7F" "delete" "#x7D" "close-brace" "#x7B" "open-brace" "#x60" "backquote" "#x5F" "underscore" "#x5E" "exponential" "#x5D" "close-bracket" "#x5C" "backslash" "#x5B" "open-bracket" "#x40" "at" "#x3F" "question-mark" "#x3B" "semi-colon" "#x3A" "colon" "#x2F" "slash" "#x2E" "period" "#x2D" "minus" "#x2C" "comma" "#x2B" "plus" "#x2A" "times" "#x29" "close-parenthesis" "#x28" "open-parenthesis" "#x27" "quote" "#x26" "ampersand" "#x23" "sharp" "#x22" "double-quote" "#x21" "exclamation-point" "#x20" "space" "#x1F" "down-arrow" "#x1E" "up-arrow" "#x1D" "right-arrow" "#x1C" "left-arrow" "#x1B" "escape" "#x0D" "return" "#x0C" "page-down" "#x0B" "page-up" "#x0A" "linefeed" "#x09" "tab" "#x08" "backspace" "#x05" "info" "#x04" "end" "#x03" "enter" "#x01" "home" "#x00" "zero" "make-symbolic-chars" "jazz:make-symbolic-chars")}
      {Lisp-Entry "symbolic-char" define () ("name") #f #f 4458 9 4458 27 ("Symbolic-Chars" "jazz:Symbolic-Chars" "%%table-ref" "name")}
      {Lisp-Entry "register-variable" define () ("declaration" "suffix" "value") #f #f 4467 9 4467 31 ("%%get-module-declaration-walker-variables" "enqueue" "jazz:enqueue" "%%cons" "variable" "generate-global-symbol" "jazz:generate-global-symbol" "symbol" "%%get-declaration-toplevel" "module-declaration" "let" "value" "suffix" "declaration")}
      {Lisp-Entry "walk-symbol" generic/specific () ("resume" "declaration" "environment" "symbol-src") ("jazz:Walker~virtual-runtime") #f 4480 30 4480 46 ("symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-symbol" generic/specific () ("resume" "declaration" "environment" "symbol-src") ("jazz:Walker") #f 4483 21 4483 37 ("walk-symbol-reference" "jazz:walk-symbol-reference" "else" "walker" "walk-enumerator" "jazz:walk-enumerator" "enumerator?" "jazz:enumerator?" "cond" "source-code" "jazz:source-code" "symbol" "let" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-setbang" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4491 9 4491 26 ("walk-symbol-assignment" "jazz:walk-symbol-assignment" "%%symbol?" "%%cddr" "%%car" "value" "%%cadr" "variable" "let" "%%desourcify" "walk-error" "jazz:walk-error" "3" "source-code" "jazz:source-code" "%%length" "%%fx=" "%%not" "if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "special-form-name?" define () ("symbol" "ls" "end") #f #f 4501 9 4501 32 ("cdr" "special-form-name?" "jazz:special-form-name?" "Special-Form" "jazz:Special-Form" "%%class-is?" "object?" "jazz:object?" "car" "walk-binding-lookup" "jazz:walk-binding-lookup" "binding" "let" "or" "eq?" "not" "pair?" "and" "end" "ls" "symbol")}
      {Lisp-Entry "lookup-symbol" define () ("walker" "resume" "declaration" "environment" "symbol-src") #f #f 4511 9 4511 27 ("lookup-analyse" "jazz:lookup-analyse" "analysis-mode?" "jazz:analysis-mode?" "register-autoload-declaration" "jazz:register-autoload-declaration" "module" "Declaration" "jazz:Declaration" "%%class-is?" "source-code" "jazz:source-code" "syntactic-closure-form" "%%get-syntactic-closure-environment" "syntactic-closure?" "walk-warning" "jazz:walk-warning" "%%get-declaration-locator" "referenced-locator" "deprecated" "%%get-declaration-compatibility" "%%eq?" "referenced-declaration" "validate-compatibility" "%%cdr" "%%car" "walk-binding-lookup" "jazz:walk-binding-lookup" "or" "%%pair?" "and" "env" "lp" "unwrap-syntactic-closure" "raw-symbol" "composite-reference?" "jazz:composite-reference?" "lookup" "walk-error" "jazz:walk-error" "new-module-reference" "jazz:new-module-reference" "%%get-declaration-toplevel" "new-autoload-declaration" "jazz:new-autoload-declaration" "Autoload-Declaration" "jazz:Autoload-Declaration" "%%is?" "if" "public-access" "jazz:public-access" "lookup-declaration" "jazz:lookup-declaration" "decl" "outline-module" "jazz:outline-module" "exported-module-reference" "let" "break-reference" "jazz:break-reference" "name" "module-name" "receive" "symbol" "lookup-composite" "define" "symbol-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "lookup-analyse" generic/specific () ("declaration" "symbol-src" "referenced-declaration") ("jazz:Walker~virtual-runtime") #f 4552 30 4552 49 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "lookup-analyse" generic/specific () ("declaration" "symbol-src" "referenced-declaration") ("jazz:Walker") #f 4555 21 4555 40 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "walk-symbol-reference" define () ("walker" "resume" "declaration" "environment" "symbol-src") #f #f 4564 9 4564 35 ("walk-free-reference" "jazz:walk-free-reference" "new-binding-reference" "jazz:new-binding-reference" "walk-binding-referenced" "jazz:walk-binding-referenced" "Variable" "jazz:Variable" "%%class-is?" "begin" "if" "lookup-symbol" "jazz:lookup-symbol" "binding" "let" "symbol-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-free-reference" generic/specific () ("resume" "declaration" "symbol-src") ("jazz:Walker~virtual-runtime") #f 4574 30 4574 54 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "walk-free-reference" generic/specific () ("resume" "declaration" "symbol-src") ("jazz:Walker") #f 4577 21 4577 45 ("walker" "walk-unresolved" "jazz:walk-unresolved" "symbol-src" "declaration" "resume")}
      {Lisp-Entry "walk-symbol-assignment" generic/specific () ("resume" "declaration" "environment" "symbol-src" "value") ("jazz:Walker~virtual-runtime") #f 4586 30 4586 57 ("value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-symbol-assignment" generic/specific () ("resume" "declaration" "environment" "symbol-src" "value") ("jazz:Walker") #f 4589 21 4589 48 ("walk-free-assignment" "jazz:walk-free-assignment" "walk" "jazz:walk" "new-assignment" "jazz:new-assignment" "walk-binding-validate-assignment" "jazz:walk-binding-validate-assignment" "begin" "if" "walker" "lookup-symbol" "jazz:lookup-symbol" "binding" "let" "value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-free-assignment" generic/specific () ("resume" "declaration" "symbol-src") ("jazz:Walker~virtual-runtime") #f 4598 30 4598 55 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "walk-free-assignment" generic/specific () ("resume" "declaration" "symbol-src") ("jazz:Walker") #f 4601 21 4601 46 ("walker" "walk-unresolved" "jazz:walk-unresolved" "symbol-src" "declaration" "resume")}
      {Lisp-Entry "walk-form" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Walker~virtual-runtime") #f 4610 30 4610 44 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-form" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Walker") #f 4613 21 4613 35 ("walk-call" "jazz:walk-call" "walk" "jazz:walk" "walk-binding-expand-form" "jazz:walk-binding-expand-form" "expansion" "walk-binding-expandable?" "jazz:walk-binding-expandable?" "walk-binding-walk-form" "jazz:walk-binding-walk-form" "walk-binding-walkable?" "jazz:walk-binding-walkable?" "if" "else" "and" "%%get-reference-binding" "ref" "Binding-Reference" "jazz:Binding-Reference" "Declaration" "jazz:Declaration" "Special-Form" "jazz:Special-Form" "%%class-is?" "or" "walker" "lookup-symbol" "jazz:lookup-symbol" "identifier?" "cond" "binding" "%%car" "source-code" "jazz:source-code" "procedure-expr" "let" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "expand-macros" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4644 9 4644 27 ("expand-macros" "jazz:expand-macros" "walk-binding-expand-form" "jazz:walk-binding-expand-form" "expansion" "%%symbol?" "%%car" "procedure-expr" "source-code" "jazz:source-code" "%%pair?" "%%not" "walk-binding-expandable?" "jazz:walk-binding-expandable?" "and" "if" "lookup-symbol" "jazz:lookup-symbol" "binding" "let" "symbol" "lookup-macro-form" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-call" define () ("walker" "resume" "declaration" "environment" "procedure-binding" "form-src") #f #f 4666 9 4666 23 ("walk-list" "jazz:walk-list" "walk" "jazz:walk" "lambda" "continuation-capture" "new-call" "jazz:new-call" "desourcify-all" "jazz:desourcify-all" "walk-binding-validate-call" "jazz:walk-binding-validate-call" "if" "%%cdr" "arguments" "source-code" "jazz:source-code" "%%car" "operator" "let" "form-src" "procedure-binding" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "validate-arguments" generic/specific () ("resume" "source-declaration" "declaration" "signature" "arguments" "form-src") ("jazz:Walker~virtual-runtime") #f 4678 30 4678 53 ("form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "validate-arguments" generic/specific () ("resume" "source-declaration" "declaration" "signature" "arguments" "form-src") ("jazz:Walker") #f 4681 21 4681 44 ("%%fx<" "walker" "walk-error" "jazz:walk-error" "%%fx>" "%%not" "and" "cond" "%%get-signature-named" "%%get-signature-optional" "%%not-null?" "or" "rest?" "%%get-lexical-binding-name" "name" "%%length" "passed" "%%get-signature-rest" "rest" "%%get-signature-mandatory" "mandatory" "let" "form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "walk-require-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4701 9 4701 38 ("listify" "jazz:listify" "add-module-require" "jazz:add-module-require" "require" "lambda" "load-unit" "jazz:load-unit" "for-each" "eval" "walk-for" "jazz:walk-for" "%%eq?" "%%when" "%%cdr" "filter-features" "jazz:filter-features" "requires" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-require" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4713 9 4713 26 ("new-begin" "jazz:new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-export-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4722 9 4722 37 ("add-module-export" "jazz:add-module-export" "export-invoice" "for-each" "filter-features" "jazz:filter-features" "export-invoices" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "walk-module-export" "jazz:walk-module-export" "export" "%%cdr" "new-export-reference" "jazz:new-export-reference" "symbol" "lambda" "map" "new-export-invoice" "jazz:new-export-invoice" "%%list" "if" "%%append" "module-exports" "%%assq" "symbols-exports" "assv" "symbol?" "jazz:partition" "partition" "let" "exports" "walk-exports" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-export" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4744 9 4744 25 ("new-begin" "jazz:new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-import-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4753 9 4753 37 ("add-module-import" "jazz:add-module-import" "%%get-lexical-binding-name" "load-unit" "jazz:load-unit" "%%get-module-invoice-module" "import-invoice" "for-each" "eval" "walk-for" "jazz:walk-for" "%%eq?" "%%when" "%%cdr" "filter-features" "jazz:filter-features" "import-invoices" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "let" "listify" "jazz:listify" "imports" "walk-imports" "new-export-reference" "jazz:new-export-reference" "symbol" "lambda" "map" "%%not" "if" "new-import-invoice" "jazz:new-import-invoice" "parse-module-invoice" "jazz:parse-module-invoice" "module-autoload" "module-only" "module-version" "module-phase" "module-load" "module-name" "receive" "walk-unresolved" "jazz:walk-unresolved" "error?:" "outline-module" "jazz:outline-module" "or" "name" "lookup-module" "jazz:lookup-module" "import" "walk-module-import" "jazz:walk-module-import" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-import" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4789 9 4789 25 ("new-begin" "jazz:new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "native-modifiers" define () () #f #f 4798 8 4798 29 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "native-keywords" define () () #f #f 4802 8 4802 28 ()}
      {Lisp-Entry "parse-native" define () ("walker" "resume" "declaration" "rest") #f #f 4806 9 4806 26 ("values" "%%null?" "%%assert" "specifier" "lambda" "%%cdr" "parse-specifier" "jazz:parse-specifier" "%%car" "name" "let" "native-modifiers" "jazz:native-modifiers" "parse-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-native-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4815 9 4815 37 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "new-export-declaration" "jazz:new-export-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "Any" "jazz:Any" "walk-specifier" "jazz:walk-specifier" "if" "type" "parse-exported-symbol" "jazz:parse-exported-symbol" "symbol" "%%cdr" "parse-native" "jazz:parse-native" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-native" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4826 9 4826 25 ("require-declaration" "jazz:require-declaration" "parse-exported-symbol" "jazz:parse-exported-symbol" "symbol" "%%cdr" "parse-native" "jazz:parse-native" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "native-syntax-modifiers" define () () #f #f 4838 8 4838 36 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "native-syntax-keywords" define () () #f #f 4842 8 4842 35 ()}
      {Lisp-Entry "parse-native-syntax" define () ("walker" "resume" "declaration" "rest") #f #f 4846 9 4846 33 ("values" "%%null?" "%%assert" "specifier" "lambda" "%%cdr" "parse-specifier" "jazz:parse-specifier" "%%car" "name" "let" "native-syntax-modifiers" "jazz:native-syntax-modifiers" "parse-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-native-syntax-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4855 9 4855 44 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "new-export-syntax-declaration" "jazz:new-export-syntax-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "Any" "jazz:Any" "walk-specifier" "jazz:walk-specifier" "if" "type" "parse-exported-symbol" "jazz:parse-exported-symbol" "symbol" "%%cdr" "parse-native-syntax" "jazz:parse-native-syntax" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-native-syntax" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4866 9 4866 32 ("require-declaration" "jazz:require-declaration" "parse-exported-symbol" "jazz:parse-exported-symbol" "symbol" "%%cdr" "parse-native-syntax" "jazz:parse-native-syntax" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "macro-modifiers" define () () #f #f 4878 8 4878 28 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-macro" define () ("walker" "resume" "declaration" "rest") #f #f 4883 9 4883 25 ("values" "parameters" "Any" "jazz:Any" "type" "%%desourcify" "name" "%%cdr" "body" "%%car" "source-code" "jazz:source-code" "signature" "let*" "macro-modifiers" "jazz:macro-modifiers" "parse-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-macro-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4893 9 4893 36 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-macro-declaration" "jazz:new-macro-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "walk-parameters" "jazz:walk-parameters" "signature" "let" "source-code" "jazz:source-code" "%%cdr" "parse-macro" "jazz:parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-macro" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4903 9 4903 24 ("%%set-declaration-source" "walk-body" "jazz:walk-body" "%%set-macro-declaration-body" "%%set-macro-declaration-signature" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "require-declaration" "jazz:require-declaration" "new-declaration" "let*" "source-code" "jazz:source-code" "%%cdr" "parse-macro" "jazz:parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "register-local-macro" define () ("module-declaration" "name" "macro") #f #f 4919 9 4919 34 ("%%get-module-declaration-local-macros" "%%table-set!" "macro" "name" "module-declaration")}
      {Lisp-Entry "walk-local-macro-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4923 9 4923 42 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "emit-signature" "jazz:emit-signature" "eval" "%%cons" "let" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-declaration-locator" "register-local-macro" "jazz:register-local-macro" "%%set-declaration-source" "%%set-local-macro-declaration-body" "%%set-local-macro-declaration-signature" "walk-body" "jazz:walk-body" "walked-body" "new-local-macro-declaration" "jazz:new-local-macro-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "let*" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "source-code" "jazz:source-code" "%%cdr" "parse-macro" "jazz:parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-local-macro" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4942 9 4942 30 ("require-declaration" "jazz:require-declaration" "source-code" "jazz:source-code" "%%cdr" "parse-macro" "jazz:parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "syntax-modifiers" define () () #f #f 4952 8 4952 29 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "parse-syntax" define () ("walker" "resume" "declaration" "rest") #f #f 4957 9 4957 26 ("values" "parameters" "Any" "jazz:Any" "type" "%%desourcify" "name" "%%cdr" "body" "%%car" "source-code" "jazz:source-code" "signature" "let*" "syntax-modifiers" "jazz:syntax-modifiers" "parse-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-syntax-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4967 9 4967 37 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-syntax-declaration" "jazz:new-syntax-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "walk-parameters" "jazz:walk-parameters" "signature" "let" "source-code" "jazz:source-code" "%%cdr" "parse-syntax" "jazz:parse-syntax" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-syntax" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4977 9 4977 25 ("%%set-declaration-source" "walk-body" "jazz:walk-body" "%%set-syntax-declaration-body" "%%set-syntax-declaration-signature" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "require-declaration" "jazz:require-declaration" "new-declaration" "let*" "source-code" "jazz:source-code" "%%cdr" "parse-syntax" "jazz:parse-syntax" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define-syntax-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 4993 9 4993 44 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "Any" "jazz:Any" "new-define-syntax-declaration" "jazz:new-define-syntax-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "%%car" "name" "let" "source-code" "jazz:source-code" "%%cdr" "syntax-modifiers" "jazz:syntax-modifiers" "parse-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define-syntax" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 5004 9 5004 32 ("%%set-declaration-source" "walk-body" "jazz:walk-body" "%%set-syntax-declaration-body" "%%set-syntax-declaration-signature" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "require-declaration" "jazz:require-declaration" "new-declaration" "body" "%%car" "name" "let*" "source-code" "jazz:source-code" "%%cdr" "syntax-modifiers" "jazz:syntax-modifiers" "parse-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define-local-syntax-declaration" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 5022 9 5022 50 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "car" "eval" "new-define-local-syntax-form" "jazz:new-define-local-syntax-form" "else" "cons" "x" "=>" "jazz" "cond" "core" "scheme" "get-dialect" "jazz:get-dialect" "%%get-dialect-bindings" "new-walk-frame" "jazz:new-walk-frame" "%%list" "env" "%%get-declaration-toplevel" "current-unit-name" "%%cons" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-declaration-locator" "register-local-macro" "jazz:register-local-macro" "%%set-declaration-source" "%%set-syntax-declaration-body" "walk-body" "jazz:walk-body" "walked-body" "Any" "jazz:Any" "new-define-local-syntax-declaration" "jazz:new-define-local-syntax-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "let*" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "body" "%%car" "name" "let" "source-code" "jazz:source-code" "%%cdr" "syntax-modifiers" "jazz:syntax-modifiers" "parse-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define-local-syntax" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 5059 9 5059 38 ("%%car" "require-declaration" "jazz:require-declaration" "source-code" "jazz:source-code" "%%cdr" "syntax-modifiers" "jazz:syntax-modifiers" "parse-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-let-syntax" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 5069 9 5069 29 ("walk-list" "jazz:walk-list" "new-begin" "jazz:new-begin" "new-define-syntax-form" "jazz:new-define-syntax-form" "%%get-code-form" "eval" "expander" "walk" "jazz:walk" "emit-expression" "jazz:emit-expression" "expander-src" "value" "%%car" "source-code" "jazz:source-code" "name" "binding" "lambda" "map" "append" "augmented-environment" "let" "walk-error" "jazz:walk-error" "%%pair?" "%%null?" "or" "%%assertion" "%%cddr" "body" "bindings" "unwrap-syntactic-closure" "%%cadr" "bindings-src" "let*" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-letrec-syntax" define () ("." "args") #f #f 5093 9 5093 32 ("walk-let-syntax" "jazz:walk-let-syntax" "apply" "args")}
      {Lisp-Entry "walk-reference" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 5102 9 5102 28 ("walk" "jazz:walk" "new-reference-reification" "jazz:new-reference-reification" ",reference-src" "lambda" "resolver" "source-code" "jazz:source-code" "%%cadr" "reference-src" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-parameters" define () ("walker" "resume" "declaration" "environment" "parameters" "extended?" "walk?") #f #f 5118 9 5118 29 ("values" "queue-list" "jazz:queue-list" "append" "new-signature" "jazz:new-signature" "signature" "List" "jazz:List" "new-rest-parameter" "jazz:new-rest-parameter" "parameter-expression" "%%symbol?" "%%null?" "new-named-parameter" "jazz:new-named-parameter" "keyword-parameter" "%%keyword->string" "%%string->symbol" "%%eq?" "%%cddr" "new-optional-parameter" "jazz:new-optional-parameter" "optional-parameter" "default" "1" "%%length" "%%fx=" "new-parameter" "jazz:new-parameter" "positional-parameter" "walk-specifier" "jazz:walk-specifier" "type" "rest" "lambda" "parse-specifier" "jazz:parse-specifier" "%%cdr" "enqueue" "jazz:enqueue" "walk" "jazz:walk" "Any" "jazz:Any" "new-dynamic-parameter" "jazz:new-dynamic-parameter" "dynamic-parameter" "%%cadr" "variable" "specifier->name" "jazz:specifier->name" "code" "specifier" "memq" "desourcify" "jazz:desourcify" "walk-error" "jazz:walk-error" "%%not" "parameter-src" "let*" "case" "section" "allowed?" "positional" "optional" "else" "keyword" "%%keyword?" "dynamic" "specifier?" "jazz:specifier?" "or" "cond" "%%car" "source-code" "jazz:source-code" "first" "%%pair?" "if" "parameter" "parameter-section" "%%cons" "set!" "%%when" "expression" "augment-environment" "sections" "scan" "iterate-parameters" "define" "keywords" "optionals" "positionals" "new-queue" "jazz:new-queue" "dynamics" "augmented-environment" "let" "walk?" "extended?" "parameters" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "emit-signature-casts" define () ("signature" "source-declaration" "environment") #f #f 5224 9 5224 34 ("queue-list" "jazz:queue-list" "%%get-signature-named" "%%get-signature-optional" "%%get-signature-positional" "for-each" "enqueue" "jazz:enqueue" "new-queue" "jazz:new-queue" "set!" "%%not" "begin" "emit-binding-reference" "jazz:emit-binding-reference" "emit-parameter-cast" "jazz:emit-parameter-cast" "cast" "Any" "jazz:Any" "%%neq?" "and" "if" "%%get-lexical-binding-type" "type" "parameter" "process" "define" "queue" "let" "environment" "source-declaration" "signature")}
      {Lisp-Entry "emit-signature" define () ("signature" "declaration" "environment") #f #f 5246 9 5246 28 ("queue-list" "jazz:queue-list" "#!rest" "#!key" "#!optional" "%%null?" "%%not" "%%when" "for-each" "emit-parameter" "jazz:emit-parameter" "enqueue" "jazz:enqueue" "parameter" "emit" "define" "new-queue" "jazz:new-queue" "queue" "%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "let" "environment" "declaration" "signature")}
      {Lisp-Entry "walk-walk-failed" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 5272 9 5272 30 ("new-walk-failed-special" "jazz:new-walk-failed-special" "walk" "jazz:walk" "*raise-walk-problems?*" "jazz:*raise-walk-problems?*" "parameterize" "Error" "jazz:Error" "is?" "jazz:is?" "%%is?" "if" "%%object?" "and" "exc" "lambda" "with-exception-filter" "jazz:with-exception-filter" "answer" "error" "jazz:error" "else" "Walk-Error" "jazz:Walk-Error" ":error" "Walk-Warning" "jazz:Walk-Warning" ":warning" "%%car" "%%eq?" "Walk-Problem" "jazz:Walk-Problem" "%%null?" "cond" "problem-subclass" "%%cddr" "rest" "%%desourcify" "%%cadr" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Catalog" define () () #f #f 5305 8 5305 20 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "get-catalog" define () () #f #f 5309 9 5309 25 ("Catalog" "jazz:Catalog")}
      {Lisp-Entry "get-catalog-entry" define () ("unit-name") #f #f 5313 9 5313 31 ("Catalog" "jazz:Catalog" "%%table-ref" "unit-name")}
      {Lisp-Entry "set-catalog-entry" define () ("unit-name" "entry") #f #f 5317 9 5317 31 ("Catalog" "jazz:Catalog" "%%table-set!" "entry" "unit-name")}
      {Lisp-Entry "set-catalog-entry-status" define () ("unit-name" "status") #f #f 5321 9 5321 38 ("%%cons" "set-catalog-entry" "jazz:set-catalog-entry" "%%cdr" "%%pair?" "if" "get-catalog-entry" "jazz:get-catalog-entry" "entry" "declaration" "let" "status" "unit-name")}
      {Lisp-Entry "valid-catalog-entry" define () ("unit-name") #f #f 5329 9 5329 33 ("Load-Stack" "jazz:Load-Stack" "cdr" "map" "circular-dependency-error" "jazz:circular-dependency-error" "%%pair?" "if" "get-catalog-entry" "jazz:get-catalog-entry" "entry" "let" "unit-name")}
      {Lisp-Entry "release-catalog-entries" define () () #f #f 5336 9 5336 37 ("%%cdr" "set-catalog-entry" "jazz:set-catalog-entry" "%%pair?" "if" "entry" "unit-name" "lambda" "Catalog" "jazz:Catalog" "iterate-table" "jazz:iterate-table")}
      {Lisp-Entry "call-with-catalog-entry-lock" define () ("unit-name" "thunk") #f #f 5343 9 5343 42 ("get-catalog-entry" "jazz:get-catalog-entry" "%%pair?" "if" "pop-load-stack" "jazz:pop-load-stack" ":walk" "push-load-stack" "jazz:push-load-stack" ":walking" "set-catalog-entry-status" "jazz:set-catalog-entry-status" "dynamic-wind" "lambda" "call-with-load-lock" "jazz:call-with-load-lock" "thunk" "unit-name")}
      {Lisp-Entry "outline-feedback" define () () #f #f 5357 8 5357 29 ("make-parameter")}
      {Lisp-Entry "outline-unit" define () ("unit-name" "#!key" "(use-catalog? #t)" "(error? #t)") #f #f 5361 9 5361 26 ("set-catalog-entry" "jazz:set-catalog-entry" "error" "jazz:error" "outline-feedback" "jazz:outline-feedback" "feedback" "call-with-catalog-entry-lock" "jazz:call-with-catalog-entry-lock" "or" "Load-Stack" "jazz:Load-Stack" "cdr" "map" "circular-dependency-error" "jazz:circular-dependency-error" "declaration" "%%pair?" "status" "get-catalog-entry" "jazz:get-catalog-entry" "entry" "not" "parse-module-declaration" "jazz:parse-module-declaration" "module" "%%cdr" "parse-unit-declaration" "jazz:parse-unit-declaration" "unit" "case" "%%car" "source-code" "jazz:source-code" "kind" "0" "generate-symbol-counter" "jazz:generate-symbol-counter" "generate-symbol-context" "jazz:generate-symbol-context" "generate-symbol-for" "jazz:generate-symbol-for" "interpret" "walk-for" "jazz:walk-for" "requested-unit-resource" "jazz:requested-unit-resource" "requested-unit-name" "jazz:requested-unit-name" "parameterize" "read-literals?:" "read-toplevel-form" "jazz:read-toplevel-form" "form" "lambda" "resource-pathname" "jazz:resource-pathname" "outline-verbose?" "jazz:outline-verbose?" "with-verbose" "jazz:with-verbose" "%%not" "and" "if" "find-unit-src" "jazz:find-unit-src" "src" "let" "load-toplevel-declaration" "define" "error?" "use-catalog?" "#!key" "unit-name")}
      {Lisp-Entry "outline-module" define () ("unit-name" "#!key" "(error? #t)") #f #f 5404 9 5404 28 ("Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%assert" "%%not" "if" "error?:" "outline-unit" "jazz:outline-unit" "declaration" "let" "error?" "#!key" "unit-name")}
      {Lisp-Entry "read-literals?" define () () #f #f 5412 8 5412 27 ("make-parameter")}
      {Lisp-Entry "read-toplevel-form" define () ("resource" "#!key" "(read-literals? #t)") #f #f 5416 9 5416 32 ("%%not" "module" "unit" "%%memq" "source-code" "jazz:source-code" "%%pair?" "and" "%%cdr" "%%not-null?" "extraneous?" "%%car" "form-src" "error" "jazz:error" "%%null?" "if" "read-source-all" "jazz:read-source-all" "all" "jazz:read-literals?" "parameterize" "port" "eol-encoding:" "char-encoding:" "path:" "%%list" "call-with-input-file" "cr-lf" "eol-encoding" "resource-char-encoding" "jazz:resource-char-encoding" "char-encoding" "lambda" "pathname-extension" "jazz:pathname-extension" "with-extension-reader" "jazz:with-extension-reader" "resource-pathname" "jazz:resource-pathname" "source" "let" "read-literals?" "#!key" "resource")}
      {Lisp-Entry "walk-unit" define () ("unit-name") #f #f 5437 9 5437 23 ("%%cdr" "walk-module" "jazz:walk-module" "module" "unit" "%%car" "source-code" "jazz:source-code" "case" "read-toplevel-form" "jazz:read-toplevel-form" "form" "0" "generate-symbol-counter" "jazz:generate-symbol-counter" "generate-symbol-context" "jazz:generate-symbol-context" "generate-symbol-for" "jazz:generate-symbol-for" "interpret" "walk-for" "jazz:walk-for" "requested-unit-resource" "jazz:requested-unit-resource" "requested-unit-name" "jazz:requested-unit-name" "parameterize" "find-unit-src" "jazz:find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "Core-Dialect" define-class () () ("class runtime") #f 5458 27 5458 44 ()}
      {Lisp-Entry "new-core-dialect" define () () #f #f 5461 9 5461 30 ("Core-Dialect" "jazz:Core-Dialect" "allocate-core-dialect" "jazz:allocate-core-dialect")}
      {Lisp-Entry "dialect-name" generic/specific () () ("jazz:Core-Dialect") #f 5465 21 5465 38 ("core")}
      {Lisp-Entry "dialect-walker" generic/specific () () ("jazz:Core-Dialect") #f 5469 21 5469 40 ("new-core-walker" "jazz:new-core-walker")}
      {Lisp-Entry "Core-Walker" define-class () () ("class runtime") #f 5481 27 5481 43 ()}
      {Lisp-Entry "new-core-walker" define () () #f #f 5484 9 5484 29 ("eq?" "test:" "%%make-table" "new-queue" "jazz:new-queue" "Core-Walker" "jazz:Core-Walker" "allocate-core-walker" "jazz:allocate-core-walker")}}})
"autoload"
 ({Lisp-File-Entry {File :context "src" "core" "module" "runtime" "autoload.scm"} 231466230. scheme
    {Lisp-Entry "core.module.runtime.autoload" unit (protected) () #f #f 41 16 41 44 ()
      {Lisp-Entry "Autoloads" define () () #f #f 44 8 44 22 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "get-autoloads" define () () #f #f 48 9 48 27 ("Autoloads" "jazz:Autoloads")}
      {Lisp-Entry "get-autoload" define () ("name") #f #f 52 9 52 26 ("Autoloads" "jazz:Autoloads" "%%table-ref" "name")}
      {Lisp-Entry "set-autoload" define () ("name" "unit-name" "loader") #f #f 56 9 56 26 ("%%cons" "Autoloads" "jazz:Autoloads" "%%table-set!" "loader" "unit-name" "name")}
      {Lisp-Entry "require-autoload" define () ("name") #f #f 60 9 60 30 ("error" "jazz:error" "get-autoload" "jazz:get-autoload" "or" "name")}
      {Lisp-Entry "register-autoload" define () ("name" "unit-name" "loader") #f #f 65 9 65 31 ("error" "jazz:error" "set-autoload" "jazz:set-autoload" "%%car" "%%eq?" "%%not" "or" "if" "get-autoload" "jazz:get-autoload" "actual" "let" "loader" "unit-name" "name")}
      {Lisp-Entry "autoload" define () ("name") #f #f 72 9 72 22 ("%%cdr" "require-autoload" "jazz:require-autoload" "autoload-info" "let" "name")}
      {Lisp-Entry "autoreload" define () ("name") #f #f 77 9 77 24 ("%%cdr" "%%car" "reload-unit" "jazz:reload-unit" "require-autoload" "jazz:require-autoload" "autoload-info" "let" "name")}}})
"boolean"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "boolean.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.boolean" unit (protected) () #f #f 37 16 37 41 ()
      {Lisp-Entry "boolean" define () ("expr") #f #f 40 9 40 21 ("%%boolean" "expr")}
      {Lisp-Entry "not-null?" define () ("expr") #f #f 44 9 44 23 ("%%not-null?" "expr")}}})
"class"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "class.scm"} 231466230. scheme
    {Lisp-Entry "core.class.syntax.class" unit (protected) () #f #f 37 16 37 39 ()
      {Lisp-Entry "category-identifier" define () () #f #f 40 8 40 32 ("object-size" "jazz:object-size")}
      {Lisp-Entry "category-fields" define () () #f #f 43 8 43 28 ("1" "category-identifier" "jazz:category-identifier" "%%fx+")}
      {Lisp-Entry "category-virtual-size" define () () #f #f 46 8 46 34 ("1" "category-fields" "jazz:category-fields" "%%fx+")}
      {Lisp-Entry "category-ancestors" define () () #f #f 49 8 49 31 ("1" "category-virtual-size" "jazz:category-virtual-size" "%%fx+")}
      {Lisp-Entry "category-descendants" define () () #f #f 52 8 52 33 ("1" "category-ancestors" "jazz:category-ancestors" "%%fx+")}
      {Lisp-Entry "class-ascendant" define () () #f #f 55 8 55 28 ("1" "category-descendants" "jazz:category-descendants" "%%fx+")}
      {Lisp-Entry "class-interfaces" define () () #f #f 58 8 58 29 ("1" "class-ascendant" "jazz:class-ascendant" "%%fx+")}
      {Lisp-Entry "class-slots" define () () #f #f 61 8 61 24 ("1" "class-interfaces" "jazz:class-interfaces" "%%fx+")}
      {Lisp-Entry "class-instance-slots" define () () #f #f 64 8 64 33 ("1" "class-slots" "jazz:class-slots" "%%fx+")}
      {Lisp-Entry "class-instance-size" define () () #f #f 67 8 67 32 ("1" "class-instance-slots" "jazz:class-instance-slots" "%%fx+")}
      {Lisp-Entry "class-level" define () () #f #f 70 8 70 24 ("1" "class-instance-size" "jazz:class-instance-size" "%%fx+")}
      {Lisp-Entry "class-dispatch-table" define () () #f #f 73 8 73 33 ("1" "class-level" "jazz:class-level" "%%fx+")}
      {Lisp-Entry "class-core-method-alist" define () () #f #f 76 8 76 36 ("1" "class-dispatch-table" "jazz:class-dispatch-table" "%%fx+")}
      {Lisp-Entry "class-core-virtual-alist" define () () #f #f 79 8 79 37 ("1" "class-core-method-alist" "jazz:class-core-method-alist" "%%fx+")}
      {Lisp-Entry "class-core-virtual-names" define () () #f #f 82 8 82 37 ("1" "class-core-virtual-alist" "jazz:class-core-virtual-alist" "%%fx+")}
      {Lisp-Entry "class-core-vtable" define () () #f #f 85 8 85 30 ("1" "class-core-virtual-names" "jazz:class-core-virtual-names" "%%fx+")}
      {Lisp-Entry "class-class-table" define () () #f #f 88 8 88 30 ("1" "class-core-vtable" "jazz:class-core-vtable" "%%fx+")}
      {Lisp-Entry "class-interface-table" define () () #f #f 91 8 91 34 ("1" "class-class-table" "jazz:class-class-table" "%%fx+")}
      {Lisp-Entry "class-size" define () () #f #f 95 8 95 23 ("1" "class-interface-table" "jazz:class-interface-table" "%%fx+")}
      {Lisp-Entry "%%get-category-identifier" define-macro () () ("macro") #f 99 20 99 45 ("jazz:category-identifier" "category-identifier" ",jazz" ",jazz:category-identifier" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-identifier" define-macro () () ("macro") #f 103 20 103 45 (",identifier" "jazz:category-identifier" "category-identifier" ",jazz" ",jazz:category-identifier" ",category" "%%object-set!" "identifier" "category")}
      {Lisp-Entry "%%get-category-fields" define-macro () () ("macro") #f 107 20 107 41 ("jazz:category-fields" "category-fields" ",jazz" ",jazz:category-fields" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-fields" define-macro () () ("macro") #f 111 20 111 41 (",fields" "jazz:category-fields" "category-fields" ",jazz" ",jazz:category-fields" ",category" "%%object-set!" "fields" "category")}
      {Lisp-Entry "%%get-category-virtual-size" define-macro () () ("macro") #f 115 20 115 47 ("jazz:category-virtual-size" "category-virtual-size" ",jazz" ",jazz:category-virtual-size" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-virtual-size" define-macro () () ("macro") #f 119 20 119 47 (",virtual-size" "jazz:category-virtual-size" "category-virtual-size" ",jazz" ",jazz:category-virtual-size" ",category" "%%object-set!" "virtual-size" "category")}
      {Lisp-Entry "%%get-category-ancestors" define-macro () () ("macro") #f 123 20 123 44 ("jazz:category-ancestors" "category-ancestors" ",jazz" ",jazz:category-ancestors" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-ancestors" define-macro () () ("macro") #f 127 20 127 44 (",ancestors" "jazz:category-ancestors" "category-ancestors" ",jazz" ",jazz:category-ancestors" ",category" "%%object-set!" "ancestors" "category")}
      {Lisp-Entry "%%get-category-descendants" define-macro () () ("macro") #f 131 20 131 46 ("jazz:category-descendants" "category-descendants" ",jazz" ",jazz:category-descendants" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-descendants" define-macro () () ("macro") #f 135 20 135 46 (",descendants" "jazz:category-descendants" "category-descendants" ",jazz" ",jazz:category-descendants" ",category" "%%object-set!" "descendants" "category")}
      {Lisp-Entry "%%get-class-ascendant" define-macro () () ("macro") #f 139 20 139 41 ("jazz:class-ascendant" "class-ascendant" ",jazz" ",jazz:class-ascendant" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-ascendant" define-macro () () ("macro") #f 143 20 143 41 (",ascendant" "jazz:class-ascendant" "class-ascendant" ",jazz" ",jazz:class-ascendant" ",class" "%%object-set!" "ascendant" "class")}
      {Lisp-Entry "%%get-class-interfaces" define-macro () () ("macro") #f 147 20 147 42 ("jazz:class-interfaces" "class-interfaces" ",jazz" ",jazz:class-interfaces" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-interfaces" define-macro () () ("macro") #f 151 20 151 42 (",interfaces" "jazz:class-interfaces" "class-interfaces" ",jazz" ",jazz:class-interfaces" ",class" "%%object-set!" "interfaces" "class")}
      {Lisp-Entry "%%get-class-slots" define-macro () () ("macro") #f 155 20 155 37 ("jazz:class-slots" "class-slots" ",jazz" ",jazz:class-slots" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-slots" define-macro () () ("macro") #f 159 20 159 37 (",slots" "jazz:class-slots" "class-slots" ",jazz" ",jazz:class-slots" ",class" "%%object-set!" "slots" "class")}
      {Lisp-Entry "%%get-class-instance-slots" define-macro () () ("macro") #f 163 20 163 46 ("jazz:class-instance-slots" "class-instance-slots" ",jazz" ",jazz:class-instance-slots" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-instance-slots" define-macro () () ("macro") #f 167 20 167 46 (",slots" "jazz:class-instance-slots" "class-instance-slots" ",jazz" ",jazz:class-instance-slots" ",class" "%%object-set!" "slots" "class")}
      {Lisp-Entry "%%get-class-instance-size" define-macro () () ("macro") #f 171 20 171 45 ("jazz:class-instance-size" "class-instance-size" ",jazz" ",jazz:class-instance-size" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-instance-size" define-macro () () ("macro") #f 175 20 175 45 (",size" "jazz:class-instance-size" "class-instance-size" ",jazz" ",jazz:class-instance-size" ",class" "%%object-set!" "size" "class")}
      {Lisp-Entry "%%get-class-level" define-macro () () ("macro") #f 179 20 179 37 ("jazz:class-level" "class-level" ",jazz" ",jazz:class-level" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-level" define-macro () () ("macro") #f 183 20 183 37 (",size" "jazz:class-level" "class-level" ",jazz" ",jazz:class-level" ",class" "%%object-set!" "size" "class")}
      {Lisp-Entry "%%get-class-dispatch-table" define-macro () () ("macro") #f 187 20 187 46 ("jazz:class-dispatch-table" "class-dispatch-table" ",jazz" ",jazz:class-dispatch-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-dispatch-table" define-macro () () ("macro") #f 191 20 191 46 (",vtable" "jazz:class-dispatch-table" "class-dispatch-table" ",jazz" ",jazz:class-dispatch-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-method-alist" define-macro () () ("macro") #f 195 20 195 49 ("jazz:class-core-method-alist" "class-core-method-alist" ",jazz" ",jazz:class-core-method-alist" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-method-alist" define-macro () () ("macro") #f 199 20 199 49 (",vtable" "jazz:class-core-method-alist" "class-core-method-alist" ",jazz" ",jazz:class-core-method-alist" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-virtual-alist" define-macro () () ("macro") #f 203 20 203 50 ("jazz:class-core-virtual-alist" "class-core-virtual-alist" ",jazz" ",jazz:class-core-virtual-alist" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-virtual-alist" define-macro () () ("macro") #f 207 20 207 50 (",vtable" "jazz:class-core-virtual-alist" "class-core-virtual-alist" ",jazz" ",jazz:class-core-virtual-alist" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-virtual-names" define-macro () () ("macro") #f 211 20 211 50 ("jazz:class-core-virtual-names" "class-core-virtual-names" ",jazz" ",jazz:class-core-virtual-names" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-virtual-names" define-macro () () ("macro") #f 215 20 215 50 (",vtable" "jazz:class-core-virtual-names" "class-core-virtual-names" ",jazz" ",jazz:class-core-virtual-names" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-vtable" define-macro () () ("macro") #f 219 20 219 43 ("jazz:class-core-vtable" "class-core-vtable" ",jazz" ",jazz:class-core-vtable" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-vtable" define-macro () () ("macro") #f 223 20 223 43 (",vtable" "jazz:class-core-vtable" "class-core-vtable" ",jazz" ",jazz:class-core-vtable" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-class-table" define-macro () () ("macro") #f 227 20 227 43 ("jazz:class-class-table" "class-class-table" ",jazz" ",jazz:class-class-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-class-table" define-macro () () ("macro") #f 231 20 231 43 (",vtable" "jazz:class-class-table" "class-class-table" ",jazz" ",jazz:class-class-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-interface-table" define-macro () () ("macro") #f 235 20 235 47 ("jazz:class-interface-table" "class-interface-table" ",jazz" ",jazz:class-interface-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-interface-table" define-macro () () ("macro") #f 239 20 239 47 (",vtable" "jazz:class-interface-table" "class-interface-table" ",jazz" ",jazz:class-interface-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-object-class" define-macro () () ("macro") #f 243 20 243 38 ("jazz:object-class" "object-class" ",jazz" ",jazz:object-class" ",object" "%%object-ref" "object")}
      {Lisp-Entry "%%set-object-class" define-macro () () ("macro") #f 247 20 247 38 (",class" "jazz:object-class" "object-class" ",jazz" ",jazz:object-class" ",object" "%%object-set!" "class" "object")}
      {Lisp-Entry "%%final-dispatch" define-macro () () ("macro") #f 251 20 251 36 ("implementation" "class")}
      {Lisp-Entry "%%class-dispatch" define-macro () () ("macro") #f 255 20 255 36 (",implementation-rank" ",class-level" ",class" "%%get-class-class-table" "%%vector-ref" "implementation-rank" "class-level" "class")}
      {Lisp-Entry "%%interface-dispatch" define-macro () () ("macro") #f 259 20 259 40 (",implementation-rank" ",interface-rank" ",class" "%%get-class-interface-table" "%%vector-ref" "implementation-rank" "interface-rank" "class")}
      {Lisp-Entry "%%class-of-impl" define-macro () () ("macro") #f 268 24 268 39 ("%%scheme-class-of-impl" "else" ",obj" "%%c-class-of-impl" "compile" "walk-for" "jazz:walk-for" "case" "obj")}
      {Lisp-Entry "%%c-class-of-impl" define-macro () () ("macro") #f 275 24 275 41 ("structure-type" "jazz:structure-type" "specialtypes" "jazz:specialtypes" "Char" "jazz:Char" "Fixnum" "jazz:Fixnum" "subtypes" "jazz:subtypes" ",obj" "#<<end-of-c-code\n{\n    ___SCMOBJ obj = ___ARG1;\n    if (___MEM_ALLOCATED(obj))\n    {\n        int subtype = (*___UNTAG(obj) & ___SMASK) >> ___HTB;\n        if (subtype == ___sJAZZ)\n            ___RESULT = ___VECTORREF(obj,0);\n        else if (subtype == ___sSTRUCTURE)\n            ___RESULT = ___FAL;\n        else\n            ___RESULT = ___BODY_AS(___ARG2,___tSUBTYPED)[subtype];\n    }\n    else if (___FIXNUMP(obj))\n        ___RESULT = ___ARG3;\n    else if (obj >= 0)\n        ___RESULT = ___ARG4;\n    else\n        ___RESULT = ___BODY_AS(___ARG5,___tSUBTYPED)[___INT(___FAL - obj)];\n}\nend-of-c-code\n" "##c-code" "extended-bindings" "declare" "let" "or" "obj")}
      {Lisp-Entry "%%scheme-class-of-impl" define-macro () () ("macro") #f 307 24 307 46 ("error" "jazz:error" "structure-type" "jazz:structure-type" "or" "else" "Marker" "jazz:Marker" "marker?" "jazz:marker?" "Unspecified" "jazz:Unspecified" "%%unspecified?" "EOF" "jazz:EOF" "%%eof-object?" "Values" "jazz:Values" "%%values?" "Foreign" "jazz:Foreign" "%%foreign?" "Procedure" "jazz:Procedure" "%%procedure?" "Continuation" "jazz:Continuation" "%%continuation?" "Port" "jazz:Port" "%%port?" "Keyword" "jazz:Keyword" "%%keyword?" "Symbol" "jazz:Symbol" "%%symbol?" "F64Vector" "jazz:F64Vector" "%%f64vector?" "F32Vector" "jazz:F32Vector" "%%f32vector?" "U64Vector" "jazz:U64Vector" "%%u64vector?" "S64Vector" "jazz:S64Vector" "%%s64vector?" "U32Vector" "jazz:U32Vector" "%%u32vector?" "S32Vector" "jazz:S32Vector" "%%s32vector?" "U16Vector" "jazz:U16Vector" "%%u16vector?" "S16Vector" "jazz:S16Vector" "%%s16vector?" "U8Vector" "jazz:U8Vector" "%%u8vector?" "S8Vector" "jazz:S8Vector" "%%s8vector?" "Vector" "jazz:Vector" "%%vector?" "String" "jazz:String" "%%string?" "Pair" "jazz:Pair" "%%pair?" "Null" "jazz:Null" "%%null?" "Number" "jazz:Number" "%%number?" "Complex" "jazz:Complex" "%%complex?" "Real" "jazz:Real" "%%real?" "Rational" "jazz:Rational" "%%rational?" "Integer" "jazz:Integer" "%%integer?" "Flonum" "jazz:Flonum" "%%flonum?" "Fixnum" "jazz:Fixnum" "%%fixnum?" "Char" "jazz:Char" "%%char?" "Boolean" "jazz:Boolean" "%%boolean?" "%%get-object-class" ",obj" "%%object?" "cond" "obj")}
      {Lisp-Entry "%%class-of-impl" define-macro () () ("macro") #f 347 24 347 39 (",obj" "%%scheme-class-of-impl" "obj")}}})
"classes"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "classes.scm"} 231466230. scheme
    {Lisp-Entry "core.class.syntax.classes" unit (protected) () #f #f 37 16 37 41 ("Category" "jazz:Category" "Type" "jazz:Type" "Object" "jazz:Object")
      {Lisp-Entry "Object" define-class () () ("class syntax") #f 45 19 45 30 ()}
      {Lisp-Entry "print-object" generic/specific () ("output" "detail") ("jazz:Object~virtual") #f 49 22 49 39 ("detail" "output")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Object~virtual") #f 50 22 50 36 ("environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Type" define-class () () ("class syntax") #f 58 19 58 28 ("Object" "jazz:Object")}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Type~virtual") #f 62 22 62 35 ("object")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Type~virtual") #f 63 22 63 38 ("subtype")}
      {Lisp-Entry "specifiable?" generic/specific () () ("jazz:Type~virtual") #f 64 22 64 39 ()}
      {Lisp-Entry "category-type?" generic/specific () () ("jazz:Type~virtual") #f 65 22 65 41 ()}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Type~virtual") #f 66 22 66 41 ()}
      {Lisp-Entry "emit-type" generic/specific () ("source-declaration" "environment") ("jazz:Type~virtual") #f 67 22 67 36 ("environment" "source-declaration")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Type~virtual") #f 68 22 68 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "emit-check" generic/specific () ("value" "source-declaration" "environment") ("jazz:Type~virtual") #f 69 22 69 37 ("environment" "source-declaration" "value")}
      {Lisp-Entry "%%subtype?" define-macro () () ("macro") #f 72 20 72 30 (",target" ",type" "of-subtype?" "jazz:of-subtype?" "type" "target")}
      {Lisp-Entry "%%subcategory?" define-macro () () ("macro") #f 76 20 76 34 (",target" "%%get-category-ancestors" ",category" "vector-memq?" "jazz:vector-memq?" "category" "target")}
      {Lisp-Entry "%%subclass?" define-macro () () ("macro") #f 80 20 80 31 (",target" "%%get-category-ancestors" ",class" "vector-memq?" "jazz:vector-memq?" "class" "target")}
      {Lisp-Entry "%%is?" define-macro () () ("macro") #f 84 20 84 25 (",object" ",type" "of-type?" "jazz:of-type?" "type" "object")}
      {Lisp-Entry "%%is-not?" define-macro () () ("macro") #f 88 20 88 29 (",type" ",object" "%%is?" "%%not" "type" "object")}
      {Lisp-Entry "Category" define-class () () ("class syntax") #f 97 19 97 32 ("descendants" "ancestors" "virtual-size" "fields" "name" "Type" "jazz:Type")}
      {Lisp-Entry "update-category" generic/specific () () ("jazz:Category~virtual") #f 105 22 105 42 ()}
      {Lisp-Entry "Class" define-class () () ("class syntax") #f 113 19 113 29 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "allocate-class" "jazz:allocate-class" "descendants" "ancestors" "virtual-size" "fields" "name" "Category" "jazz:Category")}
      {Lisp-Entry "%%class-subtype?" define-macro () () ("macro") #f 129 20 129 36 ("%%get-category-ancestors" "%%vector-ref" "%%eq?" ",trg" "%%fx>=" "and" ",cls" "%%get-class-level" "class-level" "let" "cls" "trg" "lambda" "with-uniqueness" "jazz:with-uniqueness" "class" "target")}
      {Lisp-Entry "%%class-is?" define-macro () () ("macro") #f 139 20 139 31 (",class" ",object" "class-of" "jazz:class-of" "%%class-subtype?" "class" "object")}
      {Lisp-Entry "%%category-is?" define-macro () () ("macro") #f 143 20 143 34 (",category" ",object" "%%is?" "category" "object")}
      {Lisp-Entry "%%class?" define-macro () () ("macro") #f 147 20 147 28 ("Class" "jazz:Class" ",object" "%%class-is?" "object")}
      {Lisp-Entry "%%object-class?" define-macro () () ("macro") #f 151 20 151 35 ("Object" "jazz:Object" ",object" "%%eq?" "object")}
      {Lisp-Entry "Object-Class" define-class () () ("class syntax") #f 160 19 160 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Boolean-Class" define-class () () ("class syntax") #f 169 19 169 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Char-Class" define-class () () ("class syntax") #f 170 19 170 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Numeric-Class" define-class () () ("class syntax") #f 171 19 171 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Number-Class" define-class () () ("class syntax") #f 172 19 172 36 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Numeric-Class" "jazz:Numeric-Class")}
      {Lisp-Entry "Complex-Class" define-class () () ("class syntax") #f 173 19 173 37 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Number-Class" "jazz:Number-Class")}
      {Lisp-Entry "Real-Class" define-class () () ("class syntax") #f 174 19 174 34 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Complex-Class" "jazz:Complex-Class")}
      {Lisp-Entry "Rational-Class" define-class () () ("class syntax") #f 175 19 175 38 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Real-Class" "jazz:Real-Class")}
      {Lisp-Entry "Integer-Class" define-class () () ("class syntax") #f 176 19 176 37 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Rational-Class" "jazz:Rational-Class")}
      {Lisp-Entry "Fixnum-Class" define-class () () ("class syntax") #f 177 19 177 36 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Integer-Class" "jazz:Integer-Class")}
      {Lisp-Entry "Flonum-Class" define-class () () ("class syntax") #f 178 19 178 36 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Real-Class" "jazz:Real-Class")}
      {Lisp-Entry "Sequence-Class" define-class () () ("class syntax") #f 179 19 179 38 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "List-Class" define-class () () ("class syntax") #f 180 19 180 34 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "Null-Class" define-class () () ("class syntax") #f 181 19 181 34 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "List-Class" "jazz:List-Class")}
      {Lisp-Entry "Pair-Class" define-class () () ("class syntax") #f 182 19 182 34 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "List-Class" "jazz:List-Class")}
      {Lisp-Entry "String-Class" define-class () () ("class syntax") #f 183 19 183 36 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "Vector-Class" define-class () () ("class syntax") #f 184 19 184 36 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "S8Vector-Class" define-class () () ("class syntax") #f 185 19 185 38 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "U8Vector-Class" define-class () () ("class syntax") #f 186 19 186 38 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "S16Vector-Class" define-class () () ("class syntax") #f 187 19 187 39 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "U16Vector-Class" define-class () () ("class syntax") #f 188 19 188 39 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "S32Vector-Class" define-class () () ("class syntax") #f 189 19 189 39 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "U32Vector-Class" define-class () () ("class syntax") #f 190 19 190 39 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "S64Vector-Class" define-class () () ("class syntax") #f 191 19 191 39 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "U64Vector-Class" define-class () () ("class syntax") #f 192 19 192 39 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "F32Vector-Class" define-class () () ("class syntax") #f 193 19 193 39 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "F64Vector-Class" define-class () () ("class syntax") #f 194 19 194 39 ("Class" "jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Sequence-Class" "jazz:Sequence-Class")}
      {Lisp-Entry "Structure-Class" define-class () () ("class syntax") #f 195 19 195 39 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Port-Class" define-class () () ("class syntax") #f 196 19 196 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Continuation-Class" define-class () () ("class syntax") #f 197 19 197 42 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Procedure-Class" define-class () () ("class syntax") #f 198 19 198 39 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Symbol-Class" define-class () () ("class syntax") #f 199 19 199 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Keyword-Class" define-class () () ("class syntax") #f 200 19 200 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Table-Class" define-class () () ("class syntax") #f 201 19 201 35 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Thread-Class" define-class () () ("class syntax") #f 202 19 202 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Promise-Class" define-class () () ("class syntax") #f 203 19 203 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Foreign-Class" define-class () () ("class syntax") #f 204 19 204 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Values-Class" define-class () () ("class syntax") #f 205 19 205 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "EOF-Class" define-class () () ("class syntax") #f 206 19 206 33 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Unspecified-Class" define-class () () ("class syntax") #f 207 19 207 41 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Marker-Class" define-class () () ("class syntax") #f 208 19 208 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Boolean" define-class () () ("class syntax") #f 211 19 211 31 ("Boolean-Class" "jazz:Boolean-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Char" define-class () () ("class syntax") #f 212 19 212 28 ("Char-Class" "jazz:Char-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Numeric" define-class () () ("class syntax") #f 213 19 213 31 ("Numeric-Class" "jazz:Numeric-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Number" define-class () () ("class syntax") #f 214 19 214 30 ("Number-Class" "jazz:Number-Class" "Numeric" "jazz:Numeric")}
      {Lisp-Entry "Complex" define-class () () ("class syntax") #f 215 19 215 31 ("Complex-Class" "jazz:Complex-Class" "Number" "jazz:Number")}
      {Lisp-Entry "Real" define-class () () ("class syntax") #f 216 19 216 28 ("Real-Class" "jazz:Real-Class" "Complex" "jazz:Complex")}
      {Lisp-Entry "Rational" define-class () () ("class syntax") #f 217 19 217 32 ("Rational-Class" "jazz:Rational-Class" "Real" "jazz:Real")}
      {Lisp-Entry "Integer" define-class () () ("class syntax") #f 218 19 218 31 ("Integer-Class" "jazz:Integer-Class" "Rational" "jazz:Rational")}
      {Lisp-Entry "Fixnum" define-class () () ("class syntax") #f 219 19 219 30 ("Fixnum-Class" "jazz:Fixnum-Class" "Integer" "jazz:Integer")}
      {Lisp-Entry "Flonum" define-class () () ("class syntax") #f 220 19 220 30 ("Flonum-Class" "jazz:Flonum-Class" "Real" "jazz:Real")}
      {Lisp-Entry "Sequence" define-class () () ("class syntax") #f 221 19 221 32 ("Sequence-Class" "jazz:Sequence-Class" "Object" "jazz:Object")}
      {Lisp-Entry "List" define-class () () ("class syntax") #f 222 19 222 28 ("List-Class" "jazz:List-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "Null" define-class () () ("class syntax") #f 223 19 223 28 ("Null-Class" "jazz:Null-Class" "List" "jazz:List")}
      {Lisp-Entry "Pair" define-class () () ("class syntax") #f 224 19 224 28 ("Pair-Class" "jazz:Pair-Class" "List" "jazz:List")}
      {Lisp-Entry "String" define-class () () ("class syntax") #f 225 19 225 30 ("String-Class" "jazz:String-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "Vector" define-class () () ("class syntax") #f 226 19 226 30 ("Vector-Class" "jazz:Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "S8Vector" define-class () () ("class syntax") #f 227 19 227 32 ("S8Vector-Class" "jazz:S8Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "U8Vector" define-class () () ("class syntax") #f 228 19 228 32 ("U8Vector-Class" "jazz:U8Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "S16Vector" define-class () () ("class syntax") #f 229 19 229 33 ("S16Vector-Class" "jazz:S16Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "U16Vector" define-class () () ("class syntax") #f 230 19 230 33 ("U16Vector-Class" "jazz:U16Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "S32Vector" define-class () () ("class syntax") #f 231 19 231 33 ("S32Vector-Class" "jazz:S32Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "U32Vector" define-class () () ("class syntax") #f 232 19 232 33 ("U32Vector-Class" "jazz:U32Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "S64Vector" define-class () () ("class syntax") #f 233 19 233 33 ("S64Vector-Class" "jazz:S64Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "U64Vector" define-class () () ("class syntax") #f 234 19 234 33 ("U64Vector-Class" "jazz:U64Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "F32Vector" define-class () () ("class syntax") #f 235 19 235 33 ("F32Vector-Class" "jazz:F32Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "F64Vector" define-class () () ("class syntax") #f 236 19 236 33 ("F64Vector-Class" "jazz:F64Vector-Class" "Sequence" "jazz:Sequence")}
      {Lisp-Entry "Structure" define-class () () ("class syntax") #f 237 19 237 33 ("Structure-Class" "jazz:Structure-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Port" define-class () () ("class syntax") #f 238 19 238 28 ("Port-Class" "jazz:Port-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Continuation" define-class () () ("class syntax") #f 239 19 239 36 ("Continuation-Class" "jazz:Continuation-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Procedure" define-class () () ("class syntax") #f 240 19 240 33 ("Procedure-Class" "jazz:Procedure-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Symbol" define-class () () ("class syntax") #f 241 19 241 30 ("Symbol-Class" "jazz:Symbol-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Keyword" define-class () () ("class syntax") #f 242 19 242 31 ("Keyword-Class" "jazz:Keyword-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Table" define-class () () ("class syntax") #f 243 19 243 29 ("Table-Class" "jazz:Table-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Thread" define-class () () ("class syntax") #f 244 19 244 30 ("Thread-Class" "jazz:Thread-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Promise" define-class () () ("class syntax") #f 245 19 245 31 ("Promise-Class" "jazz:Promise-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Foreign" define-class () () ("class syntax") #f 246 19 246 31 ("Foreign-Class" "jazz:Foreign-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Values" define-class () () ("class syntax") #f 247 19 247 30 ("Values-Class" "jazz:Values-Class" "Object" "jazz:Object")}
      {Lisp-Entry "EOF" define-class () () ("class syntax") #f 248 19 248 27 ("EOF-Class" "jazz:EOF-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Unspecified" define-class () () ("class syntax") #f 249 19 249 35 ("Unspecified-Class" "jazz:Unspecified-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Marker" define-class () () ("class syntax") #f 250 19 250 30 ("Marker-Class" "jazz:Marker-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Interface" define-class () () ("class syntax") #f 258 19 258 33 ("%%get-interface-rank" "rank" "%%get-interface-ascendants" "ascendants" "allocate-interface" "jazz:allocate-interface" "Object-Class" "jazz:Object-Class" "descendants" "ancestors" "virtual-size" "fields" "name" "Category" "jazz:Category")}
      {Lisp-Entry "Field" define-class () () ("class syntax") #f 268 19 268 29 ("%%get-field-name" "name" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "%%get-category-field" define-macro () () ("macro") #f 272 20 272 40 (",field-name" ",category" "%%get-category-fields" "%%table-ref" "field-name" "category")}
      {Lisp-Entry "%%set-category-field" define-macro () () ("macro") #f 276 20 276 40 (",field" ",field-name" ",category" "%%get-category-fields" "%%table-set!" "field" "field-name" "category")}
      {Lisp-Entry "Slot" define-class () () ("class syntax") #f 285 19 285 28 ("%%set-slot-initialize" "%%get-slot-initialize" "initialize" "%%get-slot-offset" "offset" "allocate-slot" "jazz:allocate-slot" "Object-Class" "jazz:Object-Class" "name" "Field" "jazz:Field")}
      {Lisp-Entry "Property" define-class () () ("class syntax") #f 295 19 295 32 ("%%set-property-setter" "%%get-property-setter" "setter" "%%set-property-getter" "%%get-property-getter" "getter" "allocate-property" "jazz:allocate-property" "Object-Class" "jazz:Object-Class" "initialize" "offset" "name" "Slot" "jazz:Slot")}
      {Lisp-Entry "Method" define-class () () ("class syntax") #f 305 19 305 30 ("%%set-method-implementation-rank" "%%get-method-implementation-rank" "implementation-rank" "%%set-method-category-rank" "%%get-method-category-rank" "category-rank" "%%set-method-implementation-tree" "%%get-method-implementation-tree" "implementation-tree" "%%set-method-implementation" "%%get-method-implementation" "implementation" "%%set-method-dispatch-type" "%%get-method-dispatch-type" "dispatch-type" "allocate-method" "jazz:allocate-method" "Object-Class" "jazz:Object-Class" "name" "Field" "jazz:Field")}
      {Lisp-Entry "Method-Node" define-class () () ("class syntax") #f 318 19 318 35 ("%%set-method-node-children" "%%get-method-node-children" "children" "%%set-method-node-next-implementation" "%%get-method-node-next-implementation" "next-implementation" "%%set-method-node-next-node" "%%get-method-node-next-node" "next-node" "%%set-method-node-implementation" "%%get-method-node-implementation" "implementation" "%%set-method-node-category" "%%get-method-node-category" "category" "allocate-method-node" "jazz:allocate-method-node" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Queue" define-class () () ("class syntax") #f 331 19 331 29 ("%%set-queue-shared?" "%%get-queue-shared?" "shared?" "%%set-queue-tail" "%%get-queue-tail" "tail" "%%set-queue-head" "%%get-queue-head" "head" "allocate-queue" "jazz:allocate-queue" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}}}
  {Lisp-File-Entry {File :context "src" "core" "exception" "syntax" "classes.scm"} 231466230. scheme
    {Lisp-Entry "core.exception.syntax.classes" unit (protected) () #f #f 37 16 37 45 ("Exception" "jazz:Exception")
      {Lisp-Entry "Exception" define-class () () ("class syntax") #f 45 19 45 33 ("Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "present-exception" generic/specific () () ("jazz:Exception~virtual") #f 49 22 49 44 ()}
      {Lisp-Entry "get-message" generic/specific () () ("jazz:Exception~virtual") #f 50 22 50 38 ()}
      {Lisp-Entry "get-detail" generic/specific () () ("jazz:Exception~virtual") #f 51 22 51 37 ()}
      {Lisp-Entry "Exception-Detail" define-class () () ("class syntax") #f 59 19 59 40 ("%%get-exception-detail-children" "children" "%%get-exception-detail-location" "location" "%%get-exception-detail-title" "title" "%%get-exception-detail-icon" "icon" "allocate-exception-detail" "jazz:allocate-exception-detail" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "System-Exception" define-class () () ("class syntax") #f 71 19 71 40 ("%%get-system-exception-exception" "exception" "Object-Class" "jazz:Object-Class" "Exception" "jazz:Exception")}
      {Lisp-Entry "Error" define-class () () ("class syntax") #f 80 19 80 29 ("%%get-error-message" "message" "allocate-error" "jazz:allocate-error" "Object-Class" "jazz:Object-Class" "Exception" "jazz:Exception")}}}
  {Lisp-File-Entry {File :context "src" "core" "module" "syntax" "classes.scm"} 231466230. scheme
    {Lisp-Entry "core.module.syntax.classes" unit (protected) () #f #f 37 16 37 42 ("Expression" "jazz:Expression" "Parameter" "jazz:Parameter" "Walker" "jazz:Walker" "Declaration-Reference" "jazz:Declaration-Reference" "Declaration" "jazz:Declaration" "Lexical-Binding" "jazz:Lexical-Binding" "Walk-Binding" "jazz:Walk-Binding")
      {Lisp-Entry "Walk-Binding" define-class () () ("class syntax") #f 45 19 45 36 ("Object-Class" "jazz:Object-Class" "Type" "jazz:Type")}
      {Lisp-Entry "walk-binding-lookup" generic/specific () ("symbol" "source-declaration") ("jazz:Walk-Binding~virtual") #f 49 22 49 46 ("source-declaration" "symbol")}
      {Lisp-Entry "walk-binding-referenced" generic/specific () () ("jazz:Walk-Binding~virtual") #f 50 22 50 50 ()}
      {Lisp-Entry "emit-binding-symbol" generic/specific () ("source-declaration" "environment") ("jazz:Walk-Binding~virtual") #f 51 22 51 46 ("environment" "source-declaration")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:Walk-Binding~virtual") #f 52 22 52 49 ("environment" "source-declaration")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:Walk-Binding~virtual") #f 53 22 53 53 ("form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-binding-call" generic/specific () ("binding-src" "arguments" "source-declaration" "environment") ("jazz:Walk-Binding~virtual") #f 54 22 54 44 ("environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "emit-inlined-binding-call" generic/specific () ("arguments" "call" "source-declaration" "environment") ("jazz:Walk-Binding~virtual") #f 55 22 55 52 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "walk-binding-validate-assignment" generic/specific () ("walker" "resume" "source-declaration" "symbol-src") ("jazz:Walk-Binding~virtual") #f 56 22 56 59 ("symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "walk-binding-assignable?" generic/specific () () ("jazz:Walk-Binding~virtual") #f 57 22 57 51 ()}
      {Lisp-Entry "emit-binding-assignment" generic/specific () ("value" "source-declaration" "environment") ("jazz:Walk-Binding~virtual") #f 58 22 58 50 ("environment" "source-declaration" "value")}
      {Lisp-Entry "walk-binding-walkable?" generic/specific () () ("jazz:Walk-Binding~virtual") #f 59 22 59 49 ()}
      {Lisp-Entry "walk-binding-walk-form" generic/specific () ("walker" "resume" "declaration" "environment" "form") ("jazz:Walk-Binding~virtual") #f 60 22 60 49 ("form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific () () ("jazz:Walk-Binding~virtual") #f 61 22 61 51 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific () ("walker" "resume" "declaration" "environment" "form") ("jazz:Walk-Binding~virtual") #f 62 22 62 51 ("form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "Lexical-Binding" define-class () () ("class syntax") #f 70 19 70 39 ("%%set-lexical-binding-hits" "%%get-lexical-binding-hits" "hits" "%%get-lexical-binding-type" "type" "%%get-lexical-binding-name" "name" "Object-Class" "jazz:Object-Class" "Walk-Binding" "jazz:Walk-Binding")}
      {Lisp-Entry "resolve-binding" generic/specific () () ("jazz:Lexical-Binding~virtual") #f 76 22 76 42 ()}
      {Lisp-Entry "Declaration" define-class () () ("class syntax") #f 84 19 84 35 ("%%set-declaration-source" "%%get-declaration-source" "source" "%%set-declaration-locator" "%%get-declaration-locator" "locator" "%%set-declaration-parent" "%%get-declaration-parent" "parent" "%%set-declaration-toplevel" "%%get-declaration-toplevel" "toplevel" "%%get-declaration-attributes" "attributes" "%%get-declaration-compatibility" "compatibility" "%%get-declaration-access" "access" "Object-Class" "jazz:Object-Class" "hits" "type" "name" "Lexical-Binding" "jazz:Lexical-Binding")}
      {Lisp-Entry "lookup-declaration" generic/specific () ("symbol" "access" "source-declaration") ("jazz:Declaration~virtual") #f 94 22 94 45 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "update-declaration" generic/specific () ("new-declaration") ("jazz:Declaration~virtual") #f 95 22 95 45 ("new-declaration")}
      {Lisp-Entry "get-declaration-inclusions" generic/specific () () ("jazz:Declaration~virtual") #f 96 22 96 53 ()}
      {Lisp-Entry "get-nextmethod-signature" generic/specific () () ("jazz:Declaration~virtual") #f 97 22 97 51 ()}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:Declaration~virtual") #f 98 22 98 43 ("environment")}
      {Lisp-Entry "expand-referenced-declaration" generic/specific () () ("jazz:Declaration~virtual") #f 99 22 99 56 ()}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:Declaration~virtual") #f 100 22 100 43 ("s" "k" "f")}
      {Lisp-Entry "Declaration-Reference" define-class () () ("class syntax") #f 108 19 108 45 ("%%set-declaration-reference-declaration" "%%get-declaration-reference-declaration" "declaration" "%%get-declaration-reference-name" "name" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "resolve-reference" generic/specific () ("module-declaration") ("jazz:Declaration-Reference~virtual") #f 113 22 113 44 ("module-declaration")}
      {Lisp-Entry "Module-Reference" define-class () () ("class syntax") #f 121 19 121 40 ("allocate-module-reference" "jazz:allocate-module-reference" "Object-Class" "jazz:Object-Class" "declaration" "name" "Declaration-Reference" "jazz:Declaration-Reference")}
      {Lisp-Entry "Export-Reference" define-class () () ("class syntax") #f 130 19 130 40 ("%%get-export-reference-module-reference" "module-reference" "allocate-export-reference" "jazz:allocate-export-reference" "Object-Class" "jazz:Object-Class" "declaration" "name" "Declaration-Reference" "jazz:Declaration-Reference")}
      {Lisp-Entry "Autoload-Reference" define-class () () ("class syntax") #f 139 19 139 42 ("allocate-autoload-reference" "jazz:allocate-autoload-reference" "Object-Class" "jazz:Object-Class" "module-reference" "declaration" "name" "Export-Reference" "jazz:Export-Reference")}
      {Lisp-Entry "Unit-Declaration" define-class () () ("class syntax") #f 148 19 148 40 ("%%set-unit-declaration-requires" "%%get-unit-declaration-requires" "requires" "allocate-unit-declaration" "jazz:allocate-unit-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Namespace-Declaration" define-class () () ("class syntax") #f 157 19 157 45 ("%%set-namespace-declaration-body" "%%get-namespace-declaration-body" "body" "%%get-namespace-declaration-children" "children" "%%get-namespace-declaration-lookups" "lookups" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "%%get-access-lookup" define-macro () () ("macro") #f 163 20 163 39 (",access" ",namespace-declaration" "%%get-namespace-declaration-lookups" "%%vector-ref" "access" "namespace-declaration")}
      {Lisp-Entry "Module-Declaration" define-class () () ("class syntax") #f 172 19 172 42 ("%%get-module-declaration-local-macros" "local-macros" "%%set-module-declaration-inclusions" "%%get-module-declaration-inclusions" "inclusions" "%%get-module-declaration-proclaims" "proclaims" "%%set-module-declaration-imports" "%%get-module-declaration-imports" "imports" "%%set-module-declaration-exports" "%%get-module-declaration-exports" "exports" "%%set-module-declaration-requires" "%%get-module-declaration-requires" "requires" "%%get-module-declaration-dialect-invoice" "dialect-invoice" "%%get-module-declaration-dialect-name" "dialect-name" "%%set-module-declaration-walker" "%%get-module-declaration-walker" "walker" "allocate-module-declaration" "jazz:allocate-module-declaration" "Object-Class" "jazz:Object-Class" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Namespace-Declaration" "jazz:Namespace-Declaration")}
      {Lisp-Entry "Module-Invoice" define-class () () ("class syntax") #f 189 19 189 38 ("%%get-module-invoice-rename" "rename" "%%get-module-invoice-prefix" "prefix" "%%get-module-invoice-except" "except" "%%get-module-invoice-only" "only" "%%get-module-invoice-version" "version" "%%get-module-invoice-phase" "phase" "%%get-module-invoice-module" "module" "%%get-module-invoice-name" "name" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Export-Invoice" define-class () () ("class syntax") #f 205 19 205 38 ("%%set-export-invoice-autoload" "%%get-export-invoice-autoload" "autoload" "allocate-export-invoice" "jazz:allocate-export-invoice" "Object-Class" "jazz:Object-Class" "rename" "prefix" "except" "only" "version" "phase" "module" "name" "Module-Invoice" "jazz:Module-Invoice")}
      {Lisp-Entry "Import-Invoice" define-class () () ("class syntax") #f 214 19 214 38 ("%%set-import-invoice-hit?" "%%get-import-invoice-hit?" "hit?" "allocate-import-invoice" "jazz:allocate-import-invoice" "Object-Class" "jazz:Object-Class" "rename" "prefix" "except" "only" "version" "phase" "module" "name" "Module-Invoice" "jazz:Module-Invoice")}
      {Lisp-Entry "Export-Declaration" define-class () () ("class syntax") #f 223 19 223 42 ("%%get-export-declaration-symbol" "symbol" "allocate-export-declaration" "jazz:allocate-export-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Export-Syntax-Declaration" define-class () () ("class syntax") #f 232 19 232 49 ("%%get-export-syntax-declaration-symbol" "symbol" "allocate-export-syntax-declaration" "jazz:allocate-export-syntax-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Autoload-Declaration" define-class () () ("class syntax") #f 241 19 241 44 ("%%set-autoload-declaration-declaration" "%%get-autoload-declaration-declaration" "declaration" "%%get-autoload-declaration-exported-module" "exported-module" "%%get-autoload-declaration-module" "module" "allocate-autoload-declaration" "jazz:allocate-autoload-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Literal" define-class () () ("class syntax") #f 252 19 252 31 ("%%get-literal-arguments" "arguments" "%%get-literal-name" "name" "allocate-literal" "jazz:allocate-literal" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Macro-Declaration" define-class () () ("class syntax") #f 262 19 262 41 ("%%set-macro-declaration-body" "%%get-macro-declaration-body" "body" "%%set-macro-declaration-signature" "%%get-macro-declaration-signature" "signature" "allocate-macro-declaration" "jazz:allocate-macro-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Local-Macro-Declaration" define-class () () ("class syntax") #f 272 19 272 47 ("%%set-local-macro-declaration-body" "%%get-local-macro-declaration-body" "body" "%%set-local-macro-declaration-signature" "%%get-local-macro-declaration-signature" "signature" "allocate-local-macro-declaration" "jazz:allocate-local-macro-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Syntax-Declaration" define-class () () ("class syntax") #f 282 19 282 42 ("%%set-syntax-declaration-body" "%%get-syntax-declaration-body" "body" "%%set-syntax-declaration-signature" "%%get-syntax-declaration-signature" "signature" "allocate-syntax-declaration" "jazz:allocate-syntax-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Define-Syntax-Declaration" define-class () () ("class syntax") #f 292 19 292 49 ("allocate-define-syntax-declaration" "jazz:allocate-define-syntax-declaration" "Object-Class" "jazz:Object-Class" "body" "signature" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Syntax-Declaration" "jazz:Syntax-Declaration")}
      {Lisp-Entry "Define-Local-Syntax-Declaration" define-class () () ("class syntax") #f 301 19 301 55 ("allocate-define-local-syntax-declaration" "jazz:allocate-define-local-syntax-declaration" "Object-Class" "jazz:Object-Class" "body" "signature" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Syntax-Declaration" "jazz:Syntax-Declaration")}
      {Lisp-Entry "Void-Class" define-class () () ("class syntax") #f 310 19 310 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Void" define-class () () ("class syntax") #f 314 19 314 28 ("Void-Class" "jazz:Void-Class" "Type" "jazz:Type")}
      {Lisp-Entry "Opt-Type" define-class () () ("class syntax") #f 323 19 323 32 ("%%get-opt-type-type" "type" "allocate-opt-type" "jazz:allocate-opt-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Key-Type" define-class () () ("class syntax") #f 332 19 332 32 ("%%get-key-type-type" "type" "%%get-key-type-key" "key" "allocate-key-type" "jazz:allocate-key-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Rest-Type" define-class () () ("class syntax") #f 342 19 342 33 ("%%get-rest-type-type" "type" "allocate-rest-type" "jazz:allocate-rest-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Function-Type" define-class () () ("class syntax") #f 351 19 351 37 ("%%get-function-type-result" "result" "%%get-function-type-rest" "rest" "%%get-function-type-named" "named" "%%get-function-type-optional" "optional" "%%get-function-type-positional" "positional" "%%get-function-type-mandatory" "mandatory" "allocate-function-type" "jazz:allocate-function-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Category-Type" define-class () () ("class syntax") #f 365 19 365 37 ("%%get-category-type-declaration" "declaration" "allocate-category-type" "jazz:allocate-category-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Values-Type" define-class () () ("class syntax") #f 374 19 374 35 ("%%get-values-type-types" "types" "allocate-values-type" "jazz:allocate-values-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Restriction-Type" define-class () () ("class syntax") #f 383 19 383 40 ("%%get-restriction-type-type" "type" "%%get-restriction-type-base" "base" "allocate-restriction-type" "jazz:allocate-restriction-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Complement-Type" define-class () () ("class syntax") #f 393 19 393 39 ("%%get-complement-type-type" "type" "allocate-complement-type" "jazz:allocate-complement-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Union-Type" define-class () () ("class syntax") #f 402 19 402 34 ("%%get-union-type-types" "types" "allocate-union-type" "jazz:allocate-union-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Template-Type" define-class () () ("class syntax") #f 411 19 411 37 ("%%get-template-type-types" "types" "%%get-template-type-class" "class" "allocate-template-type" "jazz:allocate-template-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Nillable-Type" define-class () () ("class syntax") #f 421 19 421 37 ("%%get-nillable-type-type" "type" "allocate-nillable-type" "jazz:allocate-nillable-type" "Class" "jazz:Class" "Type" "jazz:Type")}
      {Lisp-Entry "Any-Class" define-class () () ("class syntax") #f 430 19 430 33 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "Class" "jazz:Class")}
      {Lisp-Entry "Any" define-class () () ("class syntax") #f 434 19 434 27 ("Any-Class" "jazz:Any-Class" "Type" "jazz:Type")}
      {Lisp-Entry "C-Type-Declaration" define-class () () ("class syntax") #f 443 19 443 42 ("%%get-c-type-declaration-declare" "declare" "%%get-c-type-declaration-scheme-to-c" "scheme-to-c" "%%get-c-type-declaration-c-to-scheme" "c-to-scheme" "%%get-c-type-declaration-inclusions" "inclusions" "%%set-c-type-declaration-pointer-types" "%%get-c-type-declaration-pointer-types" "pointer-types" "%%get-c-type-declaration-base-type" "base-type" "%%get-c-type-declaration-expansion" "expansion" "%%get-c-type-declaration-kind" "kind" "allocate-c-type-declaration" "jazz:allocate-c-type-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "C-Definition-Declaration" define-class () () ("class syntax") #f 459 19 459 48 ("%%set-c-definition-declaration-body" "%%get-c-definition-declaration-body" "body" "%%get-c-definition-declaration-scope" "scope" "%%get-c-definition-declaration-c-name" "c-name" "%%get-c-definition-declaration-result-type" "result-type" "%%get-c-definition-declaration-parameter-types" "parameter-types" "%%set-c-definition-declaration-signature" "%%get-c-definition-declaration-signature" "signature" "allocate-c-definition-declaration" "jazz:allocate-c-definition-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Walker" define-class () () ("class syntax") #f 473 19 473 30 ("%%set-walker-autoloads" "%%get-walker-autoloads" "autoloads" "%%get-walker-references" "references" "%%get-walker-variables" "variables" "%%set-walker-literals" "%%get-walker-literals" "literals" "%%set-walker-errors" "%%get-walker-errors" "errors" "%%set-walker-warnings" "%%get-walker-warnings" "warnings" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "walker-bindings" generic/specific () () ("jazz:Walker~virtual") #f 482 22 482 42 ()}
      {Lisp-Entry "walker-environment" generic/specific () () ("jazz:Walker~virtual") #f 483 22 483 45 ()}
      {Lisp-Entry "walk-declaration" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Walker~virtual") #f 484 22 484 43 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-free-reference" generic/specific () ("resume" "declaration" "symbol-src") ("jazz:Walker~virtual") #f 485 22 485 46 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "walk-symbol-assignment" generic/specific () ("resume" "declaration" "environment" "symbol-src" "value") ("jazz:Walker~virtual") #f 486 22 486 49 ("value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-free-assignment" generic/specific () ("resume" "declaration" "symbol-src") ("jazz:Walker~virtual") #f 487 22 487 47 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "walk-symbol" generic/specific () ("resume" "declaration" "environment" "symbol-src") ("jazz:Walker~virtual") #f 488 22 488 38 ("symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-form" generic/specific () ("resume" "declaration" "environment" "form") ("jazz:Walker~virtual") #f 489 22 489 36 ("form" "environment" "declaration" "resume")}
      {Lisp-Entry "validate-proclaim" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Walker~virtual") #f 490 22 490 44 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "validate-arguments" generic/specific () ("resume" "source-declaration" "declaration" "signature" "arguments" "form-src") ("jazz:Walker~virtual") #f 491 22 491 45 ("form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "runtime-export" generic/specific () ("declaration") ("jazz:Walker~virtual") #f 492 22 492 41 ("declaration")}
      {Lisp-Entry "lookup-analyse" generic/specific () ("declaration" "symbol-src" "referenced-declaration") ("jazz:Walker~virtual") #f 493 22 493 41 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "%%get-module-declaration-walker-literals" define () ("lib-decl") #f #f 497 9 497 49 ("%%get-module-declaration-walker" "%%get-walker-literals" "lib-decl")}
      {Lisp-Entry "%%set-module-declaration-walker-literals" define () ("lib-decl" "value") #f #f 499 9 499 49 ("%%get-module-declaration-walker" "%%set-walker-literals" "value" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-variables" define () ("lib-decl") #f #f 501 9 501 50 ("%%get-module-declaration-walker" "%%get-walker-variables" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-references" define () ("lib-decl") #f #f 503 9 503 51 ("%%get-module-declaration-walker" "%%get-walker-references" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-autoloads" define () ("lib-decl") #f #f 505 9 505 50 ("%%get-module-declaration-walker" "%%get-walker-autoloads" "lib-decl")}
      {Lisp-Entry "%%set-module-declaration-walker-autoloads" define () ("lib-decl" "value") #f #f 507 9 507 50 ("%%get-module-declaration-walker" "%%set-walker-autoloads" "value" "lib-decl")}
      {Lisp-Entry "Walk-Context" define-class () () ("class syntax") #f 516 19 516 36 ("%%get-walk-context-pathname" "pathname" "%%get-walk-context-locator" "locator" "%%get-walk-context-policy" "policy" "allocate-walk-context" "jazz:allocate-walk-context" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Walk-Location" define-class () () ("class syntax") #f 527 19 527 37 ("%%get-walk-location-path" "path" "%%get-walk-location-locat" "locat" "%%get-walk-location-declaration-locator" "declaration-locator" "%%get-walk-location-unit-locator" "unit-locator" "allocate-walk-location" "jazz:allocate-walk-location" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Walk-Problem" define-class () () ("class syntax") #f 539 19 539 36 ("%%get-walk-problem-location" "location" "Object-Class" "jazz:Object-Class" "message" "Error" "jazz:Error")}
      {Lisp-Entry "Walk-Problems" define-class () () ("class syntax") #f 548 19 548 37 ("%%get-walk-problems-errors" "errors" "%%get-walk-problems-warnings" "warnings" "allocate-walk-problems" "jazz:allocate-walk-problems" "Object-Class" "jazz:Object-Class" "message" "Error" "jazz:Error")}
      {Lisp-Entry "Walk-Warning" define-class () () ("class syntax") #f 558 19 558 36 ("allocate-walk-warning" "jazz:allocate-walk-warning" "Object-Class" "jazz:Object-Class" "location" "message" "Walk-Problem" "jazz:Walk-Problem")}
      {Lisp-Entry "Walk-Error" define-class () () ("class syntax") #f 567 19 567 34 ("allocate-walk-error" "jazz:allocate-walk-error" "Object-Class" "jazz:Object-Class" "location" "message" "Walk-Problem" "jazz:Walk-Problem")}
      {Lisp-Entry "Unresolved-Error" define-class () () ("class syntax") #f 576 19 576 40 ("%%get-unresolved-error-symbol" "symbol" "allocate-unresolved-error" "jazz:allocate-unresolved-error" "Object-Class" "jazz:Object-Class" "location" "message" "Walk-Error" "jazz:Walk-Error")}
      {Lisp-Entry "Walk-Frame" define-class () () ("class syntax") #f 585 19 585 34 ("%%get-walk-frame-bindings" "bindings" "allocate-walk-frame" "jazz:allocate-walk-frame" "Object-Class" "jazz:Object-Class" "Walk-Binding" "jazz:Walk-Binding")}
      {Lisp-Entry "Signature" define-class () () ("class syntax") #f 594 19 594 33 ("%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "%%get-signature-mandatory" "mandatory" "allocate-signature" "jazz:allocate-signature" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Symbol-Binding" define-class () () ("class syntax") #f 607 19 607 38 ("%%set-symbol-binding-gensym" "%%get-symbol-binding-gensym" "gensym" "Object-Class" "jazz:Object-Class" "hits" "type" "name" "Lexical-Binding" "jazz:Lexical-Binding")}
      {Lisp-Entry "Variable" define-class () () ("class syntax") #f 616 19 616 32 ("%%set-variable-reference-count" "%%get-variable-reference-count" "reference-count" "allocate-variable" "jazz:allocate-variable" "Object-Class" "jazz:Object-Class" "gensym" "hits" "type" "name" "Symbol-Binding" "jazz:Symbol-Binding")}
      {Lisp-Entry "NextMethod-Variable" define-class () () ("class syntax") #f 625 19 625 43 ("allocate-nextmethod-variable" "jazz:allocate-nextmethod-variable" "Object-Class" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "Variable" "jazz:Variable")}
      {Lisp-Entry "Parameter" define-class () () ("class syntax") #f 634 19 634 33 ("allocate-parameter" "jazz:allocate-parameter" "Object-Class" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "Variable" "jazz:Variable")}
      {Lisp-Entry "emit-parameter" generic/specific () ("declaration" "environment") ("jazz:Parameter~virtual") #f 638 22 638 41 ("environment" "declaration")}
      {Lisp-Entry "Dynamic-Parameter" define-class () () ("class syntax") #f 646 19 646 41 ("%%get-dynamic-parameter-class" "class" "allocate-dynamic-parameter" "jazz:allocate-dynamic-parameter" "Object-Class" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "Parameter" "jazz:Parameter")}
      {Lisp-Entry "Optional-Parameter" define-class () () ("class syntax") #f 655 19 655 42 ("%%set-optional-parameter-default" "%%get-optional-parameter-default" "default" "allocate-optional-parameter" "jazz:allocate-optional-parameter" "Object-Class" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "Parameter" "jazz:Parameter")}
      {Lisp-Entry "Named-Parameter" define-class () () ("class syntax") #f 664 19 664 39 ("%%set-named-parameter-default" "%%get-named-parameter-default" "default" "allocate-named-parameter" "jazz:allocate-named-parameter" "Object-Class" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "Parameter" "jazz:Parameter")}
      {Lisp-Entry "Rest-Parameter" define-class () () ("class syntax") #f 673 19 673 38 ("allocate-rest-parameter" "jazz:allocate-rest-parameter" "Object-Class" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "Parameter" "jazz:Parameter")}
      {Lisp-Entry "Self-Binding" define-class () () ("class syntax") #f 682 19 682 36 ("allocate-self-binding" "jazz:allocate-self-binding" "Object-Class" "jazz:Object-Class" "hits" "type" "name" "Lexical-Binding" "jazz:Lexical-Binding")}
      {Lisp-Entry "Dynamic-Self-Binding" define-class () () ("class syntax") #f 691 19 691 44 ("%%get-dynamic-self-binding-code" "code" "allocate-dynamic-self-binding" "jazz:allocate-dynamic-self-binding" "Object-Class" "jazz:Object-Class" "hits" "type" "name" "Lexical-Binding" "jazz:Lexical-Binding")}
      {Lisp-Entry "Local-Variable-Binding" define-class () () ("class syntax") #f 700 19 700 46 ("%%get-local-variable-binding-variable" "variable" "allocate-local-variable-binding" "jazz:allocate-local-variable-binding" "Object-Class" "jazz:Object-Class" "hits" "type" "name" "Lexical-Binding" "jazz:Lexical-Binding")}
      {Lisp-Entry "Macro-Symbol" define-class () () ("class syntax") #f 709 19 709 36 ("%%get-macro-symbol-setter" "setter" "%%get-macro-symbol-getter" "getter" "allocate-macro-symbol" "jazz:allocate-macro-symbol" "Object-Class" "jazz:Object-Class" "gensym" "hits" "type" "name" "Symbol-Binding" "jazz:Symbol-Binding")}
      {Lisp-Entry "Form-Binding" define-class () () ("class syntax") #f 719 19 719 36 ("Object-Class" "jazz:Object-Class" "hits" "type" "name" "Lexical-Binding" "jazz:Lexical-Binding")}
      {Lisp-Entry "Special-Form" define-class () () ("class syntax") #f 728 19 728 36 ("%%get-special-form-walk" "walk" "allocate-special-form" "jazz:allocate-special-form" "Object-Class" "jazz:Object-Class" "hits" "type" "name" "Form-Binding" "jazz:Form-Binding")}
      {Lisp-Entry "Macro-Form" define-class () () ("class syntax") #f 737 19 737 34 ("%%get-macro-form-expander" "expander" "allocate-macro-form" "jazz:allocate-macro-form" "Object-Class" "jazz:Object-Class" "hits" "type" "name" "Form-Binding" "jazz:Form-Binding")}
      {Lisp-Entry "Syntax-Form" define-class () () ("class syntax") #f 746 19 746 35 ("%%get-syntax-form-expander" "expander" "allocate-syntax-form" "jazz:allocate-syntax-form" "Object-Class" "jazz:Object-Class" "hits" "type" "name" "Form-Binding" "jazz:Form-Binding")}
      {Lisp-Entry "Define-Syntax-Form" define-class () () ("class syntax") #f 755 19 755 42 ("%%get-define-syntax-form-environment" "environment" "allocate-define-syntax-form" "jazz:allocate-define-syntax-form" "Object-Class" "jazz:Object-Class" "expander" "hits" "type" "name" "Syntax-Form" "jazz:Syntax-Form")}
      {Lisp-Entry "Define-Local-Syntax-Form" define-class () () ("class syntax") #f 764 19 764 48 ("%%get-define-local-syntax-form-environment" "environment" "allocate-define-local-syntax-form" "jazz:allocate-define-local-syntax-form" "Object-Class" "jazz:Object-Class" "expander" "hits" "type" "name" "Syntax-Form" "jazz:Syntax-Form")}
      {Lisp-Entry "Syntactic-Closure" define-class () () ("class syntax") #f 773 19 773 41 ("%%get-syntactic-closure-form" "form" "%%get-syntactic-closure-variables" "variables" "%%get-syntactic-closure-environment" "environment" "allocate-syntactic-closure" "jazz:allocate-syntactic-closure" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Annotated-Variable" define-class () () ("class syntax") #f 784 19 784 42 ("%%set-annotated-variable-type" "%%get-annotated-variable-type" "type" "%%get-annotated-variable-declared-type" "declared-type" "%%get-annotated-variable-variable" "variable" "allocate-annotated-variable" "jazz:allocate-annotated-variable" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Restricted-Binding" define-class () () ("class syntax") #f 795 19 795 42 ("%%get-restricted-binding-type" "type" "%%get-restricted-binding-binding" "binding" "allocate-restricted-binding" "jazz:allocate-restricted-binding" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Annotated-Frame" define-class () () ("class syntax") #f 805 19 805 39 ("%%get-annotated-frame-reset" "reset" "%%get-annotated-frame-variables" "variables" "allocate-annotated-frame" "jazz:allocate-annotated-frame" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Code" define-class () () ("class syntax") #f 815 19 815 28 ("%%get-code-source" "source" "%%get-code-type" "type" "%%get-code-form" "form" "allocate-code" "jazz:allocate-code" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Access" define-class () () ("class syntax") #f 827 19 827 30 ("%%get-access-context" "context" "%%get-access-name" "name" "allocate-access" "jazz:allocate-access" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Expression" define-class () () ("class syntax") #f 837 19 837 34 ("%%get-expression-source" "source" "%%get-expression-type" "type" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Expression~virtual") #f 842 22 842 42 ("environment" "declaration")}
      {Lisp-Entry "emit-call" generic/specific () ("arguments" "declaration" "environment") ("jazz:Expression~virtual") #f 843 22 843 36 ("environment" "declaration" "arguments")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Expression~virtual") #f 844 22 844 42 ("s" "k" "f")}
      {Lisp-Entry "Proclaim" define-class () () ("class syntax") #f 852 19 852 32 ("%%get-proclaim-clauses" "clauses" "allocate-proclaim" "jazz:allocate-proclaim" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Constant" define-class () () ("class syntax") #f 861 19 861 32 ("%%get-constant-expansion" "expansion" "allocate-constant" "jazz:allocate-constant" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Delay" define-class () () ("class syntax") #f 870 19 870 29 ("%%get-delay-expression" "expression" "allocate-delay" "jazz:allocate-delay" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Quasiquote" define-class () () ("class syntax") #f 879 19 879 34 ("%%get-quasiquote-form" "form" "allocate-quasiquote" "jazz:allocate-quasiquote" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Binding-Reference" define-class () () ("class syntax") #f 888 19 888 41 ("%%get-reference-binding" "binding" "allocate-binding-reference" "jazz:allocate-binding-reference" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Reference-Reification" define-class () () ("class syntax") #f 897 19 897 45 ("%%get-reference-reification-resolver" "resolver" "%%get-reference-reification-reference" "reference" "allocate-reference-reification" "jazz:allocate-reference-reification" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Method-Reference" define-class () () ("class syntax") #f 907 19 907 40 ("allocate-method-reference" "jazz:allocate-method-reference" "Object-Class" "jazz:Object-Class" "binding" "source" "type" "Binding-Reference" "jazz:Binding-Reference")}
      {Lisp-Entry "Assignment" define-class () () ("class syntax") #f 916 19 916 34 ("%%get-assignment-value" "value" "%%get-assignment-binding" "binding" "allocate-assignment" "jazz:allocate-assignment" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Lambda" define-class () () ("class syntax") #f 926 19 926 30 ("%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "allocate-lambda" "jazz:allocate-lambda" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Let" define-class () () ("class syntax") #f 936 19 936 27 ("%%get-let-body" "body" "%%get-let-bindings" "bindings" "allocate-let" "jazz:allocate-let" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Named-Let" define-class () () ("class syntax") #f 946 19 946 33 ("%%get-named-let-variable" "variable" "allocate-named-let" "jazz:allocate-named-let" "Object-Class" "jazz:Object-Class" "body" "bindings" "source" "type" "Let" "jazz:Let")}
      {Lisp-Entry "Letstar" define-class () () ("class syntax") #f 955 19 955 31 ("%%get-letstar-body" "body" "%%get-letstar-bindings" "bindings" "allocate-letstar" "jazz:allocate-letstar" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Letrec" define-class () () ("class syntax") #f 965 19 965 30 ("%%get-letrec-body" "body" "%%get-letrec-bindings" "bindings" "allocate-letrec" "jazz:allocate-letrec" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Receive" define-class () () ("class syntax") #f 975 19 975 31 ("%%get-receive-body" "body" "%%get-receive-expression" "expression" "%%get-receive-variables" "variables" "allocate-receive" "jazz:allocate-receive" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Body" define-class () () ("class syntax") #f 986 19 986 28 ("%%get-body-expressions" "expressions" "%%get-body-internal-defines" "internal-defines" "allocate-body" "jazz:allocate-body" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Internal-Define" define-class () () ("class syntax") #f 996 19 996 39 ("%%get-internal-define-value" "value" "%%get-internal-define-variable" "variable" "allocate-internal-define" "jazz:allocate-internal-define" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Begin" define-class () () ("class syntax") #f 1006 19 1006 29 ("%%get-begin-expressions" "expressions" "allocate-begin" "jazz:allocate-begin" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Do" define-class () () ("class syntax") #f 1015 19 1015 26 ("%%get-do-body" "body" "%%get-do-result" "result" "%%get-do-test" "test" "%%get-do-bindings" "bindings" "allocate-do" "jazz:allocate-do" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Call" define-class () () ("class syntax") #f 1027 19 1027 28 ("%%get-call-arguments" "arguments" "%%get-call-operator" "operator" "allocate-call" "jazz:allocate-call" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "If" define-class () () ("class syntax") #f 1037 19 1037 26 ("%%get-if-no" "no" "%%get-if-yes" "yes" "%%get-if-test" "test" "allocate-if" "jazz:allocate-if" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Cond" define-class () () ("class syntax") #f 1048 19 1048 28 ("%%get-cond-clauses" "clauses" "allocate-cond" "jazz:allocate-cond" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Case" define-class () () ("class syntax") #f 1057 19 1057 28 ("%%get-case-clauses" "clauses" "%%get-case-target" "target" "allocate-case" "jazz:allocate-case" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "And" define-class () () ("class syntax") #f 1067 19 1067 27 ("%%get-and-expressions" "expressions" "allocate-and" "jazz:allocate-and" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Or" define-class () () ("class syntax") #f 1076 19 1076 26 ("%%get-or-expressions" "expressions" "allocate-or" "jazz:allocate-or" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Declare" define-class () () ("class syntax") #f 1085 19 1085 31 ("%%get-declare-declarations" "declarations" "allocate-declare" "jazz:allocate-declare" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "C-Include" define-class () () ("class syntax") #f 1094 19 1094 33 ("%%get-c-include-name" "name" "allocate-c-include" "jazz:allocate-c-include" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "C-Declare" define-class () () ("class syntax") #f 1103 19 1103 33 ("%%get-c-declare-code" "code" "allocate-c-declare" "jazz:allocate-c-declare" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "C-Named-Declare-Declaration" define-class () () ("class syntax") #f 1112 19 1112 51 ("%%get-c-named-declare-declaration-code" "code" "allocate-c-named-declare-declaration" "jazz:allocate-c-named-declare-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "C-Initialize" define-class () () ("class syntax") #f 1121 19 1121 36 ("%%get-c-initialize-code" "code" "allocate-c-initialize" "jazz:allocate-c-initialize" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "C-Function" define-class () () ("class syntax") #f 1130 19 1130 34 ("%%get-c-function-expansion" "expansion" "allocate-c-function" "jazz:allocate-c-function" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Parameterize" define-class () () ("class syntax") #f 1139 19 1139 36 ("%%get-parameterize-body" "body" "%%get-parameterize-bindings" "bindings" "allocate-parameterize" "jazz:allocate-parameterize" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Time-Special" define-class () () ("class syntax") #f 1149 19 1149 36 ("%%get-time-special-expressions" "expressions" "allocate-time" "jazz:allocate-time" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Walk-Failed-Special" define-class () () ("class syntax") #f 1158 19 1158 43 ("%%get-walk-failed-special-answer" "answer" "allocate-walk-failed" "jazz:allocate-walk-failed" "Object-Class" "jazz:Object-Class" "source" "type" "Expression" "jazz:Expression")}
      {Lisp-Entry "Analysis-Data" define-class () () ("class syntax") #f 1167 19 1167 37 ("%%set-analysis-data-declaration-references" "%%get-analysis-data-declaration-references" "declaration-references" "%%set-analysis-data-autoload-reference" "%%get-analysis-data-autoload-reference" "autoload-reference" "allocate-analysis-data" "jazz:allocate-analysis-data" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Core-Dialect" define-class () () ("class syntax") #f 1177 19 1177 36 ("allocate-core-dialect" "jazz:allocate-core-dialect" "Object-Class" "jazz:Object-Class" "bindings" "Dialect" "jazz:Dialect")}
      {Lisp-Entry "Core-Walker" define-class () () ("class syntax") #f 1186 19 1186 35 ("allocate-core-walker" "jazz:allocate-core-walker" "Object-Class" "jazz:Object-Class" "autoloads" "references" "variables" "literals" "errors" "warnings" "Walker" "jazz:Walker")}}})
"define-class"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "define-class.scm"} 231466230. scheme
    {Lisp-Entry "core.class.syntax.define-class" unit (protected) () #f #f 37 16 37 46 ()
      {Lisp-Entry "define-class" define-macro () () ("macro") #f 40 20 40 37 (",inherited-slot-names" ",',inherited-slot-names" "validate-inherited-slots" "jazz:validate-inherited-slots" "reference-name" "jazz:reference-name" "set-core-class" "jazz:set-core-class" ",instance-size" ",',instance-size" ",slot-names" ",',slot-names" ",ascendant-accessor" ",',ascendant-accessor" "eq?" "test:" "%%make-table" ",class-accessor" ",',class-accessor" "new-core-class" "jazz:new-core-class" ",',name" "%%string-append" "%%string->symbol" "naturals" "jazz:naturals" "%%object-set!" "value" ",slot-setter" ",rank" "%%object-ref" "expected-error" "jazz:expected-error" "object-of-class?" "jazz:object-of-class?" "%%core-assertion" "object" ",slot-getter" "%%cddr" "slot-setter" "%%cadr" "slot-getter" "%%car" "let" "rank" "slot" "%%object" "%%list" ",@all-variables" "class" ",constructor" "define-macro" "jazz:define-macro" ",name" "define-variable" "jazz:define-variable" "debug-core?" "jazz:debug-core?" "begin" "object-size" "jazz:object-size" "%%fx+" "instance-size" "all-length" "%%symbol->string" "generate-symbol" "jazz:generate-symbol" "slot-name" "lambda" "all-variables" "%%append" "all-slot-names" "car" "map" "slot-names" "%%length" "ascendant-size" "ascendant-accessor" "%%null?" "if" "class-accessor" "let*" "proc" "parse-define-class" "jazz:parse-define-class" "define" "slots" "constructor" "class-name" "inherited-slot-names" "ascendant-name" "name")}
      {Lisp-Entry "define-class-runtime" define-macro () () ("macro") #f 95 20 95 45 ("%%symbol->string" "%%string-append" "%%string->symbol" "name")}}})
"define-method"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "define-method.scm"} 231466230. scheme
    {Lisp-Entry "core.class.syntax.define-method" unit (protected) () #f #f 37 16 37 47 ()
      {Lisp-Entry "define-virtual" define-macro () () ("macro") #f 40 20 40 39 ("expand-define-virtual" "jazz:expand-define-virtual" "%%car" "%%null?" "if" "bootstrap-type?" "let" "rest" "signature")}
      {Lisp-Entry "define-virtual-runtime" define-macro () () ("macro") #f 45 20 45 47 ("expand-define-virtual-runtime" "jazz:expand-define-virtual-runtime" "signature")}
      {Lisp-Entry "define-method" define-macro () () ("macro") #f 49 20 49 38 ("expand-define-method" "jazz:expand-define-method" "body" "signature")}}})
"define-method-expander"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "define-method-expander.scm"} 231466230. scheme
    {Lisp-Entry "core.class.syntax.define-method-expander" unit (protected) () #f #f 37 16 37 56 ()
      {Lisp-Entry "expand-define-virtual" define () ("signature" "bootstrap-type?") #f #f 40 9 40 35 ("obj" "lambda" "with-uniqueness" "jazz:with-uniqueness" ",rank-name" "%%get-object-class" "%%get-class-core-vtable" "%%vector-ref" "format" "jazz:format" "error" "jazz:error" ",class-name" ",is-test" "%%core-assertion" "%%list" "%%symbol?" ",@extra-parameters" ",object-parameter" ",name" "define-macro" "jazz:define-macro" "%%class-is?" "jazz:bootstrap-type?" "if" "is-test" "method-rank-name" "jazz:method-rank-name" "rank-name" "method-implementation-name" "jazz:method-implementation-name" "implementation-name" "extra-parameters" "%%cadr" "object-parameter" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "bootstrap-type?" "signature")}
      {Lisp-Entry "expand-define-virtual-runtime" define () ("signature") #f #f 75 9 75 43 (",name" ",class-name" "register-virtual-name" "jazz:register-virtual-name" ",rank-name" "define" "method-rank-name" "jazz:method-rank-name" "rank-name" "method-implementation-name" "jazz:method-implementation-name" "implementation-name" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "signature")}
      {Lisp-Entry "expand-define-method" define () ("signature" "body") #f #f 85 9 85 34 ("register-method" "jazz:register-method" ",@body" ",@extra-parameters" ",object-parameter" "lambda" ",name" ",class-name" "find-nextmethod" "jazz:find-nextmethod" "nextmethod" "let" ",implementation-name" "define" "begin" "method-implementation-name" "jazz:method-implementation-name" "implementation-name" "extra-parameters" "%%cadr" "object-parameter" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "body" "signature")}
      {Lisp-Entry "method-implementation-name" define () ("class-name" "name") #f #f 100 9 100 40 ("%%string-append" "%%string->symbol" "%%symbol->string" "split-string" "jazz:split-string" "last" "jazz:last" "let" "name" "class-name")}
      {Lisp-Entry "method-rank-name" define () ("implementation-name") #f #f 105 9 105 30 ("%%symbol->string" "%%string-append" "%%string->symbol" "implementation-name")}
      {Lisp-Entry "inherited-name?" define () ("class" "method-name") #f #f 109 9 109 29 ("%%get-class-core-virtual-names" "%%memq" "and" "%%get-class-ascendant" "ascendant" "let" "method-name" "class")}
      {Lisp-Entry "register-virtual-name" define () ("class" "method-name") #f #f 115 9 115 35 ("1" "%%length" "%%fx-" "%%list" "%%get-class-core-virtual-names" "%%append" "%%set-class-core-virtual-names" "method-name" "class")}
      {Lisp-Entry "register-method" define () ("class" "method-name" "method-implementation") #f #f 123 9 123 29 ("%%get-class-core-virtual-alist" "%%set-class-core-virtual-alist" "%%cons" "%%list" "%%get-class-core-method-alist" "%%append" "%%set-class-core-method-alist" "inherited-name?" "jazz:inherited-name?" "if" "method-implementation" "method-name" "class")}
      {Lisp-Entry "get-method-rank" define () ("class" "method-name") #f #f 133 9 133 29 ("1" "%%fx+" "%%cdr" "%%car" "%%eq?" "error" "jazz:error" "%%null?" "if" "0" "rank" "%%get-class-core-virtual-names" "scan" "iter" "let" "method-name" "class")}
      {Lisp-Entry "get-method-implementation" define () ("class" "method-name") #f #f 143 9 143 39 ("get-method-rank" "jazz:get-method-rank" "%%get-class-core-vtable" "%%vector-ref" "method-name" "class")}
      {Lisp-Entry "find-nextmethod" define () ("class" "method-name") #f #f 148 9 148 29 ("error" "jazz:error" "rest" "obj" "lambda" "%%get-class-ascendant" "get-method-implementation" "jazz:get-method-implementation" "inherited-name?" "jazz:inherited-name?" "if" "method-name" "class")}}})
"development"
 ({Lisp-File-Entry {File :context "src" "core" "module" "development.scm"} 231466230. scheme
    {Lisp-Entry "core.module.development" unit () () #f #f 38 6 38 29 ()
      {Lisp-Entry "require" require () () #f #f 41 1 41 8 ("core.base")}
      {Lisp-Entry "parse" define () ("unit-name") #f #f 49 9 49 19 ("desourcify-all" "jazz:desourcify-all" "pretty-print" "read-toplevel-form" "jazz:read-toplevel-form" "form-src" "find-unit-src" "jazz:find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "parse-source" define () ("unit-name") #f #f 56 9 56 26 ("present-source" "jazz:present-source" "pretty-print" "read-toplevel-form" "jazz:read-toplevel-form" "form-src" "find-unit-src" "jazz:find-unit-src" "src" "let*" "interpret" "walk-for" "jazz:walk-for" "parameterize" "unit-name")}
      {Lisp-Entry "expand-unit" define () ("unit-name" "#!key" "(walk-for #f)") #f #f 69 9 69 25 ("expand-module-source" "jazz:expand-module-source" "module" "expand-unit-source" "jazz:expand-unit-source" "unit" "case" "0" "generate-symbol-counter" "jazz:generate-symbol-counter" "generate-symbol-context" "jazz:generate-symbol-context" "generate-symbol-for" "jazz:generate-symbol-for" "requested-unit-resource" "jazz:requested-unit-resource" "requested-unit-name" "jazz:requested-unit-name" "cdr" "rest" "car" "source-code" "jazz:source-code" "kind" "read-toplevel-form" "jazz:read-toplevel-form" "form" "find-unit-src" "jazz:find-unit-src" "src" "let*" "walk" "or" "jazz:walk-for" "parameterize" "walk-for" "#!key" "unit-name")}
      {Lisp-Entry "expand" define () ("unit-name" "." "rest") #f #f 85 9 85 20 ("current-output-port" "expand-to-port" "jazz:expand-to-port" "apply" "rest" "unit-name")}
      {Lisp-Entry "expand-to-port" define () ("unit-name" "port" "." "rest") #f #f 89 9 89 28 ("expand-unit" "jazz:expand-unit" "apply" "desourcify-all" "jazz:desourcify-all" "pretty-print" "rest" "port" "unit-name")}
      {Lisp-Entry "expand-to-file" define () ("unit-name" "#!key" "(file #f)" "#!rest" "rest") #f #f 95 9 95 28 ("expand-to-port" "jazz:expand-to-port" "apply" "port" "lambda" "or" "call-with-output-file" "scheme-readtable" "jazz:scheme-readtable" "current-readtable" "parameterize" "rest" "#!rest" "file" "#!key" "unit-name")}
      {Lisp-Entry "expand-source" define () ("unit-name" "." "rest") #f #f 102 9 102 27 ("expand-unit" "jazz:expand-unit" "apply" "present-source" "jazz:present-source" "pretty-print" "rest" "unit-name")}
      {Lisp-Entry "lookup" define () ("module-name" "name" "access") #f #f 113 9 113 20 ("walk-unit" "jazz:walk-unit" "lookup-declaration" "jazz:lookup-declaration" "access" "name" "module-name")}}})
"error"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "error.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.error" unit (protected) () #f #f 37 16 37 39 ()
      {Lisp-Entry "unimplemented" define () ("." "rest") #f #f 40 9 40 27 ("%%car" "error" "jazz:error" "%%null?" "if" "rest")}}}
  {Lisp-File-Entry {File :context "src" "core" "class" "syntax" "error.scm"} 231466230. scheme
    {Lisp-Entry "core.class.syntax.error" unit (protected) () #f #f 37 16 37 39 ()
      {Lisp-Entry "object-of-class?" define-macro () () ("variable") #f 40 22 40 43 ()}
      {Lisp-Entry "not-object-error" define () ("obj") #f #f 43 9 43 30 ("error" "jazz:error" "obj")}
      {Lisp-Entry "outside-object-error" define () ("obj" "rnk") #f #f 47 9 47 34 ("error" "jazz:error" "rnk" "obj")}
      {Lisp-Entry "expected-error" define () ("class" "obj") #f #f 51 9 51 28 ("error" "jazz:error" "obj" "class")}}}
  {Lisp-File-Entry {File :context "src" "core" "exception" "runtime" "error.scm"} 231466230. scheme
    {Lisp-Entry "core.exception.runtime.error" unit (protected) () #f #f 37 16 37 44 ("raise-jazz-error" "jazz:raise-jazz-error" "error" "jazz:error" "set!" "encapsulate-class" "jazz:encapsulate-class" "Error" "jazz:Error")
      {Lisp-Entry "Error" define-class () () ("class runtime") #f 40 27 40 37 ()}
      {Lisp-Entry "new-error" define () ("message") #f #f 43 9 43 23 ("Error" "jazz:Error" "allocate-error" "jazz:allocate-error" "message")}
      {Lisp-Entry "get-message" generic/specific () () ("jazz:Error") #f 47 21 47 37 ("error" "%%get-error-message")}
      {Lisp-Entry "present-exception" generic/specific () () ("jazz:Error") #f 51 21 51 43 ("error" "%%get-error-message")}
      {Lisp-Entry "raise-jazz-error" define () ("fmt-string" "." "rest") #f #f 58 9 58 30 ("new-error" "jazz:new-error" "raise" "format" "jazz:format" "apply" "message" "let" "proper-tail-calls" "declare" "rest" "fmt-string")}}})
"exception"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "exception.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.exception" unit (protected) () #f #f 38 16 38 43 ()
      {Lisp-Entry "current-exception-handler" define () () #f #f 43 12 43 42 ("current-exception-handler")}
      {Lisp-Entry "with-exception-handler" define () ("proc" "thunk") #f #f 46 13 46 40 ("continuation-return" "exc" "with-exception-handler" "return" "lambda" "continuation-capture" "thunk" "proc")}
      {Lisp-Entry "exception-reason" define () ("exc") #f #f 54 13 54 34 ("format" "jazz:format" "%%not" "if" "arguments" "message" "condition-property-accessor" "location" "let" "exc")}
      {Lisp-Entry "current-exception-handler" define () () #f #f 63 12 63 42 ("current-exception-handler")}
      {Lisp-Entry "with-exception-handler" define () () #f #f 66 12 66 39 ("with-exception-handler")}
      {Lisp-Entry "with-exception-catcher" define () () #f #f 69 12 69 39 ("with-exception-catcher")}
      {Lisp-Entry "display-exception" define () () #f #f 72 12 72 34 ("display-exception")}
      {Lisp-Entry "display-continuation-backtrace" define () () #f #f 75 12 75 47 ("display-continuation-backtrace")}
      {Lisp-Entry "raise" define () ("obj") #f #f 78 13 78 23 ("raise" "obj")}}}
  {Lisp-File-Entry {File :context "src" "core" "exception" "runtime" "exception.scm"} 231466230. scheme
    {Lisp-Entry "core.exception.runtime.exception" unit (protected) () #f #f 37 16 37 48 ("newline" "present-exception" "jazz:present-exception" "display" "begin" "%%is?" "%%object?" "and" "if" "port" "exc" "lambda" "set!" "##display-exception-hook" "previous-hook" "let" "System-Exception" "jazz:System-Exception" "Exception-Detail" "jazz:Exception-Detail" "encapsulate-class" "jazz:encapsulate-class" "Exception" "jazz:Exception")
      {Lisp-Entry "Exception" define-class () () ("class runtime") #f 45 27 45 41 ()}
      {Lisp-Entry "print-object" generic/specific () ("output" "detail") ("jazz:Exception") #f 48 21 48 38 ("if" "object->serial" "jazz:object->serial" "format" "jazz:format" "exception" "get-message" "jazz:get-message" "message" "let" "detail" "output")}
      {Lisp-Entry "present-exception" generic/specific () () ("jazz:Exception~virtual-runtime") #f 56 30 56 52 ()}
      {Lisp-Entry "get-message" generic/specific () () ("jazz:Exception~virtual-runtime") #f 57 30 57 46 ()}
      {Lisp-Entry "get-detail" generic/specific () () ("jazz:Exception~virtual-runtime") #f 58 30 58 45 ()}
      {Lisp-Entry "present-exception" generic/specific () () ("jazz:Exception") #f 61 21 61 43 ("get-output-string" "exception" "format" "jazz:format" "open-output-string" "output" "let")}
      {Lisp-Entry "get-message" generic/specific () () ("jazz:Exception") #f 67 21 67 37 ()}
      {Lisp-Entry "get-detail" generic/specific () () ("jazz:Exception") #f 71 21 71 36 ()}
      {Lisp-Entry "Exception-Detail" define-class () () ("class runtime") #f 83 27 83 48 ()}
      {Lisp-Entry "new-exception-detail" define () ("icon" "title" "location" "children") #f #f 86 9 86 34 ("Exception-Detail" "jazz:Exception-Detail" "allocate-exception-detail" "jazz:allocate-exception-detail" "children" "location" "title" "icon")}
      {Lisp-Entry "System-Exception" define-class () () ("class runtime") #f 98 27 98 48 ()}
      {Lisp-Entry "present-exception" generic/specific () () ("jazz:System-Exception") #f 101 21 101 43 ("exception" "%%get-system-exception-exception" "exception-reason" "jazz:exception-reason")}
      {Lisp-Entry "exception-reason" define () ("exc") #f #f 113 9 113 30 ("%%substring" "1" "%%fx-" "%%string-ref" "%%eqv?" "0" "%%fx>" "and" "if" "string-length" "len" "get-output-string" "str" "display-exception" "jazz:display-exception" "open-output-string" "output" "let" "exc")}
      {Lisp-Entry "exception-detail" define () ("exc") #f #f 124 9 124 30 ("get-detail" "jazz:get-detail" "Exception" "jazz:Exception" "%%is?" "%%object?" "and" "if" "exc")}
      {Lisp-Entry "exception-location" define () ("exc" "cont") #f #f 131 9 131 32 ("##exception->locat" "cont" "exc")}
      {Lisp-Entry "with-exception-filter" define () ("filter" "catcher" "thunk") #f #f 156 9 156 35 ("%%continuation-graft" "filter-exc" "if" "exc" "with-exception-handler" "catcher-cont" "lambda" "%%continuation-capture" "current-exception-handler" "previous-handler" "let" "thunk" "catcher" "filter")}
      {Lisp-Entry "with-exception-propagater" define () ("handler" "thunk") #f #f 181 9 181 39 ("current-exception-handler" "let" "%%continuation-graft" "raise-cont" "exc" "with-exception-handler" "catcher-cont" "lambda" "%%continuation-capture" "thunk" "handler")}}})
"expander"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "syntax" "expander.scm"} 231466230. scheme
    {Lisp-Entry "core.generic.syntax.expander" unit (protected) () #f #f 38 16 38 44 ()
      {Lisp-Entry "dynamic-parameter?" define () ("parameter") #f #f 41 9 41 32 ("%%cdr" "composite-identifier?" "jazz:composite-identifier?" "or" "%%car" "type" "let" "%%pair?" "and" "parameter")}
      {Lisp-Entry "dynamic-parameter-type" define () ("parameter") #f #f 49 9 49 36 ("specifier->name" "jazz:specifier->name" "specifier?" "jazz:specifier?" "if" "%%car" "type" "let" "parameter")}
      {Lisp-Entry "dynamic-parameter-types" define () ("parameters") #f #f 56 9 56 37 ("%%cdr" "dynamic-parameter-type" "jazz:dynamic-parameter-type" "%%cons" "%%car" "dynamic-parameter?" "jazz:dynamic-parameter?" "%%pair?" "and" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "dynamic-parameter-name" define () ("parameter") #f #f 65 9 65 36 ("%%cadr" "parameter")}
      {Lisp-Entry "dynamic-parameter-names" define () ("parameters") #f #f 69 9 69 37 ("%%cdr" "dynamic-parameter-name" "jazz:dynamic-parameter-name" "%%cons" "%%car" "dynamic-parameter?" "jazz:dynamic-parameter?" "%%pair?" "and" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "generic-parameters" define () ("parameters") #f #f 78 9 78 32 ("reverse!" "jazz:reverse!" "values" "else" "%%symbol?" "dynamic-parameter-name" "jazz:dynamic-parameter-name" "%%cons" "%%cdr" "dynamic-parameter?" "jazz:dynamic-parameter?" "cond" "%%car" "parameter" "%%pair?" "if" "result" "iterate" "let" "parameters")}
      {Lisp-Entry "specific-parameters" define () ("parameters") #f #f 92 9 92 33 ("else" "%%cdr" "dynamic-parameter-name" "jazz:dynamic-parameter-name" "%%cons" "dynamic-parameter?" "jazz:dynamic-parameter?" "cond" "%%car" "parameter" "%%pair?" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "expand-define-generic" define () ("signature" "." "body") #f #f 108 9 108 35 ("apply" "dynamic-parameter-names" "jazz:dynamic-parameter-names" ",parameter" "class-of" "jazz:class-of" "parameter" "map" "%%specific-dispatch" ",gensym-specific" "process-pending-specifics" "jazz:process-pending-specifics" "%%get-generic-pending-specifics" "%%not" "%%when" ",gensym-rest" ",@mandatory-parameters" ",@dynamic-signature" "%%list" "new-generic" "jazz:new-generic" "generic-reset" "jazz:generic-reset" "global-ref" "jazz:global-ref" ",gensym-generic" "global-bound?" "jazz:global-bound?" ",generic-locator" ",@body" ",generic-method-locator" "error" "jazz:error" ",formal-signature" "lambda" ",specific-implementation-locator" "define" "begin" "%%null?" "if" "gensym-rest" "let" "generic-parameters" "jazz:generic-parameters" "extra-parameters" "mandatory-parameters" "receive" "gensym-specific" "generate-symbol" "jazz:generate-symbol" "gensym-generic" "generic-object-locator" "jazz:generic-object-locator" "generic-locator" "implementation-locator" "jazz:implementation-locator" "specific-implementation-locator" "specific-parameters" "jazz:specific-parameters" "formal-signature" "dynamic-parameter-types" "jazz:dynamic-parameter-types" "dynamic-signature" "%%cdr" "parameters" "%%car" "generic-method-locator" "let*" "body" "signature")}
      {Lisp-Entry "generic-object-locator" define () ("locator") #f #f 144 9 144 36 ("%%symbol->string" "%%string-append" "%%string->symbol" "locator")}
      {Lisp-Entry "expand-define-specific" define () ("signature" "modifier" "." "body") #f #f 153 9 153 36 (",generic-locator" "register-specific" "jazz:register-specific" "%%set-specific-implementation" ",@body" ",@nextmethod-bindings" "let" ",formal-signature" ",gensym-lambda" ",@dynamic-signature" "lambda" "new-specific" "jazz:new-specific" ",specific-implementation-locator" "define" ",gensym-specific" "%%get-specific-ancestor-specifics" "%%get-specific-implementation" "nextmethod" "%%list" "if" "nextmethod-bindings" "gensym-lambda" "generate-symbol" "jazz:generate-symbol" "gensym-specific" "generic-object-locator" "jazz:generic-object-locator" "generic-locator" "implementation-locator" "jazz:implementation-locator" "specific-implementation-locator" "specific-parameters" "jazz:specific-parameters" "formal-signature" "dynamic-parameter-types" "jazz:dynamic-parameter-types" "dynamic-signature" "%%cdr" "parameters" "%%car" "generic-method-locator" "root" "%%eq?" "root?" "let*" "body" "modifier" "signature")}
      {Lisp-Entry "implementation-locator" define () ("generic-locator" "dynamic-signature") #f #f 174 9 174 36 ("join-strings" "jazz:join-strings" "%%string-append" "%%string->symbol" "%%car" "%%pair?" "if" "class/call" "lambda" "map" "dynamic-signature-strings" "%%symbol->string" "generic-string" "let" "dynamic-signature" "generic-locator")}}})
"expression"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "walker" "expression.scm"} 233720808. scheme
    {Lisp-Entry "core.module.syntax.walker.expression" unit (protected) () #f #f 37 16 37 52 ("Walker" "jazz:Walker" "Time-Special" "jazz:Time-Special" "Parameterize" "jazz:Parameterize" "Declare" "jazz:Declare" "Or" "jazz:Or" "And" "jazz:And" "Case" "jazz:Case" "Cond" "jazz:Cond" "If" "jazz:If" "not-null?" "jazz.dialect.kernel:not-null?" "not-type-tests" "jazz:not-type-tests" "Unspecified" "jazz:Unspecified" "unspecified?" "jazz.dialect.kernel:unspecified?" "Values" "jazz:Values" "values?" "jazz.dialect.kernel:values?" "Foreign" "jazz:Foreign" "foreign?" "jazz.dialect.kernel:foreign?" "Thread" "jazz:Thread" "thread?" "jazz.dialect.kernel:thread?" "Table" "jazz:Table" "table?" "jazz.dialect.kernel:table?" "Method" "jazz:Method" "method?" "jazz.dialect.kernel:method?" "Slot" "jazz:Slot" "slot?" "jazz.dialect.kernel:slot?" "Field" "jazz:Field" "field?" "jazz.dialect.kernel:field?" "Interface" "jazz:Interface" "interface?" "jazz.dialect.kernel:interface?" "Class" "jazz:Class" "class?" "jazz.dialect.kernel:class?" "Category" "jazz:Category" "category?" "jazz.dialect.kernel:category?" "Object" "jazz:Object" "object?" "jazz.dialect.kernel:object?" "Keyword" "jazz:Keyword" "keyword?" "jazz.dialect.kernel:keyword?" "Flonum" "jazz:Flonum" "flonum?" "jazz.dialect.kernel:flonum?" "Fixnum" "jazz:Fixnum" "fixnum?" "jazz.dialect.kernel:fixnum?" "EOF" "jazz:EOF" "eof-object?" "scheme.dialect.kernel:eof-object?" "output-port?" "scheme.dialect.kernel:output-port?" "Port" "jazz:Port" "input-port?" "scheme.dialect.kernel:input-port?" "Procedure" "jazz:Procedure" "procedure?" "scheme.dialect.kernel:procedure?" "Continuation" "jazz:Continuation" "continuation?" "jazz.dialect.kernel:continuation?" "F64Vector" "jazz:F64Vector" "f64vector?" "jazz.dialect.kernel:f64vector?" "F32Vector" "jazz:F32Vector" "f32vector?" "jazz.dialect.kernel:f32vector?" "U64Vector" "jazz:U64Vector" "u64vector?" "jazz.dialect.kernel:u64vector?" "S64Vector" "jazz:S64Vector" "s64vector?" "jazz.dialect.kernel:s64vector?" "U32Vector" "jazz:U32Vector" "u32vector?" "jazz.dialect.kernel:u32vector?" "S32Vector" "jazz:S32Vector" "s32vector?" "jazz.dialect.kernel:s32vector?" "U16Vector" "jazz:U16Vector" "u16vector?" "jazz.dialect.kernel:u16vector?" "S16Vector" "jazz:S16Vector" "s16vector?" "jazz.dialect.kernel:s16vector?" "U8Vector" "jazz:U8Vector" "u8vector?" "jazz.dialect.kernel:u8vector?" "S8Vector" "jazz:S8Vector" "s8vector?" "jazz.dialect.kernel:s8vector?" "Vector" "jazz:Vector" "vector?" "scheme.dialect.kernel:vector?" "String" "jazz:String" "string?" "scheme.dialect.kernel:string?" "Char" "jazz:Char" "char?" "scheme.dialect.kernel:char?" "Symbol" "jazz:Symbol" "symbol?" "scheme.dialect.kernel:symbol?" "Pair" "jazz:Pair" "pair?" "scheme.dialect.kernel:pair?" "Null" "jazz:Null" "null?" "scheme.dialect.kernel:null?" "List" "jazz:List" "list?" "scheme.dialect.kernel:list?" "Boolean" "jazz:Boolean" "boolean?" "scheme.dialect.kernel:boolean?" "Integer" "jazz:Integer" "integer?" "scheme.dialect.kernel:integer?" "Rational" "jazz:Rational" "rational?" "scheme.dialect.kernel:rational?" "Real" "jazz:Real" "real?" "scheme.dialect.kernel:real?" "Complex" "jazz:Complex" "complex?" "scheme.dialect.kernel:complex?" "Number" "jazz:Number" "number?" "scheme.dialect.kernel:number?" "type-tests" "jazz:type-tests" "%%table-set!" "string^int^char:void" "<string^int^char:void>" "##string-set!" "vector^int^any:void" "<vector^int^any:void>" "##vector-set!" "set-element!" "jazz.dialect.language.functional:set-element!" "string^int:char" "<string^int:char>" "##string-ref" "vector^int:any" "<vector^int:any>" "##vector-ref" "list^int:any" "<list^int:any>" "list-ref" "element" "jazz.dialect.language.functional" "jazz.dialect.language.functional:element" "string:int" "<string:int>" "##string-length" "vector:int" "<vector:int>" "##vector-length" "list:int" "<list:int>" "##length" "length" "scheme.dialect.kernel:length" "##cdr" "cdr" "scheme.dialect.kernel:cdr" "pair:any" "<pair:any>" "##car" "car" "scheme.dialect.kernel:car" "##eqv?" "eqv?" "scheme.dialect.kernel:eqv?" "any^any:bool" "<any^any:bool>" "##eq?" "eq?" "scheme.dialect.kernel:eq?" "any:bool" "<any:bool>" "##not" "not" "scheme.dialect.kernel:not" "fl:fx" "<fl:fx>" "##flonum->fixnum" "flonum->fixnum" "jazz.dialect.kernel:flonum->fixnum" "fx:fl" "<fx:fl>" "##fixnum->flonum" "fixnum->flonum" "jazz.dialect.kernel:fixnum->flonum" "fl/" "jazz.dialect.kernel:fl/" "fl*" "jazz.dialect.kernel:fl*" "fl-" "jazz.dialect.kernel:fl-" "fl^fl:fl" "<fl^fl:fl>" "fl+" "jazz.dialect.kernel:fl+" "fx*" "jazz.dialect.kernel:fx*" "fx-" "jazz.dialect.kernel:fx-" "fx+" "jazz.dialect.kernel" "jazz.dialect.kernel:fx+" "##flround" "round" "scheme.dialect.kernel:round" "##fltruncate" "truncate" "scheme.dialect.kernel:truncate" "##flceiling" "ceiling" "scheme.dialect.kernel:ceiling" "fl:fl" "<fl:fl>" "##flfloor" "floor" "scheme.dialect.kernel:floor" "fx^fx:fx" "<fx^fx:fx>" "##fxquotient" "quotient" "scheme.dialect.kernel:quotient" "##/" "##fl/" "/" "scheme.dialect.kernel:/" "##*" "##fl*" "##fx*" "*" "scheme.dialect.kernel:*" "##-" "fl^fl*:fl" "<fl^fl*:fl>" "##fl-" "fx^fx*:fx" "<fx^fx*:fx>" "##fx-" "-" "scheme.dialect.kernel:-" "number^number:number" "<number^number:number>" "int^int:int" "<int^int:int>" "##+" "fl*:fl" "<fl*:fl>" "##fl+" "fx*:fx" "<fx*:fx>" "##fx+" "+" "scheme.dialect.kernel:+" "##fl>=" "##fx>=" ">=" "scheme.dialect.kernel:>=" "##fl>" "##fx>" ">" "scheme.dialect.kernel:>" "##fl<=" "##fx<=" "<=" "scheme.dialect.kernel:<=" "##fl<" "##fx<" "<" "scheme.dialect.kernel:<" "number^number:bool" "<number^number:bool>" "##=" "fl*:bool" "<fl*:bool>" "##fl=" "fx*:bool" "<fx*:bool>" "##fx=" "=" "scheme.dialect.kernel" "scheme.dialect.kernel:=" "add-primitive-patterns" "jazz:add-primitive-patterns" "Do" "jazz:Do" "Receive" "jazz:Receive" "Letrec" "jazz:Letrec" "Letstar" "jazz:Letstar" "Named-Let" "jazz:Named-Let" "Let" "jazz:Let" "Lambda" "jazz:Lambda" "Method-Reference" "jazz:Method-Reference" "Quasiquote" "jazz:Quasiquote" "Delay" "jazz:Delay" "encapsulate-class" "jazz:encapsulate-class" "Proclaim" "jazz:Proclaim")
      {Lisp-Entry "Proclaim" define-class () () ("class runtime") #f 45 27 45 40 ()}
      {Lisp-Entry "new-proclaim" define () ("clauses") #f #f 48 9 48 26 ("Proclaim" "jazz:Proclaim" "allocate-proclaim" "jazz:allocate-proclaim" "clauses")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Proclaim") #f 52 21 52 41 ("proclaim" "jazz:proclaim" "clause" "lambda" "for-each" "%%get-declaration-toplevel" "module-declaration" "expression" "%%get-proclaim-clauses" "clauses" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Proclaim") #f 61 21 61 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "Delay" define-class () () ("class runtime") #f 73 27 73 37 ()}
      {Lisp-Entry "new-delay" define () ("expression") #f #f 76 9 76 23 ("Delay" "jazz:Delay" "allocate-delay" "jazz:allocate-delay" "expression")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Delay") #f 80 21 80 41 ("Any" "jazz:Any" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "delay" "new-code" "jazz:new-code" "%%get-delay-expression" "expression" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Delay") #f 88 21 88 41 ("%%get-delay-expression" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "Quasiquote" define-class () () ("class runtime") #f 102 27 102 42 ()}
      {Lisp-Entry "new-quasiquote" define () ("form") #f #f 105 9 105 28 ("Quasiquote" "jazz:Quasiquote" "allocate-quasiquote" "jazz:allocate-quasiquote" "form")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Quasiquote") #f 109 21 109 41 ("List" "jazz:List" "expression" "%%get-quasiquote-form" "quasiquote" "new-code" "jazz:new-code" "%%cdr" "%%cons" "%%cadr" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "%%list" "unquote-splicing" "unquote" "%%car" "%%eq?" "or" "%%pair?" "if" "form" "emit" "define" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Quasiquote") #f 124 21 124 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "Method-Reference" define-class () () ("class runtime") #f 136 27 136 48 ()}
      {Lisp-Entry "new-method-reference" define () ("binding") #f #f 139 9 139 34 ("Method-Reference" "jazz:Method-Reference" "allocate-method-reference" "jazz:allocate-method-reference" "binding")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Method-Reference") #f 143 21 143 41 ("Any" "jazz:Any" "%%get-lexical-binding-type" "or" "%%get-declaration-locator" "new-code" "jazz:new-code" "expression" "%%get-reference-binding" "method-declaration" "let" "environment" "declaration")}
      {Lisp-Entry "emit-call" generic/specific () ("arguments" "declaration" "environment") ("jazz:Method-Reference") #f 152 21 152 35 ("Any" "jazz:Any" "codes-forms" "jazz:codes-forms" "expression" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "new-code" "jazz:new-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Method-Reference") #f 159 21 159 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "Lambda" define-class () () ("class runtime") #f 171 27 171 38 ()}
      {Lisp-Entry "new-lambda" define () ("type" "source" "signature" "body") #f #f 174 9 174 24 ("Lambda" "jazz:Lambda" "allocate-lambda" "jazz:allocate-lambda" "body" "signature" "source" "type")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Lambda") #f 178 21 178 41 ("%%get-expression-source" "new-function-type" "jazz:new-function-type" ",@signature-casts" ",cast-body" ",signature-output" "%%not" "if" "%%get-code-type" "sourcified-form" "jazz:sourcified-form" "begin" "new-code" "jazz:new-code" "emit-type-cast" "jazz:emit-type-cast" "simplify-begin" "jazz:simplify-begin" "cast-body" "emit-signature-casts" "jazz:emit-signature-casts" "signature-casts" "emit-expression" "jazz:emit-expression" "body-code" "emit-signature" "jazz:emit-signature" "signature-output" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "expression" "%%get-expression-type" "type" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Lambda") #f 201 21 201 41 ("%%get-lambda-body" "fold-statement" "jazz:fold-statement" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Lambda") #f 207 21 207 35 ("%%get-lambda-body" "tree-fold" "jazz:tree-fold" "cons" "aug-env" "let" "frame" "lambda" "expression" "%%get-lambda-signature" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Let" define-class () () ("class runtime") #f 225 27 225 35 ()}
      {Lisp-Entry "new-let" define () ("source" "bindings" "body") #f #f 228 9 228 21 ("Let" "jazz:Let" "allocate-let" "jazz:allocate-let" "body" "bindings" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Let") #f 232 21 232 41 ("%%get-expression-source" "sourcified-form" "jazz:sourcified-form" ",bindings-output" "new-code" "jazz:new-code" "body-code" "%%get-lexical-binding-type" "emit-type-cast" "jazz:emit-type-cast" "emit-binding-symbol" "jazz:emit-binding-symbol" "%%get-code-type" "extend-annotated-type" "jazz:extend-annotated-type" "emit-expression" "jazz:emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "annotate-bindings" "jazz:annotate-bindings" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-let-body" "body" "expression" "%%get-let-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Let") #f 256 21 256 41 ("%%get-let-body" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Let") #f 262 21 262 35 ("%%get-let-body" "tree-fold" "jazz:tree-fold" "cdr" "tree-fold-list" "jazz:tree-fold-list" "seed2" "seed1" "car" "map" "cons" "aug-env" "expression" "%%get-let-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Named-Let" define-class () () ("class runtime") #f 278 27 278 41 ()}
      {Lisp-Entry "new-named-let" define () ("source" "variable" "bindings" "body") #f #f 281 9 281 27 ("Named-Let" "jazz:Named-Let" "allocate-named-let" "jazz:allocate-named-let" "body" "bindings" "variable" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Named-Let") #f 285 21 285 41 ("%%get-expression-source" "sourcified-form" "jazz:sourcified-form" ",bindings-output" "new-code" "jazz:new-code" "body-code" "%%get-lexical-binding-type" "emit-type-cast" "jazz:emit-type-cast" "emit-binding-symbol" "jazz:emit-binding-symbol" "%%get-code-type" "extend-annotated-type" "jazz:extend-annotated-type" "emit-expression" "jazz:emit-expression" "value-code" "%%cdr" "value" "%%car" "annotated-variable" "binding" "map" "bindings-output" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "annotate-bindings" "jazz:annotate-bindings" "Any" "jazz:Any" "new-annotated-variable" "jazz:new-annotated-variable" "%%cons" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-let-body" "body" "%%get-let-bindings" "bindings" "expression" "%%get-named-let-variable" "variable" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Named-Let") #f 310 21 310 41 ("%%get-let-body" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Named-Let") #f 316 21 316 35 ("%%get-let-body" "tree-fold" "jazz:tree-fold" "cdr" "tree-fold-list" "jazz:tree-fold-list" "seed2" "seed1" "car" "map" "%%get-named-let-variable" "cons" "aug-env" "expression" "%%get-let-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Letstar" define-class () () ("class runtime") #f 332 27 332 39 ()}
      {Lisp-Entry "new-letstar" define () ("source" "bindings" "body") #f #f 335 9 335 25 ("Letstar" "jazz:Letstar" "allocate-letstar" "jazz:allocate-letstar" "body" "bindings" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Letstar") #f 339 21 339 41 ("%%get-expression-source" "sourcified-form" "jazz:sourcified-form" ",bindings-output" "let*" "new-code" "jazz:new-code" "body-code" "%%get-lexical-binding-type" "emit-type-cast" "jazz:emit-type-cast" "emit-binding-symbol" "jazz:emit-binding-symbol" "%%get-code-type" "extend-annotated-type" "jazz:extend-annotated-type" "emit-expression" "jazz:emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "annotate-bindings" "jazz:annotate-bindings" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-letstar-body" "body" "expression" "%%get-letstar-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Letstar") #f 363 21 363 41 ("%%get-letstar-body" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Letstar") #f 369 21 369 35 ("%%get-letstar-body" "caar" "list" "cons" "cdar" "tree-fold" "jazz:tree-fold" "cdr" "pair?" "if" "aug-env" "seed2" "expression" "%%get-letstar-bindings" "ls" "lp" "let" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Letrec" define-class () () ("class runtime") #f 388 27 388 38 ()}
      {Lisp-Entry "new-letrec" define () ("source" "bindings" "body") #f #f 391 9 391 24 ("Letrec" "jazz:Letrec" "allocate-letrec" "jazz:allocate-letrec" "body" "bindings" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Letrec") #f 395 21 395 41 ("%%get-expression-source" "sourcified-form" "jazz:sourcified-form" ",bindings-output" "letrec" "new-code" "jazz:new-code" "body-code" "%%get-lexical-binding-type" "emit-type-cast" "jazz:emit-type-cast" "emit-binding-symbol" "jazz:emit-binding-symbol" "%%get-code-type" "extend-annotated-type" "jazz:extend-annotated-type" "emit-expression" "jazz:emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "annotate-bindings" "jazz:annotate-bindings" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-letrec-body" "body" "expression" "%%get-letrec-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Letrec") #f 419 21 419 41 ("%%get-letrec-body" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Letrec") #f 425 21 425 35 ("%%get-letrec-body" "tree-fold" "jazz:tree-fold" "cdr" "tree-fold-list" "jazz:tree-fold-list" "seed2" "seed1" "car" "map" "cons" "aug-env" "expression" "%%get-letrec-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Receive" define-class () () ("class runtime") #f 441 27 441 39 ()}
      {Lisp-Entry "new-receive" define () ("source" "variables" "expression" "body") #f #f 444 9 444 25 ("Receive" "jazz:Receive" "allocate-receive" "jazz:allocate-receive" "body" "expression" "variables" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Receive") #f 448 21 448 41 ("%%get-expression-source" "%%get-code-type" ",expression-output" "emit-binding-symbol" "jazz:emit-binding-symbol" "variable" "map" "receive" "new-code" "jazz:new-code" "body-code" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "expression-output" "%%cons" "augmented-environment" "frame" "lambda" "annotate-receive" "jazz:annotate-receive" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-receive-body" "body" "%%get-receive-expression" "expr" "expression" "%%get-receive-variables" "variables" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Receive") #f 467 21 467 41 ("%%get-receive-body" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Receive") #f 473 21 473 35 ("%%get-receive-body" "%%get-receive-expression" "tree-fold" "jazz:tree-fold" "seed2" "seed1" "expression" "%%get-receive-variables" "cons" "aug-env" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Do" define-class () () ("class runtime") #f 488 27 488 34 ()}
      {Lisp-Entry "new-do" define () ("bindings" "test" "result" "body") #f #f 491 9 491 20 ("Do" "jazz:Do" "allocate-do" "jazz:allocate-do" "body" "result" "test" "bindings")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Do") #f 495 21 495 41 ("%%get-code-type" ",bindings-output" "do" "new-code" "jazz:new-code" "body-code" "result-code" "test-code" ",@step-code-list" ",init-code" "emit-binding-symbol" "jazz:emit-binding-symbol" "%%list" "if" "step-code-list" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "init-code" "%%cddr" "step" "%%cadr" "init" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "annotate-bindings" "jazz:annotate-bindings" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-do-body" "body" "%%get-do-result" "result" "%%get-do-test" "test" "expression" "%%get-do-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Do") #f 527 21 527 41 ("%%get-do-body" "%%get-do-result" "%%get-do-test" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Do") #f 535 21 535 35 ("%%get-do-test" "%%get-do-body" "%%get-do-result" "tree-fold" "jazz:tree-fold" "cddr" "or" "x" "lambda" "seed2" "cadr" "tree-fold-list" "jazz:tree-fold-list" "seed1" "expression" "%%get-do-bindings" "car" "map" "cons" "aug-env" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "specializers" define () () #f #f 559 8 559 25 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "add-specializer" define () ("specialized-declaration" "specializer") #f #f 563 9 563 29 ("%%list" "%%table-ref" "%%append" "specializers" "jazz:specializers" "%%table-set!" "specializer" "specialized-declaration")}
      {Lisp-Entry "get-specializers" define () ("binding") #f #f 569 9 569 30 ("specializers" "jazz:specializers" "%%table-ref" "binding")}
      {Lisp-Entry "emit-specialized-call" define-macro () () ("variable-override") #f 573 31 573 57 ("%%cdr" "%%get-function-type-result" "codes-forms" "jazz:codes-forms" ",locator" "new-code" "jazz:new-code" "add-to-module-references" "jazz:add-to-module-references" "emit-inlined-binding-call" "jazz:emit-inlined-binding-call" "match-signature?" "jazz:match-signature?" "%%get-lexical-binding-type" "function-type" "%%car" "specializer" "on" "debug-specializers" "jazz:debug-specializers" "%%get-lexical-binding-name" "specialized" "match" "to" "unable" "%%get-declaration-locator" "In" "Warning:" "debug" "jazz:debug" "/" "scheme.dialect.kernel:/" "*" "scheme.dialect.kernel:*" "-" "scheme.dialect.kernel:-" "+" "scheme.dialect.kernel:+" ">=" "scheme.dialect.kernel:>=" ">" "scheme.dialect.kernel:>" "<=" "scheme.dialect.kernel:<=" "<" "scheme.dialect.kernel:<" "=" "scheme.dialect.kernel" "scheme.dialect.kernel:=" "%%memq" "optimizations" "%%get-declaration-toplevel" "get-module-warn?" "jazz:get-module-warn?" "warnings?" "jazz:warnings?" "and" "%%when" "begin" "%%null?" "scan" "iter" "codes-types" "jazz:codes-types" "types" "get-specializers" "jazz:get-specializers" "specializers" "%%get-reference-binding" "binding" "let" "Binding-Reference" "jazz:Binding-Reference" "%%class-is?" "emit-specialized-locator" "jazz:emit-specialized-locator" "or" "%%not" "if" "environment" "declaration" "call" "arguments-codes" "arguments" "locator" "operator" "lambda")}
      {Lisp-Entry "emit-specialized-locator" define-macro () () ("variable") #f 617 22 617 51 ()}
      {Lisp-Entry "emit-specialized-locator" define-macro () () ("variable-override") #f 619 31 619 60 ("environment" "arguments-codes" "locator" "lambda")}
      {Lisp-Entry "emit-primitive-new-call" define-macro () () ("variable-override") #f 629 31 629 59 ("environment" "declaration" "arguments-codes" "arguments" "locator" "operator" "lambda")}
      {Lisp-Entry "primitive-patterns" define () () #f #f 652 8 652 31 ()}
      {Lisp-Entry "initialize-primitive-patterns" define () () #f #f 656 9 656 43 ("set!" "primitive-patterns" "jazz:primitive-patterns" "walk-specifier" "jazz:walk-specifier" "%%list" "%%cadr" "specifier" "name" "pattern" "map" "%%table-set!" "%%cdr" "patterns" "%%car" "operator" "pair" "lambda" "for-each" "eq?" "test:" "%%make-table" "table" "let")}
      {Lisp-Entry "add-primitive-patterns" define () ("operator" "patterns") #f #f 671 9 671 36 ("%%cons" "primitive-patterns" "jazz:primitive-patterns" "set!" "patterns" "operator")}
      {Lisp-Entry "get-primitive-patterns" define () ("locator") #f #f 675 9 675 36 ("primitive-patterns" "jazz:primitive-patterns" "%%table-ref" "locator")}
      {Lisp-Entry "emit-primitive-call" define-macro () () ("variable-override") #f 724 31 724 55 ("%%cdr" "%%get-function-type-result" "codes-forms" "jazz:codes-forms" ",name" "new-code" "jazz:new-code" "match-signature?" "jazz:match-signature?" "%%car" "function-type" "name" "bind" "jazz:bind" "reference-name" "jazz:reference-name" "primitive" "call" "match" "to" "unable" "%%get-declaration-locator" "In" "Warning:" "debug" "jazz:debug" "cdr" "scheme.dialect.kernel:cdr" "car" "scheme.dialect.kernel" "scheme.dialect.kernel:car" "%%memq" "optimizations" "%%get-declaration-toplevel" "get-module-warn?" "jazz:get-module-warn?" "warnings?" "jazz:warnings?" "and" "%%when" "begin" "%%null?" "scan" "iter" "codes-types" "jazz:codes-types" "types" "get-primitive-patterns" "jazz:get-primitive-patterns" "patterns" "let" "%%not" "if" "environment" "declaration" "arguments-codes" "arguments" "locator" "operator" "lambda")}
      {Lisp-Entry "emit-inlined-call" define-macro () () ("variable-override") #f 753 31 753 53 ("emit-inlined-binding-call" "jazz:emit-inlined-binding-call" "%%get-reference-binding" "binding" "let" "Binding-Reference" "jazz:Binding-Reference" "%%class-is?" "if" "environment" "declaration" "call" "arguments" "operator" "lambda")}
      {Lisp-Entry "match-signature?" define () ("arguments" "argument-types" "function-type") #f #f 766 9 766 30 ("list-tail" "lambda" "every?" "jazz:every?" "%%get-rest-type-type" "match-rest?" "else" "%%cdr" "%%car" "cond" "expected" "types" "args" "iter" "%%null?" "%%not" "%%fx<=" "%%fx>=" "match-positional?" "Any" "jazz:Any" "%%subtype?" "%%get-category-type-declaration" "%%get-reference-binding" "%%eq?" "Binding-Reference" "jazz:Binding-Reference" "and" "or" "Category-Type" "jazz:Category-Type" "%%class-is?" "if" "expect" "type" "arg" "match?" "define" "%%get-function-type-rest" "rest" "%%get-function-type-named" "named" "%%get-function-type-optional" "optional" "%%get-function-type-positional" "positional" "%%get-function-type-mandatory" "mandatory" "%%length" "argcount" "let" "function-type" "argument-types" "arguments")}
      {Lisp-Entry "If" define-class () () ("class runtime") #f 815 27 815 34 ()}
      {Lisp-Entry "new-if" define () ("source" "test" "yes" "no") #f #f 818 9 818 20 ("If" "jazz:If" "allocate-if" "jazz:allocate-if" "no" "yes" "test" "source")}
      {Lisp-Entry "type-tests" define () () #f #f 822 8 822 23 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "not-type-tests" define () () #f #f 873 8 873 27 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "restrict-type" define () ("base" "type") #f #f 880 9 880 27 ("new-restriction-type" "jazz:new-restriction-type" "type" "base")}
      {Lisp-Entry "restriction-of?" define () ("type" "class") #f #f 884 9 884 29 ("%%get-restriction-type-type" "Restriction-Type" "jazz:Restriction-Type" "%%class-is?" "and" "class" "type")}
      {Lisp-Entry "complement-type" define () ("base" "type") #f #f 889 9 889 29 ("new-complement-type" "jazz:new-complement-type" "new-restriction-type" "jazz:new-restriction-type" "%%get-restriction-type-type" "%%get-complement-type-type" "%%get-restriction-type-base" "%%eq?" "Complement-Type" "jazz:Complement-Type" "restriction-of?" "jazz:restriction-of?" "and" "if" "type" "base")}
      {Lisp-Entry "branch-types" define () ("test" "environment") #f #f 896 9 896 26 ("%%get-nillable-type-type" "Nillable-Type" "jazz:Nillable-Type" "not-type-tests" "jazz:not-type-tests" "type-tests" "jazz:type-tests" "%%table-ref" "class" "is-not?" "jazz.dialect.language.functional" "jazz.dialect.language.functional:is-not?" "%%cadr" "2" "is?" "jazz.dialect.kernel" "jazz.dialect.kernel:is?" "1" "%%fx=" "not" "scheme.dialect.kernel" "scheme.dialect.kernel:not" "case" "%%length" "count" "%%get-call-arguments" "arguments" "%%get-declaration-locator" "operator-locator" "operator-binding" "%%get-call-operator" "operator" "Call" "jazz:Call" "%%get-or-expressions" "Or" "jazz:Or" "%%get-and-expressions" "And" "jazz:And" "%%get-lexical-binding-type" "values" "%%get-annotated-variable-variable" "find-annotated" "jazz:find-annotated" "actual-variable" "frame" "Variable" "jazz:Variable" "no" "new-restricted-binding" "jazz:new-restricted-binding" "%%list" "new-annotated-frame" "jazz:new-annotated-frame" "yes" "Pair" "jazz:Pair" "Null" "jazz:Null" "List" "jazz:List" "%%eq?" "no-type" "else" "resolve-binding" "jazz:resolve-binding" "Declaration" "jazz:Declaration" "%%get-reference-binding" "binding" "Binding-Reference" "jazz:Binding-Reference" "%%class-is?" "type?" "jazz:type?" "cond" "yes-type" "extract-binding" "actual-type" "origin" "receive" "type-expr" "process-is" "process-or" "%%cons" "%%cdr" "newenv" "%%car" "%%null?" "if" "augmented" "scan" "iter" "let" "expr-list" "process-and" "process-expr" "revenv" "env" "expr" "process-not" "define" "environment" "test")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:If") #f 1017 21 1017 41 ("%%get-expression-source" "%%get-code-type" "extend-type" "jazz:extend-type" "simplify-begin" "jazz:simplify-begin" "sourcified-form" "jazz:sourcified-form" "if" "new-code" "jazz:new-code" "%%get-if-no" "no" "%%get-if-yes" "yes" "emit-expression" "jazz:emit-expression" "branch-types" "jazz:branch-types" "no-environment" "yes-environment" "bind" "jazz:bind" "expression" "%%get-if-test" "test" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:If") #f 1031 21 1031 41 ("%%get-if-no" "%%get-if-yes" "%%get-if-test" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:If") #f 1039 21 1039 35 ("%%get-if-test" "%%get-if-yes" "%%get-if-no" "tree-fold" "jazz:tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Cond" define-class () () ("class runtime") #f 1061 27 1061 36 ()}
      {Lisp-Entry "new-cond" define () ("source" "clauses") #f #f 1064 9 1064 22 ("Cond" "jazz:Cond" "allocate-cond" "jazz:allocate-cond" "clauses" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Cond") #f 1068 21 1068 41 ("%%get-expression-source" "%%get-code-type" "lambda" "map" "extend-types" "jazz:extend-types" "%%cdr" "%%cons" "=>" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "else" "%%not" "output" "branch-types" "jazz:branch-types" "no-environment" "yes-environment" "bind" "jazz:bind" "%%cddr" "body" "%%cadr" "arrow?" "test" "%%car" "clause" "%%null?" "if" "recurse" "cond" "new-code" "jazz:new-code" "expression" "%%get-cond-clauses" "clauses" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Cond") #f 1094 21 1094 41 ("%%get-cond-clauses" "fold-expression" "jazz:fold-expression" "%%not" "if" "%%cdr" "body" "%%car" "test" "let" "clause" "lambda" "map" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Cond") #f 1106 21 1106 35 ("%%not" "%%cdr" "tree-fold" "jazz:tree-fold" "%%cddr" "body" "test" "%%car" "clause" "let*" "null?" "if" "%%get-cond-clauses" "ls" "fold" "let" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Case" define-class () () ("class runtime") #f 1132 27 1132 36 ()}
      {Lisp-Entry "new-case" define () ("source" "target" "clauses") #f #f 1135 9 1135 22 ("Case" "jazz:Case" "allocate-case" "jazz:allocate-case" "clauses" "target" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Case") #f 1139 21 1139 41 ("%%get-expression-source" "%%get-code-type" "extend-types" "jazz:extend-types" ",tries" "%%car" "tries" "emited-clause" "sourcified-form" "jazz:sourcified-form" "case" "new-code" "jazz:new-code" "emit-expression" "jazz:emit-expression" "%%cdr" "body" "clause" "lambda" "map" "emited-clauses" "%%get-case-clauses" "clauses" "expression" "%%get-case-target" "target" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Case") #f 1159 21 1159 41 ("%%get-case-clauses" "cdr" "map" "fold-expressions" "jazz:fold-expressions" "%%get-case-target" "fold-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Case") #f 1165 21 1165 35 ("%%get-case-target" "tree-fold" "jazz:tree-fold" "%%get-case-clauses" "cdr" "map" "tree-fold-list" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "And" define-class () () ("class runtime") #f 1183 27 1183 35 ()}
      {Lisp-Entry "new-and" define () ("source" "expressions") #f #f 1186 9 1186 21 ("And" "jazz:And" "allocate-and" "jazz:allocate-and" "expressions" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:And") #f 1190 21 1190 41 ("%%get-expression-source" "Any" "jazz:Any" "expression" "%%get-and-expressions" "emit-expressions" "jazz:emit-expressions" "codes-forms" "jazz:codes-forms" "and" "new-code" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:And") #f 1197 21 1197 41 ("%%get-and-expressions" "fold-expressions" "jazz:fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:And") #f 1202 21 1202 35 ("%%get-and-expressions" "tree-fold-list" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Or" define-class () () ("class runtime") #f 1218 27 1218 34 ()}
      {Lisp-Entry "new-or" define () ("source" "expressions") #f #f 1221 9 1221 20 ("Or" "jazz:Or" "allocate-or" "jazz:allocate-or" "expressions" "source")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Or") #f 1225 21 1225 41 ("%%get-expression-source" "Any" "jazz:Any" "expression" "%%get-or-expressions" "emit-expressions" "jazz:emit-expressions" "codes-forms" "jazz:codes-forms" "or" "new-code" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Or") #f 1232 21 1232 41 ("%%get-or-expressions" "fold-expressions" "jazz:fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Or") #f 1237 21 1237 35 ("%%get-or-expressions" "tree-fold-list" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Declare" define-class () () ("class runtime") #f 1253 27 1253 39 ()}
      {Lisp-Entry "new-declare" define () ("declarations") #f #f 1256 9 1256 25 ("Declare" "jazz:Declare" "allocate-declare" "jazz:allocate-declare" "declarations")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Declare") #f 1260 21 1260 41 ("Any" "jazz:Any" ",@declarations" "declare" "new-code" "jazz:new-code" "expression" "%%get-declare-declarations" "declarations" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Declare") #f 1268 21 1268 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "Parameterize" define-class () () ("class runtime") #f 1280 27 1280 44 ()}
      {Lisp-Entry "new-parameterize" define () ("bindings" "body") #f #f 1283 9 1283 30 ("Parameterize" "jazz:Parameterize" "allocate-parameterize" "jazz:allocate-parameterize" "body" "bindings")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Parameterize") #f 1287 21 1287 41 ("%%get-code-type" "sourcified-form" "jazz:sourcified-form" "%%cdr" "value" "%%car" "variable" "binding" "lambda" "map" "parameterize" "new-code" "jazz:new-code" "emit-expression" "jazz:emit-expression" "body-code" "%%get-parameterize-body" "body" "expression" "%%get-parameterize-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Parameterize") #f 1303 21 1303 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Parameterize") #f 1307 21 1307 35 ("%%get-parameterize-body" "tree-fold" "jazz:tree-fold" "expression" "%%get-parameterize-bindings" "cdr" "map" "tree-fold-list" "jazz:tree-fold-list" "seed2" "let" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Time-Special" define-class () () ("class runtime") #f 1323 27 1323 44 ()}
      {Lisp-Entry "new-time-special" define () ("expressions") #f #f 1326 9 1326 30 ("Time-Special" "jazz:Time-Special" "allocate-time" "jazz:allocate-time" "expressions")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:Time-Special") #f 1330 21 1330 41 ("Any" "jazz:Any" "emit-expressions" "jazz:emit-expressions" "codes-forms" "jazz:codes-forms" "begin" "time" "new-code" "jazz:new-code" "expression" "%%get-time-special-expressions" "expressions" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:Time-Special") #f 1340 21 1340 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "validate-proclaim" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Walker~virtual-runtime") #f 1352 30 1352 52 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "validate-proclaim" generic/specific () ("resume" "declaration" "environment" "form-src") ("jazz:Walker") #f 1355 21 1355 43 ("walker" "walk-error" "jazz:walk-error" "Module-Declaration" "jazz:Module-Declaration" "%%class-is?" "%%not" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walk-proclaim" define () ("walker" "resume" "declaration" "environment" "form-src") #f #f 1360 9 1360 27 ("new-proclaim" "jazz:new-proclaim" "%%cdr" "clauses" "%%desourcify" "form" "let" "validate-proclaim" "jazz:validate-proclaim" "form-src" "environment" "declaration" "resume" "walker")}}})
"ffi"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "walker" "ffi.scm"} 231466230. scheme
    {Lisp-Entry "core.module.syntax.walker.ffi" unit (protected) () #f #f 37 16 37 45 ("C-Function" "jazz:C-Function" "C-Initialize" "jazz:C-Initialize" "C-Named-Declare-Declaration" "jazz:C-Named-Declare-Declaration" "C-Declare" "jazz:C-Declare" "C-Include" "jazz:C-Include" "C-Definition-Declaration" "jazz:C-Definition-Declaration" "encapsulate-class" "jazz:encapsulate-class" "C-Type-Declaration" "jazz:C-Type-Declaration")
      {Lisp-Entry "C-Type-Declaration" define-class () () ("class runtime") #f 45 27 45 50 ()}
      {Lisp-Entry "new-c-type-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "kind" "expansion" "base-type" "inclusions" "c-to-scheme" "scheme-to-c" "declare") #f #f 48 9 48 36 ("setup-declaration" "jazz:setup-declaration" "C-Type-Declaration" "jazz:C-Type-Declaration" "allocate-c-type-declaration" "jazz:allocate-c-type-declaration" "new-declaration" "let" "declare" "scheme-to-c" "c-to-scheme" "inclusions" "base-type" "expansion" "kind" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "get-declaration-inclusions" generic/specific () () ("jazz:C-Type-Declaration") #f 54 21 54 52 ("declaration" "%%get-c-type-declaration-inclusions")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:C-Type-Declaration") #f 58 21 58 42 ("begin" "environment")}
      {Lisp-Entry "expand-referenced-declaration" generic/specific () () ("jazz:C-Type-Declaration") #f 62 21 62 55 ("%%list" "and" "if" ",expansion" ",locator" "c-define-type" "%%get-c-type-declaration-scheme-to-c" "scheme-to-c" "%%get-c-type-declaration-c-to-scheme" "c-to-scheme" "%%get-c-type-declaration-expansion" "expansion" "declaration" "%%get-declaration-locator" "locator" "let")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:C-Type-Declaration") #f 72 21 72 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "C-Definition-Declaration" define-class () () ("class runtime") #f 84 27 84 56 ()}
      {Lisp-Entry "new-c-definition-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "signature" "parameter-types" "result-type" "c-name" "scope") #f #f 87 9 87 42 ("setup-declaration" "jazz:setup-declaration" "C-Definition-Declaration" "jazz:C-Definition-Declaration" "allocate-c-definition-declaration" "jazz:allocate-c-definition-declaration" "new-declaration" "let" "scope" "c-name" "result-type" "parameter-types" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific () ("walker" "resume" "source-declaration" "operator" "arguments" "form-src") ("jazz:C-Definition-Declaration") #f 93 21 93 52 ("validate-arguments" "jazz:validate-arguments" "if" "declaration" "%%get-c-definition-declaration-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:C-Definition-Declaration") #f 99 21 99 42 ("%%get-declaration-source" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" ",scope" ",c-name" ",result-type" ",parameter-types" "emit-signature" "jazz:emit-signature" "c-define" "sourcify-if" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-c-definition-declaration-body" "body" "%%get-c-definition-declaration-scope" "scope" "%%get-c-definition-declaration-c-name" "c-name" "%%get-c-definition-declaration-result-type" "result-type" "%%get-c-definition-declaration-parameter-types" "parameter-types" "%%get-c-definition-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "emit-binding-reference" generic/specific () ("source-declaration" "environment") ("jazz:C-Definition-Declaration") #f 116 21 116 48 ("Any" "jazz:Any" "declaration" "%%get-declaration-locator" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:C-Definition-Declaration") #f 123 21 123 42 ("%%get-c-definition-declaration-body" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "C-Include" define-class () () ("class runtime") #f 137 27 137 41 ()}
      {Lisp-Entry "new-c-include" define () ("name") #f #f 140 9 140 27 ("C-Include" "jazz:C-Include" "allocate-c-include" "jazz:allocate-c-include" "name")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:C-Include") #f 144 21 144 41 ("Any" "jazz:Any" "%%string-append" "c-declare" "new-code" "jazz:new-code" "expression" "%%get-c-include-name" "name" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:C-Include") #f 152 21 152 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "C-Declare" define-class () () ("class runtime") #f 164 27 164 41 ()}
      {Lisp-Entry "new-c-declare" define () ("code") #f #f 167 9 167 27 ("C-Declare" "jazz:C-Declare" "allocate-c-declare" "jazz:allocate-c-declare" "code")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:C-Declare") #f 171 21 171 41 ("Any" "jazz:Any" ",code" "c-declare" "new-code" "jazz:new-code" "expression" "%%get-c-declare-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:C-Declare") #f 179 21 179 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "C-Named-Declare-Declaration" define-class () () ("class runtime") #f 191 27 191 59 ()}
      {Lisp-Entry "new-c-named-declare-declaration" define () ("name" "type" "access" "compatibility" "attributes" "parent" "code") #f #f 194 9 194 45 ("setup-declaration" "jazz:setup-declaration" "C-Named-Declare-Declaration" "jazz:C-Named-Declare-Declaration" "allocate-c-named-declare-declaration" "jazz:allocate-c-named-declare-declaration" "new-declaration" "let" "code" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "emit-declaration" generic/specific () ("environment") ("jazz:C-Named-Declare-Declaration") #f 200 21 200 42 ("begin" "environment")}
      {Lisp-Entry "expand-referenced-declaration" generic/specific () () ("jazz:C-Named-Declare-Declaration") #f 204 21 204 55 (",code" "c-declare" "declaration" "%%get-c-named-declare-declaration-code" "code" "let")}
      {Lisp-Entry "fold-declaration" generic/specific () ("f" "k" "s") ("jazz:C-Named-Declare-Declaration") #f 209 21 209 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "C-Initialize" define-class () () ("class runtime") #f 221 27 221 44 ()}
      {Lisp-Entry "new-c-initialize" define () ("code") #f #f 224 9 224 30 ("C-Initialize" "jazz:C-Initialize" "allocate-c-initialize" "jazz:allocate-c-initialize" "code")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:C-Initialize") #f 228 21 228 41 ("Any" "jazz:Any" ",code" "c-initialize" "new-code" "jazz:new-code" "expression" "%%get-c-initialize-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:C-Initialize") #f 236 21 236 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "C-Function" define-class () () ("class runtime") #f 248 27 248 42 ()}
      {Lisp-Entry "new-c-function" define () ("expansion") #f #f 251 9 251 28 ("C-Function" "jazz:C-Function" "allocate-c-function" "jazz:allocate-c-function" "expansion")}
      {Lisp-Entry "emit-expression" generic/specific () ("declaration" "environment") ("jazz:C-Function") #f 255 21 255 41 ("Any" "jazz:Any" "expression" "%%get-c-function-expansion" "new-code" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "fold-expression" generic/specific () ("f" "k" "s") ("jazz:C-Function") #f 262 21 262 41 ("expression" "s" "k" "f")}}})
"generic"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "runtime" "generic.scm"} 231466230. scheme
    {Lisp-Entry "core.generic.runtime.generic" unit (protected) () #f #f 38 16 38 44 ()
      {Lisp-Entry "new-generic" define () ("locator" "dynamic-signature" "root-proc") #f #f 41 9 41 25 ("generic-make-root" "jazz:generic-make-root" "Generic" "jazz:Generic" "allocate-generic" "jazz:allocate-generic" "generic" "identifier-name" "jazz:identifier-name" "name" "let*" "root-proc" "dynamic-signature" "locator")}
      {Lisp-Entry "generic-reset" define () ("generic" "root-proc") #f #f 48 9 48 27 ("%%get-generic-root-specific" "%%get-specific-dynamic-signature" "generic-make-root" "jazz:generic-make-root" "root-proc" "generic")}
      {Lisp-Entry "generic-make-root" define () ("generic" "dynamic-signature" "root-proc") #f #f 52 9 52 31 ("%%get-generic-pending-specifics" "%%cons" "%%set-generic-pending-specifics" "%%set-generic-root-specific" "invalid-generic-call" "jazz:invalid-generic-call" "apply" "rest" "lambda" "or" "new-specific" "jazz:new-specific" "root-specific" "let" "root-proc" "dynamic-signature" "generic")}
      {Lisp-Entry "invalid-generic-call" define () ("generic" "." "rest") #f #f 58 9 58 34 ("generic-error" "jazz:generic-error" "%%cdr" "%%car" "class-of" "jazz:class-of" "%%cons" "%%pair?" "and" "if" "%%get-generic-root-specific" "%%get-specific-dynamic-signature" "signature" "iter" "dynamic-parameters" "let" "rest" "generic")}
      {Lisp-Entry "generic-error" define () ("generic" "signature") #f #f 68 9 68 27 ("%%cons" "error" "jazz:error" "%%get-generic-root-specific" "%%get-specific-dynamic-signature" "root-signature" "%%get-generic-name" "name" "let" "signature" "generic")}
      {Lisp-Entry "register-specific" define () ("generic" "specific") #f #f 80 9 80 31 ("%%get-generic-pending-specifics" "%%cons" "%%set-generic-pending-specifics" "specific" "generic")}
      {Lisp-Entry "process-pending-specifics" define () ("generic") #f #f 89 9 89 39 ("%%set-generic-pending-specifics" "%%get-generic-pending-specifics" "%%reverse" "insert/replace-specific" "jazz:insert/replace-specific" "specific" "lambda" "for-each" "%%get-generic-root-specific" "resolve-signature" "jazz:resolve-signature" "generic")}
      {Lisp-Entry "resolve-signature" define () ("specific") #f #f 99 9 99 31 ("%%set-specific-dynamic-signature" "%%procedure?" "%%when" "%%get-specific-dynamic-signature" "signature/proc" "let" "specific")}
      {Lisp-Entry "insert/replace-specific" define () ("generic" "specific") #f #f 105 9 105 37 ("%%set-car!" "%%set-generic-root-specific" "%%get-generic-root-specific" "perfect-match" "%%set-specific-descendant-specifics" "set!" "%%memq" "%%when" "else" "remove!" "jazz:remove!" "%%get-specific-ancestor-specifics" "brothers" "brother-partition" "descendants" "%%assq" "descendant-partition" "assv" "dynamic-signature-compare" "jazz:dynamic-signature-compare" "ordered" "%%eq?" "descendant-signature" "descendant" "%%get-specific-descendant-specifics" "jazz:partition" "partition" "ancestor-signature" "ancestor" "lambda" "for-each" "%%set-specific-ancestor-specifics" "descendant-specifics" "ancestors" "generic-error" "jazz:generic-error" "%%not" "cond" "gather-dynamic-signature-ancestors" "jazz:gather-dynamic-signature-ancestors" "matches" "%%get-specific-dynamic-signature" "dynamic-signature" "let*" "%%cons" "specific-better?" "jazz:specific-better?" "%%pair?" "if" "others" "%%car" "best" "%%cdr" "scan" "iter" "let" "specifics" "put-best-first" "define" "specific" "generic")}
      {Lisp-Entry "gather-dynamic-signature-ancestors" define () ("generic" "dynamic-signature") #f #f 180 9 180 48 ("%%null?" "else" "%%cons" "%%memq" "%%cdr" "%%get-specific-descendant-specifics" "found-in-descendants" "ordered" "set!" "equal" "%%get-specific-dynamic-signature" "dynamic-signature-compare" "jazz:dynamic-signature-compare" "case" "%%car" "specific" "%%pair?" "if" "partial-matches" "%%get-generic-root-specific" "%%list" "specifics" "iter" "or" "perfect-match" "let" "dynamic-signature" "generic")}
      {Lisp-Entry "dynamic-signature-compare" define () ("descendant-signature" "ancestor-signature") #f #f 206 9 206 39 ("else" "ordered" "reverse-ordered" "subcategory?" "jazz:subcategory?" "%%cdr" "%%car" "%%eq?" "cond" "unordered" "and" "%%null?" "or" "if" "equal" "match" "iter" "let" "ancestor-signature" "descendant-signature")}
      {Lisp-Entry "dynamic-signature-equal?" define () ("dynamic-signature1" "dynamic-signature2") #f #f 228 9 228 38 ("%%cdr" "%%car" "%%eq?" "and" "%%null?" "or" "if" "iter" "let" "dynamic-signature2" "dynamic-signature1")}
      {Lisp-Entry "specific-better?" define () ("specific1" "specific2") #f #f 237 9 237 30 ("%%cdr" "%%car" "%%get-class-level" "%%fx>" "or" "signature2" "%%get-specific-dynamic-signature" "signature1" "iter" "let" "specific2" "specific1")}
      {Lisp-Entry "display-tree" define () ("generic") #f #f 249 9 249 26 ("1" "%%fx+" "newline" "%%get-specific-descendant-specifics" "%%get-specific-ancestor-specifics" "%%get-specific-dynamic-signature" "write" "specific" "lambda" "for-each" "0" "level" "%%get-generic-root-specific" "%%list" "specifics" "iterate" "let" "process-pending-specifics" "jazz:process-pending-specifics" "%%get-generic-pending-specifics" "%%null?" "%%not" "%%when" "generic")}
      {Lisp-Entry "dispatch-from-root" define () ("generic" "dynamic-classes") #f #f 274 9 274 32 ("else" "%%car" "%%pair?" "generic-error" "jazz:generic-error" "%%not" "cond" "gather-dynamic-signature-ancestors" "jazz:gather-dynamic-signature-ancestors" "matches" "let" "dynamic-classes" "generic")}}}
  {Lisp-File-Entry {File :context "src" "core" "generic" "syntax" "generic.scm"} 231466230. scheme
    {Lisp-Entry "core.generic.syntax.generic" unit (protected) () #f #f 44 16 44 43 ("Generic" "jazz:Generic" "encapsulate-class" "jazz:encapsulate-class")
      {Lisp-Entry "Generic" define-class () () ("class syntax") #f 47 19 47 31 ("%%set-generic-pending-specifics" "%%get-generic-pending-specifics" "pending-specifics" "%%set-generic-root-specific" "%%get-generic-root-specific" "root-specific" "%%get-generic-name" "name" "%%get-generic-locator" "locator" "allocate-generic" "jazz:allocate-generic" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Generic" define-class () () ("class runtime") #f 54 27 54 39 ()}
      {Lisp-Entry "define-generic" define-macro () () ("macro") #f 57 20 57 39 ("expand-define-generic" "jazz:expand-define-generic" "%%apply" "rest")}
      {Lisp-Entry "%%specific-dispatch" define-macro () () ("macro") #f 61 20 61 39 (",dynamic-classes" ",generic" "dispatch-from-root" "jazz:dispatch-from-root" "%%get-specific-implementation" "dynamic-classes" "generic")}}})
"initialize"
 ({Lisp-File-Entry {File :context "src" "core" "module" "initialize.scm"} 231466230. scheme
    {Lisp-Entry "core.module.initialize" unit (protected) () #f #f 37 16 37 38 ("initialize-primitive-patterns" "jazz:initialize-primitive-patterns")}})
"keyword"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "keyword.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.keyword" unit (protected) () #f #f 37 16 37 41 ()
      {Lisp-Entry "keyword?" define () ("obj") #f #f 42 13 42 26 ("keyword?" "obj")}
      {Lisp-Entry "keyword->string" define () ("keyword") #f #f 45 13 45 33 ("keyword->string" "keyword")}
      {Lisp-Entry "string->keyword" define () ("string") #f #f 48 13 48 33 ("string->keyword" "string")}
      {Lisp-Entry "keyword?" define () ("obj") #f #f 52 13 52 26 ("%%keyword?" "obj")}
      {Lisp-Entry "keyword->string" define () ("keyword") #f #f 55 13 55 33 ("%%keyword->string" "keyword")}
      {Lisp-Entry "string->keyword" define () ("string") #f #f 58 13 58 33 ("%%string->keyword" "string")}
      {Lisp-Entry "keyword?" define () ("obj") #f #f 62 12 62 25 ("1" "%%string-length" "%%fx-" "%%string-ref" "%%eqv?" "%%symbol->string" "str" "let" "%%symbol?" "and" "obj")}
      {Lisp-Entry "keyword->string" define () ("keyword") #f #f 68 12 68 32 ("1" "%%length" "%%fx-" "0" "%%substring" "%%symbol->string" "str" "let" "keyword")}
      {Lisp-Entry "string->keyword" define () ("string") #f #f 73 12 73 32 ("%%string-append" "%%string->symbol" "string")}}})
"list"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "list.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.list" unit (protected) () #f #f 37 16 37 38 ()
      {Lisp-Entry "find-in" define () ("proc" "lst") #f #f 40 9 40 21 ("%%cdr" "%%car" "or" "%%null?" "if" "scan" "iter" "let" "lst" "proc")}
      {Lisp-Entry "find-if" define () ("predicate" "lst") #f #f 48 9 48 21 ("%%cdr" "%%car" "value" "%%null?" "if" "scan" "iter" "let" "lst" "predicate")}
      {Lisp-Entry "getprop" define () ("plist" "target") #f #f 58 9 58 21 ("%%cddr" "else" "%%car" "%%eqv?" "%%null?" "cond" "scan" "iter" "let" "target" "plist")}
      {Lisp-Entry "getf" define () ("plist" "target" "#!key" "(not-found #f)") #f #f 68 9 68 18 ("%%cadr" "if" "getprop" "jazz:getprop" "pair" "let" "not-found" "#!key" "target" "plist")}
      {Lisp-Entry "reverse!" define () () #f #f 75 8 75 21 ("reverse")}
      {Lisp-Entry "list-copy" define () ("lst") #f #f 79 9 79 23 ("obj" "lambda" "map" "lst")}
      {Lisp-Entry "last-tail" define () ("lst") #f #f 83 9 83 23 ("else" "%%null?" "cond" "%%cdr" "tail" "scan" "iter" "let" "%%pair?" "if" "lst")}
      {Lisp-Entry "last-pair" define () ("lst") #f #f 96 9 96 23 ("%%cdr" "tail" "scan" "iter" "let" "%%pair?" "if" "lst")}
      {Lisp-Entry "last" define () ("lst") #f #f 106 9 106 18 ("last-pair" "jazz:last-pair" "%%car" "lst")}
      {Lisp-Entry "remove-duplicates" define () ("lst") #f #f 110 9 110 31 ("%%cons" "%%memv" "%%cdr" "result" "%%car" "value" "%%not-null?" "if" "scan" "iter" "let" "lst")}
      {Lisp-Entry "partition" define () ("lst" "key" "associate") #f #f 121 9 121 23 ("%%set-cdr!" "begin" "%%list" "%%cons" "%%not" "set" "category" "%%car" "element" "%%cdr" "partition" "let*" "%%null?" "if" "scan" "iter" "let" "associate" "key" "lst")}
      {Lisp-Entry "rassq" define () ("obj" "alist") #f #f 136 9 136 19 ("%%cdr" "else" "%%car" "%%cdar" "%%eq?" "%%null?" "cond" "rest" "iter" "let" "alist" "obj")}
      {Lisp-Entry "butlast" define () ("lst") #f #f 146 9 146 21 ("butlast" "jazz:butlast" "%%car" "%%cons" "%%cdr" "%%null?" "if" "lst")}
      {Lisp-Entry "naturals" define () ("from" "to") #f #f 152 9 152 22 ("reverse!" "jazz:reverse!" "1" "%%fx+" "%%cons" "set!" "%%fx<" "%%while" "n" "lst" "let" "to" "from")}
      {Lisp-Entry "remove!" define () ("target" "lst") #f #f 161 9 161 21 ("%%set-cdr!" "scan" "previous" "let" "begin" "%%null?" "if" "%%cdr" "set!" "%%car" "%%eqv?" "%%not-null?" "and" "%%while" "lst" "target")}
      {Lisp-Entry "values?" define () ("obj") #f #f 180 9 180 21 ("%%values?" "obj")}}})
"macros"
 ({Lisp-File-Entry {File :context "src" "core" "base" "syntax" "macros.scm"} 231466230. scheme
    {Lisp-Entry "core.base.syntax.macros" unit (protected) () #f #f 37 16 37 39 ()
      {Lisp-Entry "%%boolean" define-macro () () ("syntax") #f 40 20 40 29 (",expr" "if" "source-code" "jazz:source-code" "%%cadr" "expr" "let" "src" "lambda")}
      {Lisp-Entry "%%not-null?" define-macro () () ("syntax") #f 46 20 46 31 (",expr" "%%null?" "%%not" "source-code" "jazz:source-code" "%%cadr" "expr" "let" "src" "lambda")}
      {Lisp-Entry "%%when" define-macro () () ("syntax") #f 57 20 57 26 (",@body" "begin" ",test" "if" "%%cddr" "body" "source-code" "jazz:source-code" "%%cadr" "test" "let" "src" "lambda")}
      {Lisp-Entry "%%while" define-macro () () ("syntax") #f 72 20 72 27 (",@body" "begin" ",test" "if" ",iter" "generate-symbol" "jazz:generate-symbol" "iter" "%%cddr" "body" "source-code" "jazz:source-code" "%%cadr" "test" "let" "src" "lambda")}
      {Lisp-Entry "%%core-assert" define-macro () () ("syntax") #f 89 20 89 33 ("debug-core?" "jazz:debug-core?" "expand-%%assert" "jazz:expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%core-assertion" define-macro () () ("syntax") #f 94 20 94 36 ("debug-core?" "jazz:debug-core?" "expand-%%assertion" "jazz:expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "%%debug-assert" define-macro () () ("syntax") #f 99 20 99 34 ("debug-user?" "jazz:debug-user?" "expand-%%assert" "jazz:expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%debug-assertion" define-macro () () ("syntax") #f 104 20 104 37 ("debug-user?" "jazz:debug-user?" "expand-%%assertion" "jazz:expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "%%assert" define-macro () () ("syntax") #f 109 20 109 28 ("expand-%%assert" "jazz:expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%assertion" define-macro () () ("syntax") #f 114 20 114 31 ("expand-%%assertion" "jazz:expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "expand-%%assert" define () ("test?" "src") #f #f 119 9 119 29 ("error" "expand-%%assertion-body" "jazz:expand-%%assertion-body" "%%unspecified" "%%list" "%%null?" "if" "effective-body" "get-output-string" "%%desourcify" "write" "display" "open-output-string" "port" "message" "%%cddr" "body" "source-code" "jazz:source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "expand-%%assertion" define () ("test?" "src") #f #f 131 9 131 32 ("expand-%%assertion-body" "jazz:expand-%%assertion-body" "%%unspecified" "%%list" "%%null?" "if" "effective-body" "%%cdr" "body" "%%cddr" "%%car" "action" "source-code" "jazz:source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "expand-%%assertion-body" define () ("test?" "assertion" "action" "body") #f #f 139 9 139 37 (",@body" "begin" "simplify-begin" "jazz:simplify-begin" ",action" ",assertion" "%%not" "if" "body" "action" "assertion" "test?")}
      {Lisp-Entry "bind" define-macro () () ("macro") #f 166 20 166 29 (",tree-symbol" "tree-symbol" ",cdr-symbol" "cdr-symbol" ",@body" ",cdr-binding" "%%cdr" "cdr-binding" ",car-symbol" "error" "jazz:error" "%%null?" "if" "generate-symbol" "jazz:generate-symbol" "car-symbol" "%%pair?" "expand-cdr" ",tree" ",car-binding" "%%symbol?" "cond" "%%car" "car-binding" "let" "expand-car" "define" "body" "tree" "bindings")}
      {Lisp-Entry "%%compose-identifier" define-macro () () ("macro") #f 203 20 203 40 (",s2" ",s1" "%%symbol->string" "%%string-append" "%%string->symbol" "s2" "s1")}
      {Lisp-Entry "%%compose-reference" define-macro () () ("macro") #f 207 20 207 39 (",s2" ",s1" "%%symbol->string" "%%string-append" "%%string->symbol" "s2" "s1")}}})
"module"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "module.scm"} 231466230. scheme
    {Lisp-Entry "core.module.syntax.module" unit (protected) () #f #f 37 16 37 41 ()
      {Lisp-Entry "module" define-macro () () ("syntax") #f 40 20 40 26 ("save-emit-if" "jazz:save-emit-if" "source-code" "jazz:source-code" "%%cdr" "expand-module-source" "jazz:expand-module-source" "emit" "let" "form-src" "lambda")}
      {Lisp-Entry "script" define-macro () () ("syntax") #f 47 20 47 26 ("source-code" "jazz:source-code" "%%cdr" "expand-script-source" "jazz:expand-script-source" "form-src" "lambda")}}})
"object"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "object.scm"} 246587393. scheme
    {Lisp-Entry "core.class.syntax.object" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "%%object-content" define () () #f #f 42 12 42 28 ("0")}
      {Lisp-Entry "%%object-marker" define () () #f #f 46 11 46 26 ("object" "jazz:object")}
      {Lisp-Entry "%%object-content" define () () #f #f 49 11 49 27 ("1")}
      {Lisp-Entry "object-class" define () () #f #f 53 8 53 25 ("%%object-content")}
      {Lisp-Entry "object-size" define () () #f #f 57 8 57 24 ("1" "object-class" "jazz:object-class" "%%fx+")}
      {Lisp-Entry "%%subtype-jazz" define-macro () () ("macro") #f 63 24 63 38 ("7")}
      {Lisp-Entry "%%object?" define-macro () () ("macro") #f 66 24 66 33 (",expr" "##jazz?" "expr")}
      {Lisp-Entry "%%object" define-macro () () ("macro") #f 69 24 69 32 ("%%subtype-jazz" ",@rest" ",cls" "##vector" "##subtype-set!" "cls" "lambda" "with-uniqueness" "jazz:with-uniqueness" "rest" "class")}
      {Lisp-Entry "%%make-object" define-macro () () ("macro") #f 74 24 74 37 (",cls" "%%set-object-class" "%%subtype-jazz" "%%unspecified" ",size" "%%make-vector" "##subtype-set!" ",obj" "generate-symbol" "jazz:generate-symbol" "obj" "let" "cls" "lambda" "with-uniqueness" "jazz:with-uniqueness" "size" "class")}
      {Lisp-Entry "%%object-length" define-macro () () ("macro") #f 82 24 82 39 (",object" "##vector-length" "not-object-error" "jazz:not-object-error" ",obj" "%%object?" "%%core-assertion" "obj" "lambda" "with-uniqueness" "jazz:with-uniqueness" "debug-core?" "jazz:debug-core?" "if" "object")}
      {Lisp-Entry "%%object-ref" define-macro () () ("macro") #f 90 24 90 36 (",object" ",n" "##vector-ref" "not-object-error" "jazz:not-object-error" ",obj" "%%object?" "%%core-assertion" "rnk" "obj" "lambda" "with-uniqueness" "jazz:with-uniqueness" "debug-core?" "jazz:debug-core?" "if" "n" "object")}
      {Lisp-Entry "%%object-set!" define-macro () () ("syntax") #f 103 24 103 37 (",object" ",value" ",n" "##vector-set!" "not-object-error" "jazz:not-object-error" ",obj" "%%object?" "%%core-assertion" "rnk" "obj" "with-uniqueness" "jazz:with-uniqueness" "debug-core?" "jazz:debug-core?" "if" "value" "%%cddr" "%%car" "n" "%%source-code" "%%cadr" "object" "let" "src" "lambda")}
      {Lisp-Entry "%%object?" define-macro () () ("macro") #f 121 23 121 32 ("%%object-marker" "%%object-ref" "%%eq?" "0" "%%object-length" "%%fx>" ",expr" "%%vector?" "and" "expr")}
      {Lisp-Entry "%%object" define-macro () () ("macro") #f 126 23 126 31 (",@rest" "%%object-marker" "%%vector" "rest")}
      {Lisp-Entry "%%make-object" define-macro () () ("macro") #f 129 23 129 36 ("%%object-marker" "0" "%%object-set!" "%%unspecified" ",size" "%%make-vector" ",object" "generate-symbol" "jazz:generate-symbol" "object" "let" "size")}
      {Lisp-Entry "%%object-length" define-macro () () ("macro") #f 135 23 135 38 (",vector" "%%vector-length" "vector")}
      {Lisp-Entry "%%object-ref" define-macro () () ("macro") #f 138 23 138 35 (",n" ",vector" "%%vector-ref" "n" "vector")}
      {Lisp-Entry "%%object-set!" define-macro () () ("macro") #f 141 23 141 36 (",value" ",n" ",vector" "%%vector-set!" "value" "n" "vector")}}})
"output"
 ({Lisp-File-Entry {File :context "src" "core" "class" "runtime" "output.scm"} 231466230. scheme
    {Lisp-Entry "core.class.runtime.output" unit (protected) () #f #f 37 16 37 41 ("print-jazz" "jazz:print-jazz" "eq?" "if" "detail" "let" "style" "port" "object" "print-hook" "jazz:print-hook" "call-print" "Object" "jazz.dialect.language.object" "jazz.dialect.language.object:Object:call-print" ":reader" "write" "jazz:write" ":human" "output-value" "jazz:output-value" "output" "value" "lambda" "display" "jazz:display" "set!")
      {Lisp-Entry "output-mode" define () () #f #f 40 8 40 24 (":reader")}
      {Lisp-Entry "print" define () ("value" "output" "detail") #f #f 54 9 54 19 ("error" "jazz:error" "else" "write" ":describe" ":text" ":reader" "display" ":human" "case" "detail" "output" "value")}
      {Lisp-Entry "->string" define () ("value") #f #f 61 9 61 22 ("get-output-string" "output-mode" "jazz:output-mode" "output-value" "jazz:output-value" "open-output-string" "output" "let" "else" "%%values?" "%%unspecified?" "cond" "value")}
      {Lisp-Entry "output-value" define () ("value" "output" "detail") #f #f 72 9 72 26 ("print-jazz" "jazz:print-jazz" "else" "print" "jazz:print" "primitive?" "jazz:primitive?" "output-list" "jazz:output-list" "%%pair?" "%%null?" "or" "cond" "detail" "output" "value")}
      {Lisp-Entry "output-list" define () ("lst" "output" "detail") #f #f 81 9 81 25 ("begin" "display" "%%pair?" "%%cdr" "set!" "%%car" "output-value" "jazz:output-value" "and" "%%while" "done?" "scan" "let" "%%null?" "%%not" "if" "output-list-content" "define" "detail" "output" "lst")}
      {Lisp-Entry "debug" define () ("." "rest") #f #f 102 9 102 19 ("force-output" "newline" "%%cdr" "expr" "lambda" "for-each" "%%car" "->string" "jazz:->string" "display" "%%not-null?" "%%when" "console-port" "port" "let" "rest")}
      {Lisp-Entry "debug-string" define () ("str") #f #f 114 9 114 26 ("force-output" "newline" "display" "console-port" "port" "let" "str")}
      {Lisp-Entry "terminal" define () () #f #f 121 8 121 21 ("debug" "jazz:debug")}
      {Lisp-Entry "terminal-string" define () () #f #f 125 8 125 28 ("debug-string" "jazz:debug-string")}
      {Lisp-Entry "terminal-port" define () () #f #f 129 9 129 27 ("console-port")}
      {Lisp-Entry "bootstrap-output-value" define () ("value" "output") #f #f 133 9 133 36 ("->string" "jazz:->string" "display" "output" "value")}
      {Lisp-Entry "pretty-print" define () ("expr" "." "rest") #f #f 139 13 139 30 ("pretty-print" "apply" "rest" "expr")}
      {Lisp-Entry "pretty-print" define () ("expr" "." "rest") #f #f 143 13 143 30 ("pretty-print" "apply" "rest" "expr")}
      {Lisp-Entry "pretty-print" define () ("expr" "." "rest") #f #f 147 12 147 29 ("newline" "display" "rest" "expr")}
      {Lisp-Entry "call-print" define () () #f #f 157 8 157 54 ()}
      {Lisp-Entry "print-jazz" define () ("object" "output" "detail") #f #f 163 9 163 24 ("print-serial" "jazz:print-serial" "print-object" "jazz:print-object" "2" "0" "class-of" "jazz:class-of" "%%class-dispatch" "call-print" "Object" "jazz.dialect.language.object" "jazz.dialect.language.object:Object:call-print" "use-print?" "jazz:use-print?" "if" "detail" "output" "object")}}})
"output-hook"
 ({Lisp-File-Entry {File :context "src" "core" "class" "runtime" "output-hook.scm"} 231466230. scheme
    {Lisp-Entry "core.class.runtime.output-hook" unit (protected) () #f #f 37 16 37 46 ("##default-wr" "else" "writeenv-style" "jazz:writeenv-style" "writeenv-port" "jazz:writeenv-port" "##jazz?" "and" "cond" "obj" "we" "lambda" "##wr" "print-hook" "jazz:print-hook" "set!")
      {Lisp-Entry "print-hook" define () () #f #f 42 12 42 27 ()}}})
"reader"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "reader.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.reader" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "read-source-all" define () ("port" "#!optional" "(container #f)" "(line #f)" "(col #f)") #f #f 40 9 40 29 ("%%vector-ref" "%%source-code" "%%cdr" "readtable-start-syntax" "jazz:readtable-start-syntax" "##unwrap-datum" "##wrap-datum" "%%current-readtable" "%%read-all-as-a-begin-expr-from-port" "begin-vector" "let" "%%input-port-column-set!" "1" "%%fx+" "%%input-port-line-set!" "lambda" "%%input-port-names-set!" "if" "col" "line" "container" "#!optional" "port")}
      {Lisp-Entry "read-source-first" define () ("port" "#!optional" "(container #f)" "(line #f)" "(col #f)") #f #f 59 9 59 31 ("read-source-all" "jazz:read-source-all" "%%car" "col" "line" "container" "#!optional" "port")}}})
"register"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "walker" "register.scm"} 231466230. scheme
    {Lisp-Entry "core.module.syntax.walker.register" unit (protected) () #f #f 37 16 37 50 ()
      {Lisp-Entry "core" define () () ("dialect") #f 45 21 45 25 ("new-core-dialect" "jazz:new-core-dialect")}
      {Lisp-Entry "require" define () () ("special") #f 49 28 49 35 ("walk-require" "jazz:walk-require" "core")}
      {Lisp-Entry "export" define () () ("special") #f 50 28 50 34 ("walk-export" "jazz:walk-export" "core")}
      {Lisp-Entry "import" define () () ("special") #f 51 28 51 34 ("walk-import" "jazz:walk-import" "core")}
      {Lisp-Entry "proclaim" define () () ("special") #f 52 28 52 36 ("walk-proclaim" "jazz:walk-proclaim" "core")}
      {Lisp-Entry "native" define () () ("special") #f 53 28 53 34 ("walk-native" "jazz:walk-native" "core")}
      {Lisp-Entry "native-syntax" define () () ("special") #f 54 28 54 41 ("walk-native-syntax" "jazz:walk-native-syntax" "core")}
      {Lisp-Entry "macro" define () () ("special") #f 55 28 55 33 ("walk-macro" "jazz:walk-macro" "core")}
      {Lisp-Entry "local-macro" define () () ("special") #f 56 28 56 39 ("walk-local-macro" "jazz:walk-local-macro" "core")}
      {Lisp-Entry "syntax" define () () ("special") #f 57 28 57 34 ("walk-syntax" "jazz:walk-syntax" "core")}
      {Lisp-Entry "define-syntax" define () () ("special") #f 58 28 58 41 ("walk-define-syntax" "jazz:walk-define-syntax" "core")}
      {Lisp-Entry "define-local-syntax" define () () ("special") #f 59 28 59 47 ("walk-define-local-syntax" "jazz:walk-define-local-syntax" "core")}
      {Lisp-Entry "let-syntax" define () () ("special") #f 60 28 60 38 ("walk-let-syntax" "jazz:walk-let-syntax" "core")}
      {Lisp-Entry "letrec-syntax" define () () ("special") #f 61 28 61 41 ("walk-letrec-syntax" "jazz:walk-letrec-syntax" "core")}
      {Lisp-Entry "reference" define () () ("special") #f 62 28 62 37 ("walk-reference" "jazz:walk-reference" "core")}
      {Lisp-Entry "walk-failed?" define () () ("special") #f 63 28 63 40 ("walk-walk-failed" "jazz:walk-walk-failed" "core")}}})
"runtime"
 ({Lisp-File-Entry {File :context "src" "core" "class" "runtime" "runtime.scm"} 231466230. scheme
    {Lisp-Entry "core.class.runtime.runtime" unit (protected) () #f #f 37 16 37 42 ("Queue" "jazz:Queue" "Method-Node" "jazz:Method-Node" "Method" "jazz:Method" "Property" "jazz:Property" "Slot" "jazz:Slot" "Field" "jazz:Field" "Interface" "jazz:Interface" "#xF" "#xE" "#xD" "#xC" "#xB" "#xA" "#x9" "#x8" "#x7" "#x6" "#x5" "#x4" "#x3" "#x2" "#x1" "#x0" "specialtypes" "jazz:specialtypes" "subtype-boxvalues" "jazz:subtype-boxvalues" "subtype-f64vector" "jazz:subtype-f64vector" "subtype-f32vector" "jazz:subtype-f32vector" "subtype-u64vector" "jazz:subtype-u64vector" "subtype-s64vector" "jazz:subtype-s64vector" "subtype-u32vector" "jazz:subtype-u32vector" "subtype-s32vector" "jazz:subtype-s32vector" "subtype-u16vector" "jazz:subtype-u16vector" "subtype-s16vector" "jazz:subtype-s16vector" "subtype-u8vector" "jazz:subtype-u8vector" "subtype-s8vector" "jazz:subtype-s8vector" "subtype-foreign" "jazz:subtype-foreign" "subtype-bignum" "jazz:subtype-bignum" "subtype-flonum" "jazz:subtype-flonum" "subtype-string" "jazz:subtype-string" "subtype-procedure" "jazz:subtype-procedure" "subtype-continuation" "jazz:subtype-continuation" "subtype-keyword" "jazz:subtype-keyword" "subtype-symbol" "jazz:subtype-symbol" "subtype-cpxnum" "jazz:subtype-cpxnum" "subtype-ratnum" "jazz:subtype-ratnum" "subtype-pair" "jazz:subtype-pair" "subtype-vector" "jazz:subtype-vector" "subtypes" "jazz:subtypes" "%%vector-set!" "Marker" "jazz:Marker" "Marker-Class" "jazz:Marker-Class" "Unspecified" "jazz:Unspecified" "Unspecified-Class" "jazz:Unspecified-Class" "EOF" "jazz:EOF" "EOF-Class" "jazz:EOF-Class" "Values" "jazz:Values" "Values-Class" "jazz:Values-Class" "Foreign" "jazz:Foreign" "Foreign-Class" "jazz:Foreign-Class" "Promise" "jazz:Promise" "Promise-Class" "jazz:Promise-Class" "thread?" "Thread" "jazz:Thread" "Thread-Class" "jazz:Thread-Class" "table?" "Table" "jazz:Table" "Table-Class" "jazz:Table-Class" "Keyword" "jazz:Keyword" "Keyword-Class" "jazz:Keyword-Class" "Symbol" "jazz:Symbol" "Symbol-Class" "jazz:Symbol-Class" "Procedure" "jazz:Procedure" "Procedure-Class" "jazz:Procedure-Class" "Continuation" "jazz:Continuation" "Continuation-Class" "jazz:Continuation-Class" "port?" "register-structure-type" "jazz:register-structure-type" "Port" "jazz:Port" "Port-Class" "jazz:Port-Class" "Structure" "jazz:Structure" "Structure-Class" "jazz:Structure-Class" "F64Vector" "jazz:F64Vector" "F64Vector-Class" "jazz:F64Vector-Class" "F32Vector" "jazz:F32Vector" "F32Vector-Class" "jazz:F32Vector-Class" "U64Vector" "jazz:U64Vector" "U64Vector-Class" "jazz:U64Vector-Class" "S64Vector" "jazz:S64Vector" "S64Vector-Class" "jazz:S64Vector-Class" "U32Vector" "jazz:U32Vector" "U32Vector-Class" "jazz:U32Vector-Class" "S32Vector" "jazz:S32Vector" "S32Vector-Class" "jazz:S32Vector-Class" "U16Vector" "jazz:U16Vector" "U16Vector-Class" "jazz:U16Vector-Class" "S16Vector" "jazz:S16Vector" "S16Vector-Class" "jazz:S16Vector-Class" "U8Vector" "jazz:U8Vector" "U8Vector-Class" "jazz:U8Vector-Class" "S8Vector" "jazz:S8Vector" "S8Vector-Class" "jazz:S8Vector-Class" "Vector" "jazz:Vector" "Vector-Class" "jazz:Vector-Class" "String" "jazz:String" "String-Class" "jazz:String-Class" "Pair" "jazz:Pair" "Pair-Class" "jazz:Pair-Class" "Null" "jazz:Null" "Null-Class" "jazz:Null-Class" "List" "jazz:List" "List-Class" "jazz:List-Class" "Sequence" "jazz:Sequence" "Sequence-Class" "jazz:Sequence-Class" "Flonum" "jazz:Flonum" "Flonum-Class" "jazz:Flonum-Class" "Fixnum" "jazz:Fixnum" "Fixnum-Class" "jazz:Fixnum-Class" "Integer" "jazz:Integer" "Integer-Class" "jazz:Integer-Class" "Rational" "jazz:Rational" "Rational-Class" "jazz:Rational-Class" "Real" "jazz:Real" "Real-Class" "jazz:Real-Class" "Complex" "jazz:Complex" "Complex-Class" "jazz:Complex-Class" "Number" "jazz:Number" "Number-Class" "jazz:Number-Class" "Numeric" "jazz:Numeric" "Numeric-Class" "jazz:Numeric-Class" "Char" "jazz:Char" "Char-Class" "jazz:Char-Class" "Boolean" "jazz:Boolean" "Boolean-Class" "jazz:Boolean-Class" "%%set-object-class" "Object-Class" "jazz:Object-Class" "Class" "jazz:Class" "Category" "jazz:Category" "Type" "jazz:Type" "encapsulate-class" "jazz:encapsulate-class" "Object" "jazz:Object")
      {Lisp-Entry "new-interface-rank" define () () #f #f 40 8 40 31 ("0")}
      {Lisp-Entry "dispatch?" define () ("symbol") #f #f 49 9 49 23 ("%%fx-" "%%string-ref" "%%eqv?" "1" "%%fx>" "%%string-length" "len" "%%symbol->string" "name" "let" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "dispatch->symbol" define () ("dispatch") #f #f 58 9 58 30 ("1" "%%string-length" "%%fx-" "0" "%%substring" "%%string->symbol" "%%symbol->string" "name" "let" "dispatch")}
      {Lisp-Entry "composite-identifier?" define () ("symbol") #f #f 63 9 63 35 ("%%symbol->string" "memstring" "jazz:memstring" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "composite-reference?" define () ("symbol") #f #f 68 9 68 34 ("%%symbol->string" "memstring" "jazz:memstring" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "compose-helper" define () ("locator" "suffix") #f #f 73 9 73 28 ("%%symbol->string" "%%string-append" "%%string->symbol" "suffix" "locator")}
      {Lisp-Entry "split-symbol" define () ("symbol" "separator") #f #f 77 9 77 26 ("%%symbol->string" "split-string" "jazz:split-string" "string->symbol" "map" "%%symbol?" "%%debug-assert" "separator" "symbol")}
      {Lisp-Entry "split-identifier" define () ("symbol") #f #f 82 9 82 30 ("split-symbol" "jazz:split-symbol" "symbol")}
      {Lisp-Entry "split-reference" define () ("symbol") #f #f 86 9 86 29 ("split-symbol" "jazz:split-symbol" "symbol")}
      {Lisp-Entry "composite-namespace?" define () ("symbol") #f #f 90 9 90 34 ("%%symbol->string" "memstring" "jazz:memstring" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "break-namespace" define () ("symbol") #f #f 95 9 95 29 ("%%string-length" "0" "%%substring" "%%string->symbol" "1" "%%fx+" "next" "values" "%%not" "if" "string-find-reversed" "jazz:string-find-reversed" "n" "%%symbol->string" "str" "let" "symbol")}
      {Lisp-Entry "namespace-name" define () ("symbol") #f #f 105 9 105 28 ("break-namespace" "jazz:break-namespace" "name" "namespace" "receive" "symbol")}
      {Lisp-Entry "inspect-object" define () ("object") #f #f 115 9 115 28 ("1" "%%fx+" "%%object-ref" "%%vector-set!" "begin" "%%fx<" "if" "0" "n" "iter" "let" "%%make-vector" "content" "%%object-length" "size" "let*" "%%object?" "%%assert" "object")}
      {Lisp-Entry "Core-Classes" define () () #f #f 132 8 132 25 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "get-core-classes" define () () #f #f 136 9 136 30 ("Core-Classes" "jazz:Core-Classes")}
      {Lisp-Entry "core-class?" define () ("name") #f #f 140 9 140 25 ("Core-Classes" "jazz:Core-Classes" "%%table-ref" "%%boolean" "name")}
      {Lisp-Entry "get-core-class" define () ("name") #f #f 144 9 144 28 ("Core-Classes" "jazz:Core-Classes" "%%table-ref" "name")}
      {Lisp-Entry "set-core-class" define () ("name" "class") #f #f 148 9 148 28 ("Core-Classes" "jazz:Core-Classes" "%%table-set!" "class" "name")}
      {Lisp-Entry "set-core-class-redefined" define () ("name" "core-class-locator") #f #f 152 9 152 38 ("Core-Classes" "jazz:Core-Classes" "%%table-set!" "core-class-locator" "name")}
      {Lisp-Entry "object?" define () ("expr") #f #f 161 9 161 21 ("%%object?" "expr")}
      {Lisp-Entry "primitive?" define () ("expr") #f #f 165 9 165 24 ("%%object?" "%%not" "expr")}
      {Lisp-Entry "subtype?" define () ("target" "type") #f #f 169 9 169 22 ("%%subtype?" "%%boolean" "type?" "jazz:type?" "and" "%%debug-assert" "type" "target")}
      {Lisp-Entry "subcategory?" define () ("target" "category") #f #f 174 9 174 26 ("%%subcategory?" "%%boolean" "category" "target")}
      {Lisp-Entry "subclass?" define () ("target" "class") #f #f 178 9 178 23 ("%%subclass?" "%%boolean" "class" "target")}
      {Lisp-Entry "get-category-descendants" define () ("category") #f #f 182 9 182 38 ("%%get-category-descendants" "category")}
      {Lisp-Entry "get-class-ascendant" define () ("class") #f #f 186 9 186 33 ("%%get-class-ascendant" "class")}
      {Lisp-Entry "object-of-class?" define-macro () () ("variable-override") #f 190 31 190 52 ("%%get-object-class" "%%subclass?" "class" "object" "lambda")}
      {Lisp-Entry "collect-type" define () ("type" "lst") #f #f 195 9 195 26 ("%%is?" "obj" "lambda" "collect-if" "jazz:collect-if" "lst" "type")}
      {Lisp-Entry "create-class-tables" define () ("class") #f #f 201 9 201 33 ("create-class-class-table" "jazz:create-class-class-table" "create-class-interface-table" "jazz:create-class-interface-table" "class")}
      {Lisp-Entry "create-core-class-tables" define () ("class") #f #f 206 9 206 38 ("create-class-class-table" "jazz:create-class-class-table" "class")}
      {Lisp-Entry "create-class-interface-table" define () ("class") #f #f 210 9 210 42 ("%%set-class-interface-table" "%%get-category-ancestors" "class-of" "jazz:class-of" "call-into-abstract" "jazz:call-into-abstract" "rest" "object" "%%get-method-implementation-rank" "Method" "jazz:Method" "%%is?" "field" "field-name" "%%get-category-fields" "iterate-table" "jazz:iterate-table" "category-identifier" "%%get-category-identifier" "class-name" "call-into-incoherent" "jazz:call-into-incoherent" "category-vtable" "%%get-category-virtual-size" "%%get-interface-rank" "rank" "let*" "Interface" "jazz:Interface" "%%class-is?" "category" "lambda" "vector-for-each" "jazz:vector-for-each" "1" "%%fx+" "%%vector-copy" "%%vector-set!" "%%vector-ref" "ascendant-vtable" "%%fx<" "0" "i" "iter" "%%vector-length" "size" "ascendant-interface-table" "%%get-class-ascendant" "ascendant" "new-interface-rank" "jazz:new-interface-rank" "%%make-vector" "vtable" "let" "%%get-class-interface-table" "%%not" "%%when" "class")}
      {Lisp-Entry "create-class-class-table" define () ("class") #f #f 244 9 244 38 ("%%vector-ref" "%%vector-copy" "%%vector-set!" "%%fx<" "0" "i" "iter" "#" "1" "%%fx+" "%%make-vector" "vtable" "%%vector-length" "size" "ascendant-class-table" "let*" "if" "%%set-class-class-table" "%%get-class-ascendant" "ascendant" "let" "%%get-class-class-table" "%%not" "%%when" "class")}
      {Lisp-Entry "encapsulate-class" define () ("class") #f #f 260 9 260 31 ("update-core-class" "jazz:update-core-class" "%%set-class-core-vtable" "%%get-class-core-method-alist" "%%get-class-core-virtual-alist" "get-method-rank" "jazz:get-method-rank" "%%cdr" "method-implementation" "%%car" "method-name" "method" "lambda" "for-each" "%%vector-ref" "%%vector-set!" "%%fx>=" "1" "%%vector-length" "%%fx-" "n" "iter" "%%get-class-core-vtable" "ascendant-vtable" "%%get-class-ascendant" "ascendant" "%%make-vector" "vtable" "0" "%%fx>" "%%when" "%%length" "vtable-size" "%%get-class-core-virtual-names" "virtual-names" "let" "class")}
      {Lisp-Entry "update-class" define () ("class") #f #f 287 9 287 26 ("update-class-class-table" "jazz:update-class-class-table" "class")}
      {Lisp-Entry "update-core-class" define () ("class") #f #f 291 9 291 31 ("update-class-class-table" "jazz:update-class-class-table" "class")}
      {Lisp-Entry "update-class-class-table" define () ("class") #f #f 295 9 295 38 ("implementation" "resize-vector" "jazz:resize-vector" "%%get-category-virtual-size" "class-virtual-size" "%%not-null?" "%%cons" "set!" "%%set-method-category-rank" "begin" "%%get-category-descendants" "descendant" "for-each" "%%vector-set!" "%%eq?" "implementation-table" "iter" "%%neq?" "%%get-method-implementation-tree" "%%get-method-node-implementation" "new-implementation" "old-implementation" "%%get-method-implementation-rank" "implementation-rank" "let" "%%get-method-category-rank" "if" "virtual-method?" "jazz:virtual-method?" "%%when" "field" "key" "lambda" "%%get-category-fields" "iterate-table" "jazz:iterate-table" "added-methods" "%%vector-ref" "root-implementation-table" "%%get-class-level" "class-rank" "%%get-class-class-table" "class-table" "let*" "update-class-class-root-methods" "define" "class")}
      {Lisp-Entry "new-core-class" define () ("class" "name" "fields" "ascendant" "slot-names" "instance-size") #f #f 346 9 346 28 ("create-core-class-tables" "jazz:create-core-class-tables" "%%get-category-descendants" "%%cons" "%%set-category-descendants" "%%when" "%%list->vector" "%%set-category-ancestors" "%%get-class-core-virtual-names" "1" "%%get-class-level" "%%fx+" "0" "%%object" "core-class" "let" "%%get-category-ancestors" "%%vector->list" "%%append" "%%list" "%%not" "if" "compute-core-class-ancestors" "define" "instance-size" "slot-names" "ascendant" "fields" "name" "class")}
      {Lisp-Entry "validate-inherited-slots" define () ("name" "ascendant" "inherited-slot-names") #f #f 382 9 382 38 ("error" "jazz:error" "%%equal?" "%%null?" "and" "or" "%%get-field-name" "slot" "lambda" "map" "symbol?" "some?" "jazz:some?" "all-slots" "core-class-all-slot-names" "%%append" "%%not" "if" "%%get-class-ascendant" "%%get-class-instance-slots" "slots" "let" "core-class" "core-class-all-slots" "define" "inherited-slot-names" "ascendant" "name")}
      {Lisp-Entry "Object" define-class () () ("class runtime") #f 409 27 409 38 ()}
      {Lisp-Entry "get-object-slot" define () ("object" "slot-offset") #f #f 412 9 412 29 ("unspecified" "jazz:unspecified" "%%object-ref" "%%integer?" "if" "%%object?" "%%debug-assert" "slot-offset" "object")}
      {Lisp-Entry "set-object-slot" define () ("object" "slot-offset" "value") #f #f 419 9 419 29 ("%%object-set!" "%%integer?" "%%object?" "%%debug-assert" "value" "slot-offset" "object")}
      {Lisp-Entry "classname->string" define () ("class") #f #f 425 9 425 31 ("%%get-category-identifier" "%%symbol->string" "%%null?" "if" "class")}
      {Lisp-Entry "print-object" generic/specific () ("output" "detail") ("jazz:Object~virtual-runtime") #f 431 30 431 47 ("detail" "output")}
      {Lisp-Entry "print-object" generic/specific () ("output" "detail") ("jazz:Object") #f 434 21 434 38 ("object" "print-serial" "jazz:print-serial" "detail" "output")}
      {Lisp-Entry "print-serial" define () ("object" "output") #f #f 438 9 438 26 ("display" "object->serial-number" "serial" "let" "output" "object")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Object~virtual-runtime") #f 445 30 445 44 ("environment" "seed" "here" "up" "down")}
      {Lisp-Entry "tree-fold" generic/specific () ("down" "up" "here" "seed" "environment") ("jazz:Object") #f 448 21 448 35 ("expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Type" define-class () () ("class runtime") #f 460 27 460 36 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Type~virtual-runtime") #f 463 30 463 43 ("object")}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Type") #f 466 21 466 34 ("class-of" "jazz:class-of" "type" "of-subtype?" "jazz:of-subtype?" "object")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Type~virtual-runtime") #f 470 30 470 46 ("subtype")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Type") #f 473 21 473 37 ("type" "error" "jazz:error" "subtype")}
      {Lisp-Entry "specifiable?" generic/specific () () ("jazz:Type~virtual-runtime") #f 477 30 477 47 ()}
      {Lisp-Entry "specifiable?" generic/specific () () ("jazz:Type") #f 480 21 480 38 ()}
      {Lisp-Entry "category-type?" generic/specific () () ("jazz:Type~virtual-runtime") #f 484 30 484 49 ()}
      {Lisp-Entry "category-type?" generic/specific () () ("jazz:Type") #f 487 21 487 40 ()}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Type~virtual-runtime") #f 491 30 491 49 ()}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Type") #f 494 21 494 40 ("type" "error" "jazz:error")}
      {Lisp-Entry "emit-type" generic/specific () ("source-declaration" "environment") ("jazz:Type~virtual-runtime") #f 498 30 498 44 ("environment" "source-declaration")}
      {Lisp-Entry "emit-type" generic/specific () ("source-declaration" "environment") ("jazz:Type") #f 501 21 501 35 ("type" "error" "jazz:error" "environment" "source-declaration")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Type~virtual-runtime") #f 505 30 505 44 ("environment" "source-declaration" "value")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Type") #f 508 21 508 35 (",locator" ",value" "%%is?" "type" "emit-type" "jazz:emit-type" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "emit-check" generic/specific () ("value" "source-declaration" "environment") ("jazz:Type~virtual-runtime") #f 513 30 513 45 ("environment" "source-declaration" "value")}
      {Lisp-Entry "emit-check" generic/specific () ("value" "source-declaration" "environment") ("jazz:Type") #f 516 21 516 36 (",locator" ",value" "type-error" "jazz:type-error" "emit-test" "jazz:emit-test" "%%not" "if" "type" "emit-type" "jazz:emit-type" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "bootstrap-type?" define () ("object" "type-class") #f #f 523 9 523 29 ("type-class" "object")}
      {Lisp-Entry "type?" define () ("object") #f #f 528 9 528 19 ("Type" "jazz:Type" "%%is?" "%%object?" "and" "object")}
      {Lisp-Entry "structure-types" define () () #f #f 541 8 541 28 ()}
      {Lisp-Entry "register-structure-type" define () ("test" "type") #f #f 545 9 545 37 ("%%cons" "structure-types" "jazz:structure-types" "set!" "type" "test")}
      {Lisp-Entry "structure-type" define () ("object") #f #f 549 9 549 28 ("%%cdr" "%%cdar" "%%caar" "Structure" "jazz:Structure" "%%null?" "if" "structure-types" "jazz:structure-types" "scan" "iter" "let" "object")}
      {Lisp-Entry "Category" define-class () () ("class runtime") #f 563 27 563 40 ()}
      {Lisp-Entry "category?" define () ("object") #f #f 566 9 566 23 ("category-type?" "jazz:category-type?" "type?" "jazz:type?" "and" "object")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Category") #f 571 21 571 37 ("%%get-category-ancestors" "type" "vector-memq?" "jazz:vector-memq?" "category-type?" "jazz:category-type?" "and" "subtype")}
      {Lisp-Entry "category-type?" generic/specific () () ("jazz:Category") #f 576 21 576 40 ()}
      {Lisp-Entry "emit-type" generic/specific () ("source-declaration" "environment") ("jazz:Category") #f 580 21 580 35 ("type" "%%get-category-identifier" "environment" "source-declaration")}
      {Lisp-Entry "update-category" generic/specific () () ("jazz:Category~virtual-runtime") #f 584 30 584 50 ()}
      {Lisp-Entry "update-category" generic/specific () () ("jazz:Category") #f 587 21 587 41 ()}
      {Lisp-Entry "is?" define () ("object" "category") #f #f 591 9 591 17 ("%%is?" "%%boolean" "category" "object")}
      {Lisp-Entry "is-not?" define () ("object" "category") #f #f 595 9 595 21 ("%%is?" "%%not" "%%boolean" "category" "object")}
      {Lisp-Entry "get-category-identifier" define () ("category") #f #f 599 9 599 37 ("%%get-category-identifier" "category?" "jazz:category?" "%%debug-assert" "category")}
      {Lisp-Entry "add-field" define () ("category" "field") #f #f 604 9 604 23 ("%%unspecified" "%%get-field-name" "%%set-category-field" "field" "category")}
      {Lisp-Entry "Class" define-class () () ("class runtime") #f 617 27 617 37 ()}
      {Lisp-Entry "new-class" define () ("class-of-class" "identifier" "ascendant" "interfaces") #f #f 620 9 620 23 ("%%class-dispatch" "initialize-slots" "jazz:initialize-slots" "create-class-tables" "jazz:create-class-tables" "%%get-category-descendants" "%%list->vector" "%%set-class-interface-table" "%%set-class-class-table" "%%get-class-core-vtable" "%%set-class-core-vtable" "%%set-class-core-virtual-names" "%%set-class-core-virtual-alist" "%%set-class-core-method-alist" "%%set-class-dispatch-table" "1" "%%get-class-level" "%%fx+" "%%set-class-level" "object-size" "jazz:object-size" "%%set-class-instance-size" "%%get-class-instance-slots" "if" "%%set-class-instance-slots" "%%set-class-slots" "%%set-class-interfaces" "%%set-class-ascendant" "%%set-category-descendants" "%%set-category-ancestors" "0" "%%set-category-virtual-size" "eq?" "test:" "%%make-table" "%%set-category-fields" "%%set-category-identifier" "%%get-class-instance-size" "%%make-object" "add-classes" "%%get-interface-ascendants" "%%cons" "set!" "%%memq" "%%not" "else" "%%get-class-interfaces" "for-each" "%%when" "%%get-class-ascendant" "%%class?" "cond" "category" "add-interfaces" "ancestors" "let" "class" "compute-class-ancestors" "define" "interfaces" "ascendant" "identifier" "class-of-class")}
      {Lisp-Entry "class?" define () ("object") #f #f 668 9 668 20 ("Class" "jazz:Class" "%%class-is?" "object")}
      {Lisp-Entry "class-of" define () ("expr") #f #f 672 9 672 22 ("%%class-of-impl" "expr")}
      {Lisp-Entry "class-subtype?" define () ("target" "class") #f #f 676 9 676 28 ("%%class-subtype?" "class" "target")}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Class") #f 680 21 680 34 ("class" "class-of" "jazz:class-of" "%%class-subtype?" "object")}
      {Lisp-Entry "update-category" generic/specific () () ("jazz:Class") #f 684 21 684 41 ("class" "update-class" "jazz:update-class")}
      {Lisp-Entry "slot-form?" define () ("form") #f #f 688 9 688 24 ("slot" "%%car" "%%eq?" "%%pair?" "and" "form")}
      {Lisp-Entry "new" define () ("class" "." "rest") #f #f 693 9 693 17 ("0" "%%class-dispatch" "apply" "initialize-slots" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "rest" "class")}
      {Lisp-Entry "new0" define () ("class") #f #f 701 9 701 18 ("0" "%%class-dispatch" "initialize-slots" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "class")}
      {Lisp-Entry "new1" define () ("class" "arg1") #f #f 709 9 709 18 ("0" "%%class-dispatch" "initialize-slots" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "arg1" "class")}
      {Lisp-Entry "new2" define () ("class" "arg1" "arg2") #f #f 717 9 717 18 ("0" "%%class-dispatch" "initialize-slots" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "arg2" "arg1" "class")}
      {Lisp-Entry "nascent-new" define () ("class" "." "rest") #f #f 725 9 725 25 ("initialize-slots" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "rest" "class")}
      {Lisp-Entry "iterate-descendants-tree" define () ("class" "proc") #f #f 732 9 732 38 ("%%get-category-descendants" "for-each" "iter" "let" "proc" "class")}
      {Lisp-Entry "Object-Class" define-class () () ("class runtime") #f 746 27 746 44 ()}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Object-Class") #f 749 21 749 37 ("nextmethod" "class" "%%object-class?" "if" "subtype")}
      {Lisp-Entry "Boolean-Class" define-class () () ("class runtime") #f 775 27 775 45 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Boolean-Class") #f 778 21 778 34 ("%%boolean?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Boolean-Class") #f 782 21 782 40 ("bool")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Boolean-Class") #f 786 21 786 35 (",value" "%%boolean?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Boolean" define-class () () ("class runtime") #f 793 27 793 39 ()}
      {Lisp-Entry "Char-Class" define-class () () ("class runtime") #f 804 27 804 42 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Char-Class") #f 807 21 807 34 ("%%char?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Char-Class") #f 811 21 811 40 ("char")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Char-Class") #f 815 21 815 35 (",value" "%%char?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Char" define-class () () ("class runtime") #f 822 27 822 36 ()}
      {Lisp-Entry "Numeric-Class" define-class () () ("class runtime") #f 833 27 833 45 ()}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Numeric-Class") #f 836 21 836 40 ("numeric")}
      {Lisp-Entry "Numeric" define-class () () ("class runtime") #f 843 27 843 39 ()}
      {Lisp-Entry "Number-Class" define-class () () ("class runtime") #f 854 27 854 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Number-Class") #f 857 21 857 34 ("%%number?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Number-Class") #f 861 21 861 40 ("number")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Number-Class") #f 865 21 865 35 (",value" "%%number?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Number" define-class () () ("class runtime") #f 872 27 872 38 ()}
      {Lisp-Entry "Complex-Class" define-class () () ("class runtime") #f 883 27 883 45 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Complex-Class") #f 886 21 886 34 ("%%complex?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Complex-Class") #f 890 21 890 40 ("complex")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Complex-Class") #f 894 21 894 35 (",value" "%%complex?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Complex" define-class () () ("class runtime") #f 901 27 901 39 ()}
      {Lisp-Entry "Real-Class" define-class () () ("class runtime") #f 912 27 912 42 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Real-Class") #f 915 21 915 34 ("%%real?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Real-Class") #f 919 21 919 40 ("real")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Real-Class") #f 923 21 923 35 (",value" "%%real?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Real" define-class () () ("class runtime") #f 930 27 930 36 ()}
      {Lisp-Entry "Rational-Class" define-class () () ("class runtime") #f 941 27 941 46 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Rational-Class") #f 944 21 944 34 ("%%rational?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Rational-Class") #f 948 21 948 40 ("rational")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Rational-Class") #f 952 21 952 35 (",value" "%%rational?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Rational" define-class () () ("class runtime") #f 959 27 959 40 ()}
      {Lisp-Entry "Integer-Class" define-class () () ("class runtime") #f 970 27 970 45 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Integer-Class") #f 973 21 973 34 ("%%integer?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Integer-Class") #f 977 21 977 40 ("int")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Integer-Class") #f 981 21 981 35 (",value" "%%integer?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Integer" define-class () () ("class runtime") #f 988 27 988 39 ()}
      {Lisp-Entry "Fixnum-Class" define-class () () ("class runtime") #f 999 27 999 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Fixnum-Class") #f 1002 21 1002 34 ("%%fixnum?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Fixnum-Class") #f 1006 21 1006 40 ("fx")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Fixnum-Class") #f 1010 21 1010 35 (",value" "%%fixnum?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Fixnum" define-class () () ("class runtime") #f 1017 27 1017 38 ()}
      {Lisp-Entry "Flonum-Class" define-class () () ("class runtime") #f 1028 27 1028 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Flonum-Class") #f 1031 21 1031 34 ("%%flonum?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Flonum-Class") #f 1035 21 1035 40 ("fl")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Flonum-Class") #f 1039 21 1039 35 (",value" "%%flonum?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Flonum" define-class () () ("class runtime") #f 1046 27 1046 38 ()}
      {Lisp-Entry "Sequence-Class" define-class () () ("class runtime") #f 1057 27 1057 46 ()}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Sequence-Class") #f 1060 21 1060 40 ("sequence")}
      {Lisp-Entry "Sequence" define-class () () ("class runtime") #f 1067 27 1067 40 ()}
      {Lisp-Entry "List-Class" define-class () () ("class runtime") #f 1078 27 1078 42 ()}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:List-Class") #f 1081 21 1081 40 ("list")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:List-Class") #f 1085 21 1085 35 ("%%pair?" ",value" "%%null?" "or" "environment" "source-declaration" "value")}
      {Lisp-Entry "List" define-class () () ("class runtime") #f 1092 27 1092 36 ()}
      {Lisp-Entry "Null-Class" define-class () () ("class runtime") #f 1103 27 1103 42 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Null-Class") #f 1106 21 1106 34 ("%%null?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Null-Class") #f 1110 21 1110 40 ("null")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Null-Class") #f 1114 21 1114 35 (",value" "%%null?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Null" define-class () () ("class runtime") #f 1121 27 1121 36 ()}
      {Lisp-Entry "Pair-Class" define-class () () ("class runtime") #f 1132 27 1132 42 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Pair-Class") #f 1135 21 1135 34 ("%%pair?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Pair-Class") #f 1139 21 1139 40 ("pair")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Pair-Class") #f 1143 21 1143 35 (",value" "%%pair?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Pair" define-class () () ("class runtime") #f 1150 27 1150 36 ()}
      {Lisp-Entry "String-Class" define-class () () ("class runtime") #f 1161 27 1161 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:String-Class") #f 1164 21 1164 34 ("%%string?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:String-Class") #f 1168 21 1168 40 ("string")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:String-Class") #f 1172 21 1172 35 (",value" "%%string?" "environment" "source-declaration" "value")}
      {Lisp-Entry "String" define-class () () ("class runtime") #f 1179 27 1179 38 ()}
      {Lisp-Entry "Vector-Class" define-class () () ("class runtime") #f 1190 27 1190 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Vector-Class") #f 1193 21 1193 34 ("%%vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Vector-Class") #f 1197 21 1197 40 ("vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Vector-Class") #f 1201 21 1201 35 (",value" "%%vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Vector" define-class () () ("class runtime") #f 1208 27 1208 38 ()}
      {Lisp-Entry "S8Vector-Class" define-class () () ("class runtime") #f 1219 27 1219 46 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:S8Vector-Class") #f 1222 21 1222 34 ("%%s8vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:S8Vector-Class") #f 1226 21 1226 40 ("s8vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:S8Vector-Class") #f 1230 21 1230 35 (",value" "%%s8vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "S8Vector" define-class () () ("class runtime") #f 1237 27 1237 40 ()}
      {Lisp-Entry "U8Vector-Class" define-class () () ("class runtime") #f 1248 27 1248 46 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:U8Vector-Class") #f 1251 21 1251 34 ("%%u8vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:U8Vector-Class") #f 1255 21 1255 40 ("u8vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:U8Vector-Class") #f 1259 21 1259 35 (",value" "%%u8vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "U8Vector" define-class () () ("class runtime") #f 1266 27 1266 40 ()}
      {Lisp-Entry "S16Vector-Class" define-class () () ("class runtime") #f 1277 27 1277 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:S16Vector-Class") #f 1280 21 1280 34 ("%%s16vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:S16Vector-Class") #f 1284 21 1284 40 ("s16vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:S16Vector-Class") #f 1288 21 1288 35 (",value" "%%s16vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "S16Vector" define-class () () ("class runtime") #f 1295 27 1295 41 ()}
      {Lisp-Entry "U16Vector-Class" define-class () () ("class runtime") #f 1306 27 1306 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:U16Vector-Class") #f 1309 21 1309 34 ("%%u16vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:U16Vector-Class") #f 1313 21 1313 40 ("u16vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:U16Vector-Class") #f 1317 21 1317 35 (",value" "%%u16vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "U16Vector" define-class () () ("class runtime") #f 1324 27 1324 41 ()}
      {Lisp-Entry "S32Vector-Class" define-class () () ("class runtime") #f 1335 27 1335 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:S32Vector-Class") #f 1338 21 1338 34 ("%%s32vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:S32Vector-Class") #f 1342 21 1342 40 ("s32vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:S32Vector-Class") #f 1346 21 1346 35 (",value" "%%s32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "S32Vector" define-class () () ("class runtime") #f 1353 27 1353 41 ()}
      {Lisp-Entry "U32Vector-Class" define-class () () ("class runtime") #f 1364 27 1364 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:U32Vector-Class") #f 1367 21 1367 34 ("%%u32vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:U32Vector-Class") #f 1371 21 1371 40 ("u32vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:U32Vector-Class") #f 1375 21 1375 35 (",value" "%%u32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "U32Vector" define-class () () ("class runtime") #f 1382 27 1382 41 ()}
      {Lisp-Entry "S64Vector-Class" define-class () () ("class runtime") #f 1393 27 1393 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:S64Vector-Class") #f 1396 21 1396 34 ("%%s64vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:S64Vector-Class") #f 1400 21 1400 40 ("s64vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:S64Vector-Class") #f 1404 21 1404 35 (",value" "%%s64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "S64Vector" define-class () () ("class runtime") #f 1411 27 1411 41 ()}
      {Lisp-Entry "U64Vector-Class" define-class () () ("class runtime") #f 1422 27 1422 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:U64Vector-Class") #f 1425 21 1425 34 ("%%u64vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:U64Vector-Class") #f 1429 21 1429 40 ("u64vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:U64Vector-Class") #f 1433 21 1433 35 (",value" "%%u64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "U64Vector" define-class () () ("class runtime") #f 1440 27 1440 41 ()}
      {Lisp-Entry "F32Vector-Class" define-class () () ("class runtime") #f 1451 27 1451 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:F32Vector-Class") #f 1454 21 1454 34 ("%%f32vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:F32Vector-Class") #f 1458 21 1458 40 ("f32vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:F32Vector-Class") #f 1462 21 1462 35 (",value" "%%f32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "F32Vector" define-class () () ("class runtime") #f 1469 27 1469 41 ()}
      {Lisp-Entry "F64Vector-Class" define-class () () ("class runtime") #f 1480 27 1480 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:F64Vector-Class") #f 1483 21 1483 34 ("%%f64vector?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:F64Vector-Class") #f 1487 21 1487 40 ("f64vector")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:F64Vector-Class") #f 1491 21 1491 35 (",value" "%%f64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "F64Vector" define-class () () ("class runtime") #f 1498 27 1498 41 ()}
      {Lisp-Entry "Structure-Class" define-class () () ("class runtime") #f 1509 27 1509 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Structure-Class") #f 1512 21 1512 34 ("%%structure?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Structure-Class") #f 1516 21 1516 40 ("structure")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Structure-Class") #f 1520 21 1520 35 (",value" "%%structure?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Structure" define-class () () ("class runtime") #f 1527 27 1527 41 ()}
      {Lisp-Entry "Port-Class" define-class () () ("class runtime") #f 1538 27 1538 42 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Port-Class") #f 1541 21 1541 34 ("%%port?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Port-Class") #f 1545 21 1545 40 ("port")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Port-Class") #f 1549 21 1549 35 (",value" "%%port?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Port" define-class () () ("class runtime") #f 1556 27 1556 36 ()}
      {Lisp-Entry "Continuation-Class" define-class () () ("class runtime") #f 1570 27 1570 50 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Continuation-Class") #f 1573 21 1573 34 ("%%continuation?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Continuation-Class") #f 1577 21 1577 40 ("continuation")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Continuation-Class") #f 1581 21 1581 35 (",value" "%%continuation?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Continuation" define-class () () ("class runtime") #f 1588 27 1588 44 ()}
      {Lisp-Entry "Procedure-Class" define-class () () ("class runtime") #f 1599 27 1599 47 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Procedure-Class") #f 1602 21 1602 34 ("%%procedure?" "object")}
      {Lisp-Entry "of-subtype?" generic/specific () ("subtype") ("jazz:Procedure-Class") #f 1606 21 1606 37 ("class" "nextmethod" "or" "subtype")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Procedure-Class") #f 1612 21 1612 40 ("procedure")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Procedure-Class") #f 1616 21 1616 35 (",value" "%%procedure?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Procedure" define-class () () ("class runtime") #f 1623 27 1623 41 ()}
      {Lisp-Entry "Symbol-Class" define-class () () ("class runtime") #f 1634 27 1634 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Symbol-Class") #f 1637 21 1637 34 ("%%symbol?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Symbol-Class") #f 1641 21 1641 40 ("symbol")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Symbol-Class") #f 1645 21 1645 35 (",value" "%%symbol?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Symbol" define-class () () ("class runtime") #f 1652 27 1652 38 ()}
      {Lisp-Entry "Keyword-Class" define-class () () ("class runtime") #f 1663 27 1663 45 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Keyword-Class") #f 1666 21 1666 34 ("%%keyword?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Keyword-Class") #f 1670 21 1670 40 ("keyword")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Keyword-Class") #f 1674 21 1674 35 (",value" "%%keyword?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Keyword" define-class () () ("class runtime") #f 1681 27 1681 39 ()}
      {Lisp-Entry "Table-Class" define-class () () ("class runtime") #f 1692 27 1692 43 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Table-Class") #f 1695 21 1695 34 ("%%table?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Table-Class") #f 1699 21 1699 40 ("table")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Table-Class") #f 1703 21 1703 35 (",value" "%%table?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Table" define-class () () ("class runtime") #f 1710 27 1710 37 ()}
      {Lisp-Entry "Thread-Class" define-class () () ("class runtime") #f 1724 27 1724 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Thread-Class") #f 1727 21 1727 34 ("%%thread?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Thread-Class") #f 1731 21 1731 40 ("thread")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Thread-Class") #f 1735 21 1735 35 (",value" "%%thread?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Thread" define-class () () ("class runtime") #f 1742 27 1742 38 ()}
      {Lisp-Entry "Promise-Class" define-class () () ("class runtime") #f 1756 27 1756 45 ()}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Promise-Class") #f 1759 21 1759 40 ("promise")}
      {Lisp-Entry "Promise" define-class () () ("class runtime") #f 1766 27 1766 39 ()}
      {Lisp-Entry "Foreign-Class" define-class () () ("class runtime") #f 1777 27 1777 45 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Foreign-Class") #f 1780 21 1780 34 ("%%foreign?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Foreign-Class") #f 1784 21 1784 40 ("foreign")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Foreign-Class") #f 1788 21 1788 35 (",value" "%%foreign?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Foreign" define-class () () ("class runtime") #f 1795 27 1795 39 ()}
      {Lisp-Entry "Values-Class" define-class () () ("class runtime") #f 1806 27 1806 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Values-Class") #f 1809 21 1809 34 ("%%values?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Values-Class") #f 1813 21 1813 40 ("values")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Values-Class") #f 1817 21 1817 35 (",value" "%%values?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Values" define-class () () ("class runtime") #f 1824 27 1824 38 ()}
      {Lisp-Entry "EOF-Class" define-class () () ("class runtime") #f 1835 27 1835 41 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:EOF-Class") #f 1838 21 1838 34 ("%%eof-object?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:EOF-Class") #f 1842 21 1842 40 ("eof")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:EOF-Class") #f 1846 21 1846 35 (",value" "%%eof-object?" "environment" "source-declaration" "value")}
      {Lisp-Entry "EOF" define-class () () ("class runtime") #f 1853 27 1853 35 ()}
      {Lisp-Entry "Unspecified-Class" define-class () () ("class runtime") #f 1864 27 1864 49 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Unspecified-Class") #f 1867 21 1867 34 ("%%unspecified?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Unspecified-Class") #f 1871 21 1871 40 ("unspecified")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Unspecified-Class") #f 1875 21 1875 35 (",value" "%%unspecified?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Unspecified" define-class () () ("class runtime") #f 1882 27 1882 43 ()}
      {Lisp-Entry "Marker-Class" define-class () () ("class runtime") #f 1893 27 1893 44 ()}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Marker-Class") #f 1896 21 1896 34 ("marker?" "jazz:marker?" "object")}
      {Lisp-Entry "emit-specifier" generic/specific () () ("jazz:Marker-Class") #f 1900 21 1900 40 ("marker")}
      {Lisp-Entry "emit-test" generic/specific () ("value" "source-declaration" "environment") ("jazz:Marker-Class") #f 1904 21 1904 35 (",value" "marker?" "jazz:marker?" "environment" "source-declaration" "value")}
      {Lisp-Entry "Marker" define-class () () ("class runtime") #f 1911 27 1911 38 ()}
      {Lisp-Entry "subtypes" define () () #f #f 1924 12 1924 25 ("32" "%%make-vector")}
      {Lisp-Entry "specialtypes" define () () #f #f 1927 12 1927 29 ("16" "%%make-vector")}
      {Lisp-Entry "table-type" define () () #f #f 1931 12 1931 27 ("make-table" "%%structure-type")}
      {Lisp-Entry "port-type" define () () #f #f 1935 12 1935 26 ("open-output-string" "%%structure-type")}
      {Lisp-Entry "thread-type" define () () #f #f 1939 12 1939 28 ("current-thread" "%%structure-type")}
      {Lisp-Entry "Interface" define-class () () ("class runtime") #f 1992 27 1992 41 ()}
      {Lisp-Entry "new-interface" define () ("class" "identifier" "ascendants") #f #f 1995 9 1995 27 ("%%get-category-descendants" "%%set-category-descendants" "for-each" "%%list->vector" "%%set-category-ancestors" "1" "%%fx+" "set!" "new-interface-rank" "jazz:new-interface-rank" "0" "eq?" "test:" "%%make-table" "allocate-interface" "jazz:allocate-interface" "let" "%%list" "%%get-category-ancestors" "%%vector->list" "ascendant" "lambda" "map" "%%cons" "append" "%%apply" "remove-duplicates" "jazz:remove-duplicates" "interface" "compute-interface-ancestors" "define" "ascendants" "identifier" "class")}
      {Lisp-Entry "interface?" define () ("object") #f #f 2012 9 2012 24 ("Interface" "jazz:Interface" "%%class-is?" "object")}
      {Lisp-Entry "of-type?" generic/specific () ("object") ("jazz:Interface") #f 2027 21 2027 34 ("class-of" "jazz:class-of" "interface" "of-subtype?" "jazz:of-subtype?" "object")}
      {Lisp-Entry "update-category" generic/specific () () ("jazz:Interface") #f 2031 21 2031 41 ("interface" "update-interface" "jazz:update-interface")}
      {Lisp-Entry "update-interface" define () ("interface") #f #f 2035 9 2035 30 ("%%get-category-descendants" "descendant" "%%vector-set!" "%%get-method-implementation-tree" "%%get-method-node-implementation" "implementation" "%%get-method-implementation-rank" "implementation-rank" "for-each" "%%get-category-virtual-size" "%%vector-ref" "resize-vector" "jazz:resize-vector" "implementation-table" "%%get-class-interface-table" "interface-table" "Class" "jazz:Class" "%%class-is?" "category" "iter" "%%not-null?" "let" "%%cons" "set!" "%%set-method-category-rank" "%%get-method-category-rank" "%%not" "virtual-method?" "jazz:virtual-method?" "and" "%%when" "field" "key" "lambda" "%%get-category-fields" "iterate-table" "jazz:iterate-table" "added-methods" "%%get-interface-rank" "interface-rank" "let*" "update-interface-root-methods" "define" "interface")}
      {Lisp-Entry "Field" define-class () () ("class runtime") #f 2073 27 2073 37 ()}
      {Lisp-Entry "field?" define () ("object") #f #f 2076 9 2076 20 ("Field" "jazz:Field" "%%class-is?" "object")}
      {Lisp-Entry "field-name" define () ("field") #f #f 2080 9 2080 24 ("%%get-field-name" "field")}
      {Lisp-Entry "category-field" define () ("category" "field-name") #f #f 2084 9 2084 28 ("category-field" "jazz:category-field" "and" "%%get-class-ascendant" "ascendant" "let" "%%get-category-field" "or" "field-name" "category")}
      {Lisp-Entry "require-object-field" define () ("object" "name") #f #f 2091 9 2091 34 ("%%get-category-identifier" "error" "jazz:error" "%%not" "if" "category-field" "jazz:category-field" "field" "%%get-object-class" "class" "let*" "name" "object")}
      {Lisp-Entry "Slot" define-class () () ("class runtime") #f 2107 27 2107 36 ()}
      {Lisp-Entry "new-slot" define () ("slot-name" "slot-offset" "slot-initialize") #f #f 2110 9 2110 22 ("Slot" "jazz:Slot" "allocate-slot" "jazz:allocate-slot" "slot-initialize" "slot-offset" "slot-name")}
      {Lisp-Entry "slot?" define () ("object") #f #f 2114 9 2114 19 ("Slot" "jazz:Slot" "%%class-is?" "object")}
      {Lisp-Entry "add-slot" define () ("class" "slot-name" "slot-initialize" "slot-allocate?") #f #f 2118 9 2118 22 ("1" "%%fx+" "%%set-class-instance-size" "%%when" "%%get-class-instance-slots" "%%set-class-instance-slots" "%%list" "%%get-class-slots" "%%append" "%%set-class-slots" "add-field" "jazz:add-field" "new-slot" "jazz:new-slot" "slot" "and" "slot-offset" "%%get-class-instance-size" "instance-size" "let*" "else" "%%set-slot-initialize" "cond" "%%get-category-field" "actual" "let" "slot-allocate?" "slot-initialize" "slot-name" "class")}
      {Lisp-Entry "remove-own-slots" define () ("class") #f #f 2135 9 2135 30 ("%%length" "%%get-class-instance-size" "%%fx-" "%%set-class-instance-size" "if" "%%set-class-instance-slots" "%%set-class-slots" "%%get-class-instance-slots" "actual" "%%get-class-ascendant" "ascendant" "let" "class")}
      {Lisp-Entry "slot-value" define () ("object" "slot-name") #f #f 2143 9 2143 24 ("find-slot-offset" "jazz:find-slot-offset" "get-object-slot" "jazz:get-object-slot" "slot-name" "object")}
      {Lisp-Entry "set-slot-value" define () ("object" "slot-name" "value") #f #f 2147 9 2147 28 ("find-slot-offset" "jazz:find-slot-offset" "set-object-slot" "jazz:set-object-slot" "value" "slot-name" "object")}
      {Lisp-Entry "find-slot-offset" define () ("object" "slot-name") #f #f 2151 9 2151 30 ("%%get-slot-offset" "require-object-field" "jazz:require-object-field" "slot" "let" "%%object?" "%%debug-assert" "slot-name" "object")}
      {Lisp-Entry "initialize-slots" define () ("object") #f #f 2157 9 2157 30 ("%%object-set!" "%%when" "%%get-slot-initialize" "initialize" "%%get-slot-offset" "offset" "slot" "lambda" "for-each" "%%get-object-class" "%%get-class-instance-slots" "slots" "let" "object")}
      {Lisp-Entry "Property" define-class () () ("class runtime") #f 2175 27 2175 40 ()}
      {Lisp-Entry "new-property" define () ("slot-name" "slot-offset" "slot-initialize" "slot-getter" "slot-setter") #f #f 2178 9 2178 26 ("Property" "jazz:Property" "allocate-property" "jazz:allocate-property" "slot-setter" "slot-getter" "slot-initialize" "slot-offset" "slot-name")}
      {Lisp-Entry "property?" define () ("object") #f #f 2182 9 2182 23 ("Property" "jazz:Property" "%%class-is?" "object")}
      {Lisp-Entry "property-getter" define () ("property") #f #f 2186 9 2186 29 ("%%get-property-getter" "property")}
      {Lisp-Entry "property-setter" define () ("property") #f #f 2190 9 2190 29 ("%%get-property-setter" "property")}
      {Lisp-Entry "all-properties" define () ("category") #f #f 2194 9 2194 28 ("else" "%%cdr" "%%cons" "%%car" "property?" "jazz:property?" "%%null?" "cond" "%%get-class-instance-slots" "slots" "iter" "let" "category")}
      {Lisp-Entry "add-property" define () ("class" "slot-name" "slot-initialize" "slot-allocate?" "slot-getter" "slot-setter") #f #f 2201 9 2201 26 ("1" "%%fx+" "%%set-class-instance-size" "%%when" "%%get-class-instance-slots" "%%set-class-instance-slots" "%%list" "%%get-class-slots" "%%append" "%%set-class-slots" "add-field" "jazz:add-field" "new-property" "jazz:new-property" "slot" "and" "slot-offset" "%%get-class-instance-size" "instance-size" "let*" "else" "%%set-property-setter" "%%set-property-getter" "%%set-slot-initialize" "cond" "%%get-category-field" "actual" "let" "slot-setter" "slot-getter" "slot-allocate?" "slot-initialize" "slot-name" "class")}
      {Lisp-Entry "Method" define-class () () ("class runtime") #f 2228 27 2228 38 ()}
      {Lisp-Entry "method?" define () ("object") #f #f 2231 9 2231 21 ("Method" "jazz:Method" "%%class-is?" "object")}
      {Lisp-Entry "final-method?" define () ("field") #f #f 2235 9 2235 27 ("final" "%%get-method-dispatch-type" "%%eq?" "Method" "jazz:Method" "%%class-is?" "and" "field")}
      {Lisp-Entry "virtual-method?" define () ("field") #f #f 2240 9 2240 29 ("final" "%%get-method-dispatch-type" "%%neq?" "Method" "jazz:Method" "%%class-is?" "and" "field")}
      {Lisp-Entry "locate-method-owner" define () ("category" "method-name") #f #f 2245 9 2245 33 ("%%get-interface-ascendants" "Interface" "jazz:Interface" "%%get-class-interfaces" "find-in" "jazz:find-in" "%%get-class-ascendant" "or" "Class" "jazz:Class" "%%class-is?" "%%get-category-field" "%%not" "cond" "iter" "let" "method-name" "category")}
      {Lisp-Entry "iterate-class-overrides" define () ("class" "proc") #f #f 2261 9 2261 37 ("%%class-dispatch" "%%neq?" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "category-rank" "interface" "%%eq?" "or" "%%get-method-dispatch-type" "dispatch-type" "Method" "jazz:Method" "%%is?" "and" "field" "name" "lambda" "%%get-category-fields" "iterate-table-safe" "jazz:iterate-table-safe" "begin" "if" "ancestor" "iter" "%%get-class-ascendant" "ascendant" "let" "proc" "class")}
      {Lisp-Entry "update-method" define () ("class" "method-name" "method-implementation") #f #f 2280 9 2280 27 ("add-method-node" "jazz:add-method-node" "add-final-method" "jazz:add-final-method" "final" "add-virtual-method" "jazz:add-virtual-method" "interface" "%%get-method-dispatch-type" "case" "%%eq?" "if" "global-set!" "jazz:global-set!" "%%get-category-identifier" "%%compose-reference" "method-locator" "%%get-category-field" "method" "locate-method-owner" "jazz:locate-method-owner" "owner" "let" "method-implementation" "method-name" "class")}
      {Lisp-Entry "new-final-method" define () ("name" "implementation") #f #f 2297 9 2297 30 ("final" "Method" "jazz:Method" "allocate-method" "jazz:allocate-method" "implementation" "name")}
      {Lisp-Entry "add-final-method" define () ("class" "method-name" "method-implementation") #f #f 2301 9 2301 30 ("else" "%%eq?" "%%not" "cond" "locate-method-owner" "jazz:locate-method-owner" "owner" "error" "jazz:error" "%%set-method-implementation" "final-method?" "jazz:final-method?" "if" "%%get-category-field" "field" "update-final-method" "add-field" "jazz:add-field" "new-final-method" "jazz:new-final-method" "method" "let" "create-final-method" "define" "method-implementation" "method-name" "class")}
      {Lisp-Entry "new-virtual-method" define () ("name" "dispatch-type" "implementation-tree" "category-rank" "implementation-rank") #f #f 2328 9 2328 32 ("Method" "jazz:Method" "allocate-method" "jazz:allocate-method" "implementation-rank" "category-rank" "implementation-tree" "dispatch-type" "name")}
      {Lisp-Entry "add-virtual-method" define () ("category" "method-name" "method-implementation") #f #f 2332 9 2332 32 ("else" "%%eq?" "%%not" "cond" "locate-method-owner" "jazz:locate-method-owner" "owner" "%%get-method-implementation-rank" "error" "jazz:error" "%%get-method-node-children" "%%set-method-node-next-implementation" "child" "lambda" "for-each" "%%set-method-node-implementation" "%%get-method-implementation-tree" "virtual-method?" "jazz:virtual-method?" "%%get-category-field" "field" "let" "update-virtual-method" "update-category" "jazz:update-category" "add-field" "jazz:add-field" "1" "%%fx+" "%%set-category-virtual-size" "%%set-method-implementation-rank" "%%get-category-virtual-size" "virtual-size" "new-virtual-method" "jazz:new-virtual-method" "method" "new-method-node" "jazz:new-method-node" "node" "interface" "class" "Class" "jazz:Class" "%%class-is?" "if" "dispatch-type" "let*" "create-virtual-method" "define" "method-implementation" "method-name" "category")}
      {Lisp-Entry "add-method-node" define () ("class" "method-name" "method-implementation") #f #f 2370 9 2370 29 ("final-method?" "jazz:final-method?" "%%vector-set!" "%%vector-ref" "method-table" "%%get-class-interface-table" "interface" "%%get-class-class-table" "%%get-method-dispatch-type" "case" "dispatch-table" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "category-rank" "receive" "%%get-method-implementation-tree" "virtual-method?" "jazz:virtual-method?" "%%get-category-field" "field" "else" "error" "jazz:error" "cond" "locate-method-owner" "jazz:locate-method-owner" "owner" "%%get-category-descendants" "descendant" "%%memq" "%%not" "%%when" "map" "end-categories" "end-nodes" "start-node" "proc" "update-method-tree" "%%set-method-node-implementation" "values" "%%cons" "%%set-method-node-children" "%%set-method-node-next-implementation" "%%set-method-node-next-node" "for-each" "new-method-node" "jazz:new-method-node" "new-node" "old-children" "%%assq" "or" "new-children" "assv" "child-class" "lambda" "jazz:partition" "partition" "%%cdr" "%%subtype?" "child-category" "%%car" "child" "let*" "%%null?" "%%get-method-node-children" "children" "sub-iter" "iter" "category" "create-method-node" "update-method-node" "%%get-method-node-category" "%%eq?" "if" "locate-most-specific-method-node" "node" "let" "root-node" "create/update-method-node" "define" "method-implementation" "method-name" "class")}
      {Lisp-Entry "Method-Node" define-class () () ("class runtime") #f 2455 27 2455 43 ()}
      {Lisp-Entry "new-method-node" define () ("category" "implementation" "next-node" "children") #f #f 2458 9 2458 29 ("Method-Node" "jazz:Method-Node" "allocate-method-node" "jazz:allocate-method-node" "%%get-method-node-implementation" "if" "next-implementation" "let" "children" "next-node" "implementation" "category")}
      {Lisp-Entry "call-into-incoherent" define () ("." "rest") #f #f 2463 9 2463 34 ("error" "jazz:error" "rest")}
      {Lisp-Entry "call-into-abstract" define () ("class" "method" "object" "arguments") #f #f 2467 9 2467 32 ("error" "jazz:error" "arguments" "object" "method" "class")}
      {Lisp-Entry "Queue" define-class () () ("class runtime") #f 2479 27 2479 37 ()}
      {Lisp-Entry "new-queue" define () () #f #f 2482 9 2482 23 ("Queue" "jazz:Queue" "allocate-queue" "jazz:allocate-queue")}
      {Lisp-Entry "enqueue" define () ("queue" "object") #f #f 2486 9 2486 21 ("enqueue-impl" "jazz:enqueue-impl" "%%cons" "pair" "let" "object" "queue")}
      {Lisp-Entry "enqueue-list" define () ("queue" "lst") #f #f 2491 9 2491 26 ("enqueue-impl" "jazz:enqueue-impl" "%%not-null?" "%%when" "lst" "queue")}
      {Lisp-Entry "enqueue-impl" define () ("queue" "lst" "shared?") #f #f 2496 9 2496 26 ("else" "%%cdr" "%%pair?" "last-pair" "jazz:last-pair" "%%get-queue-head" "list-copy" "jazz:list-copy" "copy" "%%get-queue-shared?" "%%set-queue-head" "%%null?" "cond" "%%get-queue-tail" "let" "%%set-queue-shared?" "if" "%%set-queue-tail" "set-cdr!" "tail" "stitch" "define" "shared?" "lst" "queue")}
      {Lisp-Entry "dequeue" define () ("queue") #f #f 2519 9 2519 21 ("%%car" "%%set-queue-shared?" "%%set-queue-tail" "%%get-queue-tail" "%%eq?" "%%set-queue-head" "%%cdr" "next" "%%pair?" "%%when" "%%get-queue-head" "head" "let" "queue")}
      {Lisp-Entry "queue-list" define () ("queue") #f #f 2530 9 2530 24 ("%%get-queue-head" "queue")}
      {Lisp-Entry "reset-queue" define () ("queue") #f #f 2534 9 2534 25 ("%%set-queue-shared?" "%%set-queue-tail" "%%set-queue-head" "queue")}}})
"serial"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "serial.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.serial" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "object->serial" define () ("obj") #f #f 42 13 42 32 ("object->serial-number" "obj")}
      {Lisp-Entry "serial->object" define () ("number") #f #f 45 13 45 32 ("serial-number->object" "number")}
      {Lisp-Entry "object->serial-symbol" define () ("obj") #f #f 49 13 49 39 ("object->serial" "jazz:object->serial" "%%number->string" "%%string-append" "%%string->symbol" "obj")}
      {Lisp-Entry "serial-number" define () () #f #f 56 11 56 29 ("1")}
      {Lisp-Entry "serialized-objects" define () () #f #f 59 11 59 34 ("equal?" "test:" "%%make-table")}
      {Lisp-Entry "object->serial" define () ("obj") #f #f 62 12 62 31 ("%%table-set!" "1" "%%fx+" "set!" "serial-number" "jazz:serial-number" "number" "let" "serialized-objects" "jazz:serialized-objects" "%%table-ref" "or" "obj")}
      {Lisp-Entry "serial->object" define () ("number" "." "rest") #f #f 69 12 69 31 ("%%car" "error" "jazz:error" "%%null?" "continuation-return" "%%fx=" "if" "value" "key" "serialized-objects" "jazz:serialized-objects" "iterate-table" "jazz:iterate-table" "return" "lambda" "continuation-capture" "rest" "number")}}})
"specific"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "runtime" "specific.scm"} 231466230. scheme
    {Lisp-Entry "core.generic.runtime.specific" unit (protected) () #f #f 38 16 38 45 ()
      {Lisp-Entry "new-specific" define () ("signature-proc" "implementation") #f #f 41 9 41 26 ("Specific" "jazz:Specific" "allocate-specific" "jazz:allocate-specific" "implementation" "signature-proc")}}}
  {Lisp-File-Entry {File :context "src" "core" "generic" "syntax" "specific.scm"} 231466230. scheme
    {Lisp-Entry "core.generic.syntax.specific" unit (protected) () #f #f 45 16 45 44 ("Specific" "jazz:Specific" "encapsulate-class" "jazz:encapsulate-class")
      {Lisp-Entry "Specific" define-class () () ("class syntax") #f 48 19 48 32 ("%%set-specific-descendant-specifics" "%%get-specific-descendant-specifics" "descendant-specifics" "%%set-specific-ancestor-specifics" "%%get-specific-ancestor-specifics" "ancestor-specifics" "%%set-specific-implementation" "%%get-specific-implementation" "implementation" "%%set-specific-dynamic-signature" "%%get-specific-dynamic-signature" "dynamic-signature" "allocate-specific" "jazz:allocate-specific" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "Specific" define-class () () ("class runtime") #f 55 27 55 40 ()}
      {Lisp-Entry "define-specific" define-macro () () ("macro") #f 58 20 58 40 ("expand-define-specific" "jazz:expand-define-specific" "%%apply" "rest")}}})
"string"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "string.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.string" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "memstring" define () ("char" "string") #f #f 40 9 40 23 ("1" "%%fx+" "else" "%%string-ref" "%%eqv?" "%%fx=" "cond" "0" "n" "iter" "%%string-length" "len" "let" "string" "char")}}})
"symbol"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "symbol.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.symbol" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "identifier-name" define () ("identifier") #f #f 45 9 45 29 ("%%string-length" "1" "%%fx+" "%%substring" "%%string->symbol" "%%not" "if" "string-find-reversed" "jazz:string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "identifier")}
      {Lisp-Entry "reference-unit" define () ("reference") #f #f 59 9 59 28 ("0" "%%substring" "%%string->symbol" "%%not" "if" "string-find-reversed" "jazz:string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "reference")}
      {Lisp-Entry "reference-name" define () ("reference") #f #f 68 9 68 28 ("%%string-length" "1" "%%fx+" "%%substring" "%%string->symbol" "%%not" "if" "string-find-reversed" "jazz:string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "reference")}
      {Lisp-Entry "specifier?" define () ("expr") #f #f 82 9 82 24 ("1" "%%fx-" "0" "%%string-ref" "%%eqv?" "2" "%%fx>" "%%string-length" "len" "%%symbol->string" "str" "let" "%%symbol?" "and" "expr")}
      {Lisp-Entry "specifier->name" define () ("specifier") #f #f 91 9 91 29 ("%%symbol->string" "%%string->symbol" "%%string-length" "%%fx-" "1" "%%substring" "string" "lambda" "extract" "let" "specifier")}
      {Lisp-Entry "name->specifier" define () ("name") #f #f 98 9 98 29 ("%%symbol->string" "%%string-append" "%%string->symbol" "name")}
      {Lisp-Entry "binding-specifier" define () ("binding") #f #f 102 9 102 31 ("%%car" "specifier?" "jazz:specifier?" "%%pair?" "and" "source-code" "jazz:source-code" "%%cdr" "cdr-binding" "let" "binding")}
      {Lisp-Entry "enumerator?" define () ("obj") #f #f 114 9 114 25 ("0" "%%symbol->string" "%%string-ref" "%%eqv?" "%%symbol?" "and" "obj")}
      {Lisp-Entry "enumerator->symbol" define () ("enumerator") #f #f 119 9 119 32 ("%%string-length" "1" "%%substring" "%%string->symbol" "%%symbol->string" "name" "let" "enumerator")}
      {Lisp-Entry "symbol->enumerator" define () ("symbol") #f #f 124 9 124 32 ("%%symbol->string" "%%string-append" "%%string->symbol" "symbol")}}})
"syntax"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "syntax.scm"} 232700492. scheme
    {Lisp-Entry "core.base.runtime.syntax" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "source?" define () ("obj") #f #f 40 9 40 21 ("%%source?" "obj")}
      {Lisp-Entry "source-code" define () ("expr") #f #f 44 9 44 25 ("%%source-code" "%%source?" "if" "expr")}
      {Lisp-Entry "source-locat" define () ("expr") #f #f 50 9 50 26 ("%%source-locat" "%%source?" "if" "expr")}
      {Lisp-Entry "desourcify" define () ("expr") #f #f 56 9 56 24 ("%%desourcify" "expr")}
      {Lisp-Entry "desourcify-all" define () ("expr") #f #f 60 9 60 28 ("%%box?" "%%vector?" "%%source?" "%%unbox" "%%box" "box" "desourcify-box" "%%vector-ref" "%%vector-set!" "begin" "%%fx<" "if" "1" "%%fx-" "i" "loop" "let" "0" "%%make-vector" "x" "%%vector-length" "len" "let*" "vect" "desourcify-vector" "else" "%%null?" "%%cdr" "%%car" "%%cons" "%%pair?" "cond" "lst" "desourcify-list" "%%source-code" "desourcify-all" "src" "desourcify-source" "define" "expr")}
      {Lisp-Entry "sourcify" define () ("expr" "src") #f #f 102 9 102 22 ("%%sourcify" "src" "expr")}
      {Lisp-Entry "sourcify-if" define () ("expr" "src") #f #f 106 9 106 25 ("sourcify" "jazz:sourcify" "source?" "jazz:source?" "if" "src" "expr")}
      {Lisp-Entry "sourcify-list" define () ("lst" "src") #f #f 112 9 112 27 ("desourcify-all" "jazz:desourcify-all" "sourcify-if" "jazz:sourcify-if" "expr" "lambda" "map" "src" "lst")}
      {Lisp-Entry "locat-container" define () ("locat") #f #f 118 9 118 29 ("%%locat-container" "locat")}
      {Lisp-Entry "locat-position" define () ("locat") #f #f 122 9 122 28 ("%%locat-position" "locat")}
      {Lisp-Entry "locat->container/line/col" define () ("locat") #f #f 126 9 126 39 ("%%list" "%%filepos-col" "col" "%%filepos-line" "line" "%%locat-position" "%%position->filepos" "filepos" "if" "%%locat-container" "and" "container" "let" "locat")}
      {Lisp-Entry "container->path" define () ("container") #f #f 136 9 136 29 ("%%container->path" "container")}
      {Lisp-Entry "position->filepos" define () ("position") #f #f 140 9 140 31 ("%%position->filepos" "position")}
      {Lisp-Entry "filepos-line" define () ("filepos") #f #f 144 9 144 26 ("%%filepos-line" "filepos")}
      {Lisp-Entry "filepos-col" define () ("filepos") #f #f 148 9 148 25 ("%%filepos-col" "filepos")}
      {Lisp-Entry "save-emit-if" define () ("emit") #f #f 157 9 157 26 ("present-source" "jazz:present-source" "pretty-print" "port" "lambda" "kernel-platform" "jazz:kernel-platform" "platform-eol-encoding" "jazz:platform-eol-encoding" "eol-encoding:" "binary-with-extension" "jazz:binary-with-extension" "path:" "list" "call-with-output-file" "scheme-readtable" "jazz:scheme-readtable" "current-readtable" "parameterize" "compiled-source" "jazz:compiled-source" "save-emit?" "jazz:save-emit?" "and" "%%when" "emit")}
      {Lisp-Entry "present-source" define () ("obj") #f #f 170 9 170 28 ("%%vector?" "%%source?" "%%vector-ref" "%%vector-set!" "begin" "%%fx<" "if" "%%fx-" "i" "loop" "0" "%%make-vector" "x" "%%vector-length" "len" "let*" "vect" "present-vector" "else" "%%null?" "%%cdr" "%%car" "%%cons" "%%pair?" "cond" "lst" "present-list" "%%filepos-col" "1" "%%filepos-line" "%%fx+" "present-source" "jazz:present-source" "source" "%%vector" "%%source-locat" "%%locat-position" "pos" "source-code" "jazz:source-code" "code" "let" "src" "present-src" "define" "obj")}}}
  {Lisp-File-Entry {File :context "src" "core" "module" "syntax" "dialect" "syntax.scm"} 231466230. scheme
    {Lisp-Entry "core.module.syntax.dialect.syntax" unit (protected) () #f #f 37 16 37 49 ("Dialect" "jazz:Dialect")
      {Lisp-Entry "Dialect" define-class () () ("class syntax") #f 40 19 40 31 ("%%set-dialect-bindings" "%%get-dialect-bindings" "bindings" "Object-Class" "jazz:Object-Class" "Object" "jazz:Object")}
      {Lisp-Entry "dialect-name" generic/specific () () ("jazz:Dialect~virtual") #f 44 22 44 39 ()}
      {Lisp-Entry "dialect-walker" generic/specific () () ("jazz:Dialect~virtual") #f 45 22 45 41 ()}}})
"unspecified"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "unspecified.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.unspecified" unit (protected) () #f #f 37 16 37 45 ()
      {Lisp-Entry "unspecified" define () () #f #f 40 9 40 25 ("%%unspecified")}
      {Lisp-Entry "unspecified?" define () ("expr") #f #f 44 9 44 26 ("%%unspecified?" "expr")}
      {Lisp-Entry "specified?" define () ("expr") #f #f 48 9 48 24 ("%%unspecified?" "%%not" "expr")}}})
"vector"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "vector.scm"} 231466230. scheme
    {Lisp-Entry "core.base.runtime.vector" unit (protected) () #f #f 37 16 37 40 ()
      {Lisp-Entry "unsafe-vector-set!" define () ("vector" "index" "object") #f #f 40 9 40 32 ("##vector-set!" "object" "index" "vector")}
      {Lisp-Entry "vector-for-each" define () ("proc" "vector") #f #f 44 9 44 29 ("1" "%%fx+" "%%vector-ref" "begin" "%%fx<" "if" "0" "n" "iter" "%%vector-length" "len" "let" "vector" "proc")}
      {Lisp-Entry "vector-memq?" define () ("obj" "vector") #f #f 53 9 53 26 ("1" "%%fx+" "%%vector-ref" "%%eq?" "%%fx<" "if" "0" "n" "iter" "%%vector-length" "len" "let" "vector" "obj")}
      {Lisp-Entry "resize-vector" define () ("vector" "size") #f #f 63 9 63 27 ("%%vector-ref" "%%vector-set!" "0" "%%fx>=" "%%when" "1" "%%vector-length" "min" "%%fx-" "offset" "iter" "%%make-vector" "new-vector" "let" "size" "vector")}}})
