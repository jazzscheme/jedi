"_game"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.sample.game" "src" "jazz" "sample" "game" "_game.jazz"} 1288732034
    {Lisp-Entry "jazz.sample.game" module #f 38 8 38 24 ("jazz")
      {Lisp-Entry "Player" class #f 49 7 49 13 ("Object")
        {Lisp-Entry "player-kind" method #f 52 29 52 40 ()}
        {Lisp-Entry "human?" method #f 56 29 56 35 ("human" "'human" "player-kind" "eq?")}
        {Lisp-Entry "computer?" method #f 60 29 60 38 ("computer" "'computer" "player-kind" "eq?")}
        {Lisp-Entry "computer-move" method #f 64 29 64 42 ()}
        {Lisp-Entry "move-played" method #f 69 29 69 40 ("token" "move")}}
      {Lisp-Entry "Game" class #f 78 7 78 11 ("initialize" "History-Provider" "Object")
        {Lisp-Entry "players" slot #f 82 8 82 15 ()}
        {Lisp-Entry "get-players" accessor #f 82 49 82 57 ()}
        {Lisp-Entry "set-players" accessor #f 82 49 82 57 ()}
        {Lisp-Entry "next-player-rank" slot #f 83 8 83 24 ()}
        {Lisp-Entry "get-next-player-rank" accessor #f 83 49 83 57 ()}
        {Lisp-Entry "set-next-player-rank" accessor #f 83 49 83 57 ()}
        {Lisp-Entry "history-manager" slot #f 86 8 86 23 ()}
        {Lisp-Entry "status" slot #f 89 8 89 14 ()}
        {Lisp-Entry "get-status" accessor #f 89 49 89 57 ()}
        {Lisp-Entry "set-status" accessor #f 89 49 89 57 ()}
        {Lisp-Entry "winner" slot #f 90 8 90 14 ()}
        {Lisp-Entry "get-winner" accessor #f 90 49 90 57 ()}
        {Lisp-Entry "set-winner" accessor #f 90 49 90 57 ()}
        {Lisp-Entry "initialize" method #f 98 20 98 30 ("winner" "play" "'play" "status" "self" "History-Manager" "new" "history-manager" "0" "next-player-rank" "set!" "nextmethod")}
        {Lisp-Entry "current-history-item" method #f 111 20 111 40 ()}
        {Lisp-Entry "update-history-actions" method #f 115 20 115 42 ()}
        {Lisp-Entry "register-players" method #f 124 18 124 34 ("list->vector" "players" "set!" "lst")}
        {Lisp-Entry "get-next-player" method #f 128 18 128 33 ("next-player-rank" "players" "vector-ref")}
        {Lisp-Entry "get-second-player" method #f 132 18 132 35 ("1" "next-player-rank" "+" "modulo-players" "players" "vector-ref")}
        {Lisp-Entry "next-player!" method #f 136 21 136 33 ("1" "+" "modulo-players" "next-player-rank" "set!" "get-next-player" "prog1")}
        {Lisp-Entry "modulo-players" method #f 141 11 141 25 ("players" "vector-length" "modulo" "rank")}
        {Lisp-Entry "add-move" method #f 150 21 150 29 ("History-Move" "new" "history-manager" "add-history" "move")}
        {Lisp-Entry "append-forward-history" method #f 154 21 154 43 ("History-Move" "new" "history-manager" "append-forward-history" "move")}
        {Lisp-Entry "get-moves" method #f 158 18 158 27 ("get-forward-moves" "get-backward-moves" "append")}
        {Lisp-Entry "get-backward-moves" method #f 163 18 163 36 ("history-manager" "get-backward-history" "reverse" "get-move" "map")}
        {Lisp-Entry "get-forward-moves" method #f 167 18 167 35 ("history-manager" "get-forward-history" "get-move" "map")}
        {Lisp-Entry "play" method #f 176 29 176 33 ("move")}
        {Lisp-Entry "unplay" method #f 180 29 180 35 ("move")}
        {Lisp-Entry "play-move" method #f 189 26 189 35 ("move")}
        {Lisp-Entry "inform-players" method #f 193 11 193 25 ("vector-ref" "move-played" "players" "vector-length" "below" "0" "from" "n" "for" "loop" "token" "move")}
        {Lisp-Entry "check-status" method #f 198 29 198 41 ("draw" "'draw" "draw?" "winner" "win" "'win" "status" "set!" "win?" "cond" "token" "move" "player")}
        {Lisp-Entry "win?" method #f 206 29 206 33 ("token" "move")}
        {Lisp-Entry "draw?" method #f 210 29 210 34 ("token" "move")}
        {Lisp-Entry "save" method #f 219 26 219 30 ()}
        {Lisp-Entry "load" method #f 223 26 223 30 ()}
        {Lisp-Entry "inspect" method #f 232 26 232 33 ()}}
      {Lisp-Entry "History-Move" class #f 241 7 241 19 ("History-Item")
        {Lisp-Entry "move" slot #f 244 8 244 12 ()}
        {Lisp-Entry "get-move" accessor #f 244 20 244 28 ()}
        {Lisp-Entry "initialize" method #f 247 20 247 30 ("move~self" "set!" "nextmethod" "move")}
        {Lisp-Entry "print" method #f 252 20 252 25 ("move" "format" "lambda" "self" "print-unreadable" "readably" "printer")}}}})
"minimax"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.sample.game" "src" "jazz" "sample" "game" "minimax.jazz"} 1288732034
    {Lisp-Entry "jazz.sample.game.minimax" module #f 37 8 37 32 ("jazz")
      {Lisp-Entry "Minimax-Statistics" class #f 51 7 51 25 ("0" "initialize" "Object")
        {Lisp-Entry "last-eval" slot #f 54 8 54 17 ()}
        {Lisp-Entry "get-last-eval" accessor #f 54 60 54 68 ()}
        {Lisp-Entry "set-last-eval" accessor #f 54 60 54 68 ()}
        {Lisp-Entry "last-evaluations" slot #f 55 8 55 24 ()}
        {Lisp-Entry "get-last-evaluations" accessor #f 55 60 55 68 ()}
        {Lisp-Entry "set-last-evaluations" accessor #f 55 60 55 68 ()}
        {Lisp-Entry "last-evaluations-count" slot #f 56 8 56 30 ()}
        {Lisp-Entry "get-last-evaluations-count" accessor #f 56 60 56 68 ()}
        {Lisp-Entry "set-last-evaluations-count" accessor #f 56 60 56 68 ()}
        {Lisp-Entry "last-time" slot #f 57 8 57 17 ()}
        {Lisp-Entry "get-last-time" accessor #f 57 60 57 68 ()}
        {Lisp-Entry "set-last-time" accessor #f 57 60 57 68 ()}
        {Lisp-Entry "increase-last-evaluations-count" method #f 60 11 60 42 ("last-evaluations-count" "increase!")}}
      {Lisp-Entry "Default-Search-Depth" definition #f 69 12 69 32 ("4")}
      {Lisp-Entry "minimax" definition #f 73 20 73 27 ("cast" "normalized-eval" "-1" "10000000" "evaluate-best" "evaluate" "900000" "*" "error" "/=" "when" "position-eval" "new-eval" "delta" "increase-last-evaluations-count" "depth" "min" "cdr" "key:" "sort" "subseq" "car" "map" "+" "nb" "all" "max-candidates" "iterate-moves" "token" "random-element" "reverse" "set-last-evaluations" "set-last-eval" "list" "not" "or" "and" "cond" "cons" "set!" "evaluate-move" "eval" "move" "lambda" "gather-candidates" "evals" "<" ">" "1" "=" "if" "best-test" "best-eval" "best" "best-move" "define" "Minimax-Statistics" "new" "statistics" "let" "Default-Search-Depth" "search-depth" "search-depth:" "0" "current-eval" "current-eval:" "evaluate-move-delta" "evaluate-position" "unplay" "play" "iterate-candidates" "me")}
      {Lisp-Entry "minimax-interpreted-message" definition #f 160 13 160 40 ("format" "title")}
      {Lisp-Entry "minimax-interpreted?" definition #f 164 20 164 40 ("jazz.sample.game.minimax" "'jazz.sample.game.minimax" "unit-uptodate-binary?" "not" "or" "ai-unit")}
      {Lisp-Entry "minimax-interpreted-warner" definition #f 169 20 169 46 ("set!" "format" "system-message" "minimax-interpreted?" "not" "and" "when" "lambda" "warned?" "let" "title" "ai-unit")}
      {Lisp-Entry "warn-minimax-interpreted" definition #f 177 20 177 44 ("minimax-interpreted-warner" "title" "ai-unit")}}})
