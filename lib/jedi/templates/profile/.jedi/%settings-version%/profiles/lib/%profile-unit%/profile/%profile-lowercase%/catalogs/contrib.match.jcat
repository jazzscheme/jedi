"Match-Tester"
 ({Lisp-File-Entry {File contrib.match "src" "match" "validate" "Match-Tester.jazz"} 1288732032
    {Lisp-Entry "match.validate.Match-Tester" module #f 1 18 1 45 ("jazz")
      {Lisp-Entry "Match-Tester" class #f 8 7 8 19 ("Tester")
        {Lisp-Entry "test" method #f 15 20 15 24 ("test-match" "invoke")}
        {Lisp-Entry "test-match" method #f 24 11 24 21 ("'x" "e" "d" "***" "h:" "v:" "$$" "v" "h" "$" "20" "10" "Point" "0" "set!" "let" "get!" "w" "z" "'o" "f" "'f" "match-let*" "match-let" "even?" "if" "next" "=>" "n" "odd?" "tl" "hd" "..." "___" "29" "+" "number?" "not" "else" "or" "y" "symbol?" "?" "and" "k" "o" "#" "'#" "bad" "'bad" "good" "'good" "fail" "'fail" "28" "x" "ok" "'ok" "_" "any" "'any" "list" "c" "b" "a" "match" "1" "2" "3" "equal?" "rpt" "validate")}}}})
"_match"
 ({Lisp-File-Entry {File contrib.match "src" "match" "_match.jazz"} 1288732032
    {Lisp-Entry "match" module #f 1 8 1 13 ("jazz")
      {Lisp-Entry "syntax-new-identifier?" define-macro #f 14 15 14 37 ("cdr" "else" "pair?" "not" "cond" "caddr" "unwrap-syntactic-closure" "ls" "lp" "identifier?" "if" "cddddr" "car" "fk" "cadddr" "sk" "cadr" "id" "let" "compare" "rename" "expr" "lambda" "er-macro-transformer")}
      {Lisp-Entry "match-syntax-error" define-macro #f 32 15 32 33 ("match-syntax-error" "_" "syntax-rules")}
      {Lisp-Entry "match" define-macro #f 43 22 43 27 ("vec" "#" "set!" "match-next" "v" "let" "body" "pat" "..." "app" "atom" "match-syntax-error" "match" "syntax-rules")}
      {Lisp-Entry "match-next" define-macro #f 63 15 63 25 ("begin" "match-drop-ids" "match-one" "lambda" "let" "rest" "body" "failure" "pat" "match" "'match" "error" "s" "g" "v" "match-next" "=>" "syntax-rules")}
      {Lisp-Entry "match-one" define-macro #f 80 15 80 24 ("x" "match-two" "match-gen-ellipses" "match-extract-vars" "match-check-ellipse" "i" "fk" "sk" "s" "g" "r" "q" "p" "v" "match-one" "syntax-rules")}
      {Lisp-Entry "match-two" define-macro #f 106 15 106 24 ("syntax-new-identifier?" "id" "0" "match-vector" "#" "set-cdr!" "set-car!" "car" "cdr" "pair?" "match-syntax-error" "match-gen-search" "match-gen-ellipses" "r" "match-object-fields" "get-slots" "slots" "class-expr" "1" "match-object-positional-fields" "instance-of?" "fields" "class" "w" "proc" "pred" "x" "setter" "lambda" "let" "getter" "match-drop-ids" "match-gen-or" "match-extract-vars" "match-one" "q" "match-quasiquote" "'p" "equal?" "p" "null?" "if" "i" "fk" "..." "sk" "s" "g" "v" "match-two" "get!" "set!" "not" "or" "and" "=" "$$" "$" "?" "quasiquote" "quote" "***" "___" "_" "syntax-rules")}
      {Lisp-Entry "match-quasiquote" define-macro #f 183 15 183 31 ("'x" "vector->list" "ls" "vector?" "..." "elt" "#" "match-quasiquote-step" "cdr" "car" "w" "let" "q" "x" "depth" "match-quasiquote" "tmp" "pair?" "if" "rest" "match-one" "i" "fk" "sk" "s" "g" "p" "v" "_" "quasiquote" "unquote-splicing" "unquote" "syntax-rules")}
      {Lisp-Entry "match-quasiquote-step" define-macro #f 217 15 217 36 ("match-quasiquote" "i" "depth" "fk" "sk" "s" "g" "q" "x" "match-quasiquote-step" "syntax-rules")}
      {Lisp-Entry "match-drop-ids" define-macro #f 228 15 228 29 ("..." "ids" "expr" "_" "syntax-rules")}
      {Lisp-Entry "match-gen-or" define-macro #f 237 15 237 27 ("match-drop-ids" "match-gen-or-step" "lambda" "sk2" "let" "id-ls" "id" "i" "fk" "..." "sk" "s" "g" "p" "v" "_" "syntax-rules")}
      {Lisp-Entry "match-gen-or-step" define-macro #f 244 15 244 32 ("match-gen-or-step" "q" "match-one" "p" "i" "fk" "sk" "s" "g" "v" "_" "syntax-rules")}
      {Lisp-Entry "match-gen-ellipses" define-macro #f 265 15 265 33 ("1" "-" "=" "n" "<" "len" "length" "tail-len" "let*" "match-verify-no-ellipses" "r" "else" "cons" "cdr" "match-drop-ids" "set-car!" "match-one" "car" "w" "pair?" "reverse" "null?" "cond" "ls" "loop" "list?" "if" "let" "match-check-identifier" "id-ls" "id" "i" "fk" "..." "sk" "s" "g" "p" "v" "_" "syntax-rules")}
      {Lisp-Entry "match-verify-no-ellipses" define-macro #f 308 15 308 39 ("match-verify-no-ellipses" "match-syntax-error" "match-check-ellipse" "sk" "y" "x" "_" "syntax-rules")}
      {Lisp-Entry "match-gen-search" define-macro #f 319 15 319 31 ("cdr" "ls" "lp" "cons" "set-car!" "car" "u" "pair?" "not" "if" "next" "reverse" "let" "match-drop-ids" "match-one" "fail" "w" "lambda" "try" "letrec" "..." "id-ls" "id" "i" "fk" "sk" "s" "g" "q" "p" "v" "match-gen-search" "syntax-rules")}
      {Lisp-Entry "match-vector" define-macro #f 354 15 354 27 ("x" "match-vector-two" "match-vector-ellipses" "match-check-ellipse" "i" "fk" "sk" "q" "p" "pats" "n" "v" "_" "___" "syntax-rules")}
      {Lisp-Entry "match-vector-two" define-macro #f 367 15 367 31 ("1" "+" "match-vector" "q" "p" "pats" "match-vector-step" "=" "vector-length" "len" "let" "vector?" "if" "i" "fk" "sk" "..." "index" "pat" "n" "v" "_" "syntax-rules")}
      {Lisp-Entry "match-vector-step" define-macro #f 380 15 380 32 ("match-vector-step" "vector-set!" "match-one" "vector-ref" "w" "let" "rest" "index" "pat" "i" "fk" "..." "sk" "v" "_" "syntax-rules")}
      {Lisp-Entry "match-vector-ellipses" define-macro #f 392 15 392 36 ("match-vector-tail" "match-vector-step" ">=" "vector-length" "len" "let" "vector?" "if" "i" "fk" "sk" "p" "..." "index" "pat" "n" "v" "_" "syntax-rules")}
      {Lisp-Entry "match-vector-tail" define-macro #f 404 15 404 32 ("match-vector-tail-two" "match-extract-vars" "i" "fk" "sk" "len" "n" "p" "v" "_" "syntax-rules")}
      {Lisp-Entry "match-vector-tail-two" define-macro #f 409 15 409 36 ("cons" "1" "+" "match-drop-ids" "vetor-set!" "match-one" "vector-ref" "w" "reverse" ">=" "if" "j" "loop" "let" "id-ls" "id" "i" "fk" "..." "sk" "len" "n" "p" "v" "_" "syntax-rules")}
      {Lisp-Entry "match-object-positional-fields" define-macro #f 420 15 420 45 ("..." "1" "+" "set-object-slot" "match-one" "get-object-slot" "w" "let" "i" "fk" "sk" "s" "g" "fields" "field" "n" "v" "match-object-positional-fields" "syntax-rules")}
      {Lisp-Entry "match-object-fields" define-macro #f 430 15 430 34 ("error" "set-object-slot" "and" "match-one" "get-object-slot" "w" "if" "1" "keyword->string" "string->symbol" "match-slot-index" "n" "let" "i" "fk" "sk" "s" "g" "fields" "..." "pat" "field" "slots" "class" "v" "match-object-fields" "syntax-rules")}
      {Lisp-Entry "match-slot-index" define #f 444 9 444 25 ("1" "+" "cdr" "match-slot-index" "else" "car" "get-name" "eq?" "null?" "cond" "n" "ls" "x")}
      {Lisp-Entry "match-extract-vars" define-macro #f 456 15 456 33 ("p-ls" "syntax-new-identifier?" "#" "match-extract-vars-step" "match-check-ellipse" "r" "q" "match-extract-quasiquote-vars" "x" "proc" "..." "field" "class" "v" "i" "k" "p" "pred" "match-extract-vars" "set!" "get!" "not" "or" "and" "quasiquote" "quote" "=" "$$" "$" "?" "***" "___" "_" "syntax-rules")}
      {Lisp-Entry "match-extract-vars-step" define-macro #f 499 15 499 38 ("match-extract-vars" "..." "v2-ls" "v2" "v" "i" "k" "p" "_" "syntax-rules")}
      {Lisp-Entry "match-extract-quasiquote-vars" define-macro #f 505 15 505 44 ("..." "#" "match-extract-quasiquote-vars-step" "y" "match-extract-vars" "d" "v" "i" "k" "x" "match-extract-quasiquote-vars" "unquote-splicing" "unquote" "quasiquote" "syntax-rules")}
      {Lisp-Entry "match-extract-quasiquote-vars-step" define-macro #f 525 15 525 49 ("match-extract-quasiquote-vars" "..." "v2-ls" "v2" "d" "v" "i" "k" "x" "_" "syntax-rules")}
      {Lisp-Entry "match-lambda" define-macro #f 535 22 535 34 ("match" "expr" "lambda" "..." "clause" "_" "syntax-rules")}
      {Lisp-Entry "match-lambda*" define-macro #f 539 22 539 35 ("match" "expr" "lambda" "..." "clause" "_" "syntax-rules")}
      {Lisp-Entry "match-let" define-macro #f 543 22 543 31 ("match-named-let" "rest" "loop" "let" "match-let/helper" "body" "..." "vars" "_" "syntax-rules")}
      {Lisp-Entry "match-letrec" define-macro #f 550 22 550 34 ("letrec" "match-let/helper" "body" "vars" "_" "syntax-rules")}
      {Lisp-Entry "match-let/helper" define-macro #f 554 15 554 31 ("let" "#" "match-let/helper" "rest" "b" "a" "p" "v" "match-let*" "tmp" "pat" "body" "..." "expr" "var" "letx" "_" "syntax-rules")}
      {Lisp-Entry "match-named-let" define-macro #f 572 22 572 37 ("tmp" "match-named-let" "rest" "v" "match-let" "let" "body" "..." "var" "expr" "pat" "loop" "_" "syntax-rules")}
      {Lisp-Entry "match-let*" define-macro #f 581 22 581 32 ("match-let*" "match" "rest" "expr" "pat" "begin" "body" "_" "syntax-rules")}
      {Lisp-Entry "match-check-ellipse" define-macro #f 592 15 592 34 ("cadddr" "caddr" "unwrap-syntactic-closure" "..." "'..." "eq?" "cadr" "identifier?" "and" "if" "make-syntactic-closure" "usage-environment" "form" "lambda" "sc-macro-transformer")}
      {Lisp-Entry "match-check-identifier" define-macro #f 603 15 603 37 ("cadddr" "caddr" "cadr" "identifier?" "if" "make-syntactic-closure" "usage-environment" "form" "lambda" "sc-macro-transformer")}}})
"run"
 ({Lisp-File-Entry {File contrib.match "src" "match" "validate" "run.jazz"} 1288732032
    {Lisp-Entry "match.validate.run" module #f 1 8 1 26 ("Match-Tester" "test:" "Validation-Suite" "new" "validate" "jazz")}})
