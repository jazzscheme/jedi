"Dispatcher"
 ({Lisp-File-Entry {File core "src" "core" "generic" "runtime" "Dispatcher.jazz"} 1288732032
    {Lisp-Entry "Dispatcher" class #f 47 7 47 17 ("Object")
      {Lisp-Entry "dag-root" property #f 50 12 50 20 ()}
      {Lisp-Entry "get-dag-root" accessor #f 50 31 50 39 ()}
      {Lisp-Entry "set-dag-root" accessor #f 50 31 50 39 ()}
      {Lisp-Entry "Root-Signature" definition #f 53 14 53 28 ("root-signature" "'root-signature")}
      {Lisp-Entry "initialize" method #f 57 11 57 21 ("Root-Signature" "Dispatch-Node" "new" "dag-root" "set!" "nextmethod")}
      {Lisp-Entry "insert-signature" method #f 62 18 62 34 ("insert-node" "else" "proper-list?" "not" "category-identifier" "error" "locate-node" "cond" "List" "get-type" "and" "get-typeref" "typeref" "let" "parameter" "lambda" "accumulate" "standardize-signature" "define" "category" "signature" "procedure" "symbol")}
      {Lisp-Entry "insert-node" method #f 81 18 81 29 ("get-specific-nodes" "add-specific-node" "remove-specific-node" "add-generic-node" "remove-generic-node" "get-signature" "can-call-with?" "neq?" "and" "when" "specific" "generic" "lambda" "for-each" "Dispatch-Node" "new" "node" "gather-generics" "generics" "let*" "signature" "procedure")}
      {Lisp-Entry "remove-node" method #f 98 18 98 29 ("remove-generic-node" "get-generic-nodes" "remove-specific-node" "get-specific-nodes" "add-generic-node" "add-specific-node" "specific" "generic" "lambda" "for-each" "node")}
      {Lisp-Entry "locate-node" method #f 113 18 113 29 ("first" "get-signature" "equal?" "length" "1" "=" "and" "if" "gather-generics" "matching" "let" "signature")}
      {Lisp-Entry "gather-generics" method #f 121 18 121 33 ("dag-root" "cons" "memq?" "not" "and" "get-specific-nodes" "set!" "can-call-with?" "when" "child-node" "for-each" "no-match?" "walk-node" "lambda" "iter" "letrec" "generics" "let" "parameter-types")}
      {Lisp-Entry "find-generics" method #f 137 18 137 31 ("dag-root" "car" "eq?" "if" "gather-generics" "generics" "let" "parameter-types")}}
    {Lisp-Entry "Dispatch-Node" class #f 149 7 149 20 ("initialize" "Object")
      {Lisp-Entry "procedure" property #f 152 12 152 21 ()}
      {Lisp-Entry "get-procedure" accessor #f 152 52 152 60 ()}
      {Lisp-Entry "set-procedure" accessor #f 152 52 152 60 ()}
      {Lisp-Entry "signature" property #f 153 12 153 21 ()}
      {Lisp-Entry "get-signature" accessor #f 153 52 153 60 ()}
      {Lisp-Entry "set-signature" accessor #f 153 52 153 60 ()}
      {Lisp-Entry "generic-nodes" property #f 154 12 154 25 ()}
      {Lisp-Entry "get-generic-nodes" accessor #f 154 52 154 60 ()}
      {Lisp-Entry "set-generic-nodes" accessor #f 154 52 154 60 ()}
      {Lisp-Entry "specific-nodes" property #f 155 12 155 26 ()}
      {Lisp-Entry "get-specific-nodes" accessor #f 155 52 155 60 ()}
      {Lisp-Entry "set-specific-nodes" accessor #f 155 52 155 60 ()}
      {Lisp-Entry "initialize" method #f 158 11 158 21 ("generic-nodes" "signature" "procedure" "set!" "nextmethod" "gen" "sig" "proc")}
      {Lisp-Entry "print" method #f 165 11 165 16 ("category-identifier" "map" "format" "Root-Signature" "signature" "eq?" "if" "lambda" "self" "print-unreadable" "readably" "printer")}
      {Lisp-Entry "can-call-with?" method #f 173 11 173 25 ("null?" "finally" "return" "Java" "can-cast-into?" "not" "and" "when" "r2" "parameter-type" "r1" "remainder" "in" "data-type" "for" "loop" "Root-Signature" "signature" "eq?" "if" "sig")}
      {Lisp-Entry "add-generic-node" method #f 184 11 184 27 ("cons" "set-generic-nodes" "equal?" "generic" "lambda" "generic-nodes" "find-in" "unless" "get-signature" "sig" "let" "node")}
      {Lisp-Entry "add-specific-node" method #f 192 11 192 28 ("cons" "set-specific-nodes" "equal?" "specific" "lambda" "specific-nodes" "find-in" "unless" "get-signature" "sig" "let" "node")}
      {Lisp-Entry "remove-generic-node" method #f 200 11 200 30 ("generic-nodes" "remove" "set-generic-nodes" "generic")}
      {Lisp-Entry "remove-specific-node" method #f 204 11 204 31 ("specific-nodes" "remove" "set-specific-nodes" "specific")}}})
"_base"
 ({Lisp-File-Entry {File core "src" "core" "base" "_base.scm"} 1288732032
    {Lisp-Entry "core.base" unit #f 37 6 37 15 ()}})
"_builder"
 ({Lisp-File-Entry {File core "src" "core" "unit" "builder" "_builder.scm"} 1289506007
    {Lisp-Entry "core.unit.builder" unit #f 38 16 38 33 ()
      {Lisp-Entry "jazz.manifest-references-valid?" define #f 50 9 50 40 ("references" "private" "'private" "%%get-declaration-access" "%%neq?" "%%get-declaration-toplevel" "%%get-lexical-binding-name" "%%eq?" "else" "jazz.find-declaration" "%%not" "cond" "declaration" "symbols" "iter" "%%pair?" "if" "found" "symbol" "lambda" "jazz.every?" "error?:" "jazz.outline-module" "module-declaration" "%%cdr" "module-references" "%%car" "module-locator" "lst" "module-references-valid?" "%%manifest-references" "and" "jazz.load-manifest" "manifest" "jazz.manifest-pathname" "manifest-filepath" "%%resource-package" "jazz.digest-pathname" "digest-filepath" "let" "get-manifest-references" "define" "bin")}
      {Lisp-Entry "jazz.compile-unit-internal" define #f 89 9 89 35 ("force?:" "ld-options:" "cc-options:" "options:" "jazz.compile-source" "jazz.requested-unit-resource" "jazz.requested-unit-name" "parameterize" "manifest" "lib-uptodate?" "bin-uptodate?" "obj-uptodate?" "lib" "bin" "obj" "src" "lambda" "jazz.with-unit-resources" "force?" "ld-options" "cc-options" "options" "#!key" "unit-name")}
      {Lisp-Entry "jazz.custom-compile-unit-internal" define #f 99 9 99 42 ("jazz.compile-unit" "force?:" "unit:" "%%product-descriptor" "if" "%%product-build" "and" "build" "jazz.find-unit-product" "product" "let" "force?" "#!key" "unit-name")}
      {Lisp-Entry "jazz.find-unit-product" define #f 108 9 108 31 ("continuation-return" "eq?" "if" "phase" "declaration" "sub-unit" "jazz.for-each-subunit" "unit" "jazz.ill-formed-field-error" "jazz.cond-expand-each" "update" "jazz.product-descriptor-update" "update-descriptor" "jazz.get-product" "product" "jazz.product-descriptor-name" "product-name" "let*" "product-descriptor" "for-each" "return" "lambda" "continuation-capture" "%%package-products" "products" "%%resource-package" "package" "jazz.find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "jazz.wrap-single-host-cc-options" define #f 131 8 131 40 ("string-append" "jazz.debug-user?" "or" "if" "str" "lambda" "shell-command" "zero?" "else" "windows" "cond-expand" "gcc-4-2?" "let")}
      {Lisp-Entry "jazz.compile-source" define #f 140 9 140 28 ("unit-name:" "ld-options:" "cc-options:" "options:" "jazz.compile-file" "compile" "'compile" "jazz.walk-for" "parameterize" "lambda" "%%resource-extension" "jazz.with-extension-reader" "jazz.create-directories" "jazz.create-build-package" "build-package" "jazz.resource-build-dir" "bindir" "jazz.resource-pathname" "pathname" "%%resource-package" "package" "jazz.link-objects?" "if" "update-bin?" "not" "update-obj?" "jazz.wrap-single-host-cc-options" "jazz.compile-options" "jazz.manifest-references-valid?" "or" "and" "references-valid?" "let" "force?" "ld-options" "cc-options" "options" "#!key" "manifest-name" "bin-uptodate?" "obj-uptodate?" "bin" "obj" "src")}
      {Lisp-Entry "jazz.compile-file" define #f 159 9 159 26 ("force-output" "newline" "%%resource-path" "display" "jazz.link-libraries?" "will-compile?" "jazz.link-objects?" "or" "will-link?" "DLL" "'DLL" "jazz.obliterate-PE-timestamp" "windows" "case" "=" "jazz.resource-build-dir" "dyn" "'dyn" "##gambc-cc" "exit-status" "warnings?:" "%%list" "link-flat" "linkfile" "bin-o1" "link-o1" "jazz.probe-numbered-pathname" "begin" "jazz.build-single-objects?" "determine-o1" "delete-file" "1" "jazz.for-each-numbered-pathname" "delete-o1-files" "jazz.update-manifest-compile-time" "else" "jazz.Unit-Declaration" "jazz.generate-reference-list" "jazz.Module-Declaration" "%%is?" "cond" "jazz.get-catalog-entry" "module-declaration" "references" "src-filepath" "jazz.manifest-pathname" "manifest-filepath" "jazz.digest-pathname" "digest-filepath" "update-manifest" "jazz.error" "cc-options:" "obj" "'obj" "%%cons" "compile-file" "module-name:" "options:" "output:" "compile-file-to-c" "and" "not" "if" "-1" "##gensym-counter" "set!" "jazz.compiled-source" "0" "jazz.generate-symbol-counter" "jazz.generate-symbol-context" "jazz.generate-symbol-for" "parameterize" "string-append" "bin-c" "jazz.resource-pathname" "src-pathname" "%%symbol->string" "%%string-append" "unique-module-name" "let" "compile" "jazz.binary-with-extension" "bin-pathname-base" "unit-uniqueness-prefix" "define" "jazz.kernel-platform" "platform" "unit-name" "ld-options" "cc-options" "options" "#!key" "build-package" "update-bin?" "update-obj?" "bin" "src")}
      {Lisp-Entry "jazz.build-unit-internal" define #f 248 9 248 33 ("jazz.compile-unit" "phase" "declaration" "lambda" "jazz.for-each-subunit" "unit-name")}
      {Lisp-Entry "jazz.get-subunit-names-internal" define #f 259 9 259 40 ("jazz.for-each-subunit" "%%cons" "set!" "phase" "declaration" "unit-name" "lambda" "proc" "sub-units" "let*" "parent-name")}
      {Lisp-Entry "jazz.for-each-subunit" define #f 267 9 267 30 ("%%get-module-declaration-exports" "%%get-module-invoice-phase" "%%get-declaration-reference-name" "name" "%%get-module-invoice-module" "reference" "export" "%%get-module-declaration-requires" "%%get-unit-declaration-requires" "for-each" "jazz.Unit-Declaration" "jazz.is?" "jazz.error" "jazz.descendant-unit?" "and" "protected" "'protected" "%%get-declaration-access" "%%eq?" "or" "jazz.outline-unit" "declaration" "%%cons" "set!" "begin" "%%memq" "%%not" "if" "feature-requirement" "lambda" "jazz.parse-require" "require" "process-require" "define" "toplevel?" "phase" "unit-name" "iter" "subunits" "let" "proc" "parent-name")}}})
"_class"
 ({Lisp-File-Entry {File core "src" "core" "class" "_class.scm"} 1288732032
    {Lisp-Entry "core.class" unit #f 37 6 37 16 ()}})
"_dialect"
 ({Lisp-File-Entry {File core "src" "core" "module" "syntax" "dialect" "_dialect.scm"} 1288732032
    {Lisp-Entry "core.module.syntax.dialect" unit #f 37 16 37 42 ("jazz.Dialect" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Dialect" define-class ("class runtime") 40 27 40 39 ()}
      {Lisp-Entry "jazz.dialect-name" generic/specific ("jazz.Dialect~virtual-runtime") 43 30 43 47 ()}
      {Lisp-Entry "jazz.dialect-walker" generic/specific ("jazz.Dialect~virtual-runtime") 44 30 44 49 ()}
      {Lisp-Entry "jazz.dialect-name" generic/specific ("jazz.Dialect") 47 21 47 38 ()}
      {Lisp-Entry "jazz.dialect-walker" generic/specific ("jazz.Dialect") 51 21 51 40 ()}
      {Lisp-Entry "jazz.Dialects" define #f 63 8 63 21 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.get-dialect" define #f 67 9 67 25 ("jazz.Dialects" "%%table-ref" "name")}
      {Lisp-Entry "jazz.require-dialect" define #f 71 9 71 29 ("jazz.error" "jazz.get-dialect" "or" "name")}
      {Lisp-Entry "jazz.register-dialect" define #f 76 9 76 30 ("jazz.Dialects" "%%table-set!" "dialect" "name")}
      {Lisp-Entry "jazz.define-dialect" define-macro ("macro") 80 20 80 39 (",dialect" ",name" "',name" "jazz.register-dialect" "dialect" "name")}
      {Lisp-Entry "jazz.register-binding" define #f 89 9 89 30 ("%%get-dialect-bindings" "%%cons" "%%set-dialect-bindings" "jazz.get-dialect" "dialect" "let" "binding" "dialect-name")}
      {Lisp-Entry "jazz.define-walker-special" define-macro ("macro") 94 20 94 46 (",method" ",name" "',name" "jazz.new-special-form" ",dialect-name" "',dialect-name" "jazz.register-binding" "method" "dialect-name" "name")}
      {Lisp-Entry "jazz.define-walker-syntax" define-macro ("macro") 98 20 98 45 (",method" ",name" "',name" "jazz.new-syntax-form" ",dialect-name" "',dialect-name" "jazz.register-binding" "method" "dialect-name" "name")}
      {Lisp-Entry "jazz.define-walker-macro" define-macro ("macro") 102 20 102 44 (",method" ",name" "',name" "jazz.new-macro-form" ",dialect-name" "',dialect-name" "jazz.register-binding" "method" "dialect-name" "name")}}})
"_exception"
 ({Lisp-File-Entry {File core "src" "core" "exception" "_exception.scm"} 1288732032
    {Lisp-Entry "core.exception" unit #f 37 6 37 20 ()}})
"_generic"
 ({Lisp-File-Entry {File core "src" "core" "generic" "_generic.scm"} 1288732032
    {Lisp-Entry "core.generic" unit #f 37 6 37 18 ()}})
"_module"
 ({Lisp-File-Entry {File core "src" "core" "module" "_module.scm"} 1289667735
    {Lisp-Entry "core.module" unit #f 37 6 37 17 ()}})
"_runtime"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "_runtime.scm"} 1288732032
    {Lisp-Entry "core.base.runtime" unit #f 37 16 37 33 ()}}
  {Lisp-File-Entry {File core "src" "core" "class" "runtime" "_runtime.scm"} 1288732032
    {Lisp-Entry "core.class.runtime" unit #f 37 16 37 34 ()}}
  {Lisp-File-Entry {File core "src" "core" "generic" "runtime" "_runtime.scm"} 1288732032
    {Lisp-Entry "core.generic.runtime" unit #f 37 16 37 36 ()}}
  {Lisp-File-Entry {File core "src" "core" "module" "runtime" "_runtime.scm"} 1290444204
    {Lisp-Entry "core.module.runtime" unit #f 37 16 37 35 ("jazz.Runtime-Reference" "jazz.Native" "jazz.Module" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Module" define-class ("class") 45 19 45 30 ("%%get-module-entries" "entries" "%%get-module-exports" "exports" "%%get-module-access" "access" "%%get-module-name" "name" "jazz.allocate-module" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Module" define-class ("class runtime") 52 27 52 38 ()}
      {Lisp-Entry "jazz.new-module" define #f 55 9 55 24 ("eq?" "test:" "%%make-table" "jazz.Module" "jazz.allocate-module" "access" "name")}
      {Lisp-Entry "jazz.Native" define-class ("class") 67 19 67 30 ("%%get-native-symbol" "symbol" "jazz.allocate-native" "jazz.Object-Class" "name" "jazz.Field")}
      {Lisp-Entry "jazz.Native" define-class ("class runtime") 71 27 71 38 ()}
      {Lisp-Entry "jazz.new-native" define #f 74 9 74 24 ("jazz.Native" "jazz.allocate-native" "symbol" "name")}
      {Lisp-Entry "jazz.register-native" define #f 81 9 81 29 ("jazz.new-native" "jazz.register-module-entry" "symbol" "name" "module-name")}
      {Lisp-Entry "jazz.Runtime-Reference" define-class ("class") 90 19 90 41 ("%%get-runtime-reference-serialization" "serialization" "%%get-runtime-reference-resolver" "resolver" "jazz.allocate-runtime-reference" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Runtime-Reference" define-class ("class runtime") 95 27 95 49 ()}
      {Lisp-Entry "jazz.new-runtime-reference" define #f 98 9 98 35 ("jazz.Runtime-Reference" "jazz.allocate-runtime-reference" "serialization" "resolver")}
      {Lisp-Entry "jazz.resolve-runtime-reference" define #f 105 9 105 39 ("%%get-runtime-reference-resolver" "resolver" "let" "runtime-reference")}
      {Lisp-Entry "jazz.serialize-runtime-reference" define #f 110 9 110 41 ("%%get-runtime-reference-serialization" "runtime-reference")}
      {Lisp-Entry "jazz.deserialize-runtime-reference" define #f 114 9 114 43 ("jazz.error" "else" "module-public" "module-private" "case" "%%pair?" "if" "or" "jazz.module-ref" "%%cddr" "%%car" "name" "module-name" "deserialize-module-public" "jazz.global-ref" "%%cadr" "locator" "let" "lambda" "jazz.new-runtime-reference" "deserialize-module-private" "define" "serialization")}
      {Lisp-Entry "jazz.Modules" define #f 142 8 142 20 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.get-modules" define #f 146 9 146 25 ("jazz.Modules")}
      {Lisp-Entry "jazz.register-module" define #f 150 9 150 29 ("jazz.Modules" "%%cdr" "%%car" "pair" "%%table-set!" "info" "jazz.require-module" "jazz.iterate-table" "module-name" "lambda" "for-each" "%%get-module-exports" "exports" "jazz.new-module" "jazz.get-module" "or" "module" "let" "exported-symbols" "exported-modules" "access" "name")}
      {Lisp-Entry "jazz.get-module" define #f 167 9 167 24 ("jazz.Modules" "%%table-ref" "name")}
      {Lisp-Entry "jazz.require-module" define #f 171 9 171 28 ("jazz.error" "jazz.get-module" "or" "jazz.load-unit" "name")}
      {Lisp-Entry "jazz.get-module-entry" define #f 177 9 177 30 ("jazz.get-module" "%%get-module-entries" "%%table-ref" "entry-name" "module-name")}
      {Lisp-Entry "jazz.set-module-entry" define #f 180 9 180 30 ("jazz.get-module" "%%get-module-entries" "%%table-set!" "entry" "entry-name" "module-name")}
      {Lisp-Entry "jazz.register-module-entry" define #f 183 9 183 35 ("jazz.set-module-entry" "entry" "entry-name" "module-name")}
      {Lisp-Entry "jazz.module-get" define #f 187 9 187 24 ("jazz.load-unit" "locator" "unit-name" "jazz.bind" "jazz.global-ref" "%%symbol?" "if" "%%get-module-exports" "%%table-ref" "info" "jazz.require-module" "module" "let" "not-found" "#!key" "name" "module-name")}
      {Lisp-Entry "jazz.module-ref" define #f 199 8 199 23 ("jazz.error" "%%eq?" "if" "not-found:" "jazz.module-get" "obj" "name" "module-name" "lambda" "box" "not-found" "let")}
      {Lisp-Entry "jazz.module-set!" define #f 208 9 208 25 ("jazz.error" "jazz.load-unit" "locator" "unit-name" "jazz.bind" "jazz.global-set!" "%%symbol?" "if" "%%get-module-exports" "%%table-ref" "info" "jazz.require-module" "module" "let" "value" "name" "module-name")}
      {Lisp-Entry "jazz.type-error" define #f 225 9 225 24 ("jazz.error" "type" "value")}
      {Lisp-Entry "jazz.dispatch-error" define #f 229 9 229 28 ("%%get-category-identifier" "%%get-field-name" "jazz.error" "category" "value" "field")}}})
"_syntax"
 ({Lisp-File-Entry {File core "src" "core" "base" "syntax" "_syntax.scm"} 1288732032
    {Lisp-Entry "core.base.syntax" unit #f 37 16 37 32 ()}}
  {Lisp-File-Entry {File core "src" "core" "class" "syntax" "_syntax.scm"} 1288732032
    {Lisp-Entry "core.class.syntax" unit #f 37 16 37 33 ()}}
  {Lisp-File-Entry {File core "src" "core" "generic" "syntax" "_syntax.scm"} 1288732032
    {Lisp-Entry "core.generic.syntax" unit #f 37 16 37 35 ()}}
  {Lisp-File-Entry {File core "src" "core" "module" "syntax" "_syntax.scm"} 1288732032
    {Lisp-Entry "core.module.syntax" unit #f 37 16 37 34 ()}})
"_unit"
 ({Lisp-File-Entry {File core "src" "core" "unit" "_unit.scm"} 1288732032
    {Lisp-Entry "core.unit" unit #f 37 6 37 15 ()}})
"_walker"
 ({Lisp-File-Entry {File core "src" "core" "module" "syntax" "walker" "_walker.scm"} 1290444949
    {Lisp-Entry "core.module.syntax.walker" unit #f 59 16 59 41 ("jazz.Core-Walker" "jazz.Core-Dialect" "jazz.Walker" "jazz.Analysis-Data" "jazz.Assignment" "jazz.Constant" "jazz.Call" "jazz.Begin" "jazz.Internal-Define" "jazz.Body" "jazz.Reference-Reification" "jazz.Binding-Reference" "jazz.Expression" "jazz.Code" "jazz.Annotated-Frame" "jazz.Restricted-Binding" "jazz.Annotated-Variable" "jazz.Syntactic-Closure" "jazz.Define-Local-Syntax-Form" "jazz.Define-Syntax-Form" "jazz.Syntax-Form" "jazz.Macro-Form" "jazz.Special-Form" "jazz.Form-Binding" "jazz.Macro-Symbol" "jazz.Local-Variable-Binding" "jazz.Dynamic-Self-Binding" "jazz.Self-Binding" "jazz.Rest-Parameter" "jazz.Named-Parameter" "jazz.Optional-Parameter" "jazz.Dynamic-Parameter" "jazz.Parameter" "jazz.NextMethod-Variable" "jazz.Variable" "jazz.Symbol-Binding" "jazz.Signature" "jazz.Walk-Frame" "jazz.Unresolved-Error" "jazz.Walk-Error" "jazz.Walk-Warning" "jazz.Walk-Problems" "jazz.Walk-Problem" "jazz.Walk-Location" "jazz.Walk-Context" "jazz.Define-Local-Syntax-Declaration" "jazz.Define-Syntax-Declaration" "jazz.Syntax-Declaration" "jazz.Local-Macro-Declaration" "jazz.Macro-Declaration" "Unspecified" "'Unspecified" "EOF" "'EOF" "Values" "'Values" "Foreign" "'Foreign" "Promise" "'Promise" "Thread" "'Thread" "Table" "'Table" "F64Vector" "'F64Vector" "F32Vector" "'F32Vector" "U64Vector" "'U64Vector" "S64Vector" "'S64Vector" "U32Vector" "'U32Vector" "S32Vector" "'S32Vector" "U16Vector" "'U16Vector" "S16Vector" "'S16Vector" "U8Vector" "'U8Vector" "S8Vector" "'S8Vector" "Vector" "'Vector" "Keyword" "'Keyword" "Symbol" "'Symbol" "String" "'String" "Procedure" "'Procedure" "Continuation" "'Continuation" "Port" "'Port" "Pair" "'Pair" "Null" "'Null" "List" "'List" "Flonum" "'Flonum" "Fixnum" "'Fixnum" "Integer" "'Integer" "Rational" "'Rational" "Real" "'Real" "Complex" "'Complex" "Number" "'Number" "Char" "'Char" "Boolean" "'Boolean" "Object" "'Object" "jazz.primitive-declarations" "void" "'void" "jazz.Unspecified" "unspecified" "'unspecified" "jazz.EOF" "eof" "'eof" "jazz.Values" "values" "'values" "jazz.Foreign" "foreign" "'foreign" "jazz.Promise" "promise" "'promise" "jazz.Thread" "thread" "'thread" "jazz.Table" "table" "'table" "jazz.F64Vector" "f64vector" "'f64vector" "jazz.F32Vector" "f32vector" "'f32vector" "jazz.U64Vector" "u64vector" "'u64vector" "jazz.S64Vector" "s64vector" "'s64vector" "jazz.U32Vector" "u32vector" "'u32vector" "jazz.S32Vector" "s32vector" "'s32vector" "jazz.U16Vector" "u16vector" "'u16vector" "jazz.S16Vector" "s16vector" "'s16vector" "jazz.U8Vector" "u8vector" "'u8vector" "jazz.S8Vector" "s8vector" "'s8vector" "jazz.Vector" "vector" "'vector" "jazz.Keyword" "keyword" "'keyword" "jazz.Symbol" "symbol" "'symbol" "jazz.String" "string" "'string" "jazz.Procedure" "procedure" "'procedure" "jazz.Continuation" "continuation" "'continuation" "jazz.Port" "port" "'port" "jazz.Pair" "pair" "'pair" "jazz.Null" "null" "'null" "jazz.List" "list" "'list" "jazz.Flonum" "fl" "'fl" "jazz.Fixnum" "fx" "'fx" "jazz.Integer" "int" "'int" "jazz.Rational" "rational" "'rational" "jazz.Real" "real" "'real" "jazz.Complex" "complex" "'complex" "jazz.Number" "number" "'number" "jazz.Char" "char" "'char" "jazz.Boolean" "bool" "'bool" "jazz.Object" "object" "'object" "any" "'any" "jazz.primitive-types" "%%table-set!" "jazz.Any" "jazz.Any-Class" "type" "lambda" "jazz.object-declaration?" "set!" "jazz.Nillable-Type" "jazz.Template-Type" "jazz.Union-Type" "jazz.Complement-Type" "jazz.Restriction-Type" "jazz.Values-Type" "jazz.Category-Type" "jazz.Function-Type" "jazz.Rest-Type" "jazz.Key-Type" "jazz.Opt-Type" "jazz.Void" "jazz.Void-Class" "jazz.Literal" "jazz.Autoload-Declaration" "jazz.Export-Syntax-Declaration" "jazz.Export-Declaration" "jazz.Import-Invoice" "jazz.Export-Invoice" "jazz.Module-Invoice" "jazz.Module-Declaration" "jazz.Namespace-Declaration" "jazz.Unit-Declaration" "jazz.Autoload-Reference" "jazz.Export-Reference" "jazz.Module-Reference" "jazz.Declaration-Reference" "jazz.Declaration" "jazz.Lexical-Binding" "jazz.Walk-Binding" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.analysis-mode?" define #f 68 8 68 27 ("make-parameter")}
      {Lisp-Entry "jazz.analysis-data" define #f 73 8 73 26 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.private-access" define #f 83 8 83 27 ("0")}
      {Lisp-Entry "jazz.public-access" define #f 87 8 87 26 ("1")}
      {Lisp-Entry "jazz.protected-access" define #f 91 8 91 29 ("2")}
      {Lisp-Entry "jazz.make-access-lookups" define #f 95 9 95 33 ("eq?" "test:" "%%make-table" "%%vector-set!" "begin" "%%fx<=" "if" "0" "n" "iter" "1" "%%fx+" "%%make-vector" "lookups" "let" "access-level")}
      {Lisp-Entry "jazz.Walk-Binding" define-class ("class runtime") 110 27 110 44 ()}
      {Lisp-Entry "jazz.emit-type" generic/specific ("jazz.Walk-Binding") 113 21 113 35 ("type" "jazz.emit-binding-reference" "jazz.sourcified-form" "environment" "source-declaration")}
      {Lisp-Entry "jazz.specifiable?" generic/specific ("jazz.Walk-Binding") 117 21 117 38 ()}
      {Lisp-Entry "jazz.walk-binding-lookup" generic/specific ("jazz.Walk-Binding~virtual-runtime") 121 30 121 54 ("source-declaration" "symbol")}
      {Lisp-Entry "jazz.walk-binding-referenced" generic/specific ("jazz.Walk-Binding~virtual-runtime") 122 30 122 58 ()}
      {Lisp-Entry "jazz.emit-binding-symbol" generic/specific ("jazz.Walk-Binding~virtual-runtime") 123 30 123 54 ("environment" "source-declaration")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Walk-Binding~virtual-runtime") 124 30 124 57 ("environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.Walk-Binding~virtual-runtime") 125 30 125 61 ("form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-binding-call" generic/specific ("jazz.Walk-Binding~virtual-runtime") 126 30 126 52 ("environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "jazz.emit-inlined-binding-call" generic/specific ("jazz.Walk-Binding~virtual-runtime") 127 30 127 60 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "jazz.walk-binding-validate-assignment" generic/specific ("jazz.Walk-Binding~virtual-runtime") 128 30 128 67 ("symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-binding-assignable?" generic/specific ("jazz.Walk-Binding~virtual-runtime") 129 30 129 59 ()}
      {Lisp-Entry "jazz.emit-binding-assignment" generic/specific ("jazz.Walk-Binding~virtual-runtime") 130 30 130 58 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.walk-binding-walkable?" generic/specific ("jazz.Walk-Binding~virtual-runtime") 131 30 131 57 ()}
      {Lisp-Entry "jazz.walk-binding-walk-form" generic/specific ("jazz.Walk-Binding~virtual-runtime") 132 30 132 57 ("form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Walk-Binding~virtual-runtime") 133 30 133 59 ()}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Walk-Binding~virtual-runtime") 134 30 134 59 ("form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-binding-lookup" generic/specific ("jazz.Walk-Binding") 137 21 137 45 ("source-declaration" "symbol")}
      {Lisp-Entry "jazz.walk-binding-referenced" generic/specific ("jazz.Walk-Binding") 141 21 141 49 ("jazz.unspecified")}
      {Lisp-Entry "jazz.emit-binding-symbol" generic/specific ("jazz.Walk-Binding") 145 21 145 45 ("binding" "jazz.error" "environment" "source-declaration")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Walk-Binding") 149 21 149 48 ("binding" "jazz.error" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.Walk-Binding") 153 21 153 52 ("jazz.unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-binding-call" generic/specific ("jazz.Walk-Binding") 157 21 157 43 ("jazz.call-return-type" "jazz.codes-forms" "jazz.emit-binding-reference" "jazz.sourcified-form2" "jazz.new-code" "binding" "%%get-lexical-binding-type" "type" "let" "environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "jazz.emit-inlined-binding-call" generic/specific ("jazz.Walk-Binding") 166 21 166 51 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "jazz.walk-binding-validate-assignment" generic/specific ("jazz.Walk-Binding") 170 21 170 58 ("%%get-lexical-binding-name" "jazz.walk-error" "binding" "jazz.walk-binding-assignable?" "%%not" "%%when" "symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-binding-assignable?" generic/specific ("jazz.Walk-Binding") 175 21 175 50 ()}
      {Lisp-Entry "jazz.emit-binding-assignment" generic/specific ("jazz.Walk-Binding") 179 21 179 49 ("jazz.unspecified" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.walk-binding-walkable?" generic/specific ("jazz.Walk-Binding") 183 21 183 48 ()}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Walk-Binding") 187 21 187 50 ()}
      {Lisp-Entry "jazz.call-return-type" define #f 194 9 194 30 ("jazz.Any" "%%get-function-type-result" "jazz.Function-Type" "%%is?" "if" "operator-type")}
      {Lisp-Entry "jazz.Lexical-Binding" define-class ("class runtime") 205 27 205 47 ()}
      {Lisp-Entry "jazz.resolve-binding" generic/specific ("jazz.Lexical-Binding~virtual-runtime") 208 30 208 50 ()}
      {Lisp-Entry "jazz.resolve-binding" generic/specific ("jazz.Lexical-Binding") 211 21 211 41 ("binding")}
      {Lisp-Entry "jazz.print-object" generic/specific ("jazz.Lexical-Binding") 215 21 215 38 ("jazz.object->serial" "%%get-lexical-binding-name" "binding" "%%get-object-class" "%%get-category-identifier" "jazz.format" "detail" "output")}
      {Lisp-Entry "jazz.walk-binding-lookup" generic/specific ("jazz.Lexical-Binding") 222 21 222 45 ("binding" "%%get-lexical-binding-name" "%%eq?" "if" "source-declaration" "symbol")}
      {Lisp-Entry "jazz.get-lexical-binding-name" define #f 228 9 228 38 ("%%get-lexical-binding-name" "binding")}
      {Lisp-Entry "jazz.get-lexical-binding-hits" define #f 232 9 232 38 ("%%set-lexical-binding-hits" "eq?" "test:" "%%make-table" "table" "let" "%%get-lexical-binding-hits" "or" "binding")}
      {Lisp-Entry "jazz.emit-binding-symbol" generic/specific ("jazz.Lexical-Binding") 239 21 239 45 ("binding" "%%get-lexical-binding-name" "environment" "declaration")}
      {Lisp-Entry "jazz.Declaration" define-class ("class runtime") 251 27 251 43 ()}
      {Lisp-Entry "jazz.setup-declaration" define #f 254 9 254 31 ("%%get-declaration-toplevel" "%%set-declaration-toplevel" "%%get-declaration-locator" "%%compose-name" "%%not" "if" "%%set-declaration-locator" "%%get-lexical-binding-name" "name" "%%get-declaration-parent" "parent" "let" "new-declaration")}
      {Lisp-Entry "jazz.get-declaration-path" define #f 261 9 261 34 ("jazz.reverse!" "%%cons" "%%list" "%%not" "if" "%%get-declaration-parent" "parent" "%%get-lexical-binding-name" "name" "let" "lambda" "proc" "letrec" "declaration")}
      {Lisp-Entry "jazz.walk-binding-lookup" generic/specific ("jazz.Declaration") 272 21 272 45 ("jazz.private-access" "binding" "jazz.lookup-declaration" "source-declaration" "symbol")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.Declaration") 276 21 276 52 ("declaration" "%%get-lexical-binding-name" "jazz.walk-error" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.lookup-declaration" generic/specific ("jazz.Declaration~virtual-runtime") 280 30 280 53 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz.lookup-declaration" generic/specific ("jazz.Declaration") 283 21 283 44 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz.get-declaration-inclusions" generic/specific ("jazz.Declaration~virtual-runtime") 287 30 287 61 ()}
      {Lisp-Entry "jazz.get-declaration-inclusions" generic/specific ("jazz.Declaration") 290 21 290 52 ()}
      {Lisp-Entry "jazz.get-nextmethod-signature" generic/specific ("jazz.Declaration~virtual-runtime") 294 30 294 59 ()}
      {Lisp-Entry "jazz.get-nextmethod-signature" generic/specific ("jazz.Declaration") 297 21 297 50 ("declaration" "jazz.error")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Declaration~virtual-runtime") 301 30 301 51 ("environment")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Declaration") 304 21 304 42 ("declaration" "jazz.error" "environment")}
      {Lisp-Entry "jazz.expand-referenced-declaration" generic/specific ("jazz.Declaration~virtual-runtime") 308 30 308 64 ()}
      {Lisp-Entry "jazz.expand-referenced-declaration" generic/specific ("jazz.Declaration") 311 21 311 55 ()}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Declaration~virtual-runtime") 315 30 315 51 ("s" "k" "f")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Declaration") 318 21 318 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.declaration-result" define #f 322 9 322 32 ("jazz.unspecified" "eval" "'eval" "jazz.walk-for" "%%eq?" "if")}
      {Lisp-Entry "jazz.Declaration-Reference" define-class ("class runtime") 336 27 336 53 ()}
      {Lisp-Entry "jazz.resolve-reference" generic/specific ("jazz.Declaration-Reference~virtual-runtime") 339 30 339 52 ("module-declaration")}
      {Lisp-Entry "jazz.resolve-reference" generic/specific ("jazz.Declaration-Reference") 342 21 342 43 ("%%set-declaration-reference-declaration" "uptodate" "'uptodate" "public" "'public" "jazz.new-export-declaration" "declaration" "let" "%%get-declaration-reference-name" "jazz.parse-exported-symbol" "symbol" "name" "receive" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "jazz.Module-Reference" define-class ("class runtime") 358 27 358 48 ()}
      {Lisp-Entry "jazz.new-module-reference" define #f 361 9 361 34 ("jazz.Module-Reference" "jazz.allocate-module-reference" "declaration" "name")}
      {Lisp-Entry "jazz.resolve-reference" generic/specific ("jazz.Module-Reference") 365 21 365 43 ("%%set-declaration-reference-declaration" "%%get-declaration-reference-name" "jazz.outline-module" "declaration" "let" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "jazz.Export-Reference" define-class ("class runtime") 380 27 380 48 ()}
      {Lisp-Entry "jazz.new-export-reference" define #f 383 9 383 34 ("jazz.Export-Reference" "jazz.allocate-export-reference" "module-reference" "declaration" "name")}
      {Lisp-Entry "jazz.resolve-reference" generic/specific ("jazz.Export-Reference") 387 21 387 43 ("%%set-declaration-reference-declaration" "uptodate" "'uptodate" "public" "'public" "jazz.new-export-declaration" "declaration" "%%get-lexical-binding-name" "jazz.compose-name" "locator" "let" "%%get-declaration-reference-name" "jazz.parse-exported-symbol" "symbol" "name" "receive" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "jazz.parse-exported-symbol" define #f 396 9 396 35 ("jazz.identifier-name" "values" "jazz.composite-name?" "if" "name" "module-declaration")}
      {Lisp-Entry "jazz.Autoload-Reference" define-class ("class runtime") 410 27 410 50 ()}
      {Lisp-Entry "jazz.new-autoload-reference" define #f 413 9 413 36 ("jazz.Autoload-Reference" "jazz.allocate-autoload-reference" "module-reference" "declaration" "name")}
      {Lisp-Entry "jazz.resolve-autoload-reference" define #f 417 9 417 40 ("%%set-declaration-reference-declaration" "%%assert" "jazz.new-autoload-declaration" "declaration" "jazz.Any" "type" "%%get-declaration-reference-name" "name" "let*" "%%get-declaration-reference-declaration" "or" "exported-module-reference" "module-declaration" "declaration-reference")}
      {Lisp-Entry "jazz.Unit-Declaration" define-class ("class runtime") 435 27 435 48 ()}
      {Lisp-Entry "jazz.new-unit-declaration" define #f 438 9 438 34 ("jazz.setup-declaration" "uptodate" "'uptodate" "jazz.Unit-Declaration" "jazz.allocate-unit-declaration" "new-declaration" "let" "requires" "parent" "access" "name")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Unit-Declaration") 444 21 444 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Namespace-Declaration" define-class ("class runtime") 456 27 456 53 ()}
      {Lisp-Entry "jazz.lookup-declaration" generic/specific ("jazz.Namespace-Declaration") 459 21 459 44 ("%%get-access-lookup" "%%table-ref" "found" "jazz.get-analysis-data" "%%set-analysis-data-autoload-reference" "jazz.Autoload-Declaration" "%%is?" "jazz.get-lexical-binding-hits" "hits-table" "let" "jazz.analysis-mode?" "add-to-hits" "%%get-declaration-locator" "%%table-set!" "%%get-module-declaration-walker-references" "references-table" "module-declaration" "let*" "%%get-declaration-toplevel" "namespace-declaration" "%%neq?" "and" "%%when" "declaration" "add-to-module-references" "define" "source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Namespace-Declaration") 481 21 481 42 ("%%get-namespace-declaration-body" "jazz.fold-statements" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.get-private-lookup" define #f 488 9 488 32 ("jazz.private-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "jazz.get-public-lookup" define #f 491 9 491 31 ("jazz.public-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "jazz.get-protected-lookup" define #f 494 9 494 34 ("jazz.protected-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "jazz.Module-Declaration" define-class ("class runtime") 504 27 504 50 ()}
      {Lisp-Entry "jazz.new-module-declaration" define #f 507 9 507 36 ("jazz.setup-declaration" "eq?" "test:" "%%make-table" "jazz.new-queue" "jazz.public-access" "jazz.make-access-lookups" "uptodate" "'uptodate" "jazz.Module-Declaration" "jazz.allocate-module-declaration" "new-declaration" "let" "dialect-invoice" "dialect-name" "walker" "parent" "access" "name")}
      {Lisp-Entry "jazz.add-module-require" define #f 513 9 513 32 ("%%list" "%%get-module-declaration-requires" "%%append" "%%set-module-declaration-requires" "jazz.load-unit" "syntax" "'syntax" "%%eq?" "%%when" "phase" "feature-requirement" "unit-name" "lambda" "jazz.parse-require" "require" "module-declaration")}
      {Lisp-Entry "jazz.add-module-import" define #f 521 9 521 31 ("jazz.table-merge-reporting-conflicts!" "jazz.public-access" "imported" "imported-module-declaration" "%%get-module-invoice-only" "only" "jazz.private-access" "%%get-access-lookup" "private" "%%list" "%%append" "%%set-module-declaration-imports" "jazz.find-module-invoice" "%%get-module-declaration-imports" "imports" "if" "%%get-lexical-binding-name" "jazz.load-unit" "%%get-module-invoice-module" "let" "syntax" "'syntax" "%%get-module-invoice-phase" "%%eq?" "%%when" "new" "actual" "merge-invoice" "define" "register?" "module-invoice" "module-declaration")}
      {Lisp-Entry "jazz.add-module-export" define #f 545 9 545 31 ("jazz.table-merge-reporting-conflicts!" "exported-module-declaration" "else" "jazz.resolve-autoload-reference" "exported-module-reference" "%%table-set!" "%%get-declaration-reference-name" "jazz.identifier-name" "name" "declaration-reference" "lambda" "for-each" "cond" "autoload" "%%get-module-invoice-only" "only" "jazz.public-access" "%%get-access-lookup" "public" "%%list" "%%set-module-declaration-exports" "jazz.find-module-invoice" "%%get-module-declaration-exports" "exports" "%%get-lexical-binding-name" "jazz.load-unit" "%%get-module-invoice-module" "jazz.resolve-reference" "syntax" "'syntax" "%%get-module-invoice-phase" "%%eq?" "%%append" "if" "%%set-export-invoice-autoload" "%%when" "new-autoload" "%%get-export-invoice-autoload" "actual-autoload" "let" "new" "actual" "merge-invoice" "define" "module-invoice" "module-declaration")}
      {Lisp-Entry "jazz.table-merge-reporting-conflicts!" define #f 579 9 579 46 ("%%get-lexical-binding-name" "jazz.error" "%%null?" "conflicts" "%%fx+" "%%fx=" "%%not" "%%table-merge!" "add-count" "%%table-length" "table-count" "%%list" "%%cons" "set!" "%%neq?" "%%when" "actual-locator" "value-locator" "%%table-ref" "actual" "value" "key" "lambda" "jazz.iterate-table" "lst" "let" "find-actual-conflicts" "%%get-declaration-locator" "else" "jazz.autoload-declaration-locator-heuristic" "jazz.Autoload-Declaration" "%%get-export-declaration-symbol" "jazz.Export-Declaration" "%%is?" "cond" "decl" "effective-declaration-locator" "define" "add" "table" "suffix" "module-declaration")}
      {Lisp-Entry "jazz.generate-reference-list" define #f 613 9 613 37 ("%%cdar" "%%pair?" "map" "declarations" "%%caar" "%%get-declaration-locator" "module-locator" "out" "%%table->list" "in" "%%table-ref" "%%table-set!" "%%get-declaration-toplevel" "module" "jazz.resolve-binding" "resolved-declaration" "locator" "lambda" "%%get-module-declaration-walker-references" "jazz.iterate-table" "eq?" "test:" "%%make-table" "partition" "%%get-lexical-binding-name" "%%get-declaration-parent" "%%eq?" "composite-name" "iter" "declaration" "root-declaration" "compose-name" "%%cdr" "else" "%%cons" "%%car" "%%list" "cond" "sorted" "item" "merge-sorted" "cdr" "%%string=?" "and" "%%string<?" "string2" "car" "%%symbol->string" "string1" "let" "%%null?" "or" "if" "name2" "name1" "lesser" "define" "module-declaration")}
      {Lisp-Entry "jazz.lookup-declaration" generic/specific ("jazz.Module-Declaration") 658 21 658 44 ("nextmethod" "declaration" "%%get-module-declaration-imports" "%%set-import-invoice-hit?" "%%table-ref" "jazz.public-access" "%%get-access-lookup" "imported" "%%get-module-invoice-module" "imported-module-declaration" "let" "module-invoice" "lambda" "for-each" "jazz.analysis-mode?" "%%when" "source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Module-Declaration") 670 21 670 42 (",@body-expansion" ",@variables-expansion" ",@literals-expansion" ",@autoloads-expansion" ",@inclusions-expansion" ",@registration-expansion" "%%get-module-declaration-imports" "%%cadr" "%%symbol->string" "%%string<?" "y" "x" "jazz.queue-list" "jazz.sort" "jazz.enqueue-list" ",symbol-name" ",name" "',name" "jazz.register-autoload" "jazz.compose-name" "symbol-name" "jazz.identifier-name" "name" "decl" "%%get-declaration-reference-name" "names" "auto" "%%get-module-declaration-exports" "%%get-lexical-binding-name" "syntax" "'syntax" "%%get-module-invoice-phase" "%%get-module-invoice-module" "jazz.resolve-reference" "module-declaration" "and" "%%get-export-invoice-autoload" "autoload" "%%get-module-invoice-only" "only" "module-invoice" "%%get-module-declaration-requires" "phase" "feature-requirement" "jazz.parse-require" "spec" "lambda" "for-each" "core" "'core" "%%neq?" "%%get-module-declaration-dialect-name" "dialect-name" "core.module" "'core.module" ",unit-name" "',unit-name" "jazz.load-unit" "jazz.enqueue" "%%table-set!" "%%table-ref" "%%not" "%%when" "unit-name" "enqueue-load-unit" "define" "eq?" "test:" "%%make-table" "load-units" "jazz.new-queue" "queue" "module" "'module" "jazz.declares" "else" "eval" "jazz.walk-for" "case" "begin" "jazz.emit-module-registration" "registration-expansion" "jazz.emit-module-autoloads" "autoloads-expansion" "jazz.emit-module-variables" "variables-expansion" "jazz.emit-module-literals" "literals-expansion" "jazz.emit-module-inclusions" "inclusions-expansion" "declaration" "%%get-namespace-declaration-body" "jazz.emit-namespace-statements" "body-expansion" "let" "environment")}
      {Lisp-Entry "jazz.get-module-proclaim" define #f 739 9 739 33 ("%%get-module-declaration-proclaims" "%%table-ref" "default" "proclaim-name" "module-declaration")}
      {Lisp-Entry "jazz.set-module-proclaim" define #f 743 9 743 33 ("%%get-module-declaration-proclaims" "%%table-set!" "value" "proclaim-name" "module-declaration")}
      {Lisp-Entry "jazz.all-warnings" define #f 747 8 747 25 ("optimizations")}
      {Lisp-Entry "jazz.proclaim" define #f 751 9 751 22 ("jazz.remove!" "else" "%%cons" "jazz.set-module-proclaim" "'warn" "jazz.get-module-proclaim" "module-warnings" "jazz.error" "%%memq" "%%not" "cond" "warning" "lambda" "for-each" "jazz.all-warnings" "%%null?" "warnings" "warn" "case" "receive" "not" "'not" "%%eq?" "if" "parse-clause" "values" "%%cdr" "parameters" "%%car" "kind" "let" "%%pair?" "%%assert" "not?" "parse-not" "define" "clause" "module-declaration")}
      {Lisp-Entry "jazz.get-module-warn?" define #f 784 9 784 30 ("warn" "'warn" "jazz.get-module-proclaim" "%%memq" "warning-name" "module-declaration")}
      {Lisp-Entry "jazz.Module-Invoice" define-class ("class runtime") 796 27 796 46 ()}
      {Lisp-Entry "jazz.find-module-invoice" define #f 802 9 802 33 ("%%eq?" "and" "invoice" "lambda" "jazz.find-if" "%%get-module-invoice-phase" "target-phase" "%%get-module-invoice-name" "target-name" "let" "target" "invoices")}
      {Lisp-Entry "jazz.Export-Invoice" define-class ("class runtime") 816 27 816 46 ()}
      {Lisp-Entry "jazz.new-export-invoice" define #f 819 9 819 32 ("jazz.Export-Invoice" "jazz.allocate-export-invoice" "autoload" "only" "version" "phase" "module" "name")}
      {Lisp-Entry "jazz.Import-Invoice" define-class ("class runtime") 831 27 831 46 ()}
      {Lisp-Entry "jazz.new-import-invoice" define #f 834 9 834 32 ("jazz.Import-Invoice" "jazz.allocate-import-invoice" "only" "version" "phase" "module" "name")}
      {Lisp-Entry "jazz.Export-Declaration" define-class ("class runtime") 846 27 846 50 ()}
      {Lisp-Entry "jazz.new-export-declaration" define #f 849 9 849 36 ("jazz.setup-declaration" "jazz.Export-Declaration" "jazz.allocate-export-declaration" "new-declaration" "let" "symbol" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.Export-Declaration") 855 21 855 52 ("jazz.unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Export-Declaration") 859 21 859 42 (",symbol" "',symbol" ",name" "',name" "jazz.register-native" "jazz.Module-Declaration" "%%is?" "%%assert" "%%get-declaration-parent" "parent" "%%get-export-declaration-symbol" "symbol" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Export-Declaration") 867 21 867 48 ("jazz.Any" "declaration" "%%get-export-declaration-symbol" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Export-Declaration") 874 21 874 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Export-Syntax-Declaration" define-class ("class runtime") 886 27 886 57 ()}
      {Lisp-Entry "jazz.new-export-syntax-declaration" define #f 889 9 889 43 ("jazz.setup-declaration" "jazz.Export-Syntax-Declaration" "jazz.allocate-export-syntax-declaration" "new-declaration" "let" "symbol" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.Export-Syntax-Declaration") 895 21 895 52 ("jazz.unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Export-Syntax-Declaration") 899 21 899 42 ("begin" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Export-Syntax-Declaration") 903 21 903 48 ("jazz.Any" "declaration" "%%get-export-syntax-declaration-symbol" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Export-Syntax-Declaration") 910 21 910 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Autoload-Declaration" define-class ("class runtime") 922 27 922 52 ()}
      {Lisp-Entry "jazz.new-autoload-declaration" define #f 925 9 925 38 ("jazz.setup-declaration" "uptodate" "'uptodate" "public" "'public" "jazz.Autoload-Declaration" "jazz.allocate-autoload-declaration" "new-declaration" "let" "exported-module" "module-declaration" "parent" "type" "name")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Autoload-Declaration") 931 21 931 37 ("declaration" "jazz.resolve-binding" "jazz.of-subtype?" "subtype")}
      {Lisp-Entry "jazz.specifiable?" generic/specific ("jazz.Autoload-Declaration") 936 21 936 38 ()}
      {Lisp-Entry "jazz.resolve-binding" generic/specific ("jazz.Autoload-Declaration") 941 21 941 41 ("%%set-autoload-declaration-declaration" "%%get-declaration-locator" "jazz.error" "%%assertion" "jazz.public-access" "jazz.lookup-declaration" "decl" "%%get-lexical-binding-name" "name" "%%get-autoload-declaration-module" "%%get-autoload-declaration-exported-module" "jazz.resolve-reference" "exported-module" "let*" "declaration" "%%get-autoload-declaration-declaration" "or")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.Autoload-Declaration") 951 21 951 52 ("declaration" "jazz.resolve-binding" "jazz.walk-binding-validate-call" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Autoload-Declaration") 955 21 955 48 ("jazz.autoload-locator" "jazz.new-code" "declaration" "jazz.resolve-binding" "referenced-declaration" "let" "environment" "source-declaration")}
      {Lisp-Entry "jazz.autoload-declaration-locator-heuristic" define #f 966 9 966 52 ("%%get-lexical-binding-name" "%%get-autoload-declaration-exported-module" "%%get-declaration-reference-name" "jazz.compose-name" "declaration")}
      {Lisp-Entry "jazz.autoload-locator" define #f 970 9 970 30 ("%%get-declaration-locator" "%%symbol->string" "%%string-append" "%%string->symbol" "referenced-declaration")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Autoload-Declaration") 975 21 975 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Literal" define-class ("class runtime") 987 27 987 39 ()}
      {Lisp-Entry "jazz.new-literal" define #f 990 9 990 25 ("jazz.Literal" "jazz.allocate-literal" "arguments" "name")}
      {Lisp-Entry "jazz.Void-Class" define-class ("class runtime") 1002 27 1002 42 ()}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Void-Class") 1005 21 1005 37 ("subtype")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Void-Class") 1009 21 1009 40 ("void" "'void")}
      {Lisp-Entry "jazz.Void" define-class ("class runtime") 1016 27 1016 36 ()}
      {Lisp-Entry "jazz.Opt-Type" define-class ("class runtime") 1027 27 1027 40 ()}
      {Lisp-Entry "jazz.new-opt-type" define #f 1030 9 1030 26 ("jazz.Opt-Type" "jazz.allocate-opt-type" "type")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Opt-Type") 1034 21 1034 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-opt-type-type" "jazz.emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "jazz.Key-Type" define-class ("class runtime") 1047 27 1047 40 ()}
      {Lisp-Entry "jazz.new-key-type" define #f 1050 9 1050 26 ("jazz.Key-Type" "jazz.allocate-key-type" "type" "key")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Key-Type") 1054 21 1054 40 ("%%symbol->string" "%%keyword->string" "%%string-append" "%%string->symbol" "%%get-key-type-type" "jazz.emit-specifier" "type-specifier" "type" "%%get-key-type-key" "key" "let")}
      {Lisp-Entry "jazz.Rest-Type" define-class ("class runtime") 1068 27 1068 41 ()}
      {Lisp-Entry "jazz.new-rest-type" define #f 1071 9 1071 27 ("jazz.Rest-Type" "jazz.allocate-rest-type" "type")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Rest-Type") 1075 21 1075 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-rest-type-type" "jazz.emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "jazz.Function-Type" define-class ("class runtime") 1091 27 1091 45 ()}
      {Lisp-Entry "jazz.new-function-type" define #f 1094 9 1094 31 ("jazz.Function-Type" "jazz.allocate-function-type" "%%length" "mandatory" "let" "result" "rest" "named" "optional" "positional")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Function-Type") 1099 21 1099 37 ("jazz.Function-Type" "%%get-object-class" "%%eq?" "jazz.Procedure" "jazz.of-subtype?" "or" "subtype")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Function-Type") 1104 21 1104 40 ("get-output-string" "%%string->symbol" "%%get-function-type-result" "%%not" "%%when" "%%get-function-type-rest" "rest" "%%get-function-type-positional" "jazz.emit-specifier" "display" "write-char" "set!" "if" "type" "lambda" "for-each" "first?" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz.emit-check" generic/specific ("jazz.Function-Type") 1123 21 1123 36 ("jazz.Procedure" "jazz.type-error" ",value" "%%procedure?" "%%not" "if" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Category-Type" define-class ("class runtime") 1139 27 1139 45 ()}
      {Lisp-Entry "jazz.new-category-type" define #f 1142 9 1142 31 ("jazz.Category-Type" "jazz.allocate-category-type" "declaration")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Category-Type") 1147 21 1147 37 ("subtype")}
      {Lisp-Entry "jazz.emit-check" generic/specific ("jazz.Category-Type") 1151 21 1151 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Category-Type") 1155 21 1155 40 ("get-output-string" "%%string->symbol" "type" "%%get-category-type-declaration" "jazz.emit-specifier" "write-char" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz.Values-Type" define-class ("class runtime") 1172 27 1172 43 ()}
      {Lisp-Entry "jazz.new-values-type" define #f 1175 9 1175 29 ("jazz.Values-Type" "jazz.allocate-values-type" "types")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Values-Type") 1179 21 1179 40 ("get-output-string" "%%string->symbol" "%%get-values-type-types" "jazz.emit-specifier" "set!" "if" "type" "lambda" "for-each" "first?" "write-char" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz.Restriction-Type" define-class ("class runtime") 1202 27 1202 48 ()}
      {Lisp-Entry "jazz.new-restriction-type" define #f 1205 9 1205 34 ("jazz.Restriction-Type" "jazz.allocate-restriction-type" "type" "base")}
      {Lisp-Entry "jazz.Complement-Type" define-class ("class runtime") 1217 27 1217 47 ()}
      {Lisp-Entry "jazz.new-complement-type" define #f 1220 9 1220 33 ("jazz.Complement-Type" "jazz.allocate-complement-type" "type")}
      {Lisp-Entry "jazz.Union-Type" define-class ("class runtime") 1232 27 1232 42 ()}
      {Lisp-Entry "jazz.new-union-type" define #f 1235 9 1235 28 ("jazz.Union-Type" "jazz.allocate-union-type" "types")}
      {Lisp-Entry "jazz.Template-Type" define-class ("class runtime") 1250 27 1250 45 ()}
      {Lisp-Entry "jazz.new-template-type" define #f 1253 9 1253 31 ("jazz.Template-Type" "jazz.allocate-template-type" "types" "class")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Template-Type") 1257 21 1257 40 ("get-output-string" "%%string->symbol" "%%get-template-type-types" "set!" "if" "lambda" "for-each" "first?" "write-char" "type" "%%get-template-type-class" "jazz.emit-specifier" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz.Nillable-Type" define-class ("class runtime") 1280 27 1280 45 ()}
      {Lisp-Entry "jazz.new-nillable-type" define #f 1283 9 1283 31 ("jazz.Nillable-Type" "jazz.allocate-nillable-type" "type")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Nillable-Type") 1287 21 1287 37 ("type" "%%get-nillable-type-type" "jazz.Boolean" "jazz.of-subtype?" "or" "subtype")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Nillable-Type") 1292 21 1292 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-nillable-type-type" "jazz.emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "jazz.emit-check" generic/specific ("jazz.Nillable-Type") 1297 21 1297 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.object-declaration?" define #f 1310 8 1310 32 ()}
      {Lisp-Entry "jazz.Any-Class" define-class ("class runtime") 1322 27 1322 41 ()}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Any-Class") 1325 21 1325 37 ("subtype")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Any-Class") 1329 21 1329 40 ("any" "'any")}
      {Lisp-Entry "jazz.emit-check" generic/specific ("jazz.Any-Class") 1333 21 1333 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Any" define-class ("class runtime") 1340 27 1340 35 ()}
      {Lisp-Entry "jazz.emit-type-cast" define #f 1357 13 1357 32 ("%%fixnum->flonum" "%%fixnum?" ",value" "jazz.Flonum" "%%eq?" "jazz.generate-symbol" "value" "let" "jazz.sourcified-form" "%%get-code-type" "%%subtype?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "jazz.emit-type-cast" define #f 1369 12 1369 31 ("jazz.emit-check" "begin" "%%fixnum->flonum" "%%fixnum?" ",value" "jazz.Flonum" "jazz.generate-symbol" "value" "let" "jazz.sourcified-form" "%%get-code-type" "%%subtype?" "jazz.Void" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "jazz.emit-parameter-cast" define #f 1390 13 1390 37 ("%%fixnum->flonum" "set!" ",parameter" "%%fixnum?" "jazz.Flonum" "jazz.sourcified-form" "parameter" "let" "jazz.object-declaration?" "%%object-class?" "jazz.Any" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "jazz.emit-parameter-cast" define #f 1400 12 1400 36 ("jazz.emit-check" "%%fixnum->flonum" "set!" ",parameter" "%%fixnum?" "jazz.Flonum" "jazz.sourcified-form" "parameter" "let" "jazz.object-declaration?" "%%object-class?" "jazz.Any" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "jazz.parse-specifier" define #f 1430 9 1430 29 ("%%cdr" "%%car" "jazz.source-code" "jazz.specifier?" "%%pair?" "and" "if" "proc" "lst")}
      {Lisp-Entry "jazz.walk-specifier" define #f 1436 9 1436 28 ("%%cons" "%%list" "atomic?" "jazz.new-function-type" "rest" "named" "optional" "positional" "lambda" "jazz.butlast" "jazz.Rest-Type" "%%class-is?" "jazz.last" "last" "%%null?" "proc" "types" "split-parameters" "result" "parameters" "new-function-type" "jazz.new-template-type" "jazz.new-values-type" "values" "'values" "jazz.new-category-type" "category" "'category" "jazz.new-key-type" "%%string->keyword" "key" "'key" "jazz.new-opt-type" "opt" "'opt" "%%eq?" "jazz.new-rest-type" "jazz.new-nillable-type" "case" "parse-atomic" "write-char" "get-output-string" "%%string->symbol" "%%eof-object?" "open-output-string" "output" "parse-name" "else" "cond" "next" "parse" "jazz.enqueue" "jazz.queue-list" "begin" "iter" "jazz.new-queue" "queue" "terminator" "separator" "parse-until" "jazz.specifiable?" "%%assertion" "jazz.lookup-reference" "jazz.lookup-primitive-type" "or" "type" "name" "lookup-type" "%%eqv?" "consume" "1" "%%fx+" "set!" "read-char" "c" "readc" "peek-char" "peekc" "jazz.walk-error" "jazz.error" "%%not" "if" "%%substring" "jazz.format" "error-message" "message" "ill-formed" "define" "0" "at" "open-input-string" "input" "%%symbol->string" "string" "let" "specifier" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.specifier->type" define #f 1578 9 1578 29 ("jazz.walk-specifier" "if" "specifier" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.type->specifier" define #f 1584 9 1584 29 ("jazz.name->specifier" "jazz.specifier?" "if" "jazz.emit-specifier" "symbol" "let" "type")}
      {Lisp-Entry "jazz.primitive-types" define #f 1596 8 1596 28 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.lookup-primitive-type" define #f 1641 9 1641 35 ("jazz.primitive-types" "%%table-ref" "name")}
      {Lisp-Entry "jazz.primitive-declarations" define #f 1645 8 1645 35 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.patch-type-until-unification" define #f 1689 9 1689 42 ("jazz.public-access" "jazz.lookup-declaration" "jazz.get-catalog-entry" "module-declaration" "jazz.dialect.language.functional" "'jazz.dialect.language.functional" "jazz.dialect.language.object" "'jazz.dialect.language.object" "Object" "'Object" "%%eq?" "module-name" "if" "jazz.primitive-declarations" "%%table-ref" "name" "let" "type")}
      {Lisp-Entry "jazz.Macro-Declaration" define-class ("class runtime") 1705 27 1705 49 ()}
      {Lisp-Entry "jazz.new-macro-declaration" define #f 1708 9 1708 35 ("jazz.setup-declaration" "jazz.Macro-Declaration" "jazz.allocate-macro-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Macro-Declaration") 1714 21 1714 50 ()}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Macro-Declaration") 1718 21 1718 50 ("%%cdr" "%%apply" "jazz.need-macro" "expander" "jazz.load-unit" "%%get-declaration-parent" "parent-declaration" "jazz.walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Macro-Declaration") 1729 21 1729 42 ("%%get-declaration-source" "jazz.emit-expression" "jazz.sourcified-form" "jazz.emit-signature" "jazz.define-macro" "jazz.sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-macro-declaration-body" "body" "%%get-macro-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Macro-Declaration") 1742 21 1742 42 ("%%get-macro-declaration-body" "jazz.fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Local-Macro-Declaration" define-class ("class runtime") 1756 27 1756 55 ()}
      {Lisp-Entry "jazz.new-local-macro-declaration" define #f 1759 9 1759 41 ("jazz.setup-declaration" "jazz.Local-Macro-Declaration" "jazz.allocate-macro-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.need-local-macro" define #f 1764 9 1764 30 ("jazz.error" "%%get-module-declaration-local-macros" "%%table-ref" "or" "name" "module-declaration")}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Local-Macro-Declaration") 1768 21 1768 50 ()}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Local-Macro-Declaration") 1771 21 1771 50 ("%%cdr" "%%apply" "jazz.need-local-macro" "expander" "%%get-declaration-parent" "parent" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Local-Macro-Declaration") 1778 21 1778 42 ("begin" "environment")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Local-Macro-Declaration") 1782 21 1782 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Syntax-Declaration" define-class ("class runtime") 1794 27 1794 50 ()}
      {Lisp-Entry "jazz.new-syntax-declaration" define #f 1797 9 1797 36 ("jazz.setup-declaration" "jazz.Syntax-Declaration" "jazz.allocate-syntax-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Syntax-Declaration") 1803 21 1803 50 ()}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Syntax-Declaration") 1807 21 1807 50 ("jazz.need-macro" "expander" "jazz.load-unit" "%%get-declaration-parent" "parent-declaration" "jazz.walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Syntax-Declaration") 1817 21 1817 42 ("%%get-declaration-source" "jazz.emit-expression" "jazz.sourcified-form" "jazz.emit-signature" "jazz.define-macro" "jazz.sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-syntax-declaration-body" "body" "%%get-syntax-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Syntax-Declaration") 1830 21 1830 42 ("%%get-syntax-declaration-body" "jazz.fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Define-Syntax-Declaration" define-class ("class runtime") 1844 27 1844 57 ()}
      {Lisp-Entry "jazz.new-define-syntax-declaration" define #f 1847 9 1847 43 ("jazz.setup-declaration" "jazz.Define-Syntax-Declaration" "jazz.allocate-define-syntax-declaration" "new-declaration" "let" "syntax-form" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Define-Syntax-Declaration") 1853 21 1853 42 ("%%get-declaration-source" "jazz.register-macro" "jazz.emit-expression" "jazz.sourcified-form" "',locator" "jazz.new-define-syntax-form" "tmp" ",current-unit-name" "',current-unit-name" "jazz.outline-module" "else" "cons" "x" "=>" "jazz" "'jazz" "cond" "core" "'core" "scheme" "'scheme" "jazz.get-dialect" "%%get-dialect-bindings" "jazz.new-walk-frame" "%%list" "env" "let*" ",locator" "define" "jazz.sourcify-if" "%%get-declaration-toplevel" "current-unit-name" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-syntax-declaration-body" "body" "%%get-syntax-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Define-Syntax-Declaration") 1891 21 1891 50 ("%%get-define-syntax-form-environment" "macro-environment" "%%get-syntax-form-expander" "expander" "jazz.need-macro" "define-syntax-form" "let*" "jazz.load-unit" "%%get-declaration-parent" "parent-declaration" "jazz.walk-warning" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.Define-Local-Syntax-Declaration" define-class ("class runtime") 1911 27 1911 63 ()}
      {Lisp-Entry "jazz.new-define-local-syntax-declaration" define #f 1913 9 1913 49 ("jazz.setup-declaration" "jazz.Define-Local-Syntax-Declaration" "jazz.allocate-define-local-syntax-declaration" "new-declaration" "let" "syntax-form" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Define-Local-Syntax-Declaration") 1918 21 1918 50 ()}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Define-Local-Syntax-Declaration") 1921 21 1921 50 ("%%get-define-local-syntax-form-environment" "macro-environment" "%%get-syntax-form-expander" "expander" "let" "%%get-declaration-parent" "jazz.need-local-macro" "define-local-syntax-form" "binding" "%%get-declaration-locator" "locator" "let*" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Define-Local-Syntax-Declaration") 1928 21 1928 42 ("begin" "environment")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Define-Local-Syntax-Declaration") 1931 21 1931 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Walk-Context" define-class ("class runtime") 1942 27 1942 44 ()}
      {Lisp-Entry "jazz.new-walk-context" define #f 1945 9 1945 30 ("jazz.Walk-Context" "jazz.allocate-walk-context" "pathname" "locator" "policy")}
      {Lisp-Entry "jazz.walk-context" define #f 1949 8 1949 25 ("make-parameter")}
      {Lisp-Entry "jazz.get-walk-context" define #f 1953 9 1953 30 ("jazz.walk-context")}
      {Lisp-Entry "jazz.need-walk-context" define #f 1957 9 1957 31 ("jazz.error" "jazz.walk-context" "or")}
      {Lisp-Entry "jazz.get-walk-policy" define #f 1962 9 1962 29 ("%%get-walk-context-policy" "%%not" "if" "jazz.get-walk-context" "context" "let")}
      {Lisp-Entry "jazz.get-walk-locator" define #f 1969 9 1969 30 ("%%get-walk-context-locator" "%%not" "if" "jazz.get-walk-context" "context" "let")}
      {Lisp-Entry "jazz.get-walk-pathname" define #f 1976 9 1976 31 ("%%get-walk-context-pathname" "%%not" "if" "jazz.get-walk-context" "context" "let")}
      {Lisp-Entry "jazz.Walk-Location" define-class ("class runtime") 1991 27 1991 45 ()}
      {Lisp-Entry "jazz.new-walk-location" define #f 1994 9 1994 31 ("jazz.Walk-Location" "jazz.allocate-walk-location" "path" "locat" "declaration-locator" "unit-locator")}
      {Lisp-Entry "jazz.walk-location" define #f 1998 9 1998 27 ("%%locat-container" "%%container->path" "if" "%%get-declaration-locator" "jazz.get-walk-locator" "jazz.new-walk-location" "locat" "declaration" "walker")}
      {Lisp-Entry "jazz.Walk-Problem" define-class ("class runtime") 2014 27 2014 44 ()}
      {Lisp-Entry "jazz.Walk-Problems" define-class ("class runtime") 2025 27 2025 45 ()}
      {Lisp-Entry "jazz.new-walk-problems" define #f 2028 9 2028 31 ("jazz.Walk-Problems" "jazz.allocate-walk-problems" "errors" "warnings" "message")}
      {Lisp-Entry "jazz.get-detail" generic/specific ("jazz.Walk-Problems") 2032 21 2032 36 ("jazz.partition-walk-problems-unit" "jazz.partition-walk-problems-declaration" "jazz.queue-list" "declaration-details" "1" "%%fx+" "%%substring" "%%fx=" "declaration-locator" "jazz.new-queue" "unit-details" "or" "%%symbol->string" "%%string-length" "-1" "%%not" "if" "prefix" "unit-locator" "jazz.bind" "partition" "map" "%%get-walk-problems-errors" "%%get-walk-problems-warnings" "%%append" "all" "let" "%%get-walk-problem-location" "jazz.present-exception" "jazz.new-exception-detail" "jazz.enqueue" "problem" "lambda" "for-each" "queue" "problems" "add-details" "define")}
      {Lisp-Entry "jazz.Walk-Warning" define-class ("class runtime") 2068 27 2068 44 ()}
      {Lisp-Entry "jazz.new-walk-warning" define #f 2071 9 2071 30 ("jazz.Walk-Warning" "jazz.allocate-walk-warning" "message" "location")}
      {Lisp-Entry "jazz.Walk-Error" define-class ("class runtime") 2083 27 2083 42 ()}
      {Lisp-Entry "jazz.new-walk-error" define #f 2086 9 2086 28 ("jazz.Walk-Error" "jazz.allocate-walk-error" "message" "location")}
      {Lisp-Entry "jazz.Unresolved-Error" define-class ("class runtime") 2098 27 2098 48 ()}
      {Lisp-Entry "jazz.new-unresolved-error" define #f 2101 9 2101 34 ("jazz.Unresolved-Error" "jazz.allocate-unresolved-error" "symbol" "location")}
      {Lisp-Entry "jazz.present-exception" generic/specific ("jazz.Unresolved-Error") 2105 21 2105 43 ("error" "%%get-unresolved-error-symbol" "jazz.format")}
      {Lisp-Entry "jazz.Walk-Frame" define-class ("class runtime") 2118 27 2118 42 ()}
      {Lisp-Entry "jazz.new-walk-frame" define #f 2121 9 2121 28 ("jazz.Walk-Frame" "jazz.allocate-walk-frame" "%%table-set!" "%%get-lexical-binding-name" "name" "binding" "lambda" "for-each" "eq?" "test:" "%%make-table" "table" "let" "bindings")}
      {Lisp-Entry "jazz.walk-binding-lookup" generic/specific ("jazz.Walk-Frame") 2130 21 2130 45 ("binding" "%%get-walk-frame-bindings" "%%table-ref" "source-declaration" "symbol")}
      {Lisp-Entry "jazz.Signature" define-class ("class runtime") 2142 27 2142 41 ()}
      {Lisp-Entry "jazz.new-signature" define #f 2145 9 2145 27 ("jazz.Signature" "jazz.allocate-signature" "%%length" "mandatory" "let" "rest" "named" "optional" "positional")}
      {Lisp-Entry "jazz.only-positional?" define #f 2150 9 2150 30 ("%%get-signature-rest" "%%not" "%%get-signature-named" "%%get-signature-optional" "%%null?" "and" "signature")}
      {Lisp-Entry "jazz.Symbol-Binding" define-class ("class runtime") 2164 27 2164 46 ()}
      {Lisp-Entry "jazz.emit-binding-symbol" generic/specific ("jazz.Symbol-Binding") 2167 21 2167 45 ("%%get-lexical-binding-name" "unwrap-syntactic-closure" "binding" "%%get-symbol-binding-gensym" "or" "environment" "declaration")}
      {Lisp-Entry "jazz.Variable" define-class ("class runtime") 2180 27 2180 40 ()}
      {Lisp-Entry "jazz.new-variable" define #f 2183 9 2183 26 ("0" "jazz.Variable" "jazz.allocate-variable" "jazz.error" "jazz.variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "jazz.variable-name-valid?" define #f 2188 9 2188 34 ("%%get-syntactic-closure-form" "syntactic-closure?" "if" "jazz.specifier?" "%%not" "%%symbol?" "and" "variable-name-valid-symbol?" "define" "name")}
      {Lisp-Entry "jazz.walk-binding-referenced" generic/specific ("jazz.Variable") 2199 21 2199 49 ("1" "%%get-variable-reference-count" "%%fx+" "binding" "%%set-variable-reference-count")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Variable") 2203 21 2203 48 ("jazz.find-annotated-type" "binding" "jazz.emit-binding-symbol" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-assignable?" generic/specific ("jazz.Variable") 2210 21 2210 50 ()}
      {Lisp-Entry "jazz.emit-binding-assignment" generic/specific ("jazz.Variable") 2214 21 2214 49 ("jazz.Any" "jazz.sourcified-form" "jazz.emit-binding-symbol" "set!" "jazz.new-code" "%%get-code-type" "jazz.extend-annotated-type" "jazz.Annotated-Variable" "%%class-is?" "%%when" "binding" "jazz.find-annotated" "annotated-type" "annotated-variable" "annotated-frame" "receive" "jazz.emit-expression" "value-code" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.NextMethod-Variable" define-class ("class runtime") 2234 27 2234 51 ()}
      {Lisp-Entry "jazz.new-nextmethod-variable" define #f 2237 9 2237 37 ("0" "jazz.NextMethod-Variable" "jazz.allocate-nextmethod-variable" "jazz.error" "jazz.variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.NextMethod-Variable") 2242 21 2242 48 ("jazz.Any" "jazz.sourcified-form" ",name" "apply" "rest" "lambda" "if" "jazz.new-code" "jazz.*self*" "self" "binding" "%%get-lexical-binding-name" "name" "let" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.NextMethod-Variable") 2253 21 2253 52 ("declaration" "jazz.validate-arguments" "if" "jazz.get-nextmethod-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-binding-call" generic/specific ("jazz.NextMethod-Variable") 2259 21 2259 43 ("jazz.call-return-type" "jazz.codes-forms" "jazz.sourcified-form" ",name" "jazz.new-code" "if" "jazz.*self*" "self" "%%get-lexical-binding-type" "type" "binding" "%%get-lexical-binding-name" "name" "let" "environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "jazz.Parameter" define-class ("class runtime") 2285 27 2285 41 ()}
      {Lisp-Entry "jazz.new-parameter" define #f 2288 9 2288 27 ("0" "jazz.Parameter" "jazz.allocate-parameter" "jazz.error" "jazz.variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "jazz.emit-parameter" generic/specific ("jazz.Parameter~virtual-runtime") 2293 30 2293 49 ("environment" "declaration")}
      {Lisp-Entry "jazz.emit-parameter" generic/specific ("jazz.Parameter") 2296 21 2296 40 ("parameter" "jazz.emit-binding-symbol" "environment" "declaration")}
      {Lisp-Entry "jazz.Dynamic-Parameter" define-class ("class runtime") 2308 27 2308 49 ()}
      {Lisp-Entry "jazz.new-dynamic-parameter" define #f 2311 9 2311 35 ("0" "jazz.Dynamic-Parameter" "jazz.allocate-dynamic-parameter" "class" "type" "name")}
      {Lisp-Entry "jazz.emit-parameter" generic/specific ("jazz.Dynamic-Parameter") 2315 21 2315 40 ("jazz.emit-binding-symbol" "jazz.emit-expression" "jazz.sourcified-form" "%%list" "parameter" "%%get-dynamic-parameter-class" "class" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.Optional-Parameter" define-class ("class runtime") 2328 27 2328 50 ()}
      {Lisp-Entry "jazz.new-optional-parameter" define #f 2331 9 2331 36 ("0" "jazz.Optional-Parameter" "jazz.allocate-optional-parameter" "default" "type" "name")}
      {Lisp-Entry "jazz.emit-parameter" generic/specific ("jazz.Optional-Parameter") 2335 21 2335 40 ("jazz.emit-expression" "jazz.sourcified-form" "jazz.emit-binding-symbol" "%%list" "parameter" "%%get-optional-parameter-default" "default" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.Named-Parameter" define-class ("class runtime") 2348 27 2348 47 ()}
      {Lisp-Entry "jazz.new-named-parameter" define #f 2351 9 2351 33 ("0" "jazz.Named-Parameter" "jazz.allocate-named-parameter" "default" "type" "name")}
      {Lisp-Entry "jazz.emit-parameter" generic/specific ("jazz.Named-Parameter") 2355 21 2355 40 ("jazz.emit-expression" "jazz.sourcified-form" "%%get-lexical-binding-name" "%%list" "parameter" "%%get-named-parameter-default" "default" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.emit-binding-symbol" generic/specific ("jazz.Named-Parameter") 2360 21 2360 45 ("parameter" "%%get-lexical-binding-name" "environment" "declaration")}
      {Lisp-Entry "jazz.Rest-Parameter" define-class ("class runtime") 2372 27 2372 46 ()}
      {Lisp-Entry "jazz.new-rest-parameter" define #f 2375 9 2375 32 ("0" "jazz.Rest-Parameter" "jazz.allocate-rest-parameter" "type" "name")}
      {Lisp-Entry "jazz.emit-parameter" generic/specific ("jazz.Rest-Parameter") 2379 21 2379 40 ("parameter" "jazz.emit-binding-symbol" "environment" "declaration")}
      {Lisp-Entry "jazz.Self-Binding" define-class ("class runtime") 2394 27 2394 44 ()}
      {Lisp-Entry "jazz.new-self-binding" define #f 2397 9 2397 30 ("self" "'self" "jazz.Self-Binding" "jazz.allocate-self-binding" "type")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Self-Binding") 2401 21 2401 48 ("%%get-declaration-parent" "self" "'self" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.Dynamic-Self-Binding" define-class ("class runtime") 2416 27 2416 52 ()}
      {Lisp-Entry "jazz.new-dynamic-self-binding" define #f 2419 9 2419 38 ("self" "'self" "jazz.Dynamic-Self-Binding" "jazz.allocate-dynamic-self-binding" "code" "type")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Dynamic-Self-Binding") 2423 21 2423 48 ("%%get-declaration-parent" "declaration" "%%get-dynamic-self-binding-code" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.*self*" define #f 2438 8 2438 19 ("make-parameter")}
      {Lisp-Entry "jazz.Local-Variable-Binding" define-class ("class runtime") 2447 27 2447 54 ()}
      {Lisp-Entry "jazz.new-local-variable-binding" define #f 2450 9 2450 40 ("jazz.Local-Variable-Binding" "jazz.allocate-local-variable-binding" "variable" "type")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Local-Variable-Binding") 2454 21 2454 48 ("jazz.Any" "declaration" "%%get-local-variable-binding-variable" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.Macro-Symbol" define-class ("class runtime") 2469 27 2469 44 ()}
      {Lisp-Entry "jazz.new-macro-symbol" define #f 2472 9 2472 30 ("jazz.Macro-Symbol" "jazz.allocate-macro-symbol" "setter" "getter" "name")}
      {Lisp-Entry "jazz.Form-Binding" define-class ("class runtime") 2501 27 2501 44 ()}
      {Lisp-Entry "jazz.special-forms" define #f 2512 8 2512 26 ()}
      {Lisp-Entry "jazz.add-special-form" define #f 2516 9 2516 30 ("%%cons" "jazz.special-forms" "set!" "special-form" "symbol")}
      {Lisp-Entry "jazz.find-special-form" define #f 2520 9 2520 31 ("symbol")}
      {Lisp-Entry "jazz.Special-Form" define-class ("class runtime") 2527 27 2527 44 ()}
      {Lisp-Entry "jazz.new-special-form" define #f 2530 9 2530 30 ("jazz.Special-Form" "jazz.allocate-special-form" "walk" "name")}
      {Lisp-Entry "jazz.walk-binding-walkable?" generic/specific ("jazz.Special-Form") 2534 21 2534 48 ()}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Special-Form") 2538 21 2538 48 ("binding" "%%get-lexical-binding-name" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-walk-form" generic/specific ("jazz.Special-Form") 2542 21 2542 48 ("jazz.find-special-form" "%%symbol?" "if" "walk" "binding" "%%get-special-form-walk" "walk-proc/symbol" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.Macro-Form" define-class ("class runtime") 2559 27 2559 42 ()}
      {Lisp-Entry "jazz.new-macro-form" define #f 2562 9 2562 28 ("jazz.Macro-Form" "jazz.allocate-macro-form" "expander" "name")}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Macro-Form") 2566 21 2566 50 ()}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Macro-Form") 2570 21 2570 50 ("%%cdr" "apply" "binding" "%%get-macro-form-expander" "expander" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.Syntax-Form" define-class ("class runtime") 2584 27 2584 43 ()}
      {Lisp-Entry "jazz.new-syntax-form" define #f 2587 9 2587 29 ("jazz.Syntax-Form" "jazz.allocate-syntax-form" "expander" "name")}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Syntax-Form") 2591 21 2591 50 ()}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Syntax-Form") 2595 21 2595 50 ("binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.Define-Syntax-Form" define-class ("class runtime") 2608 27 2608 50 ()}
      {Lisp-Entry "jazz.new-define-syntax-form" define #f 2611 9 2611 36 ("jazz.Define-Syntax-Form" "jazz.allocate-define-syntax-form" "environment" "expander" "name")}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Define-Syntax-Form") 2615 21 2615 50 ("%%get-define-syntax-form-environment" "macro-environment" "binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.Define-Local-Syntax-Form" define-class ("class runtime") 2629 27 2629 56 ()}
      {Lisp-Entry "jazz.new-define-local-syntax-form" define #f 2632 9 2632 42 ("jazz.Define-Local-Syntax-Form" "jazz.allocate-define-local-syntax-form" "environment" "expander" "name")}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Define-Local-Syntax-Form") 2636 21 2636 50 ("%%get-define-local-syntax-form-environment" "macro-environment" "binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.Syntactic-Closure" define-class ("class runtime") 2650 27 2650 49 ()}
      {Lisp-Entry "syntactic-closure?" define #f 2653 9 2653 27 ("jazz.Syntactic-Closure" "%%class-is?" "x")}
      {Lisp-Entry "make-syntactic-closure" define #f 2656 9 2656 31 ("jazz.Syntactic-Closure" "jazz.allocate-syntactic-closure" "%%source-code" "%%source?" "and" "%%pair?" "%%symbol?" "or" "if" "form" "vars" "env")}
      {Lisp-Entry "syntactic-closure-form" define #f 2664 9 2664 31 ("%%get-syntactic-closure-form" "sc")}
      {Lisp-Entry "unwrap-syntactic-closure" define #f 2667 9 2667 33 ("else" "%%source-code" "%%source?" "%%get-syntactic-closure-form" "unwrap-syntactic-closure" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "strip-syntactic-closures" define #f 2675 9 2675 33 ("else" "%%vector->list" "%%list->vector" "%%vector?" "%%cdr" "%%car" "cons" "%%pair?" "%%source-code" "%%source?" "%%get-syntactic-closure-form" "strip-syntactic-closures" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "strip-source-info" define #f 2688 9 2688 26 ("else" "%%vector->list" "%%list->vector" "%%vector?" "%%cdr" "%%car" "cons" "%%pair?" "%%source-code" "strip-source-info" "%%source?" "cond" "x")}
      {Lisp-Entry "identifier?" define #f 2698 9 2698 20 ("symbol?" "else" "%%source-code" "%%source?" "syntactic-closure-form" "identifier?" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "identifier=?" define #f 2705 9 2705 21 ("not" "and" "y^" "unwrap-syntactic-closure" "x^" "let" "eq?" "or" "%%get-lexical-binding-name" "jazz.Lexical-Binding" "%%class-is?" "binding-name" "jazz.walk-binding-lookup" "binding" "lambda" "jazz.find-in" "jazz.composite-name?" "if" "environment" "symbol" "lookup-identifier" "define" "y" "y-env" "x" "x-env")}
      {Lisp-Entry "sc-macro-transformer" define #f 2725 8 2725 28 ("make-syntactic-closure" "mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "rsc-macro-transformer" define #f 2730 8 2730 29 ("mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "er-macro-transformer" define #f 2735 8 2735 28 ("identifier=?" "y" "x" "compare" "cons" "set!" "make-syntactic-closure" "name" "else" "cdr" "=>" "assq" "cond" "identifier" "renames" "rename" "let" "mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "jazz.Annotated-Variable" define-class ("class runtime") 2760 27 2760 50 ()}
      {Lisp-Entry "jazz.new-annotated-variable" define #f 2763 9 2763 36 ("jazz.Annotated-Variable" "jazz.allocate-annotated-variable" "type" "declared-type" "variable")}
      {Lisp-Entry "jazz.Restricted-Binding" define-class ("class runtime") 2775 27 2775 50 ()}
      {Lisp-Entry "jazz.new-restricted-binding" define #f 2778 9 2778 36 ("jazz.Restricted-Binding" "jazz.allocate-restricted-binding" "type" "binding")}
      {Lisp-Entry "jazz.Annotated-Frame" define-class ("class runtime") 2790 27 2790 47 ()}
      {Lisp-Entry "jazz.new-annotated-frame" define #f 2793 9 2793 33 ("jazz.Annotated-Frame" "jazz.allocate-annotated-frame" "reset" "variables")}
      {Lisp-Entry "jazz.inspect-annotated-variable" define #f 2801 9 2801 40 ("%%get-annotated-variable-type" "%%get-annotated-variable-variable" ":variable" "%%get-restricted-binding-type" "%%get-restricted-binding-binding" "%%get-lexical-binding-name" ":restricted" "jazz.Restricted-Binding" "%%class-is?" "if" "jazz.object->serial-symbol" "serial" "let" "variable")}
      {Lisp-Entry "jazz.inspect-annotated-frame" define #f 2812 9 2812 37 ("%%get-annotated-frame-variables" "jazz.inspect-annotated-variable" "map" ":frame" "frame")}
      {Lisp-Entry "jazz.inspect-annotated-environment" define #f 2817 9 2817 43 ("jazz.inspect-annotated-frame" "map" ":environment" "environment")}
      {Lisp-Entry "jazz.Code" define-class ("class runtime") 2827 27 2827 36 ()}
      {Lisp-Entry "jazz.new-code" define #f 2830 9 2830 22 ("jazz.Code" "jazz.allocate-code" "source" "type" "form")}
      {Lisp-Entry "jazz.codes-forms" define #f 2837 9 2837 25 ("jazz.sourcified-form" "code" "lambda" "map" "codes")}
      {Lisp-Entry "jazz.codes-types" define #f 2843 9 2843 25 ("%%get-code-type" "code" "lambda" "map" "codes")}
      {Lisp-Entry "jazz.sourcify-code" define #f 2850 9 2850 27 ("%%get-code-type" "%%get-code-form" "jazz.new-code" "%%source?" "%%not" "or" "if" "src" "code")}
      {Lisp-Entry "jazz.sourcified-form" define #f 2859 9 2859 29 ("jazz.sourcify-if" "%%get-code-source" "src" "%%get-code-form" "form" "let" "code")}
      {Lisp-Entry "jazz.sourcified-form2" define #f 2866 9 2866 30 ("jazz.sourcify-if" "%%get-code-form" "form" "let" "src" "code")}
      {Lisp-Entry "jazz.annotate-signature" define #f 2876 9 2876 32 ("jazz.queue-list" "%%when" "for-each" "jazz.new-annotated-variable" "jazz.enqueue" "jazz.Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "parameter" "annotate" "define" "jazz.new-queue" "queue" "%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "let" "signature")}
      {Lisp-Entry "jazz.annotate-inlined-signature" define #f 2895 9 2895 40 ("jazz.queue-list" "jazz.new-annotated-variable" "jazz.enqueue" "%%get-code-type" "or" "type" "%%get-lexical-binding-type" "declared-type" "argument" "parameter" "lambda" "for-each" "jazz.new-queue" "queue" "%%get-signature-positional" "positional" "let" "arguments" "signature")}
      {Lisp-Entry "jazz.annotate-bindings" define #f 2907 9 2907 31 ("jazz.new-annotated-variable" "jazz.Void" "or" "type" "%%get-lexical-binding-type" "declared-type" "%%cdr" "value" "%%car" "variable" "let" "binding" "lambda" "map" "bindings")}
      {Lisp-Entry "jazz.annotate-receive" define #f 2917 9 2917 30 ("jazz.new-annotated-variable" "jazz.Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "let" "parameter" "lambda" "map" "parameters")}
      {Lisp-Entry "jazz.annotate-internal-defines" define #f 2925 9 2925 39 ("jazz.new-annotated-variable" "jazz.Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "%%get-internal-define-variable" "variable" "let" "internal-define" "lambda" "map" "internal-defines")}
      {Lisp-Entry "jazz.with-annotated-frame" define #f 2934 9 2934 34 ("jazz.new-annotated-frame" "set!" "k" "lambda" "continuation-capture" "reset" "let" "proc" "variables")}
      {Lisp-Entry "jazz.find-annotated" define #f 2942 9 2942 28 ("%%get-annotated-variable-type" "%%get-annotated-variable-variable" "%%cdr" "set!" "%%not" "begin" "%%get-restricted-binding-type" "values" "%%eq?" "jazz.Declaration" "and" "%%get-restricted-binding-binding" "binding" "jazz.Restricted-Binding" "annotated-variable" "else" "list" "jazz.Variable" "%%get-annotated-frame-variables" "jazz.Annotated-Frame" "%%class-is?" "cond" "variables" "iter-variables" "or" "%%car" "annotated-frame" "%%null?" "if" "frames" "iter-frames" "type" "let" "environment" "variable")}
      {Lisp-Entry "jazz.find-annotated-type" define #f 2974 9 2974 33 ("%%get-lexical-binding-type" "info" "let" "jazz.find-annotated" "type" "variable" "frame" "receive" "jazz.Variable" "%%class-is?" "if" "environment" "binding")}
      {Lisp-Entry "jazz.extend-annotated-type" define #f 2987 9 2987 35 ("continuation-return" "%%get-annotated-frame-reset" "reset" "jazz.Any" "extended-type" "%%subtype?" "%%not" "%%when" "%%set-annotated-variable-type" "jazz.Void" "%%eq?" "if" "%%get-annotated-variable-type" "actual-type" "%%get-annotated-variable-declared-type" "declared-type" "let" "new-type" "variable" "frame")}
      {Lisp-Entry "jazz.extend-type" define #f 3010 9 3010 25 ("else" "%%subtype?" "jazz.Void" "%%eq?" "jazz.Any" "%%not" "or" "cond" "type2" "type1")}
      {Lisp-Entry "jazz.extend-types" define #f 3024 9 3024 26 ("%%cdr" "jazz.extend-types" "%%car" "jazz.extend-type" "jazz.Void" "%%null?" "if" "types")}
      {Lisp-Entry "jazz.type-union" define #f 3030 9 3030 24 ("jazz.new-union-type" "types")}
      {Lisp-Entry "jazz.type-difference" define #f 3034 9 3034 29 ("type2" "type1")}
      {Lisp-Entry "jazz.Walker" define-class ("class runtime") 3043 27 3043 38 ()}
      {Lisp-Entry "jazz.walk-warning" define #f 3051 9 3051 26 ("jazz.new-walk-warning" "jazz.walker-warning" "jazz.format" "apply" "message" "jazz.source-locat" "jazz.walk-location" "location" "let" "rest" "fmt-string" "src" "declaration" "walker")}
      {Lisp-Entry "jazz.walk-error" define #f 3057 9 3057 24 ("jazz.new-walk-error" "jazz.walker-error" "jazz.format" "apply" "message" "jazz.source-locat" "jazz.walk-location" "location" "let" "rest" "fmt-string" "src" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-unresolved" define #f 3063 9 3063 29 ("jazz.source-code" "jazz.new-unresolved-error" "jazz.walker-error" "jazz.source-locat" "jazz.walk-location" "location" "let" "symbol-src" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walker-warning" define #f 3068 9 3068 28 ("%%list" "%%get-walker-warnings" "%%append" "%%set-walker-warnings" "jazz.warnings?" "if" "warning" "walker")}
      {Lisp-Entry "jazz.walker-error" define #f 3073 9 3073 26 ("jazz.validate-walk-problems" "jazz.unspecified" "continuation-return" "jazz.delay-reporting?" "and" "if" "%%list" "%%get-walker-errors" "%%append" "%%set-walker-errors" "error" "resume" "walker")}
      {Lisp-Entry "jazz.validate-walk-problems" define #f 3080 9 3080 36 ("jazz.new-walk-problems" "raise" "get-output-string" "message" "jazz.partition-walk-problems-unit" "jazz.partition-walk-problems-declaration" "jazz.present-exception" "problem" "1" "%%fx+" "%%substring" "%%fx=" "toplevel?" "declaration-locator" "%%symbol->string" "%%string-length" "-1" "%%not" "if" "prefix" "problems" "unit-locator" "jazz.bind" "partition" "lambda" "for-each" "jazz.format" "%%append" "all" "open-output-string" "output" "%%not-null?" "or" "%%when" "%%get-walker-errors" "errors" "%%get-walker-warnings" "warnings" "let" "walker")}
      {Lisp-Entry "jazz.partition-walk-problems-unit" define #f 3108 9 3108 42 ("assv" "%%get-walk-problem-location" "%%get-walk-location-unit-locator" "problem" "lambda" "jazz.partition" "problems")}
      {Lisp-Entry "jazz.partition-walk-problems-declaration" define #f 3115 9 3115 49 ("assoc" "%%get-walk-problem-location" "%%get-walk-location-declaration-locator" "%%symbol->string" "problem" "lambda" "jazz.partition" "problems")}
      {Lisp-Entry "jazz.parse-modifiers" define #f 3127 9 3127 29 ("%%cdar" "%%cons" "%%reverse" "values" "%%apply" "res" "lp" "modifiers" "let" "jazz.walk-error" "lambda" "=>" "%%eq?" "to" "from" "names" "get-modifier" "%%car" "jazz.source-code" "%%pair?" "and" "if" "ls" "skip-modifiers" "%%cdr" "else" "%%caar" "%%memq" "%%null?" "cond" "x" "is-modifier?" "define" "rest" "infos" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-unit-declaration" define #f 3158 9 3158 36 ("jazz.new-unit-declaration" "jazz.error" "%%neq?" "jazz.requested-unit-name" "access" "name" "%%desourcify" "jazz.filter-features" "jazz.listify" "map" "append" "set!" "require" "'require" "%%eq?" "%%pair?" "and" "expr" "lambda" "for-each" "requires" "body" "collect-requires" "%%cdr" "'public" "%%cddr" "%%cadr" "public" "protected" "%%memq" "if" "%%car" "jazz.source-code" "first" "let" "proc" "rest" "parse" "define" "partial-form")}
      {Lisp-Entry "jazz.parse-module" define #f 3187 9 3187 26 ("%%symbol?" "%%assert" "%%cddr" "body" "%%cadr" "dialect-name" "name" "access" "receive" "'public" "%%cdr" "values" "public" "protected" "%%memq" "if" "%%car" "jazz.source-code" "first" "let" "rest" "parse-modifiers" "define" "partial-form")}
      {Lisp-Entry "jazz.parse-module-invoice" define #f 3205 9 3205 34 ("%%reverse" "values" "'autoload" "'only" "'phase" "%%cdar" "begin" "'load" "%%caar" "%%eq?" "if" "%%cons" "set!" "%%not" "and" "%%while" "autoload" "only" "phase" "load" "version" "%%cdr" "scan" "%%car" "name" "let" "jazz.error" "%%pair?" "%%assertion" "specification")}
      {Lisp-Entry "jazz.parse-module-declaration" define #f 3245 9 3245 38 ("jazz.walk-module-declaration" "jazz.dialect-walker" "walker" "jazz.require-dialect" "dialect" "jazz.load-dialect-invoice" "dialect-invoice" "let*" "jazz.new-walk-context" "jazz.walk-context" "parameterize" "jazz.error" "%%neq?" "jazz.requested-unit-name" "and" "if" "jazz.parse-module" "body" "dialect-name" "access" "name" "receive" "partial-form")}
      {Lisp-Entry "jazz.walk-module-declaration" define #f 3256 9 3256 37 ("jazz.validate-walk-problems" "jazz.walker-environment" "%%cons" "jazz.walk-declarations" "%%set-module-declaration-walker" "jazz.add-module-import" "%%when" "jazz.new-module-declaration" "or" "declaration" "let" "body" "dialect-invoice" "dialect-name" "access" "name" "actual" "walker")}
      {Lisp-Entry "jazz.walk-module-export" define #f 3267 9 3267 32 ("jazz.new-autoload-reference" "jazz.new-export-reference" "symbol" "lambda" "map" "%%not" "if" "jazz.new-export-invoice" "jazz.new-module-reference" "module-reference" "let" "jazz.parse-module-invoice" "module-autoload" "module-only" "module-version" "module-phase" "module-load" "module-name" "receive" "export" "walker")}
      {Lisp-Entry "jazz.expand-module-source" define #f 3286 9 3286 34 ("jazz.walk-module" "jazz.emit-declaration" "partial-form")}
      {Lisp-Entry "jazz.rename-identifier-conflicts" define #f 3290 9 3290 41 ("list" "or" "%%cdr" "symbol->string" "jazz.generate-symbol" "%%set-symbol-binding-gensym" "%%get-symbol-binding-gensym" "jazz.Variable" "not" "and" "eq?" "same?" "binding" "found?" "%%car" "ls" "lp2" "pair?" "e" "lp1" "let" "%%get-lexical-binding-name" "unwrap-syntactic-closure" "sym" "%%get-reference-binding" "var" "let*" "jazz.Binding-Reference" "%%is?" "cond" "child-seed" "env" "seed" "x" "lambda" "jazz.tree-fold-list" "environment" "expressions")}
      {Lisp-Entry "jazz.walk-module" define #f 3328 9 3328 25 ("%%set-namespace-declaration-body" "jazz.rename-identifier-conflicts" "jazz.validate-walk-problems" "jazz.walk-namespace" "jazz.walker-environment" "%%cons" "environment" "jazz.set-catalog-entry" "jazz.walk-module-declaration" "let" "lambda" "jazz.call-with-catalog-entry-lock" "declaration" "jazz.get-catalog-entry" "actual" "resume" "jazz.dialect-walker" "walker" "jazz.require-dialect" "dialect" "jazz.load-dialect-invoice" "dialect-invoice" "let*" "jazz.new-walk-context" "jazz.walk-context" "parameterize" "jazz.error" "%%neq?" "jazz.requested-unit-name" "and" "if" "jazz.parse-module" "body" "dialect-name" "access" "name" "receive" "partial-form")}
      {Lisp-Entry "jazz.cond-expand" define #f 3351 9 3351 25 ("begin" "else" "'else" "jazz.feature-satisfied?" "feature-requirement" "%%desourcify" "%%symbol?" "%%not" "or" "clause" "jazz.error" "%%null?" "%%cdr" "scan" "iter" "let" "cond-expand" "'cond-expand" "%%car" "%%eq?" "jazz.source-code" "%%pair?" "and" "if" "cont" "form-src")}
      {Lisp-Entry "jazz.walk-namespace" define #f 3371 9 3371 28 ("jazz.queue-list" "jazz.walk" "jazz.enqueue" "%%when" "expr?" "expr-src" "jazz.cond-expand" "continuation-capture" "form-src" "lambda" "for-each" "jazz.new-queue" "queue" "let" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.load-dialect-invoice" define #f 3384 9 3384 34 ("syntax" "'syntax" "jazz.outline-module" "jazz.new-import-invoice" "core" "'core" "%%eq?" "jazz.error" "%%symbol?" "%%not" "if" "dialect-name")}
      {Lisp-Entry "jazz.emit-module-inclusions" define #f 3397 9 3397 36 ("jazz.expand-referenced-declaration" "map" "%%get-module-declaration-inclusions" "jazz.enqueue" "jazz.queue-list" "%%not" "%%when" "jazz.get-declaration-inclusions" "for-each" "declaration" "lambda" "collect-declarations" "letrec" "jazz.new-queue" "queue" "let" "%%cdr" "%%car" "%%get-lexical-binding-name" "%%eq?" "%%null?" "if" "lst" "name" "find-name" "define" "module-declaration")}
      {Lisp-Entry "jazz.emit-module-literals" define #f 3421 9 3421 34 ("%%get-module-declaration-walker-literals" "jazz.emit-expression" "jazz.sourcified-form" ",name" "define" "%%cdr" "value" "%%car" "name" "let" "info" "lambda" "map" "module-declaration")}
      {Lisp-Entry "jazz.emit-module-variables" define #f 3429 9 3429 35 ("%%get-module-declaration-walker-variables" "jazz.queue-list" ",value" ",symbol" "jazz.define-variable" "%%cdr" "value" "%%car" "symbol" "let" "variable" "lambda" "map" "module-declaration")}
      {Lisp-Entry "jazz.emit-module-autoloads" define #f 3437 9 3437 35 ("%%cadr" "%%symbol->string" "%%string<?" "y" "x" "jazz.queue-list" "jazz.sort" "%%get-module-declaration-walker-autoloads" "jazz.emit-binding-reference" "jazz.sourcified-form" "set!" "%%get-declaration-toplevel" "%%get-declaration-locator" "jazz.load-unit" "begin" "if" "loaded?" ",locator" "define" "jazz.enqueue" "%%table-set!" "%%table-ref" "%%not" "%%when" "jazz.autoload-locator" "locator" "jazz.resolve-binding" "referenced-declaration" "autoload-declaration" "lambda" "for-each" "eq?" "test:" "%%make-table" "locators" "jazz.new-queue" "queue" "let" "environment" "module-declaration")}
      {Lisp-Entry "jazz.emit-module-registration" define #f 3458 9 3458 38 ("%%car" "%%cons" "if" "jazz.runtime-export" "export" "jazz.Autoload-Declaration" "%%is?" "%%get-declaration-toplevel" "%%eq?" "or" "decl" "name" "jazz.public-access" "%%get-access-lookup" "jazz.iterate-table-safe" "%%get-module-declaration-walker" "walker" "%%symbol->string" "%%string<?" "y" "x" "jazz.queue-list" "jazz.sort" "%%get-module-declaration-exports" "%%get-module-invoice-name" "jazz.enqueue" "%%not" "and" "%%get-export-invoice-autoload" "autoload" "%%get-module-invoice-only" "only" "syntax" "'syntax" "%%get-module-invoice-phase" "%%neq?" "%%when" "module-invoice" "lambda" "for-each" "jazz.new-queue" "queue" "let" "%%get-declaration-access" "%%get-lexical-binding-name" "jazz.register-module" "environment" "declaration")}
      {Lisp-Entry "jazz.runtime-export" generic/specific ("jazz.Walker~virtual-runtime") 3482 30 3482 49 ("declaration")}
      {Lisp-Entry "jazz.runtime-export" generic/specific ("jazz.Walker") 3485 21 3485 40 ("else" "%%get-declaration-toplevel" "%%cons" "jazz.resolve-binding" "referenced-declaration" "let" "jazz.Autoload-Declaration" "%%get-declaration-locator" "jazz.Export-Declaration" "%%is?" "cond" "declaration")}
      {Lisp-Entry "jazz.walker-bindings" generic/specific ("jazz.Walker~virtual-runtime") 3501 30 3501 50 ()}
      {Lisp-Entry "jazz.walker-bindings" generic/specific ("jazz.Walker") 3504 21 3504 41 ("core" "'core" "jazz.get-dialect" "%%get-dialect-bindings")}
      {Lisp-Entry "jazz.walker-environment" generic/specific ("jazz.Walker~virtual-runtime") 3508 30 3508 53 ()}
      {Lisp-Entry "jazz.walker-environment" generic/specific ("jazz.Walker") 3511 21 3511 44 ("walker" "jazz.walker-bindings" "jazz.new-walk-frame" "%%list")}
      {Lisp-Entry "jazz.walk-declaration" generic/specific ("jazz.Walker~virtual-runtime") 3526 30 3526 51 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-declaration" generic/specific ("jazz.Walker") 3529 21 3529 42 ("else" "jazz.walk-define-local-syntax-declaration" "define-local-syntax" "jazz.walk-define-syntax-declaration" "define-syntax" "jazz.walk-syntax-declaration" "syntax" "jazz.walk-local-macro-declaration" "local-macro" "jazz.walk-macro-declaration" "macro" "jazz.walk-native-syntax-declaration" "native-syntax" "jazz.walk-native-declaration" "native" "jazz.walk-import-declaration" "import" "jazz.walk-export-declaration" "export" "walker" "jazz.walk-require-declaration" "require" "case" "%%car" "first" "let" "jazz.source-code" "%%pair?" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-declarations" define #f 3547 9 3547 31 ("jazz.walk-declaration" "jazz.source-code" "%%cdr" "jazz.begin-form?" "if" "jazz.expand-macros" "expansion" "let" "%%when" "expr?" "expr" "jazz.cond-expand" "continuation-capture" "form-src" "lambda" "for-each" "walk" "define" "forms" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.add-declaration-child" define #f 3564 9 3564 35 ("jazz.public-access" "private" "'private" "%%get-declaration-access" "%%neq?" "jazz.private-access" "%%get-access-lookup" "%%table-set!" "%%get-namespace-declaration-children" "jazz.enqueue" "jazz.find-child-declaration" "%%not" "%%when" "%%get-lexical-binding-name" "name" "let" "child" "namespace-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.require-declaration" define #f 3590 9 3590 33 ("jazz.error" "%%assertion" "jazz.find-declaration" "declaration" "let" "name" "namespace-declaration")}
      {Lisp-Entry "jazz.find-declaration" define #f 3596 9 3596 30 ("jazz.private-access" "%%get-access-lookup" "%%table-ref" "name" "namespace-declaration")}
      {Lisp-Entry "jazz.find-child-declaration" define #f 3600 9 3600 36 ("%%get-namespace-declaration-children" "jazz.queue-list" "%%get-lexical-binding-name" "%%eq?" "decl" "lambda" "jazz.find-if" "name" "namespace-declaration")}
      {Lisp-Entry "jazz.begin-form?" define #f 3606 9 3606 25 ("begin" "'begin" "%%car" "%%eq?" "jazz.source-code" "%%pair?" "and" "form")}
      {Lisp-Entry "jazz.define-form?" define #f 3611 9 3611 26 ("define" "'define" "%%car" "%%eq?" "jazz.source-code" "%%pair?" "and" "form")}
      {Lisp-Entry "jazz.register-autoload-declaration" define #f 3621 9 3621 43 ("%%cons" "%%set-module-declaration-walker-autoloads" "%%memq" "%%not" "%%when" "%%get-module-declaration-walker-autoloads" "declarations" "let" "autoload-declaration" "module-declaration")}
      {Lisp-Entry "jazz.lookup-reference" define #f 3632 9 3632 30 ("jazz.walk-unresolved" "jazz.lookup-symbol" "or" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.Expression" define-class ("class runtime") 3642 27 3642 42 ()}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Expression~virtual-runtime") 3645 30 3645 50 ("environment" "declaration")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Expression") 3648 21 3648 41 ("expression" "jazz.error" "environment" "declaration")}
      {Lisp-Entry "jazz.emit-call" generic/specific ("jazz.Expression~virtual-runtime") 3652 30 3652 44 ("environment" "declaration" "arguments")}
      {Lisp-Entry "jazz.emit-call" generic/specific ("jazz.Expression") 3655 21 3655 35 ("jazz.Any" "jazz.codes-forms" "expression" "jazz.emit-expression" "jazz.sourcified-form" "jazz.new-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Expression~virtual-runtime") 3662 30 3662 50 ("s" "k" "f")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Expression") 3665 21 3665 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.emit-expressions" define #f 3669 9 3669 30 ("jazz.emit-expression" "expression" "lambda" "map" "environment" "declaration" "expressions")}
      {Lisp-Entry "jazz.fold-expressions" define #f 3675 9 3675 30 ("%%cdr" "jazz.fold-expressions" "%%car" "jazz.fold-expression" "%%null?" "if" "seed" "s" "k" "f" "expressions")}
      {Lisp-Entry "jazz.tree-fold-list" define #f 3682 9 3682 28 ("car" "jazz.tree-fold" "cdr" "jazz.tree-fold-list" "null?" "if" "environment" "seed" "here" "up" "down" "ls")}
      {Lisp-Entry "jazz.Binding-Reference" define-class ("class runtime") 3696 27 3696 49 ()}
      {Lisp-Entry "jazz.new-binding-reference" define #f 3699 9 3699 35 ("jazz.Binding-Reference" "jazz.allocate-binding-reference" "binding" "symbol-src")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Binding-Reference") 3703 21 3703 41 ("%%get-expression-source" "expression" "%%get-reference-binding" "jazz.emit-binding-reference" "jazz.sourcify-code" "environment" "declaration")}
      {Lisp-Entry "jazz.emit-call" generic/specific ("jazz.Binding-Reference") 3708 21 3708 35 ("%%get-expression-source" "expression" "%%get-reference-binding" "jazz.emit-binding-call" "jazz.sourcify-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Binding-Reference") 3713 21 3713 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Reference-Reification" define-class ("class runtime") 3725 27 3725 53 ()}
      {Lisp-Entry "jazz.new-reference-reification" define #f 3728 9 3728 39 ("jazz.Reference-Reification" "jazz.allocate-reference-reification" "resolver" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Reference-Reification") 3732 21 3732 41 ("jazz.Any" ",serialization" "',serialization" "jazz.emit-expression" "%%get-code-form" "jazz.new-runtime-reference" "jazz.new-code" "serialization" "jazz.Binding-Reference" "%%assert" "%%get-lambda-body" "%%get-body-expressions" "expression" "%%get-reference-reification-resolver" "resolver" "%%cdr" "%%table-ref" "jazz.public-access" "%%get-access-lookup" "imported" "%%get-module-invoice-module" "imported-module-declaration" "%%car" "module-invoice" "%%null?" "%%get-module-declaration-imports" "scan" "iter" "symbol" ",name" ",import" "module-public" "find-import" "import" "%%get-lexical-binding-name" "name" "%%get-declaration-locator" "module-private" "%%eq?" "jazz.Declaration" "%%is?" "if" "%%get-reference-binding" "binding" "%%get-declaration-toplevel" "module" "let" "reference" "determine-serialization" "define" "environment" "declaration")}
      {Lisp-Entry "jazz.Body" define-class ("class runtime") 3777 27 3777 36 ()}
      {Lisp-Entry "jazz.new-body" define #f 3780 9 3780 22 ("jazz.Body" "jazz.allocate-body" "expressions" "internal-defines")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Body") 3784 21 3784 41 ("jazz.Any" "jazz.emit-expressions" "jazz.codes-forms" "%%append" "jazz.new-code" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-internal-defines" "jazz.with-annotated-frame" "%%get-body-expressions" "expressions" "expression" "%%get-body-internal-defines" "internal-defines" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Body") 3797 21 3797 41 ("%%get-body-expressions" "%%get-body-internal-defines" "jazz.fold-statements" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Body") 3803 21 3803 35 ("%%get-body-internal-defines" "%%get-body-expressions" "jazz.tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Internal-Define" define-class ("class runtime") 3824 27 3824 47 ()}
      {Lisp-Entry "jazz.new-internal-define" define #f 3827 9 3827 33 ("jazz.Internal-Define" "jazz.allocate-internal-define" "value" "variable")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Internal-Define") 3831 21 3831 41 ("jazz.Any" "jazz.emit-expression" "jazz.sourcified-form" "jazz.emit-binding-symbol" "define" "jazz.new-code" "%%get-internal-define-value" "value" "expression" "%%get-internal-define-variable" "variable" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Internal-Define") 3841 21 3841 41 ("%%get-internal-define-value" "jazz.fold-statement" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Internal-Define") 3847 21 3847 35 ("%%get-internal-define-value" "jazz.tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Begin" define-class ("class runtime") 3865 27 3865 37 ()}
      {Lisp-Entry "jazz.new-begin" define #f 3868 9 3868 23 ("jazz.Begin" "jazz.allocate-begin" "expressions" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Begin") 3872 21 3872 41 ("%%get-expression-source" "%%get-code-type" "jazz.sourcified-form" "begin" "jazz.new-code" "jazz.emit-statements-code" "code" "expression" "%%get-begin-expressions" "expressions" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Begin") 3881 21 3881 41 ("%%get-begin-expressions" "jazz.fold-statements" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Begin") 3886 21 3886 35 ("%%get-begin-expressions" "jazz.tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.emit-specialized-call" define-macro ("variable") 3904 22 3904 48 ()}
      {Lisp-Entry "jazz.emit-primitive-new-call" define-macro ("variable") 3905 22 3905 50 ()}
      {Lisp-Entry "jazz.emit-primitive-call" define-macro ("variable") 3906 22 3906 46 ()}
      {Lisp-Entry "jazz.emit-inlined-call" define-macro ("variable") 3907 22 3907 44 ()}
      {Lisp-Entry "jazz.Call" define-class ("class runtime") 3910 27 3910 36 ()}
      {Lisp-Entry "jazz.new-call" define #f 3913 9 3913 22 ("jazz.Call" "jazz.allocate-call" "arguments" "operator" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Call") 3917 21 3917 41 ("%%get-expression-source" "jazz.emit-call" "jazz.emit-inlined-call" "jazz.emit-primitive-call" "jazz.emit-primitive-new-call" "jazz.emit-specialized-call" "or" "jazz.sourcify-code" "jazz.emit-expressions" "arguments-codes" "%%get-declaration-locator" "jazz.Declaration" "%%get-reference-binding" "binding" "jazz.Binding-Reference" "%%class-is?" "if" "locator" "%%get-call-arguments" "arguments" "expression" "%%get-call-operator" "operator" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Call") 3936 21 3936 41 ("%%get-call-arguments" "jazz.fold-expressions" "%%get-call-operator" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Call") 3942 21 3942 35 ("%%get-call-arguments" "%%get-call-operator" "cons" "jazz.tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Constant" define-class ("class runtime") 3961 27 3961 40 ()}
      {Lisp-Entry "jazz.new-constant" define #f 3964 9 3964 26 ("jazz.Constant" "jazz.allocate-constant" "type" "expansion")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Constant") 3968 21 3968 41 ("%%get-expression-type" "expression" "%%get-constant-expansion" "jazz.new-code" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Constant") 3975 21 3975 41 ("%%get-constant-expansion" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Assignment" define-class ("class runtime") 3989 27 3989 42 ()}
      {Lisp-Entry "jazz.new-assignment" define #f 3992 9 3992 28 ("jazz.Assignment" "jazz.allocate-assignment" "value" "binding")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Assignment") 3996 21 3996 41 ("%%get-assignment-value" "expression" "%%get-assignment-binding" "jazz.emit-binding-assignment" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Assignment") 4000 21 4000 41 ("%%get-assignment-value" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Assignment") 4006 21 4006 35 ("%%get-assignment-value" "jazz.tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Analysis-Data" define-class ("class runtime") 4021 27 4021 45 ()}
      {Lisp-Entry "jazz.new-analysis-data" define #f 4024 9 4024 31 ("jazz.Analysis-Data" "jazz.allocate-analysis-data")}
      {Lisp-Entry "jazz.get-analysis-data" define #f 4031 9 4031 31 ("%%table-set!" "jazz.new-analysis-data" "data" "let" "jazz.analysis-data" "%%table-ref" "or" "locator")}
      {Lisp-Entry "jazz.emit-namespace-statements" define #f 4043 9 4043 39 ("jazz.queue-list" "jazz.sourcified-form" "jazz.emit-expression" "code" "jazz.emit-declaration" "jazz.enqueue" "jazz.Declaration" "%%class-is?" "if" "statement" "lambda" "for-each" "jazz.new-queue" "queue" "let" "environment" "declaration" "statements")}
      {Lisp-Entry "jazz.emit-statements-code" define #f 4055 9 4055 34 ("jazz.new-code" "jazz.sourcified-form" "%%get-code-type" "set!" "jazz.emit-expression" "code" "jazz.emit-declaration" "jazz.Declaration" "%%class-is?" "if" "statement" "lambda" "map" "emited" "last-type" "let" "environment" "declaration" "statements")}
      {Lisp-Entry "jazz.fold-statement" define #f 4068 9 4068 28 ("jazz.fold-expression" "jazz.fold-declaration" "jazz.Declaration" "%%class-is?" "if" "s" "k" "f" "statement")}
      {Lisp-Entry "jazz.fold-statements" define #f 4074 9 4074 29 ("%%cdr" "jazz.fold-statements" "%%car" "jazz.fold-statement" "%%null?" "if" "seed" "s" "k" "f" "statements")}
      {Lisp-Entry "jazz.walk" define #f 4085 9 4085 18 ("jazz.walk-constant" "else" "%%get-syntactic-closure-form" "%%get-syntactic-closure-environment" "append" "jazz.walk" "syntactic-closure?" "jazz.walk-form" "%%pair?" "jazz.walk-symbol" "identifier?" "cond" "jazz.source-code" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-list" define #f 4097 9 4097 23 ("jazz.queue-list" "jazz.walk" "jazz.enqueue" "continuation-capture" "form" "lambda" "for-each" "jazz.new-queue" "queue" "let" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-body" define #f 4107 9 4107 23 ("jazz.queue-list" "map" "jazz.enqueue" "jazz.new-variable" "%%symbol?" "%%desourcify" "%%cadr" "signature" "internal-define" "augmented-environment" "jazz.new-queue" "variables" "jazz.walk-list" "jazz.new-body" "%%car" "%%eq?" "%%null?" "or" "scan" "iter" "expressions" "'expressions" "else" "defines" "'defines" "%%cons" "jazz.define-form?" "jazz.error" "%%neq?" "set!" "%%not" "substate" "sub" "for-each" "state" "jazz.begin-form?" "cond" "form" "lambda" "process" "letrec" "internal-defines" "jazz.walk" "jazz.new-internal-define" "jazz.Any" "jazz.walk-specifier" "if" "type" "let" "jazz.source-code" "%%cdr" "jazz.parse-define" "parameters" "value" "specifier" "name" "receive" "variable" "form-src" "walk-internal-define" "define" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-define" define #f 4155 9 4155 26 (",@body" ",@specifier-list" ",parameters" "%%list" "specifier-list" "body" "%%desourcify" "parameters" "values" "specifier" "lambda" "%%cdr" "jazz.parse-specifier" "name" "let" "%%car" "jazz.source-code" "%%symbol?" "if" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-quote" define #f 4174 9 4174 24 ("jazz.walk-constant" "jazz.Null" "quote" "jazz.new-constant" "%%null?" "if" "%%cadr" "expression" "strip-syntactic-closures" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-keyword" define #f 4182 9 4182 26 ("jazz.Keyword" "jazz.new-constant" "keyword" "walker")}
      {Lisp-Entry "jazz.walk-enumerator" define #f 4186 9 4186 29 ("jazz.Symbol" "quote" "'quote" "%%list" "jazz.new-constant" "enumerator" "walker")}
      {Lisp-Entry "jazz.walk-constant" define #f 4190 9 4190 27 ("jazz.walk-literal/constant" "else" "jazz.Pair" "jazz.scheme-pair-literal?" "jazz.Any" "#!void" "#!rest" "#!key" "#!optional" "%%eq?" "%%box?" "or" "jazz.Null" "%%null?" "jazz.Values" "%%values?" "jazz.F64Vector" "%%f64vector?" "jazz.F32Vector" "%%f32vector?" "jazz.U64Vector" "%%u64vector?" "jazz.S64Vector" "%%s64vector?" "jazz.U32Vector" "%%u32vector?" "jazz.S32Vector" "%%s32vector?" "jazz.U16Vector" "%%u16vector?" "jazz.S16Vector" "%%s16vector?" "jazz.U8Vector" "%%u8vector?" "jazz.S8Vector" "%%s8vector?" "jazz.Vector" "%%vector?" "jazz.Symbol" ",form-src" "quote" "%%symbol?" "jazz.Number" "%%number?" "jazz.Flonum" "%%flonum?" "jazz.Fixnum" "%%fixnum?" "jazz.Keyword" "%%keyword?" "jazz.String" "%%string?" "jazz.Char" "%%char?" "jazz.Boolean" "jazz.new-constant" "%%boolean?" "cond" "jazz.source-code" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.scheme-pair-literal?" define #f 4246 9 4246 34 ("%%cdr" "%%car" "%%pair?" "and" "%%vector?" "%%symbol?" "%%number?" "%%keyword?" "%%string?" "%%char?" "%%boolean?" "%%null?" "or" "expr" "lambda" "scheme-data?" "letrec" "form")}
      {Lisp-Entry "jazz.walk-literal/constant" define #f 4268 9 4268 35 ("jazz.lookup-reference" "jazz.new-constant" "jazz.class-of" "%%get-category-identifier" "jazz.identifier-name" "if" "literal-type" "%%set-cdr!" "%%get-module-declaration-walker-literals" "%%set-module-declaration-walker-literals" "info" "jazz.generate-global-symbol" "locator" "jazz.walk-error" "else" "%%cdr" "cons" "%%pair?" ",arg" "quote" "arg" "lambda" "map" ",constructor-name" "%%desourcify" "jazz.require-literal-constructor" "%%car" "constructor-name" "%%get-literal-arguments" "arguments" "%%get-literal-name" "name" "cond" "jazz.walk" "jazz.walker-environment" "%%cons" "walk-literal/constant" "define" "jazz.Literal" "%%is?" "literal?" "%%get-declaration-toplevel" "module-declaration" "let" "literal/constant" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.make-symbolic-chars" define #f 4300 9 4300 33 ("eq?" "test:" "%%cdr" "integer->char" "%%car" "%%cons" "pair" "lambda" "map" "%%list->table" "alist")}
      {Lisp-Entry "jazz.Symbolic-Chars" define #f 4308 8 4308 27 ("#xA9" "copyright" "#x7F" "delete" "#x7D" "close-brace" "#x7B" "open-brace" "#x60" "backquote" "#x5F" "underscore" "#x5E" "exponential" "#x5D" "close-bracket" "#x5C" "backslash" "#x5B" "open-bracket" "#x40" "at" "#x3F" "question-mark" "#x3B" "semi-colon" "#x3A" "colon" "#x2F" "slash" "#x2E" "period" "#x2D" "minus" "#x2C" "comma" "#x2B" "plus" "#x2A" "times" "#x29" "close-parenthesis" "#x28" "open-parenthesis" "#x27" "quote" "#x26" "ampersand" "#x23" "sharp" "#x22" "double-quote" "#x21" "exclamation-point" "#x20" "space" "#x1F" "down-arrow" "#x1E" "up-arrow" "#x1D" "right-arrow" "#x1C" "left-arrow" "#x1B" "escape" "#x0D" "return" "#x0C" "page-down" "#x0B" "page-up" "#x0A" "linefeed" "#x09" "tab" "#x08" "backspace" "#x05" "info" "#x04" "end" "#x03" "enter" "#x01" "home" "#x00" "zero" "jazz.make-symbolic-chars")}
      {Lisp-Entry "jazz.symbolic-char" define #f 4356 9 4356 27 ("jazz.Symbolic-Chars" "%%table-ref" "name")}
      {Lisp-Entry "jazz.register-variable" define #f 4365 9 4365 31 ("%%get-module-declaration-walker-variables" "jazz.enqueue" "%%cons" "variable" "jazz.generate-global-symbol" "symbol" "%%get-declaration-toplevel" "module-declaration" "let" "value" "suffix" "declaration")}
      {Lisp-Entry "jazz.walk-symbol" generic/specific ("jazz.Walker~virtual-runtime") 4378 30 4378 46 ("symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-symbol" generic/specific ("jazz.Walker") 4381 21 4381 37 ("jazz.walk-symbol-reference" "else" "walker" "jazz.walk-enumerator" "jazz.enumerator?" "cond" "jazz.source-code" "symbol" "let" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-setbang" define #f 4389 9 4389 26 ("jazz.walk-symbol-assignment" "%%symbol?" "%%cddr" "%%car" "value" "%%cadr" "variable" "let" "%%desourcify" "jazz.walk-error" "3" "jazz.source-code" "%%length" "%%fx=" "%%not" "if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.special-form-name?" define #f 4399 9 4399 32 ("cdr" "jazz.special-form-name?" "jazz.Special-Form" "%%class-is?" "jazz.object?" "car" "jazz.walk-binding-lookup" "binding" "let" "or" "eq?" "not" "pair?" "and" "end" "ls" "symbol")}
      {Lisp-Entry "jazz.lookup-symbol" define #f 4409 9 4409 27 ("jazz.lookup-analyse" "jazz.analysis-mode?" "jazz.register-autoload-declaration" "module" "jazz.Declaration" "%%class-is?" "jazz.source-code" "syntactic-closure-form" "%%get-syntactic-closure-environment" "syntactic-closure?" "jazz.walk-warning" "%%get-declaration-locator" "referenced-locator" "deprecated" "'deprecated" "%%get-declaration-compatibility" "%%eq?" "referenced-declaration" "validate-compatibility" "%%cdr" "%%car" "jazz.walk-binding-lookup" "or" "%%pair?" "and" "env" "lp" "unwrap-syntactic-closure" "raw-symbol" "jazz.composite-name?" "lookup" "jazz.walk-error" "jazz.new-module-reference" "%%get-declaration-toplevel" "jazz.new-autoload-declaration" "jazz.Autoload-Declaration" "%%is?" "if" "jazz.public-access" "jazz.lookup-declaration" "decl" "jazz.outline-module" "exported-module-reference" "let" "jazz.split-composite" "name" "module-name" "receive" "symbol" "lookup-composite" "define" "symbol-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.lookup-analyse" generic/specific ("jazz.Walker~virtual-runtime") 4450 30 4450 49 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "jazz.lookup-analyse" generic/specific ("jazz.Walker") 4453 21 4453 40 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "jazz.walk-symbol-reference" define #f 4462 9 4462 35 ("jazz.walk-free-reference" "jazz.new-binding-reference" "jazz.walk-binding-referenced" "jazz.Variable" "%%class-is?" "begin" "if" "jazz.lookup-symbol" "binding" "let" "symbol-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-free-reference" generic/specific ("jazz.Walker~virtual-runtime") 4472 30 4472 54 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-free-reference" generic/specific ("jazz.Walker") 4475 21 4475 45 ("walker" "jazz.walk-unresolved" "symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-symbol-assignment" generic/specific ("jazz.Walker~virtual-runtime") 4484 30 4484 57 ("value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-symbol-assignment" generic/specific ("jazz.Walker") 4487 21 4487 48 ("jazz.walk-free-assignment" "jazz.walk" "jazz.new-assignment" "jazz.walk-binding-validate-assignment" "begin" "if" "walker" "jazz.lookup-symbol" "binding" "let" "value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-free-assignment" generic/specific ("jazz.Walker~virtual-runtime") 4496 30 4496 55 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-free-assignment" generic/specific ("jazz.Walker") 4499 21 4499 46 ("walker" "jazz.walk-unresolved" "symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-form" generic/specific ("jazz.Walker~virtual-runtime") 4508 30 4508 44 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-form" generic/specific ("jazz.Walker") 4511 21 4511 35 ("jazz.walk-call" "jazz.walk" "jazz.walk-binding-expand-form" "expansion" "jazz.walk-binding-expandable?" "jazz.walk-binding-walk-form" "jazz.walk-binding-walkable?" "if" "else" "and" "%%get-reference-binding" "ref" "jazz.Binding-Reference" "jazz.Declaration" "jazz.Special-Form" "%%class-is?" "or" "walker" "jazz.lookup-symbol" "identifier?" "cond" "binding" "%%car" "jazz.source-code" "procedure-expr" "let" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.expand-macros" define #f 4542 9 4542 27 ("jazz.expand-macros" "jazz.walk-binding-expand-form" "expansion" "%%symbol?" "%%car" "procedure-expr" "jazz.source-code" "%%pair?" "%%not" "jazz.walk-binding-expandable?" "and" "if" "jazz.lookup-symbol" "binding" "let" "symbol" "lookup-macro-form" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-call" define #f 4564 9 4564 23 ("jazz.walk-list" "jazz.walk" "lambda" "continuation-capture" "jazz.new-call" "jazz.desourcify-all" "jazz.walk-binding-validate-call" "if" "%%cdr" "arguments" "jazz.source-code" "%%car" "operator" "let" "form-src" "procedure-binding" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.validate-arguments" generic/specific ("jazz.Walker~virtual-runtime") 4576 30 4576 53 ("form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "jazz.validate-arguments" generic/specific ("jazz.Walker") 4579 21 4579 44 ("%%fx<" "walker" "jazz.walk-error" "%%fx>" "%%not" "and" "cond" "%%get-signature-named" "%%get-signature-optional" "%%not-null?" "or" "rest?" "%%get-lexical-binding-name" "name" "%%length" "passed" "%%get-signature-rest" "rest" "%%get-signature-mandatory" "mandatory" "let" "form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "jazz.walk-require-declaration" define #f 4599 9 4599 38 ("jazz.listify" "jazz.add-module-require" "require" "lambda" "jazz.load-unit" "for-each" "eval" "'eval" "jazz.walk-for" "%%eq?" "%%when" "%%cdr" "jazz.filter-features" "requires" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-require" define #f 4611 9 4611 26 ("jazz.new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-export-declaration" define #f 4620 9 4620 37 ("jazz.add-module-export" "export-invoice" "for-each" "jazz.filter-features" "export-invoices" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "jazz.walk-module-export" "export" "%%cdr" "jazz.new-export-reference" "symbol" "lambda" "map" "jazz.new-export-invoice" "%%list" "if" "%%append" "module-exports" "%%assq" "symbols-exports" "assv" "symbol?" "jazz.partition" "partition" "let" "exports" "walk-exports" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-export" define #f 4642 9 4642 25 ("jazz.new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-import-declaration" define #f 4651 9 4651 37 ("jazz.add-module-import" "%%get-lexical-binding-name" "jazz.load-unit" "%%get-module-invoice-module" "import-invoice" "for-each" "eval" "'eval" "jazz.walk-for" "%%eq?" "%%when" "%%cdr" "jazz.filter-features" "import-invoices" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "let" "jazz.listify" "imports" "walk-imports" "jazz.new-export-reference" "symbol" "lambda" "map" "%%not" "if" "jazz.new-import-invoice" "jazz.parse-module-invoice" "module-autoload" "module-only" "module-version" "module-phase" "module-load" "module-name" "receive" "jazz.walk-unresolved" "error?:" "jazz.outline-module" "or" "name" "jazz.lookup-module" "import" "jazz.walk-module-import" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-import" define #f 4687 9 4687 25 ("jazz.new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.native-modifiers" define #f 4696 8 4696 29 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "jazz.native-keywords" define #f 4700 8 4700 28 ()}
      {Lisp-Entry "jazz.parse-native" define #f 4704 9 4704 26 ("values" "%%null?" "%%assert" "specifier" "lambda" "%%cdr" "jazz.parse-specifier" "%%car" "name" "let" "jazz.native-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-native-declaration" define #f 4713 9 4713 37 ("jazz.add-declaration-child" "effective-declaration" "jazz.new-export-declaration" "jazz.find-child-declaration" "or" "new-declaration" "jazz.Any" "jazz.walk-specifier" "if" "type" "jazz.parse-exported-symbol" "symbol" "%%cdr" "jazz.parse-native" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-native" define #f 4724 9 4724 25 ("jazz.require-declaration" "jazz.parse-exported-symbol" "symbol" "%%cdr" "jazz.parse-native" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.native-syntax-modifiers" define #f 4736 8 4736 36 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "jazz.native-syntax-keywords" define #f 4740 8 4740 35 ()}
      {Lisp-Entry "jazz.parse-native-syntax" define #f 4744 9 4744 33 ("values" "%%null?" "%%assert" "specifier" "lambda" "%%cdr" "jazz.parse-specifier" "%%car" "name" "let" "jazz.native-syntax-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-native-syntax-declaration" define #f 4753 9 4753 44 ("jazz.add-declaration-child" "effective-declaration" "jazz.new-export-syntax-declaration" "jazz.find-child-declaration" "or" "new-declaration" "jazz.Any" "jazz.walk-specifier" "if" "type" "jazz.parse-exported-symbol" "symbol" "%%cdr" "jazz.parse-native-syntax" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-native-syntax" define #f 4764 9 4764 32 ("jazz.require-declaration" "jazz.parse-exported-symbol" "symbol" "%%cdr" "jazz.parse-native-syntax" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.macro-modifiers" define #f 4776 8 4776 28 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "jazz.parse-macro" define #f 4781 9 4781 25 ("values" "parameters" "jazz.Any" "type" "%%desourcify" "name" "%%cdr" "body" "%%car" "jazz.source-code" "signature" "let*" "jazz.macro-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-macro-declaration" define #f 4791 9 4791 36 ("jazz.add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz.new-macro-declaration" "jazz.find-child-declaration" "or" "new-declaration" "jazz.walk-parameters" "signature" "let" "jazz.source-code" "%%cdr" "jazz.parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-macro" define #f 4801 9 4801 24 ("%%set-declaration-source" "jazz.walk-body" "%%set-macro-declaration-body" "%%set-macro-declaration-signature" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.require-declaration" "new-declaration" "let*" "jazz.source-code" "%%cdr" "jazz.parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.register-local-macro" define #f 4817 9 4817 34 ("%%get-module-declaration-local-macros" "%%table-set!" "macro" "name" "module-declaration")}
      {Lisp-Entry "jazz.walk-local-macro-declaration" define #f 4821 9 4821 42 ("jazz.add-declaration-child" "effective-declaration" "jazz.emit-expression" "jazz.sourcified-form" "jazz.emit-signature" "eval" "%%cons" "let" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-declaration-locator" "jazz.register-local-macro" "%%set-declaration-source" "%%set-local-macro-declaration-body" "%%set-local-macro-declaration-signature" "jazz.walk-body" "walked-body" "jazz.new-local-macro-declaration" "jazz.find-child-declaration" "or" "new-declaration" "let*" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.source-code" "%%cdr" "jazz.parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-local-macro" define #f 4840 9 4840 30 ("jazz.require-declaration" "jazz.source-code" "%%cdr" "jazz.parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.syntax-modifiers" define #f 4850 8 4850 29 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "jazz.parse-syntax" define #f 4855 9 4855 26 ("values" "parameters" "jazz.Any" "type" "%%desourcify" "name" "%%cdr" "body" "%%car" "jazz.source-code" "signature" "let*" "jazz.syntax-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-syntax-declaration" define #f 4865 9 4865 37 ("jazz.add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz.new-syntax-declaration" "jazz.find-child-declaration" "or" "new-declaration" "jazz.walk-parameters" "signature" "let" "jazz.source-code" "%%cdr" "jazz.parse-syntax" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-syntax" define #f 4875 9 4875 25 ("%%set-declaration-source" "jazz.walk-body" "%%set-syntax-declaration-body" "%%set-syntax-declaration-signature" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.require-declaration" "new-declaration" "let*" "jazz.source-code" "%%cdr" "jazz.parse-syntax" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-define-syntax-declaration" define #f 4891 9 4891 44 ("jazz.add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz.Any" "jazz.new-define-syntax-declaration" "jazz.find-child-declaration" "or" "new-declaration" "%%car" "name" "let" "jazz.source-code" "%%cdr" "jazz.syntax-modifiers" "jazz.parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-define-syntax" define #f 4902 9 4902 32 ("%%set-declaration-source" "jazz.walk-body" "%%set-syntax-declaration-body" "%%set-syntax-declaration-signature" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.require-declaration" "new-declaration" "body" "%%car" "name" "let*" "jazz.source-code" "%%cdr" "jazz.syntax-modifiers" "jazz.parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-define-local-syntax-declaration" define #f 4920 9 4920 50 ("jazz.add-declaration-child" "effective-declaration" "jazz.emit-expression" "jazz.sourcified-form" "car" "eval" "jazz.new-define-local-syntax-form" "else" "cons" "x" "=>" "jazz" "'jazz" "cond" "core" "'core" "scheme" "'scheme" "jazz.get-dialect" "%%get-dialect-bindings" "jazz.new-walk-frame" "%%list" "env" "%%get-declaration-toplevel" "current-unit-name" "%%cons" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-declaration-locator" "jazz.register-local-macro" "%%set-declaration-source" "%%set-syntax-declaration-body" "jazz.walk-body" "walked-body" "jazz.Any" "jazz.new-define-local-syntax-declaration" "jazz.find-child-declaration" "or" "new-declaration" "let*" "jazz.walk-parameters" "augmented-environment" "signature" "body" "%%car" "name" "let" "jazz.source-code" "%%cdr" "jazz.syntax-modifiers" "jazz.parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-define-local-syntax" define #f 4957 9 4957 38 ("%%car" "jazz.require-declaration" "jazz.source-code" "%%cdr" "jazz.syntax-modifiers" "jazz.parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-let-syntax" define #f 4967 9 4967 29 ("jazz.walk-list" "jazz.new-begin" "jazz.new-define-syntax-form" "%%get-code-form" "eval" "expander" "jazz.walk" "jazz.emit-expression" "expander-src" "value" "%%car" "jazz.source-code" "name" "binding" "lambda" "map" "append" "augmented-environment" "let" "jazz.walk-error" "%%pair?" "%%null?" "or" "%%assertion" "%%cddr" "body" "bindings" "unwrap-syntactic-closure" "%%cadr" "bindings-src" "let*" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-letrec-syntax" define #f 4991 9 4991 32 ("jazz.walk-let-syntax" "apply" "args")}
      {Lisp-Entry "jazz.walk-reference" define #f 5000 9 5000 28 ("jazz.walk" "jazz.new-reference-reification" "jazz.source-code" "%%cadr" "lambda" "resolver" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-parameters" define #f 5015 9 5015 29 ("values" "jazz.queue-list" "append" "jazz.new-signature" "signature" "jazz.List" "jazz.new-rest-parameter" "parameter-expression" "%%symbol?" "%%null?" "jazz.new-named-parameter" "keyword-parameter" "%%keyword->string" "%%string->symbol" "%%eq?" "%%cddr" "jazz.new-optional-parameter" "optional-parameter" "default" "1" "%%length" "%%fx=" "jazz.new-parameter" "positional-parameter" "jazz.walk-specifier" "type" "rest" "lambda" "jazz.parse-specifier" "%%cdr" "jazz.enqueue" "jazz.walk" "jazz.Any" "jazz.new-dynamic-parameter" "dynamic-parameter" "%%cadr" "variable" "jazz.specifier->name" "code" "specifier" "memq" "jazz.desourcify" "jazz.walk-error" "%%not" "parameter-src" "let*" "case" "section" "allowed?" "positional" "'positional" "optional" "'optional" "else" "keyword" "'keyword" "%%keyword?" "dynamic" "'dynamic" "jazz.specifier?" "or" "cond" "%%car" "jazz.source-code" "first" "%%pair?" "if" "parameter" "parameter-section" "%%cons" "set!" "%%when" "expression" "augment-environment" "sections" "scan" "iterate-parameters" "define" "keywords" "optionals" "positionals" "jazz.new-queue" "dynamics" "augmented-environment" "let" "walk?" "extended?" "parameters" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-signature-casts" define #f 5121 9 5121 34 ("jazz.queue-list" "%%get-signature-named" "%%get-signature-optional" "%%get-signature-positional" "for-each" "jazz.enqueue" "jazz.new-queue" "set!" "%%not" "begin" "jazz.emit-binding-reference" "jazz.emit-parameter-cast" "cast" "jazz.Any" "%%neq?" "and" "if" "%%get-lexical-binding-type" "type" "parameter" "process" "define" "queue" "let" "environment" "source-declaration" "signature")}
      {Lisp-Entry "jazz.emit-signature" define #f 5143 9 5143 28 ("jazz.queue-list" "#!rest" "#!key" "#!optional" "%%null?" "%%not" "%%when" "for-each" "jazz.emit-parameter" "jazz.enqueue" "parameter" "emit" "define" "jazz.new-queue" "queue" "%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "let" "environment" "declaration" "signature")}
      {Lisp-Entry "jazz.Catalog" define #f 5172 8 5172 20 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.get-catalog" define #f 5176 9 5176 25 ("jazz.Catalog")}
      {Lisp-Entry "jazz.get-catalog-entry" define #f 5180 9 5180 31 ("jazz.Catalog" "%%table-ref" "unit-name")}
      {Lisp-Entry "jazz.set-catalog-entry" define #f 5184 9 5184 31 ("jazz.Catalog" "%%table-set!" "entry" "unit-name")}
      {Lisp-Entry "jazz.set-catalog-entry-status" define #f 5188 9 5188 38 ("%%cons" "jazz.set-catalog-entry" "%%cdr" "%%pair?" "if" "jazz.get-catalog-entry" "entry" "declaration" "let" "status" "unit-name")}
      {Lisp-Entry "jazz.release-catalog-entries" define #f 5196 9 5196 37 ("%%cdr" "jazz.set-catalog-entry" "%%pair?" "if" "entry" "unit-name" "lambda" "jazz.Catalog" "jazz.iterate-table")}
      {Lisp-Entry "jazz.call-with-catalog-entry-lock" define #f 5203 9 5203 42 ("jazz.get-catalog-entry" "%%pair?" "if" "jazz.pop-load-stack" ":walk" "':walk" "jazz.push-load-stack" ":walking" "':walking" "jazz.set-catalog-entry-status" "dynamic-wind" "lambda" "jazz.call-with-load-lock" "thunk" "unit-name")}
      {Lisp-Entry "jazz.outline-feedback" define #f 5217 8 5217 29 ("make-parameter")}
      {Lisp-Entry "jazz.outline-unit" define #f 5221 9 5221 26 ("jazz.set-catalog-entry" "jazz.error" "jazz.outline-feedback" "feedback" "jazz.call-with-catalog-entry-lock" "or" "jazz.Load-Stack" "cdr" "map" "jazz.circular-dependency-error" "declaration" "%%pair?" "status" "jazz.get-catalog-entry" "entry" "not" "jazz.parse-module-declaration" "module" "%%cdr" "jazz.parse-unit-declaration" "unit" "case" "%%car" "jazz.source-code" "kind" "0" "jazz.generate-symbol-counter" "jazz.generate-symbol-context" "jazz.generate-symbol-for" "interpret" "'interpret" "jazz.walk-for" "jazz.requested-unit-resource" "jazz.requested-unit-name" "parameterize" "read-literals?:" "jazz.read-toplevel-form" "form" "lambda" "jazz.resource-pathname" "jazz.outline-verbose?" "jazz.with-verbose" "%%not" "and" "if" "jazz.find-unit-src" "src" "let" "load-toplevel-declaration" "define" "error?" "use-catalog?" "#!key" "unit-name")}
      {Lisp-Entry "jazz.outline-module" define #f 5264 9 5264 28 ("jazz.Module-Declaration" "%%class-is?" "%%assert" "%%not" "if" "error?:" "jazz.outline-unit" "declaration" "let" "error?" "#!key" "unit-name")}
      {Lisp-Entry "jazz.read-literals?" define #f 5272 8 5272 27 ("make-parameter")}
      {Lisp-Entry "jazz.read-toplevel-form" define #f 5276 9 5276 32 ("%%not" "module" "unit" "%%memq" "jazz.source-code" "%%pair?" "and" "%%cdr" "%%not-null?" "extraneous?" "%%car" "form-src" "jazz.error" "%%null?" "if" "jazz.read-source-all" "all" "jazz.read-literals?" "parameterize" "port" "eol-encoding:" "char-encoding:" "path:" "%%list" "call-with-input-file" "cr-lf" "'cr-lf" "eol-encoding" "jazz.resource-char-encoding" "char-encoding" "lambda" "jazz.pathname-extension" "jazz.with-extension-reader" "jazz.resource-pathname" "source" "let" "read-literals?" "#!key" "resource")}
      {Lisp-Entry "jazz.walk-unit" define #f 5297 9 5297 23 ("%%cdr" "jazz.walk-module" "module" "unit" "%%car" "jazz.source-code" "case" "jazz.read-toplevel-form" "form" "0" "jazz.generate-symbol-counter" "jazz.generate-symbol-context" "jazz.generate-symbol-for" "interpret" "'interpret" "jazz.walk-for" "jazz.requested-unit-resource" "jazz.requested-unit-name" "parameterize" "jazz.find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "jazz.Core-Dialect" define-class ("class runtime") 5318 27 5318 44 ()}
      {Lisp-Entry "jazz.new-core-dialect" define #f 5321 9 5321 30 ("jazz.Core-Dialect" "jazz.allocate-core-dialect")}
      {Lisp-Entry "jazz.dialect-name" generic/specific ("jazz.Core-Dialect") 5325 21 5325 38 ("core" "'core")}
      {Lisp-Entry "jazz.dialect-walker" generic/specific ("jazz.Core-Dialect") 5329 21 5329 40 ("jazz.new-core-walker")}
      {Lisp-Entry "jazz.Core-Walker" define-class ("class runtime") 5341 27 5341 43 ()}
      {Lisp-Entry "jazz.new-core-walker" define #f 5344 9 5344 29 ("eq?" "test:" "%%make-table" "jazz.new-queue" "jazz.Core-Walker" "jazz.allocate-core-walker")}}})
"autoload"
 ({Lisp-File-Entry {File core "src" "core" "module" "runtime" "autoload.scm"} 1290447588
    {Lisp-Entry "core.module.runtime.autoload" unit #f 41 16 41 44 ()
      {Lisp-Entry "jazz.Autoloads" define #f 44 8 44 22 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.get-autoloads" define #f 48 9 48 27 ("jazz.Autoloads")}
      {Lisp-Entry "jazz.get-autoload" define #f 52 9 52 26 ("jazz.Autoloads" "%%table-ref" "name")}
      {Lisp-Entry "jazz.set-autoload" define #f 56 9 56 26 ("%%cons" "jazz.Autoloads" "%%table-set!" "loader" "unit-name" "name")}
      {Lisp-Entry "jazz.require-autoload" define #f 60 9 60 30 ("jazz.error" "jazz.get-autoload" "or" "name")}
      {Lisp-Entry "jazz.register-autoload" define #f 65 9 65 31 ("jazz.error" "jazz.set-autoload" "%%car" "%%eq?" "%%not" "or" "if" "jazz.get-autoload" "actual" "let" "loader" "unit-name" "name")}
      {Lisp-Entry "jazz.autoload" define #f 72 9 72 22 ("%%cdr" "jazz.require-autoload" "autoload-info" "let" "name")}
      {Lisp-Entry "jazz.autoreload" define #f 77 9 77 24 ("%%cdr" "%%car" "jazz.reload-unit" "jazz.require-autoload" "autoload-info" "let" "name")}}})
"boolean"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "boolean.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.boolean" unit #f 37 16 37 41 ()
      {Lisp-Entry "jazz.boolean" define #f 40 9 40 21 ("%%boolean" "expr")}
      {Lisp-Entry "jazz.not-null?" define #f 44 9 44 23 ("%%not-null?" "expr")}}})
"class"
 ({Lisp-File-Entry {File core "src" "core" "class" "syntax" "class.scm"} 1288732032
    {Lisp-Entry "core.class.syntax.class" unit #f 37 16 37 39 ()
      {Lisp-Entry "jazz.category-identifier" define #f 40 8 40 32 ("jazz.object-size")}
      {Lisp-Entry "jazz.category-fields" define #f 43 8 43 28 ("1" "jazz.category-identifier" "%%fx+")}
      {Lisp-Entry "jazz.category-virtual-size" define #f 46 8 46 34 ("1" "jazz.category-fields" "%%fx+")}
      {Lisp-Entry "jazz.category-ancestors" define #f 49 8 49 31 ("1" "jazz.category-virtual-size" "%%fx+")}
      {Lisp-Entry "jazz.category-descendants" define #f 52 8 52 33 ("1" "jazz.category-ancestors" "%%fx+")}
      {Lisp-Entry "jazz.class-ascendant" define #f 55 8 55 28 ("1" "jazz.category-descendants" "%%fx+")}
      {Lisp-Entry "jazz.class-interfaces" define #f 58 8 58 29 ("1" "jazz.class-ascendant" "%%fx+")}
      {Lisp-Entry "jazz.class-slots" define #f 61 8 61 24 ("1" "jazz.class-interfaces" "%%fx+")}
      {Lisp-Entry "jazz.class-instance-slots" define #f 64 8 64 33 ("1" "jazz.class-slots" "%%fx+")}
      {Lisp-Entry "jazz.class-instance-size" define #f 67 8 67 32 ("1" "jazz.class-instance-slots" "%%fx+")}
      {Lisp-Entry "jazz.class-level" define #f 70 8 70 24 ("1" "jazz.class-instance-size" "%%fx+")}
      {Lisp-Entry "jazz.class-dispatch-table" define #f 73 8 73 33 ("1" "jazz.class-level" "%%fx+")}
      {Lisp-Entry "jazz.class-core-method-alist" define #f 76 8 76 36 ("1" "jazz.class-dispatch-table" "%%fx+")}
      {Lisp-Entry "jazz.class-core-virtual-alist" define #f 79 8 79 37 ("1" "jazz.class-core-method-alist" "%%fx+")}
      {Lisp-Entry "jazz.class-core-virtual-names" define #f 82 8 82 37 ("1" "jazz.class-core-virtual-alist" "%%fx+")}
      {Lisp-Entry "jazz.class-core-vtable" define #f 85 8 85 30 ("1" "jazz.class-core-virtual-names" "%%fx+")}
      {Lisp-Entry "jazz.class-class-table" define #f 88 8 88 30 ("1" "jazz.class-core-vtable" "%%fx+")}
      {Lisp-Entry "jazz.class-interface-table" define #f 91 8 91 34 ("1" "jazz.class-class-table" "%%fx+")}
      {Lisp-Entry "jazz.class-size" define #f 95 8 95 23 ("1" "jazz.class-interface-table" "%%fx+")}
      {Lisp-Entry "%%get-category-identifier" define-macro ("macro") 99 20 99 45 ("jazz.category-identifier" ",jazz.category-identifier" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-identifier" define-macro ("macro") 103 20 103 45 (",identifier" "jazz.category-identifier" ",jazz.category-identifier" ",category" "%%object-set!" "identifier" "category")}
      {Lisp-Entry "%%get-category-fields" define-macro ("macro") 107 20 107 41 ("jazz.category-fields" ",jazz.category-fields" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-fields" define-macro ("macro") 111 20 111 41 (",fields" "jazz.category-fields" ",jazz.category-fields" ",category" "%%object-set!" "fields" "category")}
      {Lisp-Entry "%%get-category-virtual-size" define-macro ("macro") 115 20 115 47 ("jazz.category-virtual-size" ",jazz.category-virtual-size" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-virtual-size" define-macro ("macro") 119 20 119 47 (",virtual-size" "jazz.category-virtual-size" ",jazz.category-virtual-size" ",category" "%%object-set!" "virtual-size" "category")}
      {Lisp-Entry "%%get-category-ancestors" define-macro ("macro") 123 20 123 44 ("jazz.category-ancestors" ",jazz.category-ancestors" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-ancestors" define-macro ("macro") 127 20 127 44 (",ancestors" "jazz.category-ancestors" ",jazz.category-ancestors" ",category" "%%object-set!" "ancestors" "category")}
      {Lisp-Entry "%%get-category-descendants" define-macro ("macro") 131 20 131 46 ("jazz.category-descendants" ",jazz.category-descendants" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-descendants" define-macro ("macro") 135 20 135 46 (",descendants" "jazz.category-descendants" ",jazz.category-descendants" ",category" "%%object-set!" "descendants" "category")}
      {Lisp-Entry "%%get-class-ascendant" define-macro ("macro") 139 20 139 41 ("jazz.class-ascendant" ",jazz.class-ascendant" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-ascendant" define-macro ("macro") 143 20 143 41 (",ascendant" "jazz.class-ascendant" ",jazz.class-ascendant" ",class" "%%object-set!" "ascendant" "class")}
      {Lisp-Entry "%%get-class-interfaces" define-macro ("macro") 147 20 147 42 ("jazz.class-interfaces" ",jazz.class-interfaces" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-interfaces" define-macro ("macro") 151 20 151 42 (",interfaces" "jazz.class-interfaces" ",jazz.class-interfaces" ",class" "%%object-set!" "interfaces" "class")}
      {Lisp-Entry "%%get-class-slots" define-macro ("macro") 155 20 155 37 ("jazz.class-slots" ",jazz.class-slots" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-slots" define-macro ("macro") 159 20 159 37 (",slots" "jazz.class-slots" ",jazz.class-slots" ",class" "%%object-set!" "slots" "class")}
      {Lisp-Entry "%%get-class-instance-slots" define-macro ("macro") 163 20 163 46 ("jazz.class-instance-slots" ",jazz.class-instance-slots" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-instance-slots" define-macro ("macro") 167 20 167 46 (",slots" "jazz.class-instance-slots" ",jazz.class-instance-slots" ",class" "%%object-set!" "slots" "class")}
      {Lisp-Entry "%%get-class-instance-size" define-macro ("macro") 171 20 171 45 ("jazz.class-instance-size" ",jazz.class-instance-size" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-instance-size" define-macro ("macro") 175 20 175 45 (",size" "jazz.class-instance-size" ",jazz.class-instance-size" ",class" "%%object-set!" "size" "class")}
      {Lisp-Entry "%%get-class-level" define-macro ("macro") 179 20 179 37 ("jazz.class-level" ",jazz.class-level" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-level" define-macro ("macro") 183 20 183 37 (",size" "jazz.class-level" ",jazz.class-level" ",class" "%%object-set!" "size" "class")}
      {Lisp-Entry "%%get-class-dispatch-table" define-macro ("macro") 187 20 187 46 ("jazz.class-dispatch-table" ",jazz.class-dispatch-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-dispatch-table" define-macro ("macro") 191 20 191 46 (",vtable" "jazz.class-dispatch-table" ",jazz.class-dispatch-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-method-alist" define-macro ("macro") 195 20 195 49 ("jazz.class-core-method-alist" ",jazz.class-core-method-alist" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-method-alist" define-macro ("macro") 199 20 199 49 (",vtable" "jazz.class-core-method-alist" ",jazz.class-core-method-alist" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-virtual-alist" define-macro ("macro") 203 20 203 50 ("jazz.class-core-virtual-alist" ",jazz.class-core-virtual-alist" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-virtual-alist" define-macro ("macro") 207 20 207 50 (",vtable" "jazz.class-core-virtual-alist" ",jazz.class-core-virtual-alist" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-virtual-names" define-macro ("macro") 211 20 211 50 ("jazz.class-core-virtual-names" ",jazz.class-core-virtual-names" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-virtual-names" define-macro ("macro") 215 20 215 50 (",vtable" "jazz.class-core-virtual-names" ",jazz.class-core-virtual-names" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-vtable" define-macro ("macro") 219 20 219 43 ("jazz.class-core-vtable" ",jazz.class-core-vtable" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-vtable" define-macro ("macro") 223 20 223 43 (",vtable" "jazz.class-core-vtable" ",jazz.class-core-vtable" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-class-table" define-macro ("macro") 227 20 227 43 ("jazz.class-class-table" ",jazz.class-class-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-class-table" define-macro ("macro") 231 20 231 43 (",vtable" "jazz.class-class-table" ",jazz.class-class-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-interface-table" define-macro ("macro") 235 20 235 47 ("jazz.class-interface-table" ",jazz.class-interface-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-interface-table" define-macro ("macro") 239 20 239 47 (",vtable" "jazz.class-interface-table" ",jazz.class-interface-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-object-class" define-macro ("macro") 243 20 243 38 ("jazz.object-class" ",jazz.object-class" ",object" "%%object-ref" "object")}
      {Lisp-Entry "%%set-object-class" define-macro ("macro") 247 20 247 38 (",class" "jazz.object-class" ",jazz.object-class" ",object" "%%object-set!" "class" "object")}
      {Lisp-Entry "%%final-dispatch" define-macro ("macro") 251 20 251 36 ("implementation" "class")}
      {Lisp-Entry "%%class-dispatch" define-macro ("macro") 255 20 255 36 (",implementation-rank" ",class-level" ",class" "%%get-class-class-table" "%%vector-ref" "implementation-rank" "class-level" "class")}
      {Lisp-Entry "%%interface-dispatch" define-macro ("macro") 259 20 259 40 (",implementation-rank" ",interface-rank" ",class" "%%get-class-interface-table" "%%vector-ref" "implementation-rank" "interface-rank" "class")}
      {Lisp-Entry "%%class-of-impl" define-macro ("macro") 268 24 268 39 ("%%scheme-class-of-impl" "else" ",obj" "%%c-class-of-impl" "compile" "jazz.walk-for" "case" "obj")}
      {Lisp-Entry "%%c-class-of-impl" define-macro ("macro") 275 24 275 41 ("jazz.structure-type" "jazz.specialtypes" "jazz.Char" "jazz.Fixnum" "jazz.subtypes" ",obj" "#<<end-of-c-code\n{\n    ___SCMOBJ obj = ___ARG1;\n    if (___MEM_ALLOCATED(obj))\n    {\n        int subtype = (*___UNTAG(obj) & ___SMASK) >> ___HTB;\n        if (subtype == ___sJAZZ)\n            ___RESULT = ___VECTORREF(obj,0);\n        else if (subtype == ___sSTRUCTURE)\n            ___RESULT = ___FAL;\n        else\n            ___RESULT = ___BODY_AS(___ARG2,___tSUBTYPED)[subtype];\n    }\n    else if (___FIXNUMP(obj))\n        ___RESULT = ___ARG3;\n    else if (obj >= 0)\n        ___RESULT = ___ARG4;\n    else\n        ___RESULT = ___BODY_AS(___ARG5,___tSUBTYPED)[___INT(___FAL - obj)];\n}\nend-of-c-code\n" "##c-code" "extended-bindings" "declare" "let" "or" "obj")}
      {Lisp-Entry "%%scheme-class-of-impl" define-macro ("macro") 307 24 307 46 ("jazz.error" "jazz.structure-type" "or" "else" "jazz.Marker" "jazz.marker?" "jazz.Unspecified" "%%unspecified?" "jazz.EOF" "%%eof-object?" "jazz.Values" "%%values?" "jazz.Foreign" "%%foreign?" "jazz.Procedure" "%%procedure?" "jazz.Continuation" "%%continuation?" "jazz.Port" "%%port?" "jazz.Keyword" "%%keyword?" "jazz.Symbol" "%%symbol?" "jazz.F64Vector" "%%f64vector?" "jazz.F32Vector" "%%f32vector?" "jazz.U64Vector" "%%u64vector?" "jazz.S64Vector" "%%s64vector?" "jazz.U32Vector" "%%u32vector?" "jazz.S32Vector" "%%s32vector?" "jazz.U16Vector" "%%u16vector?" "jazz.S16Vector" "%%s16vector?" "jazz.U8Vector" "%%u8vector?" "jazz.S8Vector" "%%s8vector?" "jazz.Vector" "%%vector?" "jazz.String" "%%string?" "jazz.Pair" "%%pair?" "jazz.Null" "%%null?" "jazz.Number" "%%number?" "jazz.Complex" "%%complex?" "jazz.Real" "%%real?" "jazz.Rational" "%%rational?" "jazz.Integer" "%%integer?" "jazz.Flonum" "%%flonum?" "jazz.Fixnum" "%%fixnum?" "jazz.Char" "%%char?" "jazz.Boolean" "%%boolean?" "%%get-object-class" ",obj" "%%object?" "cond" "obj")}
      {Lisp-Entry "%%class-of-impl" define-macro ("macro") 347 24 347 39 (",obj" "%%scheme-class-of-impl" "obj")}}})
"classes"
 ({Lisp-File-Entry {File core "src" "core" "class" "syntax" "classes.scm"} 1288818285
    {Lisp-Entry "core.class.syntax.classes" unit #f 37 16 37 41 ()
      {Lisp-Entry "jazz.Object" define-class ("class") 45 19 45 30 ()}
      {Lisp-Entry "jazz.print-object" generic/specific ("jazz.Object~virtual") 49 22 49 39 ("detail" "output")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Object~virtual") 50 22 50 36 ("environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Type" define-class ("class") 58 19 58 28 ("jazz.Object")}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Type~virtual") 62 22 62 35 ("object")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Type~virtual") 63 22 63 38 ("subtype")}
      {Lisp-Entry "jazz.specifiable?" generic/specific ("jazz.Type~virtual") 64 22 64 39 ()}
      {Lisp-Entry "jazz.category-type?" generic/specific ("jazz.Type~virtual") 65 22 65 41 ()}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Type~virtual") 66 22 66 41 ()}
      {Lisp-Entry "jazz.emit-type" generic/specific ("jazz.Type~virtual") 67 22 67 36 ("environment" "source-declaration")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Type~virtual") 68 22 68 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.emit-check" generic/specific ("jazz.Type~virtual") 69 22 69 37 ("environment" "source-declaration" "value")}
      {Lisp-Entry "%%subtype?" define-macro ("macro") 72 20 72 30 (",target" ",type" "jazz.of-subtype?" "type" "target")}
      {Lisp-Entry "%%subcategory?" define-macro ("macro") 76 20 76 34 (",target" "%%get-category-ancestors" ",category" "jazz.vector-memq?" "category" "target")}
      {Lisp-Entry "%%subclass?" define-macro ("macro") 80 20 80 31 (",target" "%%get-category-ancestors" ",class" "jazz.vector-memq?" "class" "target")}
      {Lisp-Entry "%%is?" define-macro ("macro") 84 20 84 25 (",object" ",type" "jazz.of-type?" "type" "object")}
      {Lisp-Entry "%%is-not?" define-macro ("macro") 88 20 88 29 (",type" ",object" "%%is?" "%%not" "type" "object")}
      {Lisp-Entry "jazz.Category" define-class ("class") 97 19 97 32 ("descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Type")}
      {Lisp-Entry "jazz.update-category" generic/specific ("jazz.Category~virtual") 105 22 105 42 ()}
      {Lisp-Entry "jazz.Class" define-class ("class") 113 19 113 29 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "jazz.allocate-class" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Category")}
      {Lisp-Entry "%%class-subtype?" define-macro ("macro") 129 20 129 36 ("%%get-category-ancestors" "%%vector-ref" "%%eq?" ",trg" "%%fx>=" "and" ",cls" "%%get-class-level" "class-level" "let" "cls" "trg" "lambda" "jazz.with-uniqueness" "class" "target")}
      {Lisp-Entry "%%class-is?" define-macro ("macro") 139 20 139 31 (",class" ",object" "jazz.class-of" "%%class-subtype?" "class" "object")}
      {Lisp-Entry "%%category-is?" define-macro ("macro") 143 20 143 34 (",category" ",object" "%%is?" "category" "object")}
      {Lisp-Entry "%%class?" define-macro ("macro") 147 20 147 28 ("jazz.Class" ",object" "%%class-is?" "object")}
      {Lisp-Entry "%%object-class?" define-macro ("macro") 151 20 151 35 ("jazz.Object" ",object" "%%eq?" "object")}
      {Lisp-Entry "jazz.Object-Class" define-class ("class") 160 19 160 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Boolean-Class" define-class ("class") 169 19 169 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Char-Class" define-class ("class") 170 19 170 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Numeric-Class" define-class ("class") 171 19 171 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Number-Class" define-class ("class") 172 19 172 36 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Numeric-Class")}
      {Lisp-Entry "jazz.Complex-Class" define-class ("class") 173 19 173 37 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Number-Class")}
      {Lisp-Entry "jazz.Real-Class" define-class ("class") 174 19 174 34 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Complex-Class")}
      {Lisp-Entry "jazz.Rational-Class" define-class ("class") 175 19 175 38 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Real-Class")}
      {Lisp-Entry "jazz.Integer-Class" define-class ("class") 176 19 176 37 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Rational-Class")}
      {Lisp-Entry "jazz.Fixnum-Class" define-class ("class") 177 19 177 36 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Integer-Class")}
      {Lisp-Entry "jazz.Flonum-Class" define-class ("class") 178 19 178 36 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Real-Class")}
      {Lisp-Entry "jazz.Sequence-Class" define-class ("class") 179 19 179 38 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.List-Class" define-class ("class") 180 19 180 34 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.Null-Class" define-class ("class") 181 19 181 34 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.List-Class")}
      {Lisp-Entry "jazz.Pair-Class" define-class ("class") 182 19 182 34 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.List-Class")}
      {Lisp-Entry "jazz.String-Class" define-class ("class") 183 19 183 36 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.Vector-Class" define-class ("class") 184 19 184 36 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.S8Vector-Class" define-class ("class") 185 19 185 38 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.U8Vector-Class" define-class ("class") 186 19 186 38 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.S16Vector-Class" define-class ("class") 187 19 187 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.U16Vector-Class" define-class ("class") 188 19 188 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.S32Vector-Class" define-class ("class") 189 19 189 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.U32Vector-Class" define-class ("class") 190 19 190 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.S64Vector-Class" define-class ("class") 191 19 191 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.U64Vector-Class" define-class ("class") 192 19 192 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.F32Vector-Class" define-class ("class") 193 19 193 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.F64Vector-Class" define-class ("class") 194 19 194 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.Structure-Class" define-class ("class") 195 19 195 39 ("jazz.Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Sequence-Class")}
      {Lisp-Entry "jazz.Port-Class" define-class ("class") 196 19 196 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Continuation-Class" define-class ("class") 197 19 197 42 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Procedure-Class" define-class ("class") 198 19 198 39 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Symbol-Class" define-class ("class") 199 19 199 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Keyword-Class" define-class ("class") 200 19 200 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Table-Class" define-class ("class") 201 19 201 35 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Thread-Class" define-class ("class") 202 19 202 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Promise-Class" define-class ("class") 203 19 203 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Foreign-Class" define-class ("class") 204 19 204 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Values-Class" define-class ("class") 205 19 205 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.EOF-Class" define-class ("class") 206 19 206 33 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Unspecified-Class" define-class ("class") 207 19 207 41 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Marker-Class" define-class ("class") 208 19 208 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Boolean" define-class ("class") 211 19 211 31 ("jazz.Boolean-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Char" define-class ("class") 212 19 212 28 ("jazz.Char-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Numeric" define-class ("class") 213 19 213 31 ("jazz.Numeric-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Number" define-class ("class") 214 19 214 30 ("jazz.Number-Class" "jazz.Numeric")}
      {Lisp-Entry "jazz.Complex" define-class ("class") 215 19 215 31 ("jazz.Complex-Class" "jazz.Number")}
      {Lisp-Entry "jazz.Real" define-class ("class") 216 19 216 28 ("jazz.Real-Class" "jazz.Complex")}
      {Lisp-Entry "jazz.Rational" define-class ("class") 217 19 217 32 ("jazz.Rational-Class" "jazz.Real")}
      {Lisp-Entry "jazz.Integer" define-class ("class") 218 19 218 31 ("jazz.Integer-Class" "jazz.Rational")}
      {Lisp-Entry "jazz.Fixnum" define-class ("class") 219 19 219 30 ("jazz.Fixnum-Class" "jazz.Integer")}
      {Lisp-Entry "jazz.Flonum" define-class ("class") 220 19 220 30 ("jazz.Flonum-Class" "jazz.Real")}
      {Lisp-Entry "jazz.Sequence" define-class ("class") 221 19 221 32 ("jazz.Sequence-Class" "jazz.Object")}
      {Lisp-Entry "jazz.List" define-class ("class") 222 19 222 28 ("jazz.List-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.Null" define-class ("class") 223 19 223 28 ("jazz.Null-Class" "jazz.List")}
      {Lisp-Entry "jazz.Pair" define-class ("class") 224 19 224 28 ("jazz.Pair-Class" "jazz.List")}
      {Lisp-Entry "jazz.String" define-class ("class") 225 19 225 30 ("jazz.String-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.Vector" define-class ("class") 226 19 226 30 ("jazz.Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.S8Vector" define-class ("class") 227 19 227 32 ("jazz.S8Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.U8Vector" define-class ("class") 228 19 228 32 ("jazz.U8Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.S16Vector" define-class ("class") 229 19 229 33 ("jazz.S16Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.U16Vector" define-class ("class") 230 19 230 33 ("jazz.U16Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.S32Vector" define-class ("class") 231 19 231 33 ("jazz.S32Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.U32Vector" define-class ("class") 232 19 232 33 ("jazz.U32Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.S64Vector" define-class ("class") 233 19 233 33 ("jazz.S64Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.U64Vector" define-class ("class") 234 19 234 33 ("jazz.U64Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.F32Vector" define-class ("class") 235 19 235 33 ("jazz.F32Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.F64Vector" define-class ("class") 236 19 236 33 ("jazz.F64Vector-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.Structure" define-class ("class") 237 19 237 33 ("jazz.Structure-Class" "jazz.Sequence")}
      {Lisp-Entry "jazz.Port" define-class ("class") 238 19 238 28 ("jazz.Port-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Continuation" define-class ("class") 239 19 239 36 ("jazz.Continuation-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Procedure" define-class ("class") 240 19 240 33 ("jazz.Procedure-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Symbol" define-class ("class") 241 19 241 30 ("jazz.Symbol-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Keyword" define-class ("class") 242 19 242 31 ("jazz.Keyword-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Table" define-class ("class") 243 19 243 29 ("jazz.Table-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Thread" define-class ("class") 244 19 244 30 ("jazz.Thread-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Promise" define-class ("class") 245 19 245 31 ("jazz.Promise-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Foreign" define-class ("class") 246 19 246 31 ("jazz.Foreign-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Values" define-class ("class") 247 19 247 30 ("jazz.Values-Class" "jazz.Object")}
      {Lisp-Entry "jazz.EOF" define-class ("class") 248 19 248 27 ("jazz.EOF-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Unspecified" define-class ("class") 249 19 249 35 ("jazz.Unspecified-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Marker" define-class ("class") 250 19 250 30 ("jazz.Marker-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Interface" define-class ("class") 258 19 258 33 ("%%get-interface-rank" "rank" "%%get-interface-ascendants" "ascendants" "jazz.allocate-interface" "jazz.Object-Class" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Category")}
      {Lisp-Entry "jazz.Field" define-class ("class") 268 19 268 29 ("%%get-field-name" "name" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "%%get-category-field" define-macro ("macro") 272 20 272 40 (",field-name" ",category" "%%get-category-fields" "%%table-ref" "field-name" "category")}
      {Lisp-Entry "%%set-category-field" define-macro ("macro") 276 20 276 40 (",field" ",field-name" ",category" "%%get-category-fields" "%%table-set!" "field" "field-name" "category")}
      {Lisp-Entry "jazz.Slot" define-class ("class") 285 19 285 28 ("%%get-slot-initialize" "initialize" "%%get-slot-offset" "offset" "jazz.allocate-slot" "jazz.Object-Class" "name" "jazz.Field")}
      {Lisp-Entry "jazz.Property" define-class ("class") 295 19 295 32 ("%%get-property-setter" "setter" "%%get-property-getter" "getter" "jazz.allocate-property" "jazz.Object-Class" "initialize" "offset" "name" "jazz.Slot")}
      {Lisp-Entry "jazz.Method" define-class ("class") 305 19 305 30 ("%%set-method-implementation-rank" "%%get-method-implementation-rank" "implementation-rank" "%%set-method-category-rank" "%%get-method-category-rank" "category-rank" "%%set-method-implementation-tree" "%%get-method-implementation-tree" "implementation-tree" "%%set-method-implementation" "%%get-method-implementation" "implementation" "%%set-method-dispatch-type" "%%get-method-dispatch-type" "dispatch-type" "jazz.allocate-method" "jazz.Object-Class" "name" "jazz.Field")}
      {Lisp-Entry "jazz.Method-Node" define-class ("class") 318 19 318 35 ("%%set-method-node-children" "%%get-method-node-children" "children" "%%set-method-node-next-implementation" "%%get-method-node-next-implementation" "next-implementation" "%%set-method-node-next-node" "%%get-method-node-next-node" "next-node" "%%set-method-node-implementation" "%%get-method-node-implementation" "implementation" "%%set-method-node-category" "%%get-method-node-category" "category" "jazz.allocate-method-node" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Queue" define-class ("class") 331 19 331 29 ("%%set-queue-shared?" "%%get-queue-shared?" "shared?" "%%set-queue-tail" "%%get-queue-tail" "tail" "%%set-queue-head" "%%get-queue-head" "head" "jazz.allocate-queue" "jazz.Object-Class" "jazz.Object")}}}
  {Lisp-File-Entry {File core "src" "core" "exception" "syntax" "classes.scm"} 1288732032
    {Lisp-Entry "core.exception.syntax.classes" unit #f 37 16 37 45 ()
      {Lisp-Entry "jazz.Exception" define-class ("class") 45 19 45 33 ("jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.present-exception" generic/specific ("jazz.Exception~virtual") 49 22 49 44 ()}
      {Lisp-Entry "jazz.get-message" generic/specific ("jazz.Exception~virtual") 50 22 50 38 ()}
      {Lisp-Entry "jazz.get-detail" generic/specific ("jazz.Exception~virtual") 51 22 51 37 ()}
      {Lisp-Entry "jazz.Exception-Detail" define-class ("class") 59 19 59 40 ("%%get-exception-detail-children" "children" "%%get-exception-detail-location" "location" "%%get-exception-detail-title" "title" "%%get-exception-detail-icon" "icon" "jazz.allocate-exception-detail" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.System-Exception" define-class ("class") 71 19 71 40 ("%%get-system-exception-exception" "exception" "jazz.Object-Class" "jazz.Exception")}
      {Lisp-Entry "jazz.Error" define-class ("class") 80 19 80 29 ("%%get-error-message" "message" "jazz.allocate-error" "jazz.Object-Class" "jazz.Exception")}}}
  {Lisp-File-Entry {File core "src" "core" "module" "syntax" "classes.scm"} 1290258223
    {Lisp-Entry "core.module.syntax.classes" unit #f 37 16 37 42 ()
      {Lisp-Entry "jazz.Walk-Binding" define-class ("class") 45 19 45 36 ("jazz.Object-Class" "jazz.Type")}
      {Lisp-Entry "jazz.walk-binding-lookup" generic/specific ("jazz.Walk-Binding~virtual") 49 22 49 46 ("source-declaration" "symbol")}
      {Lisp-Entry "jazz.walk-binding-referenced" generic/specific ("jazz.Walk-Binding~virtual") 50 22 50 50 ()}
      {Lisp-Entry "jazz.emit-binding-symbol" generic/specific ("jazz.Walk-Binding~virtual") 51 22 51 46 ("environment" "source-declaration")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.Walk-Binding~virtual") 52 22 52 49 ("environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.Walk-Binding~virtual") 53 22 53 53 ("form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-binding-call" generic/specific ("jazz.Walk-Binding~virtual") 54 22 54 44 ("environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "jazz.emit-inlined-binding-call" generic/specific ("jazz.Walk-Binding~virtual") 55 22 55 52 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "jazz.walk-binding-validate-assignment" generic/specific ("jazz.Walk-Binding~virtual") 56 22 56 59 ("symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-binding-assignable?" generic/specific ("jazz.Walk-Binding~virtual") 57 22 57 51 ()}
      {Lisp-Entry "jazz.emit-binding-assignment" generic/specific ("jazz.Walk-Binding~virtual") 58 22 58 50 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.walk-binding-walkable?" generic/specific ("jazz.Walk-Binding~virtual") 59 22 59 49 ()}
      {Lisp-Entry "jazz.walk-binding-walk-form" generic/specific ("jazz.Walk-Binding~virtual") 60 22 60 49 ("form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-binding-expandable?" generic/specific ("jazz.Walk-Binding~virtual") 61 22 61 51 ()}
      {Lisp-Entry "jazz.walk-binding-expand-form" generic/specific ("jazz.Walk-Binding~virtual") 62 22 62 51 ("form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.Lexical-Binding" define-class ("class") 70 19 70 39 ("%%set-lexical-binding-hits" "%%get-lexical-binding-hits" "hits" "%%get-lexical-binding-type" "type" "%%get-lexical-binding-name" "name" "jazz.Object-Class" "jazz.Walk-Binding")}
      {Lisp-Entry "jazz.resolve-binding" generic/specific ("jazz.Lexical-Binding~virtual") 76 22 76 42 ()}
      {Lisp-Entry "jazz.Declaration" define-class ("class") 84 19 84 35 ("%%set-declaration-source" "%%get-declaration-source" "source" "%%set-declaration-locator" "%%get-declaration-locator" "locator" "%%set-declaration-parent" "%%get-declaration-parent" "parent" "%%set-declaration-toplevel" "%%get-declaration-toplevel" "toplevel" "%%get-declaration-attributes" "attributes" "%%get-declaration-compatibility" "compatibility" "%%get-declaration-access" "access" "jazz.Object-Class" "hits" "type" "name" "jazz.Lexical-Binding")}
      {Lisp-Entry "jazz.lookup-declaration" generic/specific ("jazz.Declaration~virtual") 94 22 94 45 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz.update-declaration" generic/specific ("jazz.Declaration~virtual") 95 22 95 45 ("new-declaration")}
      {Lisp-Entry "jazz.get-declaration-inclusions" generic/specific ("jazz.Declaration~virtual") 96 22 96 53 ()}
      {Lisp-Entry "jazz.get-nextmethod-signature" generic/specific ("jazz.Declaration~virtual") 97 22 97 51 ()}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.Declaration~virtual") 98 22 98 43 ("environment")}
      {Lisp-Entry "jazz.expand-referenced-declaration" generic/specific ("jazz.Declaration~virtual") 99 22 99 56 ()}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.Declaration~virtual") 100 22 100 43 ("s" "k" "f")}
      {Lisp-Entry "jazz.Declaration-Reference" define-class ("class") 108 19 108 45 ("%%set-declaration-reference-declaration" "%%get-declaration-reference-declaration" "declaration" "%%get-declaration-reference-name" "name" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.resolve-reference" generic/specific ("jazz.Declaration-Reference~virtual") 113 22 113 44 ("module-declaration")}
      {Lisp-Entry "jazz.Module-Reference" define-class ("class") 121 19 121 40 ("jazz.allocate-module-reference" "jazz.Object-Class" "declaration" "name" "jazz.Declaration-Reference")}
      {Lisp-Entry "jazz.Export-Reference" define-class ("class") 130 19 130 40 ("%%get-export-reference-module-reference" "module-reference" "jazz.allocate-export-reference" "jazz.Object-Class" "declaration" "name" "jazz.Declaration-Reference")}
      {Lisp-Entry "jazz.Autoload-Reference" define-class ("class") 139 19 139 42 ("jazz.allocate-autoload-reference" "jazz.Object-Class" "module-reference" "declaration" "name" "jazz.Export-Reference")}
      {Lisp-Entry "jazz.Unit-Declaration" define-class ("class") 148 19 148 40 ("%%set-unit-declaration-requires" "%%get-unit-declaration-requires" "requires" "jazz.allocate-unit-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Namespace-Declaration" define-class ("class") 157 19 157 45 ("%%set-namespace-declaration-body" "%%get-namespace-declaration-body" "body" "%%get-namespace-declaration-children" "children" "%%get-namespace-declaration-lookups" "lookups" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "%%get-access-lookup" define-macro ("macro") 163 20 163 39 (",access" ",namespace-declaration" "%%get-namespace-declaration-lookups" "%%vector-ref" "access" "namespace-declaration")}
      {Lisp-Entry "jazz.Module-Declaration" define-class ("class") 172 19 172 42 ("%%get-module-declaration-local-macros" "local-macros" "%%set-module-declaration-inclusions" "%%get-module-declaration-inclusions" "inclusions" "%%get-module-declaration-proclaims" "proclaims" "%%set-module-declaration-imports" "%%get-module-declaration-imports" "imports" "%%set-module-declaration-exports" "%%get-module-declaration-exports" "exports" "%%set-module-declaration-requires" "%%get-module-declaration-requires" "requires" "%%get-module-declaration-dialect-invoice" "dialect-invoice" "%%get-module-declaration-dialect-name" "dialect-name" "%%set-module-declaration-walker" "%%get-module-declaration-walker" "walker" "jazz.allocate-module-declaration" "jazz.Object-Class" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Namespace-Declaration")}
      {Lisp-Entry "jazz.Module-Invoice" define-class ("class") 189 19 189 38 ("%%get-module-invoice-rename" "rename" "%%get-module-invoice-prefix" "prefix" "%%get-module-invoice-except" "except" "%%get-module-invoice-only" "only" "%%get-module-invoice-version" "version" "%%get-module-invoice-phase" "phase" "%%get-module-invoice-module" "module" "%%get-module-invoice-name" "name" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Export-Invoice" define-class ("class") 205 19 205 38 ("%%set-export-invoice-autoload" "%%get-export-invoice-autoload" "autoload" "jazz.allocate-export-invoice" "jazz.Object-Class" "rename" "prefix" "except" "only" "version" "phase" "module" "name" "jazz.Module-Invoice")}
      {Lisp-Entry "jazz.Import-Invoice" define-class ("class") 214 19 214 38 ("%%set-import-invoice-hit?" "%%get-import-invoice-hit?" "hit?" "jazz.allocate-import-invoice" "jazz.Object-Class" "rename" "prefix" "except" "only" "version" "phase" "module" "name" "jazz.Module-Invoice")}
      {Lisp-Entry "jazz.Export-Declaration" define-class ("class") 223 19 223 42 ("%%get-export-declaration-symbol" "symbol" "jazz.allocate-export-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Export-Syntax-Declaration" define-class ("class") 232 19 232 49 ("%%get-export-syntax-declaration-symbol" "symbol" "jazz.allocate-export-syntax-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Autoload-Declaration" define-class ("class") 241 19 241 44 ("%%set-autoload-declaration-declaration" "%%get-autoload-declaration-declaration" "declaration" "%%get-autoload-declaration-exported-module" "exported-module" "%%get-autoload-declaration-module" "module" "jazz.allocate-autoload-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Literal" define-class ("class") 252 19 252 31 ("%%get-literal-arguments" "arguments" "%%get-literal-name" "name" "jazz.allocate-literal" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Macro-Declaration" define-class ("class") 262 19 262 41 ("%%set-macro-declaration-body" "%%get-macro-declaration-body" "body" "%%set-macro-declaration-signature" "%%get-macro-declaration-signature" "signature" "jazz.allocate-macro-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Local-Macro-Declaration" define-class ("class") 272 19 272 47 ("%%set-local-macro-declaration-body" "%%get-local-macro-declaration-body" "body" "%%set-local-macro-declaration-signature" "%%get-local-macro-declaration-signature" "signature" "jazz.allocate-local-macro-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Syntax-Declaration" define-class ("class") 282 19 282 42 ("%%set-syntax-declaration-body" "%%get-syntax-declaration-body" "body" "%%set-syntax-declaration-signature" "%%get-syntax-declaration-signature" "signature" "jazz.allocate-syntax-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Define-Syntax-Declaration" define-class ("class") 292 19 292 49 ("jazz.allocate-define-syntax-declaration" "jazz.Object-Class" "body" "signature" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Syntax-Declaration")}
      {Lisp-Entry "jazz.Define-Local-Syntax-Declaration" define-class ("class") 301 19 301 55 ("jazz.allocate-define-local-syntax-declaration" "jazz.Object-Class" "body" "signature" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Syntax-Declaration")}
      {Lisp-Entry "jazz.Void-Class" define-class ("class") 310 19 310 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Void" define-class ("class") 314 19 314 28 ("jazz.Void-Class" "jazz.Type")}
      {Lisp-Entry "jazz.Opt-Type" define-class ("class") 323 19 323 32 ("%%get-opt-type-type" "type" "jazz.allocate-opt-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Key-Type" define-class ("class") 332 19 332 32 ("%%get-key-type-type" "type" "%%get-key-type-key" "key" "jazz.allocate-key-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Rest-Type" define-class ("class") 342 19 342 33 ("%%get-rest-type-type" "type" "jazz.allocate-rest-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Function-Type" define-class ("class") 351 19 351 37 ("%%get-function-type-result" "result" "%%get-function-type-rest" "rest" "%%get-function-type-named" "named" "%%get-function-type-optional" "optional" "%%get-function-type-positional" "positional" "%%get-function-type-mandatory" "mandatory" "jazz.allocate-function-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Category-Type" define-class ("class") 365 19 365 37 ("%%get-category-type-declaration" "declaration" "jazz.allocate-category-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Values-Type" define-class ("class") 374 19 374 35 ("%%get-values-type-types" "types" "jazz.allocate-values-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Restriction-Type" define-class ("class") 383 19 383 40 ("%%get-restriction-type-type" "type" "%%get-restriction-type-base" "base" "jazz.allocate-restriction-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Complement-Type" define-class ("class") 393 19 393 39 ("%%get-complement-type-type" "type" "jazz.allocate-complement-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Union-Type" define-class ("class") 402 19 402 34 ("%%get-union-type-types" "types" "jazz.allocate-union-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Template-Type" define-class ("class") 411 19 411 37 ("%%get-template-type-types" "types" "%%get-template-type-class" "class" "jazz.allocate-template-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Nillable-Type" define-class ("class") 421 19 421 37 ("%%get-nillable-type-type" "type" "jazz.allocate-nillable-type" "jazz.Class" "jazz.Type")}
      {Lisp-Entry "jazz.Any-Class" define-class ("class") 430 19 430 33 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz.Class")}
      {Lisp-Entry "jazz.Any" define-class ("class") 434 19 434 27 ("jazz.Any-Class" "jazz.Type")}
      {Lisp-Entry "jazz.C-Type-Declaration" define-class ("class") 443 19 443 42 ("%%get-c-type-declaration-declare" "declare" "%%get-c-type-declaration-scheme-to-c" "scheme-to-c" "%%get-c-type-declaration-c-to-scheme" "c-to-scheme" "%%get-c-type-declaration-inclusions" "inclusions" "%%set-c-type-declaration-pointer-types" "%%get-c-type-declaration-pointer-types" "pointer-types" "%%get-c-type-declaration-base-type" "base-type" "%%get-c-type-declaration-expansion" "expansion" "%%get-c-type-declaration-kind" "kind" "jazz.allocate-c-type-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.C-Definition-Declaration" define-class ("class") 459 19 459 48 ("%%set-c-definition-declaration-body" "%%get-c-definition-declaration-body" "body" "%%get-c-definition-declaration-scope" "scope" "%%get-c-definition-declaration-c-name" "c-name" "%%get-c-definition-declaration-result-type" "result-type" "%%get-c-definition-declaration-parameter-types" "parameter-types" "%%set-c-definition-declaration-signature" "%%get-c-definition-declaration-signature" "signature" "jazz.allocate-c-definition-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Walker" define-class ("class") 473 19 473 30 ("%%set-walker-autoloads" "%%get-walker-autoloads" "autoloads" "%%get-walker-references" "references" "%%get-walker-variables" "variables" "%%set-walker-literals" "%%get-walker-literals" "literals" "%%set-walker-errors" "%%get-walker-errors" "errors" "%%set-walker-warnings" "%%get-walker-warnings" "warnings" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.walker-bindings" generic/specific ("jazz.Walker~virtual") 482 22 482 42 ()}
      {Lisp-Entry "jazz.walker-environment" generic/specific ("jazz.Walker~virtual") 483 22 483 45 ()}
      {Lisp-Entry "jazz.walk-declaration" generic/specific ("jazz.Walker~virtual") 484 22 484 43 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-free-reference" generic/specific ("jazz.Walker~virtual") 485 22 485 46 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-symbol-assignment" generic/specific ("jazz.Walker~virtual") 486 22 486 49 ("value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-free-assignment" generic/specific ("jazz.Walker~virtual") 487 22 487 47 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-symbol" generic/specific ("jazz.Walker~virtual") 488 22 488 38 ("symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-form" generic/specific ("jazz.Walker~virtual") 489 22 489 36 ("form" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.validate-proclaim" generic/specific ("jazz.Walker~virtual") 490 22 490 44 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.validate-arguments" generic/specific ("jazz.Walker~virtual") 491 22 491 45 ("form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "jazz.runtime-export" generic/specific ("jazz.Walker~virtual") 492 22 492 41 ("declaration")}
      {Lisp-Entry "jazz.lookup-analyse" generic/specific ("jazz.Walker~virtual") 493 22 493 41 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "%%get-module-declaration-walker-literals" define #f 497 9 497 49 ("%%get-module-declaration-walker" "%%get-walker-literals" "lib-decl")}
      {Lisp-Entry "%%set-module-declaration-walker-literals" define #f 499 9 499 49 ("%%get-module-declaration-walker" "%%set-walker-literals" "value" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-variables" define #f 501 9 501 50 ("%%get-module-declaration-walker" "%%get-walker-variables" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-references" define #f 503 9 503 51 ("%%get-module-declaration-walker" "%%get-walker-references" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-autoloads" define #f 505 9 505 50 ("%%get-module-declaration-walker" "%%get-walker-autoloads" "lib-decl")}
      {Lisp-Entry "%%set-module-declaration-walker-autoloads" define #f 507 9 507 50 ("%%get-module-declaration-walker" "%%set-walker-autoloads" "value" "lib-decl")}
      {Lisp-Entry "jazz.Walk-Context" define-class ("class") 516 19 516 36 ("%%get-walk-context-pathname" "pathname" "%%get-walk-context-locator" "locator" "%%get-walk-context-policy" "policy" "jazz.allocate-walk-context" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Walk-Location" define-class ("class") 527 19 527 37 ("%%get-walk-location-path" "path" "%%get-walk-location-locat" "locat" "%%get-walk-location-declaration-locator" "declaration-locator" "%%get-walk-location-unit-locator" "unit-locator" "jazz.allocate-walk-location" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Walk-Problem" define-class ("class") 539 19 539 36 ("%%get-walk-problem-location" "location" "jazz.Object-Class" "message" "jazz.Error")}
      {Lisp-Entry "jazz.Walk-Problems" define-class ("class") 548 19 548 37 ("%%get-walk-problems-errors" "errors" "%%get-walk-problems-warnings" "warnings" "jazz.allocate-walk-problems" "jazz.Object-Class" "message" "jazz.Error")}
      {Lisp-Entry "jazz.Walk-Warning" define-class ("class") 558 19 558 36 ("jazz.allocate-walk-warning" "jazz.Object-Class" "location" "message" "jazz.Walk-Problem")}
      {Lisp-Entry "jazz.Walk-Error" define-class ("class") 567 19 567 34 ("jazz.allocate-walk-error" "jazz.Object-Class" "location" "message" "jazz.Walk-Problem")}
      {Lisp-Entry "jazz.Unresolved-Error" define-class ("class") 576 19 576 40 ("%%get-unresolved-error-symbol" "symbol" "jazz.allocate-unresolved-error" "jazz.Object-Class" "location" "message" "jazz.Walk-Error")}
      {Lisp-Entry "jazz.Walk-Frame" define-class ("class") 585 19 585 34 ("%%get-walk-frame-bindings" "bindings" "jazz.allocate-walk-frame" "jazz.Object-Class" "jazz.Walk-Binding")}
      {Lisp-Entry "jazz.Signature" define-class ("class") 594 19 594 33 ("%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "%%get-signature-mandatory" "mandatory" "jazz.allocate-signature" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Symbol-Binding" define-class ("class") 607 19 607 38 ("%%set-symbol-binding-gensym" "%%get-symbol-binding-gensym" "gensym" "jazz.Object-Class" "hits" "type" "name" "jazz.Lexical-Binding")}
      {Lisp-Entry "jazz.Variable" define-class ("class") 616 19 616 32 ("%%set-variable-reference-count" "%%get-variable-reference-count" "reference-count" "jazz.allocate-variable" "jazz.Object-Class" "gensym" "hits" "type" "name" "jazz.Symbol-Binding")}
      {Lisp-Entry "jazz.NextMethod-Variable" define-class ("class") 625 19 625 43 ("jazz.allocate-nextmethod-variable" "jazz.Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz.Variable")}
      {Lisp-Entry "jazz.Parameter" define-class ("class") 634 19 634 33 ("jazz.allocate-parameter" "jazz.Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz.Variable")}
      {Lisp-Entry "jazz.emit-parameter" generic/specific ("jazz.Parameter~virtual") 638 22 638 41 ("environment" "declaration")}
      {Lisp-Entry "jazz.Dynamic-Parameter" define-class ("class") 646 19 646 41 ("%%get-dynamic-parameter-class" "class" "jazz.allocate-dynamic-parameter" "jazz.Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz.Parameter")}
      {Lisp-Entry "jazz.Optional-Parameter" define-class ("class") 655 19 655 42 ("%%set-optional-parameter-default" "%%get-optional-parameter-default" "default" "jazz.allocate-optional-parameter" "jazz.Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz.Parameter")}
      {Lisp-Entry "jazz.Named-Parameter" define-class ("class") 664 19 664 39 ("%%set-named-parameter-default" "%%get-named-parameter-default" "default" "jazz.allocate-named-parameter" "jazz.Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz.Parameter")}
      {Lisp-Entry "jazz.Rest-Parameter" define-class ("class") 673 19 673 38 ("jazz.allocate-rest-parameter" "jazz.Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz.Parameter")}
      {Lisp-Entry "jazz.Self-Binding" define-class ("class") 682 19 682 36 ("jazz.allocate-self-binding" "jazz.Object-Class" "hits" "type" "name" "jazz.Lexical-Binding")}
      {Lisp-Entry "jazz.Dynamic-Self-Binding" define-class ("class") 691 19 691 44 ("%%get-dynamic-self-binding-code" "code" "jazz.allocate-dynamic-self-binding" "jazz.Object-Class" "hits" "type" "name" "jazz.Lexical-Binding")}
      {Lisp-Entry "jazz.Local-Variable-Binding" define-class ("class") 700 19 700 46 ("%%get-local-variable-binding-variable" "variable" "jazz.allocate-local-variable-binding" "jazz.Object-Class" "hits" "type" "name" "jazz.Lexical-Binding")}
      {Lisp-Entry "jazz.Macro-Symbol" define-class ("class") 709 19 709 36 ("%%get-macro-symbol-setter" "setter" "%%get-macro-symbol-getter" "getter" "jazz.allocate-macro-symbol" "jazz.Object-Class" "gensym" "hits" "type" "name" "jazz.Symbol-Binding")}
      {Lisp-Entry "jazz.Form-Binding" define-class ("class") 719 19 719 36 ("jazz.Object-Class" "hits" "type" "name" "jazz.Lexical-Binding")}
      {Lisp-Entry "jazz.Special-Form" define-class ("class") 728 19 728 36 ("%%get-special-form-walk" "walk" "jazz.allocate-special-form" "jazz.Object-Class" "hits" "type" "name" "jazz.Form-Binding")}
      {Lisp-Entry "jazz.Macro-Form" define-class ("class") 737 19 737 34 ("%%get-macro-form-expander" "expander" "jazz.allocate-macro-form" "jazz.Object-Class" "hits" "type" "name" "jazz.Form-Binding")}
      {Lisp-Entry "jazz.Syntax-Form" define-class ("class") 746 19 746 35 ("%%get-syntax-form-expander" "expander" "jazz.allocate-syntax-form" "jazz.Object-Class" "hits" "type" "name" "jazz.Form-Binding")}
      {Lisp-Entry "jazz.Define-Syntax-Form" define-class ("class") 755 19 755 42 ("%%get-define-syntax-form-environment" "environment" "jazz.allocate-define-syntax-form" "jazz.Object-Class" "expander" "hits" "type" "name" "jazz.Syntax-Form")}
      {Lisp-Entry "jazz.Define-Local-Syntax-Form" define-class ("class") 764 19 764 48 ("%%get-define-local-syntax-form-environment" "environment" "jazz.allocate-define-local-syntax-form" "jazz.Object-Class" "expander" "hits" "type" "name" "jazz.Syntax-Form")}
      {Lisp-Entry "jazz.Syntactic-Closure" define-class ("class") 773 19 773 41 ("%%get-syntactic-closure-form" "form" "%%get-syntactic-closure-variables" "variables" "%%get-syntactic-closure-environment" "environment" "jazz.allocate-syntactic-closure" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Annotated-Variable" define-class ("class") 784 19 784 42 ("%%set-annotated-variable-type" "%%get-annotated-variable-type" "type" "%%get-annotated-variable-declared-type" "declared-type" "%%get-annotated-variable-variable" "variable" "jazz.allocate-annotated-variable" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Restricted-Binding" define-class ("class") 795 19 795 42 ("%%get-restricted-binding-type" "type" "%%get-restricted-binding-binding" "binding" "jazz.allocate-restricted-binding" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Annotated-Frame" define-class ("class") 805 19 805 39 ("%%get-annotated-frame-reset" "reset" "%%get-annotated-frame-variables" "variables" "jazz.allocate-annotated-frame" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Code" define-class ("class") 815 19 815 28 ("%%get-code-source" "source" "%%get-code-type" "type" "%%get-code-form" "form" "jazz.allocate-code" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Access" define-class ("class") 827 19 827 30 ("%%get-access-context" "context" "%%get-access-name" "name" "jazz.allocate-access" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Expression" define-class ("class") 837 19 837 34 ("%%get-expression-source" "source" "%%get-expression-type" "type" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Expression~virtual") 842 22 842 42 ("environment" "declaration")}
      {Lisp-Entry "jazz.emit-call" generic/specific ("jazz.Expression~virtual") 843 22 843 36 ("environment" "declaration" "arguments")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Expression~virtual") 844 22 844 42 ("s" "k" "f")}
      {Lisp-Entry "jazz.Proclaim" define-class ("class") 852 19 852 32 ("%%get-proclaim-clauses" "clauses" "jazz.allocate-proclaim" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Constant" define-class ("class") 861 19 861 32 ("%%get-constant-expansion" "expansion" "jazz.allocate-constant" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Delay" define-class ("class") 870 19 870 29 ("%%get-delay-expression" "expression" "jazz.allocate-delay" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Quasiquote" define-class ("class") 879 19 879 34 ("%%get-quasiquote-form" "form" "jazz.allocate-quasiquote" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Binding-Reference" define-class ("class") 888 19 888 41 ("%%get-reference-binding" "binding" "jazz.allocate-binding-reference" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Reference-Reification" define-class ("class") 897 19 897 45 ("%%get-reference-reification-resolver" "resolver" "jazz.allocate-reference-reification" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Method-Reference" define-class ("class") 906 19 906 40 ("jazz.allocate-method-reference" "jazz.Object-Class" "binding" "source" "type" "jazz.Binding-Reference")}
      {Lisp-Entry "jazz.Assignment" define-class ("class") 915 19 915 34 ("%%get-assignment-value" "value" "%%get-assignment-binding" "binding" "jazz.allocate-assignment" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Lambda" define-class ("class") 925 19 925 30 ("%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "jazz.allocate-lambda" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Let" define-class ("class") 935 19 935 27 ("%%get-let-body" "body" "%%get-let-bindings" "bindings" "jazz.allocate-let" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Named-Let" define-class ("class") 945 19 945 33 ("%%get-named-let-variable" "variable" "jazz.allocate-named-let" "jazz.Object-Class" "body" "bindings" "source" "type" "jazz.Let")}
      {Lisp-Entry "jazz.Letstar" define-class ("class") 954 19 954 31 ("%%get-letstar-body" "body" "%%get-letstar-bindings" "bindings" "jazz.allocate-letstar" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Letrec" define-class ("class") 964 19 964 30 ("%%get-letrec-body" "body" "%%get-letrec-bindings" "bindings" "jazz.allocate-letrec" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Receive" define-class ("class") 974 19 974 31 ("%%get-receive-body" "body" "%%get-receive-expression" "expression" "%%get-receive-variables" "variables" "jazz.allocate-receive" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Body" define-class ("class") 985 19 985 28 ("%%get-body-expressions" "expressions" "%%get-body-internal-defines" "internal-defines" "jazz.allocate-body" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Internal-Define" define-class ("class") 995 19 995 39 ("%%get-internal-define-value" "value" "%%get-internal-define-variable" "variable" "jazz.allocate-internal-define" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Begin" define-class ("class") 1005 19 1005 29 ("%%get-begin-expressions" "expressions" "jazz.allocate-begin" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Do" define-class ("class") 1014 19 1014 26 ("%%get-do-body" "body" "%%get-do-result" "result" "%%get-do-test" "test" "%%get-do-bindings" "bindings" "jazz.allocate-do" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Call" define-class ("class") 1026 19 1026 28 ("%%get-call-arguments" "arguments" "%%get-call-operator" "operator" "jazz.allocate-call" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.If" define-class ("class") 1036 19 1036 26 ("%%get-if-no" "no" "%%get-if-yes" "yes" "%%get-if-test" "test" "jazz.allocate-if" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Cond" define-class ("class") 1047 19 1047 28 ("%%get-cond-clauses" "clauses" "jazz.allocate-cond" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Case" define-class ("class") 1056 19 1056 28 ("%%get-case-clauses" "clauses" "%%get-case-target" "target" "jazz.allocate-case" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.And" define-class ("class") 1066 19 1066 27 ("%%get-and-expressions" "expressions" "jazz.allocate-and" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Or" define-class ("class") 1075 19 1075 26 ("%%get-or-expressions" "expressions" "jazz.allocate-or" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Declare" define-class ("class") 1084 19 1084 31 ("%%get-declare-declarations" "declarations" "jazz.allocate-declare" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.C-Include" define-class ("class") 1093 19 1093 33 ("%%get-c-include-name" "name" "jazz.allocate-c-include" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.C-Declare" define-class ("class") 1102 19 1102 33 ("%%get-c-declare-code" "code" "jazz.allocate-c-declare" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.C-Named-Declare-Declaration" define-class ("class") 1111 19 1111 51 ("%%get-c-named-declare-declaration-code" "code" "jazz.allocate-c-named-declare-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.C-Initialize" define-class ("class") 1120 19 1120 36 ("%%get-c-initialize-code" "code" "jazz.allocate-c-initialize" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.C-Function" define-class ("class") 1129 19 1129 34 ("%%get-c-function-expansion" "expansion" "jazz.allocate-c-function" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Parameterize" define-class ("class") 1138 19 1138 36 ("%%get-parameterize-body" "body" "%%get-parameterize-bindings" "bindings" "jazz.allocate-parameterize" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Time-Special" define-class ("class") 1148 19 1148 36 ("%%get-time-special-expressions" "expressions" "jazz.allocate-time" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Analysis-Data" define-class ("class") 1157 19 1157 37 ("%%set-analysis-data-declaration-references" "%%get-analysis-data-declaration-references" "declaration-references" "%%set-analysis-data-autoload-reference" "%%get-analysis-data-autoload-reference" "autoload-reference" "jazz.allocate-analysis-data" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Core-Dialect" define-class ("class") 1167 19 1167 36 ("jazz.allocate-core-dialect" "jazz.Object-Class" "bindings" "jazz.Dialect")}
      {Lisp-Entry "jazz.Core-Walker" define-class ("class") 1176 19 1176 35 ("jazz.allocate-core-walker" "jazz.Object-Class" "autoloads" "references" "variables" "literals" "errors" "warnings" "jazz.Walker")}}})
"define-class"
 ({Lisp-File-Entry {File core "src" "core" "class" "syntax" "define-class.scm"} 1288732032
    {Lisp-Entry "core.class.syntax.define-class" unit #f 37 16 37 46 ()
      {Lisp-Entry "jazz.define-class" define-macro ("macro") 40 20 40 37 (",inherited-slot-names" "',inherited-slot-names" ",',inherited-slot-names" "',',inherited-slot-names" "jazz.validate-inherited-slots" "jazz.identifier-name" "jazz.set-core-class" ",instance-size" "',instance-size" ",',instance-size" ",slot-names" "',slot-names" ",',slot-names" "',',slot-names" ",ascendant-accessor" "',ascendant-accessor" ",',ascendant-accessor" "eq?" "test:" "%%make-table" "',',name" ",class-accessor" "',class-accessor" ",',class-accessor" "jazz.new-core-class" "',name" ",',name" "%%string-append" "%%string->symbol" "jazz.naturals" "'%%object-set!" "%%object-set!" "value" ",slot-setter" "'%%object-ref" ",rank" "%%object-ref" "jazz.expected-error" "jazz.object-of-class?" "%%core-assertion" "object" ",slot-getter" "%%cddr" "slot-setter" "%%cadr" "slot-getter" "%%car" "let" "rank" "slot" "%%object" "'%%object" "%%list" ",@all-variables" "class" ",constructor" "jazz.define-macro" ",name" "jazz.define-variable" "jazz.debug-core?" "begin" "jazz.object-size" "%%fx+" "instance-size" "all-length" "%%symbol->string" "jazz.generate-symbol" "slot-name" "lambda" "all-variables" "%%append" "all-slot-names" "car" "map" "slot-names" "%%length" "ascendant-size" "ascendant-accessor" "%%null?" "if" "class-accessor" "let*" "proc" "jazz.parse-define-class" "define" "slots" "constructor" "class-name" "inherited-slot-names" "ascendant-name" "name")}
      {Lisp-Entry "jazz.define-class-runtime" define-macro ("macro") 95 20 95 45 ("%%symbol->string" "%%string-append" "%%string->symbol" "name")}}})
"define-method"
 ({Lisp-File-Entry {File core "src" "core" "class" "syntax" "define-method.scm"} 1288732032
    {Lisp-Entry "core.class.syntax.define-method" unit #f 37 16 37 47 ()
      {Lisp-Entry "jazz.define-virtual" define-macro ("macro") 40 20 40 39 ("jazz.expand-define-virtual" "%%car" "%%null?" "if" "bootstrap-type?" "let" "rest" "signature")}
      {Lisp-Entry "jazz.define-virtual-runtime" define-macro ("macro") 45 20 45 47 ("jazz.expand-define-virtual-runtime" "signature")}
      {Lisp-Entry "jazz.define-method" define-macro ("macro") 49 20 49 38 ("jazz.expand-define-method" "body" "signature")}}})
"define-method-expander"
 ({Lisp-File-Entry {File core "src" "core" "class" "syntax" "define-method-expander.scm"} 1288732032
    {Lisp-Entry "core.class.syntax.define-method-expander" unit #f 37 16 37 56 ()
      {Lisp-Entry "jazz.expand-define-virtual" define #f 40 9 40 35 ("obj" "lambda" "jazz.with-uniqueness" ",rank-name" "',rank-name" "%%get-object-class" "'%%get-object-class" "%%get-class-core-vtable" "'%%get-class-core-vtable" "%%vector-ref" "'%%vector-ref" "',name" "jazz.format" "jazz.error" "'jazz.error" ",class-name" "',class-name" ",is-test" "',is-test" "%%core-assertion" "'%%core-assertion" "%%list" "%%symbol?" ",@extra-parameters" ",object-parameter" ",name" "jazz.define-macro" "%%class-is?" "'%%class-is?" "jazz.bootstrap-type?" "'jazz.bootstrap-type?" "if" "is-test" "jazz.method-rank-name" "rank-name" "jazz.method-implementation-name" "implementation-name" "extra-parameters" "%%cadr" "object-parameter" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "bootstrap-type?" "signature")}
      {Lisp-Entry "jazz.expand-define-virtual-runtime" define #f 75 9 75 43 (",name" "',name" ",class-name" "jazz.register-virtual-name" ",rank-name" "define" "jazz.method-rank-name" "rank-name" "jazz.method-implementation-name" "implementation-name" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "signature")}
      {Lisp-Entry "jazz.expand-define-method" define #f 85 9 85 34 ("jazz.register-method" ",@body" ",@extra-parameters" ",object-parameter" "lambda" ",name" "',name" ",class-name" "jazz.find-nextmethod" "nextmethod" "let" ",implementation-name" "define" "begin" "jazz.method-implementation-name" "implementation-name" "extra-parameters" "%%cadr" "object-parameter" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "body" "signature")}
      {Lisp-Entry "jazz.method-implementation-name" define #f 100 9 100 40 ("%%string-append" "%%string->symbol" "%%symbol->string" "jazz.split-string" "jazz.last" "let" "name" "class-name")}
      {Lisp-Entry "jazz.method-rank-name" define #f 105 9 105 30 ("%%symbol->string" "%%string-append" "%%string->symbol" "implementation-name")}
      {Lisp-Entry "jazz.inherited-name?" define #f 109 9 109 29 ("%%get-class-core-virtual-names" "%%memq" "and" "%%get-class-ascendant" "ascendant" "let" "method-name" "class")}
      {Lisp-Entry "jazz.register-virtual-name" define #f 115 9 115 35 ("1" "%%length" "%%fx-" "%%list" "%%get-class-core-virtual-names" "%%append" "%%set-class-core-virtual-names" "method-name" "class")}
      {Lisp-Entry "jazz.register-method" define #f 123 9 123 29 ("%%get-class-core-virtual-alist" "%%set-class-core-virtual-alist" "%%cons" "%%list" "%%get-class-core-method-alist" "%%append" "%%set-class-core-method-alist" "jazz.inherited-name?" "if" "method-implementation" "method-name" "class")}
      {Lisp-Entry "jazz.get-method-rank" define #f 133 9 133 29 ("1" "%%fx+" "%%cdr" "%%car" "%%eq?" "jazz.error" "%%null?" "if" "0" "rank" "%%get-class-core-virtual-names" "scan" "iter" "let" "method-name" "class")}
      {Lisp-Entry "jazz.get-method-implementation" define #f 143 9 143 39 ("jazz.get-method-rank" "%%get-class-core-vtable" "%%vector-ref" "method-name" "class")}
      {Lisp-Entry "jazz.find-nextmethod" define #f 148 9 148 29 ("jazz.error" "rest" "obj" "lambda" "%%get-class-ascendant" "jazz.get-method-implementation" "jazz.inherited-name?" "if" "method-name" "class")}}})
"development"
 ({Lisp-File-Entry {File core "src" "core" "module" "development.scm"} 1288732032
    {Lisp-Entry "core.module.development" unit #f 38 6 38 29 ()
      {Lisp-Entry "jazz.parse" define #f 49 9 49 19 ("jazz.desourcify-all" "pretty-print" "jazz.read-toplevel-form" "form-src" "jazz.find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "jazz.parse-source" define #f 56 9 56 26 ("jazz.present-source" "pretty-print" "jazz.read-toplevel-form" "form-src" "jazz.find-unit-src" "src" "let*" "interpret" "'interpret" "jazz.walk-for" "parameterize" "unit-name")}
      {Lisp-Entry "jazz.expand-unit" define #f 69 9 69 25 ("jazz.expand-module-source" "module" "jazz.expand-unit-source" "unit" "case" "0" "jazz.generate-symbol-counter" "jazz.generate-symbol-context" "jazz.generate-symbol-for" "jazz.requested-unit-resource" "jazz.requested-unit-name" "cdr" "rest" "car" "jazz.source-code" "kind" "jazz.read-toplevel-form" "form" "jazz.find-unit-src" "src" "let*" "walk" "'walk" "or" "jazz.walk-for" "parameterize" "walk-for" "#!key" "unit-name")}
      {Lisp-Entry "jazz.expand" define #f 85 9 85 20 ("current-output-port" "jazz.expand-to-port" "apply" "rest" "unit-name")}
      {Lisp-Entry "jazz.expand-to-port" define #f 89 9 89 28 ("jazz.expand-unit" "apply" "jazz.desourcify-all" "pretty-print" "rest" "port" "unit-name")}
      {Lisp-Entry "jazz.expand-to-file" define #f 95 9 95 28 ("jazz.expand-to-port" "apply" "port" "lambda" "or" "call-with-output-file" "jazz.scheme-readtable" "current-readtable" "parameterize" "rest" "#!rest" "file" "#!key" "unit-name")}
      {Lisp-Entry "jazz.expand-source" define #f 102 9 102 27 ("jazz.expand-unit" "apply" "jazz.present-source" "pretty-print" "rest" "unit-name")}
      {Lisp-Entry "jazz.lookup" define #f 113 9 113 20 ("jazz.walk-unit" "jazz.lookup-declaration" "access" "name" "module-name")}}})
"error"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "error.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.error" unit #f 37 16 37 39 ()
      {Lisp-Entry "jazz.unimplemented" define #f 40 9 40 27 ("%%car" "jazz.error" "%%null?" "if" "rest")}}}
  {Lisp-File-Entry {File core "src" "core" "class" "syntax" "error.scm"} 1288732032
    {Lisp-Entry "core.class.syntax.error" unit #f 37 16 37 39 ()
      {Lisp-Entry "jazz.object-of-class?" define-macro ("variable") 40 22 40 43 ()}
      {Lisp-Entry "jazz.not-object-error" define #f 43 9 43 30 ("jazz.error" "obj")}
      {Lisp-Entry "jazz.outside-object-error" define #f 47 9 47 34 ("jazz.error" "rnk" "obj")}
      {Lisp-Entry "jazz.expected-error" define #f 51 9 51 28 ("jazz.error" "obj" "class")}}}
  {Lisp-File-Entry {File core "src" "core" "exception" "runtime" "error.scm"} 1288732032
    {Lisp-Entry "core.exception.runtime.error" unit #f 37 16 37 44 ("jazz.raise-jazz-error" "jazz.error" "set!" "jazz.Error" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Error" define-class ("class runtime") 40 27 40 37 ()}
      {Lisp-Entry "jazz.new-error" define #f 43 9 43 23 ("jazz.Error" "jazz.allocate-error" "message")}
      {Lisp-Entry "jazz.get-message" generic/specific ("jazz.Error") 47 21 47 37 ("error" "%%get-error-message")}
      {Lisp-Entry "jazz.present-exception" generic/specific ("jazz.Error") 51 21 51 43 ("error" "%%get-error-message")}
      {Lisp-Entry "jazz.raise-jazz-error" define #f 58 9 58 30 ("jazz.new-error" "raise" "jazz.format" "apply" "message" "let" "proper-tail-calls" "declare" "rest" "fmt-string")}}})
"exception"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "exception.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.exception" unit #f 38 16 38 43 ()
      {Lisp-Entry "jazz.current-exception-handler" define #f 43 12 43 42 ("current-exception-handler")}
      {Lisp-Entry "jazz.with-exception-handler" define #f 46 13 46 40 ("continuation-return" "exc" "with-exception-handler" "return" "lambda" "continuation-capture" "thunk" "proc")}
      {Lisp-Entry "jazz.exception-reason" define #f 54 13 54 34 ("jazz.format" "%%not" "if" "'arguments" "arguments" "'message" "message" "'location" "'exc" "condition-property-accessor" "location" "let" "exc")}
      {Lisp-Entry "jazz.current-exception-handler" define #f 63 12 63 42 ("current-exception-handler")}
      {Lisp-Entry "jazz.with-exception-handler" define #f 66 12 66 39 ("with-exception-handler")}
      {Lisp-Entry "jazz.with-exception-catcher" define #f 69 12 69 39 ("with-exception-catcher")}
      {Lisp-Entry "jazz.display-exception" define #f 72 12 72 34 ("display-exception")}
      {Lisp-Entry "jazz.display-continuation-backtrace" define #f 75 12 75 47 ("display-continuation-backtrace")}
      {Lisp-Entry "jazz.raise" define #f 78 13 78 23 ("raise" "obj")}}}
  {Lisp-File-Entry {File core "src" "core" "exception" "runtime" "exception.scm"} 1288732032
    {Lisp-Entry "core.exception.runtime.exception" unit #f 37 16 37 48 ("newline" "jazz.present-exception" "display" "begin" "%%is?" "%%object?" "and" "if" "port" "exc" "lambda" "set!" "##display-exception-hook" "previous-hook" "let" "jazz.System-Exception" "jazz.Exception-Detail" "jazz.Exception" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Exception" define-class ("class runtime") 45 27 45 41 ()}
      {Lisp-Entry "jazz.print-object" generic/specific ("jazz.Exception") 48 21 48 38 ("if" "jazz.object->serial" "jazz.format" "exception" "jazz.get-message" "message" "let" "detail" "output")}
      {Lisp-Entry "jazz.present-exception" generic/specific ("jazz.Exception~virtual-runtime") 56 30 56 52 ()}
      {Lisp-Entry "jazz.get-message" generic/specific ("jazz.Exception~virtual-runtime") 57 30 57 46 ()}
      {Lisp-Entry "jazz.get-detail" generic/specific ("jazz.Exception~virtual-runtime") 58 30 58 45 ()}
      {Lisp-Entry "jazz.present-exception" generic/specific ("jazz.Exception") 61 21 61 43 ("get-output-string" "exception" "jazz.format" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz.get-message" generic/specific ("jazz.Exception") 67 21 67 37 ()}
      {Lisp-Entry "jazz.get-detail" generic/specific ("jazz.Exception") 71 21 71 36 ()}
      {Lisp-Entry "jazz.Exception-Detail" define-class ("class runtime") 83 27 83 48 ()}
      {Lisp-Entry "jazz.new-exception-detail" define #f 86 9 86 34 ("jazz.Exception-Detail" "jazz.allocate-exception-detail" "children" "location" "title" "icon")}
      {Lisp-Entry "jazz.System-Exception" define-class ("class runtime") 98 27 98 48 ()}
      {Lisp-Entry "jazz.present-exception" generic/specific ("jazz.System-Exception") 101 21 101 43 ("exception" "%%get-system-exception-exception" "jazz.exception-reason")}
      {Lisp-Entry "jazz.exception-reason" define #f 113 9 113 30 ("%%substring" "1" "%%fx-" "%%string-ref" "%%eqv?" "0" "%%fx>" "and" "if" "string-length" "len" "get-output-string" "str" "jazz.display-exception" "open-output-string" "output" "let" "exc")}
      {Lisp-Entry "jazz.exception-detail" define #f 124 9 124 30 ("jazz.get-detail" "jazz.Exception" "%%is?" "%%object?" "and" "if" "exc")}
      {Lisp-Entry "jazz.exception-location" define #f 131 9 131 32 ("##exception->locat" "cont" "exc")}}})
"expander"
 ({Lisp-File-Entry {File core "src" "core" "generic" "syntax" "expander.scm"} 1288732032
    {Lisp-Entry "core.generic.syntax.expander" unit #f 38 16 38 44 ()
      {Lisp-Entry "jazz.dynamic-parameter?" define #f 41 9 41 32 ("%%cdr" "jazz.composite-name?" "or" "%%car" "type" "let" "%%pair?" "and" "parameter")}
      {Lisp-Entry "jazz.dynamic-parameter-type" define #f 49 9 49 36 ("jazz.specifier->name" "jazz.specifier?" "if" "%%car" "type" "let" "parameter")}
      {Lisp-Entry "jazz.dynamic-parameter-types" define #f 56 9 56 37 ("%%cdr" "jazz.dynamic-parameter-type" "%%cons" "%%car" "jazz.dynamic-parameter?" "%%pair?" "and" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "jazz.dynamic-parameter-name" define #f 65 9 65 36 ("%%cadr" "parameter")}
      {Lisp-Entry "jazz.dynamic-parameter-names" define #f 69 9 69 37 ("%%cdr" "jazz.dynamic-parameter-name" "%%cons" "%%car" "jazz.dynamic-parameter?" "%%pair?" "and" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "jazz.generic-parameters" define #f 78 9 78 32 ("jazz.reverse!" "values" "else" "%%symbol?" "jazz.dynamic-parameter-name" "%%cons" "%%cdr" "jazz.dynamic-parameter?" "cond" "%%car" "parameter" "%%pair?" "if" "result" "iterate" "let" "parameters")}
      {Lisp-Entry "jazz.specific-parameters" define #f 92 9 92 33 ("else" "%%cdr" "jazz.dynamic-parameter-name" "%%cons" "jazz.dynamic-parameter?" "cond" "%%car" "parameter" "%%pair?" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "jazz.expand-define-generic" define #f 108 9 108 35 ("apply" "jazz.dynamic-parameter-names" ",parameter" "jazz.class-of" "parameter" "map" "%%specific-dispatch" ",gensym-specific" "jazz.process-pending-specifics" "%%get-generic-pending-specifics" "%%not" "%%when" ",gensym-rest" ",@mandatory-parameters" ",@dynamic-signature" "%%list" "',generic-method-locator" "jazz.new-generic" "jazz.generic-reset" "jazz.global-ref" ",gensym-generic" "',generic-locator" "jazz.global-bound?" ",generic-locator" ",@body" ",generic-method-locator" "jazz.error" ",formal-signature" "lambda" ",specific-implementation-locator" "define" "begin" "%%null?" "if" "gensym-rest" "let" "jazz.generic-parameters" "extra-parameters" "mandatory-parameters" "receive" "gensym-specific" "jazz.generate-symbol" "gensym-generic" "jazz.generic-object-locator" "generic-locator" "jazz.implementation-locator" "specific-implementation-locator" "jazz.specific-parameters" "formal-signature" "jazz.dynamic-parameter-types" "dynamic-signature" "%%cdr" "parameters" "%%car" "generic-method-locator" "let*" "body" "signature")}
      {Lisp-Entry "jazz.generic-object-locator" define #f 144 9 144 36 ("%%symbol->string" "%%string-append" "%%string->symbol" "locator")}
      {Lisp-Entry "jazz.expand-define-specific" define #f 153 9 153 36 (",generic-locator" "jazz.register-specific" "%%set-specific-implementation" ",@body" ",@nextmethod-bindings" "let" ",formal-signature" ",gensym-lambda" ",@dynamic-signature" "lambda" "jazz.new-specific" ",specific-implementation-locator" "define" ",gensym-specific" "%%get-specific-ancestor-specifics" "%%get-specific-implementation" "nextmethod" "%%list" "if" "nextmethod-bindings" "gensym-lambda" "jazz.generate-symbol" "gensym-specific" "jazz.generic-object-locator" "generic-locator" "jazz.implementation-locator" "specific-implementation-locator" "jazz.specific-parameters" "formal-signature" "jazz.dynamic-parameter-types" "dynamic-signature" "%%cdr" "parameters" "%%car" "generic-method-locator" "root" "'root" "%%eq?" "root?" "let*" "body" "modifier" "signature")}
      {Lisp-Entry "jazz.implementation-locator" define #f 174 9 174 36 ("jazz.join-strings" "%%string-append" "%%string->symbol" "%%car" "%%pair?" "if" "class/call" "lambda" "map" "dynamic-signature-strings" "%%symbol->string" "generic-string" "let" "dynamic-signature" "generic-locator")}}})
"expression"
 ({Lisp-File-Entry {File core "src" "core" "module" "syntax" "walker" "expression.scm"} 1289938304
    {Lisp-Entry "core.module.syntax.walker.expression" unit #f 37 16 37 52 ("jazz.Time-Special" "jazz.Parameterize" "jazz.Declare" "jazz.Or" "jazz.And" "jazz.Case" "jazz.Cond" "jazz.If" "jazz.dialect.kernel.not-null?" "'jazz.dialect.kernel.not-null?" "jazz.not-type-tests" "jazz.Unspecified" "jazz.dialect.kernel.unspecified?" "'jazz.dialect.kernel.unspecified?" "jazz.Values" "jazz.dialect.kernel.values?" "'jazz.dialect.kernel.values?" "jazz.Foreign" "jazz.dialect.kernel.foreign?" "'jazz.dialect.kernel.foreign?" "jazz.Thread" "jazz.dialect.kernel.thread?" "'jazz.dialect.kernel.thread?" "jazz.Table" "jazz.dialect.kernel.table?" "'jazz.dialect.kernel.table?" "jazz.Method" "jazz.dialect.kernel.method?" "'jazz.dialect.kernel.method?" "jazz.Slot" "jazz.dialect.kernel.slot?" "'jazz.dialect.kernel.slot?" "jazz.Field" "jazz.dialect.kernel.field?" "'jazz.dialect.kernel.field?" "jazz.Interface" "jazz.dialect.kernel.interface?" "'jazz.dialect.kernel.interface?" "jazz.Class" "jazz.dialect.kernel.class?" "'jazz.dialect.kernel.class?" "jazz.Category" "jazz.dialect.kernel.category?" "'jazz.dialect.kernel.category?" "jazz.Object" "jazz.dialect.kernel.object?" "'jazz.dialect.kernel.object?" "jazz.Keyword" "jazz.dialect.kernel.keyword?" "'jazz.dialect.kernel.keyword?" "jazz.Flonum" "jazz.dialect.kernel.flonum?" "'jazz.dialect.kernel.flonum?" "jazz.Fixnum" "jazz.dialect.kernel.fixnum?" "'jazz.dialect.kernel.fixnum?" "jazz.EOF" "scheme.dialect.kernel.eof-object?" "'scheme.dialect.kernel.eof-object?" "scheme.dialect.kernel.output-port?" "'scheme.dialect.kernel.output-port?" "jazz.Port" "scheme.dialect.kernel.input-port?" "'scheme.dialect.kernel.input-port?" "jazz.Procedure" "scheme.dialect.kernel.procedure?" "'scheme.dialect.kernel.procedure?" "jazz.Continuation" "jazz.dialect.kernel.continuation?" "'jazz.dialect.kernel.continuation?" "jazz.F64Vector" "jazz.dialect.kernel.f64vector?" "'jazz.dialect.kernel.f64vector?" "jazz.F32Vector" "jazz.dialect.kernel.f32vector?" "'jazz.dialect.kernel.f32vector?" "jazz.U64Vector" "jazz.dialect.kernel.u64vector?" "'jazz.dialect.kernel.u64vector?" "jazz.S64Vector" "jazz.dialect.kernel.s64vector?" "'jazz.dialect.kernel.s64vector?" "jazz.U32Vector" "jazz.dialect.kernel.u32vector?" "'jazz.dialect.kernel.u32vector?" "jazz.S32Vector" "jazz.dialect.kernel.s32vector?" "'jazz.dialect.kernel.s32vector?" "jazz.U16Vector" "jazz.dialect.kernel.u16vector?" "'jazz.dialect.kernel.u16vector?" "jazz.S16Vector" "jazz.dialect.kernel.s16vector?" "'jazz.dialect.kernel.s16vector?" "jazz.U8Vector" "jazz.dialect.kernel.u8vector?" "'jazz.dialect.kernel.u8vector?" "jazz.S8Vector" "jazz.dialect.kernel.s8vector?" "'jazz.dialect.kernel.s8vector?" "jazz.Vector" "scheme.dialect.kernel.vector?" "'scheme.dialect.kernel.vector?" "jazz.String" "scheme.dialect.kernel.string?" "'scheme.dialect.kernel.string?" "jazz.Char" "scheme.dialect.kernel.char?" "'scheme.dialect.kernel.char?" "jazz.Symbol" "scheme.dialect.kernel.symbol?" "'scheme.dialect.kernel.symbol?" "jazz.Pair" "scheme.dialect.kernel.pair?" "'scheme.dialect.kernel.pair?" "jazz.Null" "scheme.dialect.kernel.null?" "'scheme.dialect.kernel.null?" "jazz.List" "scheme.dialect.kernel.list?" "'scheme.dialect.kernel.list?" "jazz.Boolean" "scheme.dialect.kernel.boolean?" "'scheme.dialect.kernel.boolean?" "jazz.Integer" "scheme.dialect.kernel.integer?" "'scheme.dialect.kernel.integer?" "jazz.Rational" "scheme.dialect.kernel.rational?" "'scheme.dialect.kernel.rational?" "jazz.Real" "scheme.dialect.kernel.real?" "'scheme.dialect.kernel.real?" "jazz.Complex" "scheme.dialect.kernel.complex?" "'scheme.dialect.kernel.complex?" "jazz.Number" "scheme.dialect.kernel.number?" "'scheme.dialect.kernel.number?" "jazz.type-tests" "%%table-set!" "jazz.emit-inlined-call" ",name" "name" "jazz.bind" "jazz.identifier-name" "primitive" "'primitive" "jazz.get-primitive-patterns" "patterns" "jazz.emit-primitive-call" "##string-set!" "##vector-set!" "jazz.dialect.language.functional.set-element!" "'jazz.dialect.language.functional.set-element!" "##string-ref" "##vector-ref" "list-ref" "jazz.dialect.language.functional.element" "'jazz.dialect.language.functional.element" "##string-length" "##vector-length" "##length" "scheme.dialect.kernel.length" "'scheme.dialect.kernel.length" "##cdr" "scheme.dialect.kernel.cdr" "'scheme.dialect.kernel.cdr" "##car" "scheme.dialect.kernel.car" "'scheme.dialect.kernel.car" "##eqv?" "scheme.dialect.kernel.eqv?" "'scheme.dialect.kernel.eqv?" "##eq?" "scheme.dialect.kernel.eq?" "'scheme.dialect.kernel.eq?" "##not" "scheme.dialect.kernel.not" "'scheme.dialect.kernel.not" "##flonum->fixnum" "jazz.dialect.kernel.flonum->fixnum" "'jazz.dialect.kernel.flonum->fixnum" "##fixnum->flonum" "jazz.dialect.kernel.fixnum->flonum" "'jazz.dialect.kernel.fixnum->flonum" "jazz.dialect.kernel.fl/" "'jazz.dialect.kernel.fl/" "jazz.dialect.kernel.fl*" "'jazz.dialect.kernel.fl*" "jazz.dialect.kernel.fl-" "'jazz.dialect.kernel.fl-" "jazz.dialect.kernel.fl+" "'jazz.dialect.kernel.fl+" "jazz.dialect.kernel.fx*" "'jazz.dialect.kernel.fx*" "jazz.dialect.kernel.fx-" "'jazz.dialect.kernel.fx-" "jazz.dialect.kernel.fx+" "'jazz.dialect.kernel.fx+" "##flround" "scheme.dialect.kernel.round" "'scheme.dialect.kernel.round" "##fltruncate" "scheme.dialect.kernel.truncate" "'scheme.dialect.kernel.truncate" "##flceiling" "scheme.dialect.kernel.ceiling" "'scheme.dialect.kernel.ceiling" "##flfloor" "scheme.dialect.kernel.floor" "'scheme.dialect.kernel.floor" "##fxquotient" "scheme.dialect.kernel.quotient" "'scheme.dialect.kernel.quotient" "##/" "##fl/" "'scheme.dialect.kernel./" "##*" "##fl*" "##fx*" "'scheme.dialect.kernel.*" "##-" "##fl-" "##fx-" "'scheme.dialect.kernel.-" "##+" "##fl+" "##fx+" "'scheme.dialect.kernel.+" "##fl>=" "##fx>=" "'scheme.dialect.kernel.>=" "##fl>" "##fx>" "'scheme.dialect.kernel.>" "##fl<=" "##fx<=" "'scheme.dialect.kernel.<=" "##fl<" "##fx<" "'scheme.dialect.kernel.<" "##=" "##fl=" "##fx=" "'scheme.dialect.kernel.=" "jazz.add-primitive-patterns" "jazz.emit-primitive-new-call" "%%cdr" "%%get-function-type-result" "jazz.codes-forms" ",locator" "jazz.new-code" "jazz.emit-inlined-binding-call" "jazz.match-signature?" "%%get-lexical-binding-type" "function-type" "%%car" "specializer" "on" "'on" "jazz.debug-specializers" "%%get-lexical-binding-name" "specialized" "'specialized" "'call" "match" "'match" "to" "'to" "unable" "'unable" "%%get-declaration-locator" "In" "'In" "Warning:" "'Warning:" "jazz.debug" "scheme.dialect.kernel./" "scheme.dialect.kernel.*" "scheme.dialect.kernel.-" "scheme.dialect.kernel.+" "scheme.dialect.kernel.>=" "scheme.dialect.kernel.>" "scheme.dialect.kernel.<=" "scheme.dialect.kernel.<" "scheme.dialect.kernel.=" "%%memq" "optimizations" "'optimizations" "%%get-declaration-toplevel" "jazz.get-module-warn?" "jazz.warnings?" "and" "%%when" "begin" "%%null?" "scan" "iter" "jazz.codes-types" "types" "jazz.get-specializers" "specializers" "%%get-reference-binding" "binding" "let" "jazz.Binding-Reference" "%%class-is?" "jazz.emit-specialized-locator" "or" "%%not" "if" "environment" "declaration" "call" "arguments-codes" "arguments" "locator" "operator" "lambda" "jazz.emit-specialized-call" "set!" "jazz.Do" "jazz.Receive" "jazz.Letrec" "jazz.Letstar" "jazz.Named-Let" "jazz.Let" "jazz.Lambda" "jazz.Method-Reference" "jazz.Quasiquote" "jazz.Delay" "jazz.Proclaim" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Proclaim" define-class ("class runtime") 45 27 45 40 ()}
      {Lisp-Entry "jazz.new-proclaim" define #f 48 9 48 26 ("jazz.Proclaim" "jazz.allocate-proclaim" "clauses")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Proclaim") 52 21 52 41 ("jazz.proclaim" "clause" "lambda" "for-each" "%%get-declaration-toplevel" "module-declaration" "expression" "%%get-proclaim-clauses" "clauses" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Proclaim") 61 21 61 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Delay" define-class ("class runtime") 73 27 73 37 ()}
      {Lisp-Entry "jazz.new-delay" define #f 76 9 76 23 ("jazz.Delay" "jazz.allocate-delay" "expression")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Delay") 80 21 80 41 ("jazz.Any" "jazz.emit-expression" "jazz.sourcified-form" "delay" "jazz.new-code" "%%get-delay-expression" "expression" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Delay") 88 21 88 41 ("%%get-delay-expression" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Quasiquote" define-class ("class runtime") 102 27 102 42 ()}
      {Lisp-Entry "jazz.new-quasiquote" define #f 105 9 105 28 ("jazz.Quasiquote" "jazz.allocate-quasiquote" "form")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Quasiquote") 109 21 109 41 ("jazz.List" "expression" "%%get-quasiquote-form" "quasiquote" "'quasiquote" "jazz.new-code" "%%cdr" "%%cons" "%%cadr" "jazz.emit-expression" "jazz.sourcified-form" "%%list" "unquote-splicing" "'unquote-splicing" "unquote" "'unquote" "%%car" "%%eq?" "or" "%%pair?" "if" "form" "lambda" "emit" "letrec" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Quasiquote") 124 21 124 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Method-Reference" define-class ("class runtime") 136 27 136 48 ()}
      {Lisp-Entry "jazz.new-method-reference" define #f 139 9 139 34 ("jazz.Method-Reference" "jazz.allocate-method-reference" "binding")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Method-Reference") 143 21 143 41 ("jazz.Any" "%%get-lexical-binding-type" "or" "%%get-declaration-locator" "jazz.new-code" "expression" "%%get-reference-binding" "method-declaration" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.emit-call" generic/specific ("jazz.Method-Reference") 152 21 152 35 ("jazz.Any" "jazz.codes-forms" "expression" "jazz.emit-expression" "jazz.sourcified-form" "jazz.new-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Method-Reference") 159 21 159 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Lambda" define-class ("class runtime") 171 27 171 38 ()}
      {Lisp-Entry "jazz.new-lambda" define #f 174 9 174 24 ("jazz.Lambda" "jazz.allocate-lambda" "body" "signature" "source" "type")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Lambda") 178 21 178 41 ("%%get-expression-source" "jazz.new-function-type" ",@signature-casts" ",cast-body" ",signature-output" "%%not" "if" "%%get-code-type" "jazz.sourcified-form" "begin" "jazz.new-code" "jazz.emit-type-cast" "jazz.simplify-begin" "cast-body" "jazz.emit-signature-casts" "signature-casts" "jazz.emit-expression" "body-code" "jazz.emit-signature" "signature-output" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "expression" "%%get-expression-type" "type" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Lambda") 201 21 201 41 ("%%get-lambda-body" "jazz.fold-statement" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Lambda") 207 21 207 35 ("%%get-lambda-body" "jazz.tree-fold" "cons" "aug-env" "let" "frame" "lambda" "expression" "%%get-lambda-signature" "jazz.annotate-signature" "jazz.with-annotated-frame" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Let" define-class ("class runtime") 225 27 225 35 ()}
      {Lisp-Entry "jazz.new-let" define #f 228 9 228 21 ("jazz.Let" "jazz.allocate-let" "body" "bindings" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Let") 232 21 232 41 ("%%get-expression-source" "jazz.sourcified-form" ",bindings-output" "jazz.new-code" "body-code" "%%get-lexical-binding-type" "jazz.emit-type-cast" "jazz.emit-binding-symbol" "%%get-code-type" "jazz.extend-annotated-type" "jazz.emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz.annotate-bindings" "jazz.with-annotated-frame" "%%get-let-body" "body" "expression" "%%get-let-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Let") 256 21 256 41 ("%%get-let-body" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Let") 262 21 262 35 ("%%get-let-body" "jazz.tree-fold" "cdr" "jazz.tree-fold-list" "seed2" "seed1" "car" "map" "cons" "aug-env" "expression" "%%get-let-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Named-Let" define-class ("class runtime") 278 27 278 41 ()}
      {Lisp-Entry "jazz.new-named-let" define #f 281 9 281 27 ("jazz.Named-Let" "jazz.allocate-named-let" "body" "bindings" "variable" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Named-Let") 285 21 285 41 ("%%get-expression-source" "jazz.sourcified-form" ",bindings-output" "jazz.new-code" "body-code" "%%get-lexical-binding-type" "jazz.emit-type-cast" "jazz.emit-binding-symbol" "%%get-code-type" "jazz.extend-annotated-type" "jazz.emit-expression" "value-code" "%%cdr" "value" "%%car" "annotated-variable" "binding" "map" "bindings-output" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz.annotate-bindings" "jazz.Any" "jazz.new-annotated-variable" "%%cons" "jazz.with-annotated-frame" "%%get-let-body" "body" "%%get-let-bindings" "bindings" "expression" "%%get-named-let-variable" "variable" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Named-Let") 310 21 310 41 ("%%get-let-body" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Named-Let") 316 21 316 35 ("%%get-let-body" "jazz.tree-fold" "cdr" "jazz.tree-fold-list" "seed2" "seed1" "car" "map" "%%get-named-let-variable" "cons" "aug-env" "expression" "%%get-let-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Letstar" define-class ("class runtime") 332 27 332 39 ()}
      {Lisp-Entry "jazz.new-letstar" define #f 335 9 335 25 ("jazz.Letstar" "jazz.allocate-letstar" "body" "bindings" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Letstar") 339 21 339 41 ("%%get-expression-source" "jazz.sourcified-form" ",bindings-output" "let*" "jazz.new-code" "body-code" "%%get-lexical-binding-type" "jazz.emit-type-cast" "jazz.emit-binding-symbol" "%%get-code-type" "jazz.extend-annotated-type" "jazz.emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz.annotate-bindings" "jazz.with-annotated-frame" "%%get-letstar-body" "body" "expression" "%%get-letstar-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Letstar") 363 21 363 41 ("%%get-letstar-body" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Letstar") 369 21 369 35 ("%%get-letstar-body" "caar" "list" "cons" "cdar" "jazz.tree-fold" "cdr" "pair?" "if" "aug-env" "seed2" "expression" "%%get-letstar-bindings" "ls" "lp" "let" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Letrec" define-class ("class runtime") 388 27 388 38 ()}
      {Lisp-Entry "jazz.new-letrec" define #f 391 9 391 24 ("jazz.Letrec" "jazz.allocate-letrec" "body" "bindings" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Letrec") 395 21 395 41 ("%%get-expression-source" "jazz.sourcified-form" ",bindings-output" "letrec" "jazz.new-code" "body-code" "%%get-lexical-binding-type" "jazz.emit-type-cast" "jazz.emit-binding-symbol" "%%get-code-type" "jazz.extend-annotated-type" "jazz.emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz.annotate-bindings" "jazz.with-annotated-frame" "%%get-letrec-body" "body" "expression" "%%get-letrec-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Letrec") 419 21 419 41 ("%%get-letrec-body" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Letrec") 425 21 425 35 ("%%get-letrec-body" "jazz.tree-fold" "cdr" "jazz.tree-fold-list" "seed2" "seed1" "car" "map" "cons" "aug-env" "expression" "%%get-letrec-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Receive" define-class ("class runtime") 441 27 441 39 ()}
      {Lisp-Entry "jazz.new-receive" define #f 444 9 444 25 ("jazz.Receive" "jazz.allocate-receive" "body" "expression" "variables" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Receive") 448 21 448 41 ("%%get-expression-source" "%%get-code-type" ",expression-output" "jazz.emit-binding-symbol" "variable" "map" "receive" "jazz.new-code" "body-code" "jazz.emit-expression" "jazz.sourcified-form" "expression-output" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-receive" "jazz.with-annotated-frame" "%%get-receive-body" "body" "%%get-receive-expression" "expr" "expression" "%%get-receive-variables" "variables" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Receive") 467 21 467 41 ("%%get-receive-body" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Receive") 473 21 473 35 ("%%get-receive-body" "%%get-receive-expression" "jazz.tree-fold" "seed2" "seed1" "expression" "%%get-receive-variables" "cons" "aug-env" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Do" define-class ("class runtime") 488 27 488 34 ()}
      {Lisp-Entry "jazz.new-do" define #f 491 9 491 20 ("jazz.Do" "jazz.allocate-do" "body" "result" "test" "bindings")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Do") 495 21 495 41 ("%%get-code-type" ",bindings-output" "do" "jazz.new-code" "body-code" "result-code" "test-code" ",@step-code-list" ",init-code" "jazz.emit-binding-symbol" "%%list" "if" "step-code-list" "jazz.emit-expression" "jazz.sourcified-form" "init-code" "%%cddr" "step" "%%cadr" "init" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz.annotate-bindings" "jazz.with-annotated-frame" "%%get-do-body" "body" "%%get-do-result" "result" "%%get-do-test" "test" "expression" "%%get-do-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Do") 527 21 527 41 ("%%get-do-body" "%%get-do-result" "%%get-do-test" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Do") 535 21 535 35 ("%%get-do-test" "%%get-do-body" "%%get-do-result" "jazz.tree-fold" "cddr" "or" "x" "lambda" "seed2" "cadr" "jazz.tree-fold-list" "seed1" "expression" "%%get-do-bindings" "car" "map" "cons" "aug-env" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.specializers" define #f 559 8 559 25 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.add-specializer" define #f 563 9 563 29 ("%%list" "%%table-ref" "%%append" "jazz.specializers" "%%table-set!" "specializer" "specialized-declaration")}
      {Lisp-Entry "jazz.get-specializers" define #f 569 9 569 30 ("jazz.specializers" "%%table-ref" "binding")}
      {Lisp-Entry "jazz.emit-specialized-locator" define #f 615 8 615 37 ()}
      {Lisp-Entry "jazz.primitive-patterns" define #f 650 8 650 31 ()}
      {Lisp-Entry "jazz.initialize-primitive-patterns" define #f 654 9 654 43 ("set!" "jazz.primitive-patterns" "jazz.walk-specifier" "%%list" "%%cadr" "specifier" "name" "pattern" "map" "%%table-set!" "%%cdr" "patterns" "%%car" "operator" "pair" "lambda" "for-each" "eq?" "test:" "%%make-table" "table" "let")}
      {Lisp-Entry "jazz.add-primitive-patterns" define #f 669 9 669 36 ("%%cons" "jazz.primitive-patterns" "set!" "patterns" "operator")}
      {Lisp-Entry "jazz.get-primitive-patterns" define #f 673 9 673 36 ("jazz.primitive-patterns" "%%table-ref" "locator")}
      {Lisp-Entry "jazz.match-signature?" define #f 764 9 764 30 ("list-tail" "lambda" "jazz.every?" "%%get-rest-type-type" "match-rest?" "else" "%%cdr" "%%car" "cond" "expected" "types" "args" "iter" "%%null?" "%%not" "%%fx<=" "%%fx>=" "match-positional?" "jazz.Any" "%%subtype?" "%%get-category-type-declaration" "%%get-reference-binding" "%%eq?" "jazz.Binding-Reference" "and" "or" "jazz.Category-Type" "%%class-is?" "if" "expect" "type" "arg" "match?" "define" "%%get-function-type-rest" "rest" "%%get-function-type-named" "named" "%%get-function-type-optional" "optional" "%%get-function-type-positional" "positional" "%%get-function-type-mandatory" "mandatory" "%%length" "argcount" "let" "function-type" "argument-types" "arguments")}
      {Lisp-Entry "jazz.If" define-class ("class runtime") 813 27 813 34 ()}
      {Lisp-Entry "jazz.new-if" define #f 816 9 816 20 ("jazz.If" "jazz.allocate-if" "no" "yes" "test" "source")}
      {Lisp-Entry "jazz.type-tests" define #f 820 8 820 23 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.not-type-tests" define #f 871 8 871 27 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.restrict-type" define #f 878 9 878 27 ("jazz.new-restriction-type" "type" "base")}
      {Lisp-Entry "jazz.restriction-of?" define #f 882 9 882 29 ("%%get-restriction-type-type" "jazz.Restriction-Type" "%%class-is?" "and" "class" "type")}
      {Lisp-Entry "jazz.complement-type" define #f 887 9 887 29 ("jazz.new-complement-type" "jazz.new-restriction-type" "%%get-restriction-type-type" "%%get-complement-type-type" "%%get-restriction-type-base" "%%eq?" "jazz.Complement-Type" "jazz.restriction-of?" "and" "if" "type" "base")}
      {Lisp-Entry "jazz.branch-types" define #f 894 9 894 26 ("%%get-nillable-type-type" "jazz.Nillable-Type" "jazz.not-type-tests" "jazz.type-tests" "%%table-ref" "class" "jazz.dialect.language.functional.is-not?" "%%cadr" "2" "jazz.dialect.kernel.is?" "1" "%%fx=" "scheme.dialect.kernel.not" "case" "%%length" "count" "%%get-call-arguments" "arguments" "%%get-declaration-locator" "operator-locator" "operator-binding" "%%get-call-operator" "operator" "jazz.Call" "%%get-or-expressions" "jazz.Or" "%%get-and-expressions" "jazz.And" "%%get-lexical-binding-type" "values" "%%get-annotated-variable-variable" "jazz.find-annotated" "actual-variable" "frame" "jazz.Variable" "no" "jazz.new-restricted-binding" "%%list" "jazz.new-annotated-frame" "yes" "jazz.Pair" "jazz.Null" "jazz.List" "%%eq?" "no-type" "else" "jazz.resolve-binding" "jazz.Declaration" "%%get-reference-binding" "binding" "jazz.Binding-Reference" "%%class-is?" "jazz.type?" "cond" "yes-type" "extract-binding" "actual-type" "origin" "receive" "type-expr" "process-is" "process-or" "%%cons" "%%cdr" "newenv" "%%car" "%%null?" "if" "augmented" "scan" "iter" "let" "expr-list" "process-and" "process-expr" "revenv" "env" "expr" "process-not" "define" "environment" "test")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.If") 1015 21 1015 41 ("%%get-expression-source" "%%get-code-type" "jazz.extend-type" "jazz.simplify-begin" "jazz.sourcified-form" "if" "jazz.new-code" "%%get-if-no" "no" "%%get-if-yes" "yes" "jazz.emit-expression" "jazz.branch-types" "no-environment" "yes-environment" "jazz.bind" "expression" "%%get-if-test" "test" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.If") 1029 21 1029 41 ("%%get-if-no" "%%get-if-yes" "%%get-if-test" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.If") 1037 21 1037 35 ("%%get-if-test" "%%get-if-yes" "%%get-if-no" "jazz.tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Cond" define-class ("class runtime") 1059 27 1059 36 ()}
      {Lisp-Entry "jazz.new-cond" define #f 1062 9 1062 22 ("jazz.Cond" "jazz.allocate-cond" "clauses" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Cond") 1066 21 1066 41 ("%%get-expression-source" "%%get-code-type" "lambda" "map" "jazz.extend-types" "%%cdr" "%%cons" "=>" "jazz.emit-expression" "jazz.sourcified-form" "else" "'else" "%%not" "output" "jazz.branch-types" "no-environment" "yes-environment" "jazz.bind" "%%cddr" "body" "%%cadr" "arrow?" "test" "%%car" "clause" "%%null?" "if" "recurse" "cond" "jazz.new-code" "expression" "%%get-cond-clauses" "clauses" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Cond") 1092 21 1092 41 ("%%get-cond-clauses" "jazz.fold-expression" "%%not" "if" "%%cdr" "body" "%%car" "test" "let" "clause" "lambda" "map" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Cond") 1104 21 1104 35 ("%%not" "%%cdr" "jazz.tree-fold" "%%cddr" "body" "test" "%%car" "clause" "let*" "null?" "if" "%%get-cond-clauses" "ls" "fold" "let" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Case" define-class ("class runtime") 1130 27 1130 36 ()}
      {Lisp-Entry "jazz.new-case" define #f 1133 9 1133 22 ("jazz.Case" "jazz.allocate-case" "clauses" "target" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Case") 1137 21 1137 41 ("%%get-expression-source" "%%get-code-type" "jazz.extend-types" ",tries" "%%car" "tries" "emited-clause" "jazz.sourcified-form" "case" "jazz.new-code" "jazz.emit-expression" "%%cdr" "body" "clause" "lambda" "map" "emited-clauses" "%%get-case-clauses" "clauses" "expression" "%%get-case-target" "target" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Case") 1157 21 1157 41 ("%%get-case-clauses" "cdr" "map" "jazz.fold-expressions" "%%get-case-target" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Case") 1163 21 1163 35 ("%%get-case-target" "jazz.tree-fold" "%%get-case-clauses" "cdr" "map" "jazz.tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.And" define-class ("class runtime") 1181 27 1181 35 ()}
      {Lisp-Entry "jazz.new-and" define #f 1184 9 1184 21 ("jazz.And" "jazz.allocate-and" "expressions" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.And") 1188 21 1188 41 ("%%get-expression-source" "jazz.Any" "expression" "%%get-and-expressions" "jazz.emit-expressions" "jazz.codes-forms" "and" "jazz.new-code" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.And") 1195 21 1195 41 ("%%get-and-expressions" "jazz.fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.And") 1200 21 1200 35 ("%%get-and-expressions" "jazz.tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Or" define-class ("class runtime") 1216 27 1216 34 ()}
      {Lisp-Entry "jazz.new-or" define #f 1219 9 1219 20 ("jazz.Or" "jazz.allocate-or" "expressions" "source")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Or") 1223 21 1223 41 ("%%get-expression-source" "jazz.Any" "expression" "%%get-or-expressions" "jazz.emit-expressions" "jazz.codes-forms" "or" "jazz.new-code" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Or") 1230 21 1230 41 ("%%get-or-expressions" "jazz.fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Or") 1235 21 1235 35 ("%%get-or-expressions" "jazz.tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Declare" define-class ("class runtime") 1251 27 1251 39 ()}
      {Lisp-Entry "jazz.new-declare" define #f 1254 9 1254 25 ("jazz.Declare" "jazz.allocate-declare" "declarations")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Declare") 1258 21 1258 41 ("jazz.Any" ",@declarations" "declare" "jazz.new-code" "expression" "%%get-declare-declarations" "declarations" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Declare") 1266 21 1266 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Parameterize" define-class ("class runtime") 1278 27 1278 44 ()}
      {Lisp-Entry "jazz.new-parameterize" define #f 1281 9 1281 30 ("jazz.Parameterize" "jazz.allocate-parameterize" "body" "bindings")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Parameterize") 1285 21 1285 41 ("%%get-code-type" "jazz.sourcified-form" "%%cdr" "value" "%%car" "variable" "binding" "lambda" "map" "parameterize" "jazz.new-code" "jazz.emit-expression" "body-code" "%%get-parameterize-body" "body" "expression" "%%get-parameterize-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Parameterize") 1301 21 1301 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Parameterize") 1305 21 1305 35 ("%%get-parameterize-body" "jazz.tree-fold" "expression" "%%get-parameterize-bindings" "cdr" "map" "jazz.tree-fold-list" "seed2" "let" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Time-Special" define-class ("class runtime") 1321 27 1321 44 ()}
      {Lisp-Entry "jazz.new-time-special" define #f 1324 9 1324 30 ("jazz.Time-Special" "jazz.allocate-time" "expressions")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.Time-Special") 1328 21 1328 41 ("jazz.Any" "jazz.emit-expressions" "jazz.codes-forms" "begin" "time" "jazz.new-code" "expression" "%%get-time-special-expressions" "expressions" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.Time-Special") 1338 21 1338 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.validate-proclaim" generic/specific ("jazz.Walker~virtual-runtime") 1350 30 1350 52 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.validate-proclaim" generic/specific ("jazz.Walker") 1353 21 1353 43 ("walker" "jazz.walk-error" "jazz.Module-Declaration" "%%class-is?" "%%not" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-proclaim" define #f 1358 9 1358 27 ("jazz.new-proclaim" "%%cdr" "clauses" "%%desourcify" "form" "let" "jazz.validate-proclaim" "form-src" "environment" "declaration" "resume" "walker")}}})
"ffi"
 ({Lisp-File-Entry {File core "src" "core" "module" "syntax" "walker" "ffi.scm"} 1288732032
    {Lisp-Entry "core.module.syntax.walker.ffi" unit #f 37 16 37 45 ("jazz.C-Function" "jazz.C-Initialize" "jazz.C-Named-Declare-Declaration" "jazz.C-Declare" "jazz.C-Include" "jazz.C-Definition-Declaration" "jazz.C-Type-Declaration" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.C-Type-Declaration" define-class ("class runtime") 45 27 45 50 ()}
      {Lisp-Entry "jazz.new-c-type-declaration" define #f 48 9 48 36 ("jazz.setup-declaration" "jazz.C-Type-Declaration" "jazz.allocate-c-type-declaration" "new-declaration" "let" "declare" "scheme-to-c" "c-to-scheme" "inclusions" "base-type" "expansion" "kind" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.get-declaration-inclusions" generic/specific ("jazz.C-Type-Declaration") 54 21 54 52 ("declaration" "%%get-c-type-declaration-inclusions")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.C-Type-Declaration") 58 21 58 42 ("begin" "environment")}
      {Lisp-Entry "jazz.expand-referenced-declaration" generic/specific ("jazz.C-Type-Declaration") 62 21 62 55 ("%%list" "and" "if" ",expansion" ",locator" "c-define-type" "%%get-c-type-declaration-scheme-to-c" "scheme-to-c" "%%get-c-type-declaration-c-to-scheme" "c-to-scheme" "%%get-c-type-declaration-expansion" "expansion" "declaration" "%%get-declaration-locator" "locator" "let")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.C-Type-Declaration") 72 21 72 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.C-Definition-Declaration" define-class ("class runtime") 84 27 84 56 ()}
      {Lisp-Entry "jazz.new-c-definition-declaration" define #f 87 9 87 42 ("jazz.setup-declaration" "jazz.C-Definition-Declaration" "jazz.allocate-c-definition-declaration" "new-declaration" "let" "scope" "c-name" "result-type" "parameter-types" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" generic/specific ("jazz.C-Definition-Declaration") 93 21 93 52 ("jazz.validate-arguments" "if" "declaration" "%%get-c-definition-declaration-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.C-Definition-Declaration") 99 21 99 42 ("%%get-declaration-source" "jazz.emit-expression" "jazz.sourcified-form" ",scope" ",c-name" ",result-type" ",parameter-types" "jazz.emit-signature" "c-define" "jazz.sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-c-definition-declaration-body" "body" "%%get-c-definition-declaration-scope" "scope" "%%get-c-definition-declaration-c-name" "c-name" "%%get-c-definition-declaration-result-type" "result-type" "%%get-c-definition-declaration-parameter-types" "parameter-types" "%%get-c-definition-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" generic/specific ("jazz.C-Definition-Declaration") 116 21 116 48 ("jazz.Any" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.C-Definition-Declaration") 123 21 123 42 ("%%get-c-definition-declaration-body" "jazz.fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.C-Include" define-class ("class runtime") 137 27 137 41 ()}
      {Lisp-Entry "jazz.new-c-include" define #f 140 9 140 27 ("jazz.C-Include" "jazz.allocate-c-include" "name")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.C-Include") 144 21 144 41 ("jazz.Any" "%%string-append" "c-declare" "jazz.new-code" "expression" "%%get-c-include-name" "name" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.C-Include") 152 21 152 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.C-Declare" define-class ("class runtime") 164 27 164 41 ()}
      {Lisp-Entry "jazz.new-c-declare" define #f 167 9 167 27 ("jazz.C-Declare" "jazz.allocate-c-declare" "code")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.C-Declare") 171 21 171 41 ("jazz.Any" ",code" "c-declare" "jazz.new-code" "expression" "%%get-c-declare-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.C-Declare") 179 21 179 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.C-Named-Declare-Declaration" define-class ("class runtime") 191 27 191 59 ()}
      {Lisp-Entry "jazz.new-c-named-declare-declaration" define #f 194 9 194 45 ("jazz.setup-declaration" "jazz.C-Named-Declare-Declaration" "jazz.allocate-c-named-declare-declaration" "new-declaration" "let" "code" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.emit-declaration" generic/specific ("jazz.C-Named-Declare-Declaration") 200 21 200 42 ("begin" "environment")}
      {Lisp-Entry "jazz.expand-referenced-declaration" generic/specific ("jazz.C-Named-Declare-Declaration") 204 21 204 55 (",code" "c-declare" "declaration" "%%get-c-named-declare-declaration-code" "code" "let")}
      {Lisp-Entry "jazz.fold-declaration" generic/specific ("jazz.C-Named-Declare-Declaration") 209 21 209 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.C-Initialize" define-class ("class runtime") 221 27 221 44 ()}
      {Lisp-Entry "jazz.new-c-initialize" define #f 224 9 224 30 ("jazz.C-Initialize" "jazz.allocate-c-initialize" "code")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.C-Initialize") 228 21 228 41 ("jazz.Any" ",code" "c-initialize" "jazz.new-code" "expression" "%%get-c-initialize-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.C-Initialize") 236 21 236 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.C-Function" define-class ("class runtime") 248 27 248 42 ()}
      {Lisp-Entry "jazz.new-c-function" define #f 251 9 251 28 ("jazz.C-Function" "jazz.allocate-c-function" "expansion")}
      {Lisp-Entry "jazz.emit-expression" generic/specific ("jazz.C-Function") 255 21 255 41 ("jazz.Any" "expression" "%%get-c-function-expansion" "jazz.new-code" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" generic/specific ("jazz.C-Function") 262 21 262 41 ("expression" "s" "k" "f")}}})
"generic"
 ({Lisp-File-Entry {File core "src" "core" "generic" "runtime" "generic.scm"} 1288732032
    {Lisp-Entry "core.generic.runtime.generic" unit #f 38 16 38 44 ()
      {Lisp-Entry "jazz.new-generic" define #f 41 9 41 25 ("jazz.generic-make-root" "jazz.Generic" "jazz.allocate-generic" "generic" "jazz.identifier-name" "name" "let*" "root-proc" "dynamic-signature" "locator")}
      {Lisp-Entry "jazz.generic-reset" define #f 48 9 48 27 ("%%get-generic-root-specific" "%%get-specific-dynamic-signature" "jazz.generic-make-root" "root-proc" "generic")}
      {Lisp-Entry "jazz.generic-make-root" define #f 52 9 52 31 ("%%get-generic-pending-specifics" "%%cons" "%%set-generic-pending-specifics" "%%set-generic-root-specific" "jazz.invalid-generic-call" "apply" "rest" "lambda" "or" "jazz.new-specific" "root-specific" "let" "root-proc" "dynamic-signature" "generic")}
      {Lisp-Entry "jazz.invalid-generic-call" define #f 58 9 58 34 ("jazz.generic-error" "%%cdr" "%%car" "jazz.class-of" "%%cons" "%%pair?" "and" "if" "%%get-generic-root-specific" "%%get-specific-dynamic-signature" "signature" "iter" "dynamic-parameters" "let" "rest" "generic")}
      {Lisp-Entry "jazz.generic-error" define #f 68 9 68 27 ("%%cons" "jazz.error" "%%get-generic-root-specific" "%%get-specific-dynamic-signature" "root-signature" "%%get-generic-name" "name" "let" "signature" "generic")}
      {Lisp-Entry "jazz.register-specific" define #f 80 9 80 31 ("%%get-generic-pending-specifics" "%%cons" "%%set-generic-pending-specifics" "specific" "generic")}
      {Lisp-Entry "jazz.process-pending-specifics" define #f 89 9 89 39 ("%%set-generic-pending-specifics" "%%get-generic-pending-specifics" "%%reverse" "jazz.insert/replace-specific" "specific" "lambda" "for-each" "%%get-generic-root-specific" "jazz.resolve-signature" "generic")}
      {Lisp-Entry "jazz.resolve-signature" define #f 99 9 99 31 ("%%set-specific-dynamic-signature" "%%procedure?" "%%when" "%%get-specific-dynamic-signature" "signature/proc" "let" "specific")}
      {Lisp-Entry "jazz.insert/replace-specific" define #f 105 9 105 37 ("%%set-car!" "%%set-generic-root-specific" "%%get-generic-root-specific" "perfect-match" "%%set-specific-descendant-specifics" "set!" "%%memq" "%%when" "else" "jazz.remove!" "%%get-specific-ancestor-specifics" "brothers" "brother-partition" "descendants" "%%assq" "descendant-partition" "assv" "jazz.dynamic-signature-compare" "ordered" "'ordered" "%%eq?" "descendant-signature" "descendant" "%%get-specific-descendant-specifics" "jazz.partition" "partition" "ancestor-signature" "ancestor" "lambda" "for-each" "%%set-specific-ancestor-specifics" "descendant-specifics" "ancestors" "jazz.generic-error" "%%not" "cond" "jazz.gather-dynamic-signature-ancestors" "matches" "%%get-specific-dynamic-signature" "dynamic-signature" "let*" "%%cons" "jazz.specific-better?" "%%pair?" "if" "others" "%%car" "best" "%%cdr" "scan" "iter" "let" "specifics" "put-best-first" "define" "specific" "generic")}
      {Lisp-Entry "jazz.gather-dynamic-signature-ancestors" define #f 180 9 180 48 ("%%null?" "else" "%%cons" "%%memq" "%%cdr" "%%get-specific-descendant-specifics" "found-in-descendants" "ordered" "set!" "equal" "%%get-specific-dynamic-signature" "jazz.dynamic-signature-compare" "case" "%%car" "specific" "%%pair?" "if" "partial-matches" "%%get-generic-root-specific" "%%list" "specifics" "iter" "or" "perfect-match" "let" "dynamic-signature" "generic")}
      {Lisp-Entry "jazz.dynamic-signature-compare" define #f 206 9 206 39 ("else" "ordered" "'ordered" "reverse-ordered" "'reverse-ordered" "jazz.subcategory?" "%%cdr" "%%car" "%%eq?" "cond" "unordered" "'unordered" "and" "%%null?" "or" "if" "equal" "'equal" "match" "iter" "let" "ancestor-signature" "descendant-signature")}
      {Lisp-Entry "jazz.dynamic-signature-equal?" define #f 228 9 228 38 ("%%cdr" "%%car" "%%eq?" "and" "%%null?" "or" "if" "iter" "let" "dynamic-signature2" "dynamic-signature1")}
      {Lisp-Entry "jazz.specific-better?" define #f 237 9 237 30 ("%%cdr" "%%car" "%%get-class-level" "%%fx>" "or" "signature2" "%%get-specific-dynamic-signature" "signature1" "iter" "let" "specific2" "specific1")}
      {Lisp-Entry "jazz.display-tree" define #f 249 9 249 26 ("1" "%%fx+" "newline" "%%get-specific-descendant-specifics" "%%get-specific-ancestor-specifics" "%%get-specific-dynamic-signature" "write" "specific" "lambda" "for-each" "0" "level" "%%get-generic-root-specific" "%%list" "specifics" "iterate" "let" "jazz.process-pending-specifics" "%%get-generic-pending-specifics" "%%null?" "%%not" "%%when" "generic")}
      {Lisp-Entry "jazz.dispatch-from-root" define #f 274 9 274 32 ("else" "%%car" "%%pair?" "jazz.generic-error" "%%not" "cond" "jazz.gather-dynamic-signature-ancestors" "matches" "let" "dynamic-classes" "generic")}}}
  {Lisp-File-Entry {File core "src" "core" "generic" "syntax" "generic.scm"} 1288732032
    {Lisp-Entry "core.generic.syntax.generic" unit #f 44 16 44 43 ("jazz.Generic" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Generic" define-class ("class") 47 19 47 31 ("%%set-generic-pending-specifics" "%%get-generic-pending-specifics" "pending-specifics" "%%set-generic-root-specific" "%%get-generic-root-specific" "root-specific" "%%get-generic-name" "name" "%%get-generic-locator" "locator" "jazz.allocate-generic" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Generic" define-class ("class runtime") 54 27 54 39 ()}
      {Lisp-Entry "jazz.define-generic" define-macro ("macro") 57 20 57 39 ("jazz.expand-define-generic" "%%apply" "rest")}
      {Lisp-Entry "%%specific-dispatch" define-macro ("macro") 61 20 61 39 (",dynamic-classes" ",generic" "jazz.dispatch-from-root" "%%get-specific-implementation" "dynamic-classes" "generic")}}})
"initialize"
 ({Lisp-File-Entry {File core "src" "core" "module" "initialize.scm"} 1288732032
    {Lisp-Entry "core.module.initialize" unit #f 37 16 37 38 ("jazz.initialize-primitive-patterns")}})
"keyword"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "keyword.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.keyword" unit #f 37 16 37 41 ()
      {Lisp-Entry "jazz.keyword?" define #f 42 13 42 26 ("keyword?" "obj")}
      {Lisp-Entry "jazz.keyword->string" define #f 45 13 45 33 ("keyword->string" "keyword")}
      {Lisp-Entry "jazz.string->keyword" define #f 48 13 48 33 ("string->keyword" "string")}
      {Lisp-Entry "jazz.keyword?" define #f 52 13 52 26 ("%%keyword?" "obj")}
      {Lisp-Entry "jazz.keyword->string" define #f 55 13 55 33 ("%%keyword->string" "keyword")}
      {Lisp-Entry "jazz.string->keyword" define #f 58 13 58 33 ("%%string->keyword" "string")}
      {Lisp-Entry "jazz.keyword?" define #f 62 12 62 25 ("1" "%%string-length" "%%fx-" "%%string-ref" "%%eqv?" "%%symbol->string" "str" "let" "%%symbol?" "and" "obj")}
      {Lisp-Entry "jazz.keyword->string" define #f 68 12 68 32 ("1" "%%length" "%%fx-" "0" "%%substring" "%%symbol->string" "str" "let" "keyword")}
      {Lisp-Entry "jazz.string->keyword" define #f 73 12 73 32 ("%%string-append" "%%string->symbol" "string")}}})
"list"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "list.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.list" unit #f 37 16 37 38 ()
      {Lisp-Entry "jazz.find-in" define #f 40 9 40 21 ("%%cdr" "%%car" "or" "%%null?" "if" "scan" "iter" "let" "lst" "proc")}
      {Lisp-Entry "jazz.find-if" define #f 48 9 48 21 ("%%cdr" "%%car" "value" "%%null?" "if" "scan" "iter" "let" "lst" "predicate")}
      {Lisp-Entry "jazz.getprop" define #f 58 9 58 21 ("%%cddr" "else" "%%car" "%%eqv?" "%%null?" "cond" "scan" "iter" "let" "target" "plist")}
      {Lisp-Entry "jazz.getf" define #f 68 9 68 18 ("%%cadr" "if" "jazz.getprop" "pair" "let" "not-found" "#!key" "target" "plist")}
      {Lisp-Entry "jazz.reverse!" define #f 75 8 75 21 ("reverse")}
      {Lisp-Entry "jazz.list-copy" define #f 79 9 79 23 ("obj" "lambda" "map" "lst")}
      {Lisp-Entry "jazz.last-tail" define #f 83 9 83 23 ("else" "%%null?" "cond" "%%cdr" "tail" "scan" "iter" "let" "%%pair?" "if" "lst")}
      {Lisp-Entry "jazz.last-pair" define #f 96 9 96 23 ("%%cdr" "tail" "scan" "iter" "let" "%%pair?" "if" "lst")}
      {Lisp-Entry "jazz.last" define #f 106 9 106 18 ("jazz.last-pair" "%%car" "lst")}
      {Lisp-Entry "jazz.remove-duplicates" define #f 110 9 110 31 ("%%cons" "%%memv" "%%cdr" "result" "%%car" "value" "%%not-null?" "if" "scan" "iter" "let" "lst")}
      {Lisp-Entry "jazz.partition" define #f 121 9 121 23 ("%%set-cdr!" "begin" "%%list" "%%cons" "%%not" "set" "category" "%%car" "element" "%%cdr" "partition" "let*" "%%null?" "if" "scan" "iter" "let" "associate" "key" "lst")}
      {Lisp-Entry "jazz.rassq" define #f 136 9 136 19 ("%%cdr" "else" "%%car" "%%cdar" "%%eq?" "%%null?" "cond" "rest" "iter" "let" "alist" "obj")}
      {Lisp-Entry "jazz.butlast" define #f 146 9 146 21 ("jazz.butlast" "%%car" "%%cons" "%%cdr" "%%null?" "if" "lst")}
      {Lisp-Entry "jazz.naturals" define #f 152 9 152 22 ("jazz.reverse!" "1" "%%fx+" "%%cons" "set!" "%%fx<" "%%while" "n" "lst" "let" "to" "from")}
      {Lisp-Entry "jazz.remove!" define #f 161 9 161 21 ("%%set-cdr!" "scan" "previous" "let" "begin" "%%null?" "if" "%%cdr" "set!" "%%car" "%%eqv?" "%%not-null?" "and" "%%while" "lst" "target")}
      {Lisp-Entry "jazz.values?" define #f 180 9 180 21 ("%%values?" "obj")}}})
"macros"
 ({Lisp-File-Entry {File core "src" "core" "base" "syntax" "macros.scm"} 1288732032
    {Lisp-Entry "core.base.syntax.macros" unit #f 37 16 37 39 ()
      {Lisp-Entry "%%boolean" define-macro ("syntax") 40 20 40 29 (",expr" "if" "jazz.source-code" "%%cadr" "expr" "let" "src" "lambda")}
      {Lisp-Entry "%%not-null?" define-macro ("syntax") 46 20 46 31 (",expr" "%%null?" "%%not" "jazz.source-code" "%%cadr" "expr" "let" "src" "lambda")}
      {Lisp-Entry "%%when" define-macro ("syntax") 57 20 57 26 (",@body" "begin" ",test" "if" "%%cddr" "body" "jazz.source-code" "%%cadr" "test" "let" "src" "lambda")}
      {Lisp-Entry "%%while" define-macro ("syntax") 72 20 72 27 (",@body" "begin" ",test" "if" ",iter" "jazz.generate-symbol" "iter" "%%cddr" "body" "jazz.source-code" "%%cadr" "test" "let" "src" "lambda")}
      {Lisp-Entry "%%core-assert" define-macro ("syntax") 89 20 89 33 ("jazz.debug-core?" "jazz.expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%core-assertion" define-macro ("syntax") 94 20 94 36 ("jazz.debug-core?" "jazz.expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "%%debug-assert" define-macro ("syntax") 99 20 99 34 ("jazz.debug-user?" "jazz.expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%debug-assertion" define-macro ("syntax") 104 20 104 37 ("jazz.debug-user?" "jazz.expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "%%assert" define-macro ("syntax") 109 20 109 28 ("jazz.expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%assertion" define-macro ("syntax") 114 20 114 31 ("jazz.expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "jazz.expand-%%assert" define #f 119 9 119 29 ("error" "'error" "jazz.expand-%%assertion-body" "%%unspecified" "'%%unspecified" "%%list" "%%null?" "if" "effective-body" "get-output-string" "%%desourcify" "write" "display" "open-output-string" "port" "message" "%%cddr" "body" "jazz.source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "jazz.expand-%%assertion" define #f 131 9 131 32 ("jazz.expand-%%assertion-body" "%%unspecified" "'%%unspecified" "%%list" "%%null?" "if" "effective-body" "%%cdr" "body" "%%cddr" "%%car" "action" "jazz.source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "jazz.expand-%%assertion-body" define #f 139 9 139 37 (",@body" "begin" "jazz.simplify-begin" ",action" ",assertion" "%%not" "if" "body" "action" "assertion" "test?")}
      {Lisp-Entry "jazz.bind" define-macro ("macro") 166 20 166 29 (",tree-symbol" "tree-symbol" ",cdr-symbol" "cdr-symbol" ",@body" ",cdr-binding" "%%cdr" "cdr-binding" ",car-symbol" "jazz.error" "%%null?" "if" "jazz.generate-symbol" "car-symbol" "%%pair?" "expand-cdr" ",tree" ",car-binding" "%%symbol?" "cond" "%%car" "car-binding" "let" "expand-car" "define" "body" "tree" "bindings")}
      {Lisp-Entry "%%compose-name" define-macro ("macro") 203 20 203 34 (",s2" ",s1" "%%symbol->string" "%%string-append" "%%string->symbol" "s2" "s1")}}})
"module"
 ({Lisp-File-Entry {File core "src" "core" "module" "syntax" "module.scm"} 1288732032
    {Lisp-Entry "core.module.syntax.module" unit #f 37 16 37 41 ()
      {Lisp-Entry "module" define-macro ("syntax") 40 20 40 26 ("jazz.save-emit-if" "jazz.source-code" "%%cdr" "jazz.expand-module-source" "emit" "let" "form-src" "lambda")}}})
"object"
 ({Lisp-File-Entry {File core "src" "core" "class" "syntax" "object.scm"} 1288732032
    {Lisp-Entry "core.class.syntax.object" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz.instances-statistics?" define #f 41 8 41 34 ()}
      {Lisp-Entry "jazz.instances-statistics" define #f 45 8 45 33 ("eq?" "test:" "%%make-table" "jazz.instances-statistics?" "if")}
      {Lisp-Entry "jazz.register-instance" define #f 51 9 51 31 ("%%cons" "list" "0" "%%table-ref" "%%fx+" "jazz.instances-statistics" "%%table-set!" "count" "case" "1" "##vector-ref" "name" "if" "jazz.keep-instances-statistics" "keep" "let" "obj" "class")}
      {Lisp-Entry "%%register-instance" define-macro ("macro") 65 20 65 39 (",obj" ",class" "jazz.register-instance" "jazz.instances-statistics?" "if" "obj" "class")}
      {Lisp-Entry "%%object-content" define #f 73 12 73 28 ("0")}
      {Lisp-Entry "%%object-marker" define #f 77 11 77 26 ("jazz.object" "'jazz.object")}
      {Lisp-Entry "%%object-content" define #f 80 11 80 27 ("1")}
      {Lisp-Entry "jazz.object-class" define #f 84 8 84 25 ("%%object-content")}
      {Lisp-Entry "jazz.object-size" define #f 88 8 88 24 ("1" "jazz.object-class" "%%fx+")}
      {Lisp-Entry "%%subtype-jazz" define-macro ("macro") 94 24 94 38 ("7")}
      {Lisp-Entry "%%object?" define-macro ("macro") 97 24 97 33 (",expr" "##jazz?" "expr")}
      {Lisp-Entry "%%object" define-macro ("macro") 100 24 100 32 ("%%register-instance" "%%subtype-jazz" ",@rest" ",cls" "##vector" "##subtype-set!" ",obj" "jazz.generate-symbol" "obj" "let" "jazz.instances-statistics?" "if" "cls" "lambda" "jazz.with-uniqueness" "rest" "class")}
      {Lisp-Entry "%%make-object" define-macro ("macro") 110 24 110 37 ("%%register-instance" ",cls" "%%set-object-class" "%%subtype-jazz" "%%unspecified" ",size" "%%make-vector" "##subtype-set!" ",obj" "jazz.generate-symbol" "obj" "let" "cls" "lambda" "jazz.with-uniqueness" "size" "class")}
      {Lisp-Entry "%%object-length" define-macro ("macro") 119 24 119 39 (",object" "##vector-length" "jazz.not-object-error" ",obj" "%%object?" "%%core-assertion" "obj" "lambda" "jazz.with-uniqueness" "jazz.debug-core?" "if" "object")}
      {Lisp-Entry "%%object-ref" define-macro ("macro") 127 24 127 36 (",object" ",n" "##vector-ref" "jazz.not-object-error" ",obj" "%%object?" "%%core-assertion" "rnk" "obj" "lambda" "jazz.with-uniqueness" "jazz.debug-core?" "if" "n" "object")}
      {Lisp-Entry "%%object-set!" define-macro ("syntax") 140 24 140 37 (",object" ",value" ",n" "##vector-set!" "jazz.not-object-error" ",obj" "%%object?" "%%core-assertion" "rnk" "obj" "jazz.with-uniqueness" "jazz.debug-core?" "if" "value" "%%cddr" "%%car" "n" "%%source-code" "%%cadr" "object" "let" "src" "lambda")}
      {Lisp-Entry "%%object?" define-macro ("macro") 158 23 158 32 ("%%object-marker" "%%object-ref" "%%eq?" "0" "%%object-length" "%%fx>" ",expr" "%%vector?" "and" "expr")}
      {Lisp-Entry "%%object" define-macro ("macro") 163 23 163 31 (",@rest" "%%object-marker" "%%vector" "rest")}
      {Lisp-Entry "%%make-object" define-macro ("macro") 166 23 166 36 ("%%object-marker" "0" "%%object-set!" "%%unspecified" ",size" "%%make-vector" ",object" "jazz.generate-symbol" "object" "let" "size")}
      {Lisp-Entry "%%object-length" define-macro ("macro") 172 23 172 38 (",vector" "%%vector-length" "vector")}
      {Lisp-Entry "%%object-ref" define-macro ("macro") 175 23 175 35 (",n" ",vector" "%%vector-ref" "n" "vector")}
      {Lisp-Entry "%%object-set!" define-macro ("macro") 178 23 178 36 (",value" ",n" ",vector" "%%vector-set!" "value" "n" "vector")}}})
"output"
 ({Lisp-File-Entry {File core "src" "core" "class" "runtime" "output.scm"} 1288732032
    {Lisp-Entry "core.class.runtime.output" unit #f 37 16 37 41 ("jazz.print-jazz" "display" "'display" "eq?" "if" "detail" "let" "style" "port" "object" "jazz.print-hook" "jazz.dialect.language.object.Object.call-print" ":reader" "':reader" "jazz.write" ":human" "':human" "jazz.output-value" "output" "value" "lambda" "jazz.display" "set!")
      {Lisp-Entry "jazz.output-mode" define #f 40 8 40 24 (":reader" "':reader")}
      {Lisp-Entry "jazz.print" define #f 54 9 54 19 ("jazz.error" "else" "write" ":describe" ":text" ":reader" "display" ":human" "case" "detail" "output" "value")}
      {Lisp-Entry "jazz.->string" define #f 61 9 61 22 ("get-output-string" "jazz.output-mode" "jazz.output-value" "open-output-string" "output" "let" "else" "%%values?" "%%unspecified?" "cond" "value")}
      {Lisp-Entry "jazz.output-value" define #f 72 9 72 26 ("jazz.print-jazz" "else" "jazz.print" "jazz.primitive?" "jazz.output-list" "%%pair?" "%%null?" "or" "cond" "detail" "output" "value")}
      {Lisp-Entry "jazz.output-list" define #f 81 9 81 25 ("begin" "display" "%%pair?" "%%cdr" "set!" "%%car" "jazz.output-value" "and" "%%while" "done?" "scan" "let" "%%null?" "%%not" "if" "output-list-content" "define" "detail" "output" "lst")}
      {Lisp-Entry "jazz.debug" define #f 102 9 102 19 ("force-output" "newline" "%%cdr" "expr" "lambda" "for-each" "%%car" "jazz.->string" "display" "%%not-null?" "%%when" "console-port" "port" "let" "rest")}
      {Lisp-Entry "jazz.debug-string" define #f 114 9 114 26 ("force-output" "newline" "display" "console-port" "port" "let" "str")}
      {Lisp-Entry "jazz.terminal" define #f 121 8 121 21 ("jazz.debug")}
      {Lisp-Entry "jazz.terminal-string" define #f 125 8 125 28 ("jazz.debug-string")}
      {Lisp-Entry "jazz.terminal-port" define #f 129 9 129 27 ("console-port")}
      {Lisp-Entry "jazz.bootstrap-output-value" define #f 133 9 133 36 ("jazz.->string" "display" "output" "value")}
      {Lisp-Entry "jazz.pretty-print" define #f 139 13 139 30 ("pretty-print" "apply" "rest" "expr")}
      {Lisp-Entry "jazz.pretty-print" define #f 143 13 143 30 ("pretty-print" "apply" "rest" "expr")}
      {Lisp-Entry "jazz.pretty-print" define #f 147 12 147 29 ("newline" "display" "rest" "expr")}
      {Lisp-Entry "jazz.dialect.language.object.Object.call-print" define #f 157 8 157 54 ()}
      {Lisp-Entry "jazz.print-jazz" define #f 163 9 163 24 ("jazz.print-serial" "jazz.print-object" "2" "0" "jazz.class-of" "%%class-dispatch" "jazz.dialect.language.object.Object.call-print" "jazz.use-print?" "if" "detail" "output" "object")}}})
"output-hook"
 ({Lisp-File-Entry {File core "src" "core" "class" "runtime" "output-hook.scm"} 1288732032
    {Lisp-Entry "core.class.runtime.output-hook" unit #f 37 16 37 46 ("##default-wr" "else" "jazz.writeenv-style" "jazz.writeenv-port" "##jazz?" "and" "cond" "obj" "we" "lambda" "##wr" "jazz.print-hook" "set!")
      {Lisp-Entry "jazz.print-hook" define #f 42 12 42 27 ()}}})
"reader"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "reader.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.reader" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz.read-source-all" define #f 40 9 40 29 ("%%vector-ref" "%%source-code" "%%cdr" "jazz.readtable-start-syntax" "##unwrap-datum" "##wrap-datum" "%%current-readtable" "%%read-all-as-a-begin-expr-from-port" "begin-vector" "let" "%%input-port-column-set!" "1" "%%fx+" "%%input-port-line-set!" "lambda" "%%input-port-names-set!" "if" "col" "line" "container" "#!optional" "port")}
      {Lisp-Entry "jazz.read-source-first" define #f 59 9 59 31 ("jazz.read-source-all" "%%car" "col" "line" "container" "#!optional" "port")}}})
"register"
 ({Lisp-File-Entry {File core "src" "core" "module" "syntax" "walker" "register.scm"} 1290196308
    {Lisp-Entry "core.module.syntax.walker.register" unit #f 37 16 37 50 ()
      {Lisp-Entry "core" define ("dialect") 45 21 45 25 ("jazz.new-core-dialect")}
      {Lisp-Entry "require" define ("special") 49 28 49 35 ("jazz.walk-require" "core")}
      {Lisp-Entry "export" define ("special") 50 28 50 34 ("jazz.walk-export" "core")}
      {Lisp-Entry "import" define ("special") 51 28 51 34 ("jazz.walk-import" "core")}
      {Lisp-Entry "proclaim" define ("special") 52 28 52 36 ("jazz.walk-proclaim" "core")}
      {Lisp-Entry "native" define ("special") 53 28 53 34 ("jazz.walk-native" "core")}
      {Lisp-Entry "native-syntax" define ("special") 54 28 54 41 ("jazz.walk-native-syntax" "core")}
      {Lisp-Entry "macro" define ("special") 55 28 55 33 ("jazz.walk-macro" "core")}
      {Lisp-Entry "local-macro" define ("special") 56 28 56 39 ("jazz.walk-local-macro" "core")}
      {Lisp-Entry "syntax" define ("special") 57 28 57 34 ("jazz.walk-syntax" "core")}
      {Lisp-Entry "define-syntax" define ("special") 58 28 58 41 ("jazz.walk-define-syntax" "core")}
      {Lisp-Entry "define-local-syntax" define ("special") 59 28 59 47 ("jazz.walk-define-local-syntax" "core")}
      {Lisp-Entry "let-syntax" define ("special") 60 28 60 38 ("jazz.walk-let-syntax" "core")}
      {Lisp-Entry "letrec-syntax" define ("special") 61 28 61 41 ("jazz.walk-letrec-syntax" "core")}
      {Lisp-Entry "reference" define ("special") 62 28 62 37 ("jazz.walk-reference" "core")}}})
"runtime"
 ({Lisp-File-Entry {File core "src" "core" "class" "runtime" "runtime.scm"} 1289506007
    {Lisp-Entry "core.class.runtime.runtime" unit #f 37 16 37 42 ("jazz.Queue" "jazz.Method-Node" "jazz.Method" "jazz.Property" "jazz.Slot" "jazz.Field" "jazz.Interface" "#xF" "#xE" "#xD" "#xC" "#xB" "#xA" "#x9" "#x8" "#x7" "#x6" "#x5" "#x4" "#x3" "#x2" "#x1" "#x0" "jazz.specialtypes" "jazz.subtype-boxvalues" "jazz.subtype-f64vector" "jazz.subtype-f32vector" "jazz.subtype-u64vector" "jazz.subtype-s64vector" "jazz.subtype-u32vector" "jazz.subtype-s32vector" "jazz.subtype-u16vector" "jazz.subtype-s16vector" "jazz.subtype-u8vector" "jazz.subtype-s8vector" "jazz.subtype-foreign" "jazz.subtype-bignum" "jazz.subtype-flonum" "jazz.subtype-string" "jazz.subtype-procedure" "jazz.subtype-continuation" "jazz.subtype-keyword" "jazz.subtype-symbol" "jazz.subtype-cpxnum" "jazz.subtype-ratnum" "jazz.subtype-pair" "jazz.subtype-vector" "jazz.subtypes" "%%vector-set!" "jazz.Marker" "jazz.Marker-Class" "jazz.Unspecified" "jazz.Unspecified-Class" "jazz.EOF" "jazz.EOF-Class" "jazz.Values" "jazz.Values-Class" "jazz.Foreign" "jazz.Foreign-Class" "jazz.Promise" "jazz.Promise-Class" "thread?" "jazz.Thread" "jazz.Thread-Class" "table?" "jazz.Table" "jazz.Table-Class" "jazz.Keyword" "jazz.Keyword-Class" "jazz.Symbol" "jazz.Symbol-Class" "jazz.Procedure" "jazz.Procedure-Class" "jazz.Continuation" "jazz.Continuation-Class" "port?" "jazz.register-structure-type" "jazz.Port" "jazz.Port-Class" "jazz.Structure" "jazz.Structure-Class" "jazz.F64Vector" "jazz.F64Vector-Class" "jazz.F32Vector" "jazz.F32Vector-Class" "jazz.U64Vector" "jazz.U64Vector-Class" "jazz.S64Vector" "jazz.S64Vector-Class" "jazz.U32Vector" "jazz.U32Vector-Class" "jazz.S32Vector" "jazz.S32Vector-Class" "jazz.U16Vector" "jazz.U16Vector-Class" "jazz.S16Vector" "jazz.S16Vector-Class" "jazz.U8Vector" "jazz.U8Vector-Class" "jazz.S8Vector" "jazz.S8Vector-Class" "jazz.Vector" "jazz.Vector-Class" "jazz.String" "jazz.String-Class" "jazz.Pair" "jazz.Pair-Class" "jazz.Null" "jazz.Null-Class" "jazz.List" "jazz.List-Class" "jazz.Sequence" "jazz.Sequence-Class" "jazz.Flonum" "jazz.Flonum-Class" "jazz.Fixnum" "jazz.Fixnum-Class" "jazz.Integer" "jazz.Integer-Class" "jazz.Rational" "jazz.Rational-Class" "jazz.Real" "jazz.Real-Class" "jazz.Complex" "jazz.Complex-Class" "jazz.Number" "jazz.Number-Class" "jazz.Numeric" "jazz.Numeric-Class" "jazz.Char" "jazz.Char-Class" "jazz.Boolean" "jazz.Boolean-Class" "%%set-object-class" "jazz.Object-Class" "jazz.Class" "jazz.Category" "jazz.Type" "jazz.Object" "jazz.encapsulate-class" "%%get-object-class" "%%subclass?" "class" "object" "lambda" "jazz.object-of-class?" "set!")
      {Lisp-Entry "jazz.new-interface-rank" define #f 40 8 40 31 ("0")}
      {Lisp-Entry "jazz.dispatch?" define #f 49 9 49 23 ("%%fx-" "%%string-ref" "%%eqv?" "1" "%%fx>" "%%string-length" "len" "%%symbol->string" "name" "let" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "jazz.dispatch->symbol" define #f 58 9 58 30 ("1" "%%string-length" "%%fx-" "0" "%%substring" "%%string->symbol" "%%symbol->string" "name" "let" "dispatch")}
      {Lisp-Entry "jazz.composite-name?" define #f 63 9 63 29 ("%%symbol->string" "jazz.memstring" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "jazz.compose-name" define #f 68 9 68 26 ("symbol->string" "map" "jazz.join-strings" "%%string->symbol" "rest")}
      {Lisp-Entry "jazz.compose-helper" define #f 72 9 72 28 ("%%symbol->string" "%%string-append" "%%string->symbol" "suffix" "locator")}
      {Lisp-Entry "jazz.split-identifier" define #f 76 9 76 30 ("%%symbol->string" "jazz.split-string" "string->symbol" "map" "%%symbol?" "%%debug-assert" "identifier")}
      {Lisp-Entry "jazz.inspect-object" define #f 86 9 86 28 ("1" "%%fx+" "%%object-ref" "%%vector-set!" "begin" "%%fx<" "if" "0" "n" "iter" "let" "%%make-vector" "content" "%%object-length" "size" "let*" "%%object?" "%%assert" "object")}
      {Lisp-Entry "jazz.Core-Classes" define #f 103 8 103 25 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.get-core-classes" define #f 107 9 107 30 ("jazz.Core-Classes")}
      {Lisp-Entry "jazz.core-class?" define #f 111 9 111 25 ("jazz.Core-Classes" "%%table-ref" "%%boolean" "name")}
      {Lisp-Entry "jazz.get-core-class" define #f 115 9 115 28 ("jazz.Core-Classes" "%%table-ref" "name")}
      {Lisp-Entry "jazz.set-core-class" define #f 119 9 119 28 ("jazz.Core-Classes" "%%table-set!" "class" "name")}
      {Lisp-Entry "jazz.set-core-class-redefined" define #f 123 9 123 38 ("jazz.Core-Classes" "%%table-set!" "core-class-locator" "name")}
      {Lisp-Entry "jazz.object?" define #f 132 9 132 21 ("%%object?" "expr")}
      {Lisp-Entry "jazz.primitive?" define #f 136 9 136 24 ("%%object?" "%%not" "expr")}
      {Lisp-Entry "jazz.subtype?" define #f 140 9 140 22 ("%%subtype?" "%%boolean" "jazz.type?" "%%assert" "type" "target")}
      {Lisp-Entry "jazz.subcategory?" define #f 145 9 145 26 ("%%subcategory?" "%%boolean" "category" "target")}
      {Lisp-Entry "jazz.subclass?" define #f 149 9 149 23 ("%%subclass?" "%%boolean" "class" "target")}
      {Lisp-Entry "jazz.get-category-descendants" define #f 153 9 153 38 ("%%get-category-descendants" "category")}
      {Lisp-Entry "jazz.get-class-ascendant" define #f 157 9 157 33 ("%%get-class-ascendant" "class")}
      {Lisp-Entry "jazz.collect-type" define #f 166 9 166 26 ("%%is?" "obj" "lambda" "jazz.collect-if" "lst" "type")}
      {Lisp-Entry "jazz.create-class-tables" define #f 172 9 172 33 ("jazz.create-class-class-table" "jazz.create-class-interface-table" "class")}
      {Lisp-Entry "jazz.create-core-class-tables" define #f 177 9 177 38 ("jazz.create-class-class-table" "class")}
      {Lisp-Entry "jazz.create-class-interface-table" define #f 181 9 181 42 ("%%set-class-interface-table" "%%get-category-ancestors" "jazz.class-of" "jazz.call-into-abstract" "rest" "object" "%%get-method-implementation-rank" "jazz.Method" "%%is?" "field" "field-name" "%%get-category-fields" "jazz.iterate-table" "category-identifier" "%%get-category-identifier" "class-name" "jazz.call-into-incoherent" "category-vtable" "%%get-category-virtual-size" "%%get-interface-rank" "rank" "let*" "jazz.Interface" "%%class-is?" "category" "lambda" "jazz.vector-for-each" "1" "%%fx+" "%%vector-copy" "%%vector-set!" "%%vector-ref" "ascendant-vtable" "%%fx<" "0" "i" "iter" "%%vector-length" "size" "ascendant-interface-table" "%%get-class-ascendant" "ascendant" "jazz.new-interface-rank" "%%make-vector" "vtable" "let" "%%get-class-interface-table" "%%not" "%%when" "class")}
      {Lisp-Entry "jazz.create-class-class-table" define #f 215 9 215 38 ("%%vector-ref" "%%vector-copy" "%%vector-set!" "%%fx<" "0" "i" "iter" "#" "'#" "1" "%%fx+" "%%make-vector" "vtable" "%%vector-length" "size" "ascendant-class-table" "let*" "if" "%%set-class-class-table" "%%get-class-ascendant" "ascendant" "let" "%%get-class-class-table" "%%not" "%%when" "class")}
      {Lisp-Entry "jazz.encapsulate-class" define #f 231 9 231 31 ("jazz.update-core-class" "%%set-class-core-vtable" "%%get-class-core-method-alist" "%%get-class-core-virtual-alist" "jazz.get-method-rank" "%%cdr" "method-implementation" "%%car" "method-name" "method" "lambda" "for-each" "%%vector-ref" "%%vector-set!" "%%fx>=" "1" "%%vector-length" "%%fx-" "n" "iter" "%%get-class-core-vtable" "ascendant-vtable" "%%get-class-ascendant" "ascendant" "%%make-vector" "vtable" "0" "%%fx>" "%%when" "%%length" "vtable-size" "%%get-class-core-virtual-names" "virtual-names" "let" "class")}
      {Lisp-Entry "jazz.update-class" define #f 258 9 258 26 ("jazz.update-class-class-table" "class")}
      {Lisp-Entry "jazz.update-core-class" define #f 262 9 262 31 ("jazz.update-class-class-table" "class")}
      {Lisp-Entry "jazz.update-class-class-table" define #f 266 9 266 38 ("implementation" "jazz.resize-vector" "%%get-category-virtual-size" "class-virtual-size" "%%not-null?" "%%cons" "set!" "%%set-method-category-rank" "begin" "%%get-category-descendants" "descendant" "for-each" "%%vector-set!" "%%eq?" "implementation-table" "iter" "%%neq?" "%%get-method-implementation-tree" "%%get-method-node-implementation" "new-implementation" "old-implementation" "%%get-method-implementation-rank" "implementation-rank" "let" "%%get-method-category-rank" "if" "jazz.virtual-method?" "%%when" "field" "key" "lambda" "%%get-category-fields" "jazz.iterate-table" "added-methods" "%%vector-ref" "root-implementation-table" "%%get-class-level" "class-rank" "%%get-class-class-table" "class-table" "let*" "update-class-class-root-methods" "define" "class")}
      {Lisp-Entry "jazz.new-core-class" define #f 317 9 317 28 ("jazz.create-core-class-tables" "%%get-category-descendants" "%%cons" "%%set-category-descendants" "%%when" "%%list->vector" "%%set-category-ancestors" "%%get-class-core-virtual-names" "1" "%%get-class-level" "%%fx+" "0" "%%object" "core-class" "let" "%%get-category-ancestors" "%%vector->list" "%%append" "%%list" "%%not" "if" "compute-core-class-ancestors" "define" "instance-size" "slot-names" "ascendant" "fields" "name" "class")}
      {Lisp-Entry "jazz.validate-inherited-slots" define #f 353 9 353 38 ("jazz.error" "%%equal?" "%%null?" "and" "or" "%%get-field-name" "slot" "lambda" "map" "symbol?" "jazz.some?" "all-slots" "core-class-all-slot-names" "%%append" "%%not" "if" "%%get-class-ascendant" "%%get-class-instance-slots" "slots" "let" "core-class" "core-class-all-slots" "define" "inherited-slot-names" "ascendant" "name")}
      {Lisp-Entry "jazz.Object" define-class ("class runtime") 380 27 380 38 ()}
      {Lisp-Entry "jazz.get-object-slot" define #f 383 9 383 29 ("jazz.unspecified" "%%object-ref" "%%integer?" "if" "%%object?" "%%debug-assert" "slot-offset" "object")}
      {Lisp-Entry "jazz.set-object-slot" define #f 390 9 390 29 ("%%object-set!" "%%integer?" "%%object?" "%%debug-assert" "value" "slot-offset" "object")}
      {Lisp-Entry "jazz.classname->string" define #f 396 9 396 31 ("%%get-category-identifier" "%%symbol->string" "%%null?" "if" "class")}
      {Lisp-Entry "jazz.print-object" generic/specific ("jazz.Object~virtual-runtime") 402 30 402 47 ("detail" "output")}
      {Lisp-Entry "jazz.print-object" generic/specific ("jazz.Object") 405 21 405 38 ("object" "jazz.print-serial" "detail" "output")}
      {Lisp-Entry "jazz.print-serial" define #f 409 9 409 26 ("display" "object->serial-number" "serial" "let" "output" "object")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Object~virtual-runtime") 416 30 416 44 ("environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.tree-fold" generic/specific ("jazz.Object") 419 21 419 35 ("expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz.Type" define-class ("class runtime") 431 27 431 36 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Type~virtual-runtime") 434 30 434 43 ("object")}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Type") 437 21 437 34 ("jazz.class-of" "type" "jazz.of-subtype?" "object")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Type~virtual-runtime") 441 30 441 46 ("subtype")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Type") 444 21 444 37 ("type" "jazz.error" "subtype")}
      {Lisp-Entry "jazz.specifiable?" generic/specific ("jazz.Type~virtual-runtime") 448 30 448 47 ()}
      {Lisp-Entry "jazz.specifiable?" generic/specific ("jazz.Type") 451 21 451 38 ()}
      {Lisp-Entry "jazz.category-type?" generic/specific ("jazz.Type~virtual-runtime") 455 30 455 49 ()}
      {Lisp-Entry "jazz.category-type?" generic/specific ("jazz.Type") 458 21 458 40 ()}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Type~virtual-runtime") 462 30 462 49 ()}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Type") 465 21 465 40 ("type" "jazz.error")}
      {Lisp-Entry "jazz.emit-type" generic/specific ("jazz.Type~virtual-runtime") 469 30 469 44 ("environment" "source-declaration")}
      {Lisp-Entry "jazz.emit-type" generic/specific ("jazz.Type") 472 21 472 35 ("type" "jazz.error" "environment" "source-declaration")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Type~virtual-runtime") 476 30 476 44 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Type") 479 21 479 35 (",locator" ",value" "%%is?" "type" "jazz.emit-type" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.emit-check" generic/specific ("jazz.Type~virtual-runtime") 484 30 484 45 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.emit-check" generic/specific ("jazz.Type") 487 21 487 36 (",locator" ",value" "jazz.type-error" "jazz.emit-test" "%%not" "if" "type" "jazz.emit-type" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.bootstrap-type?" define #f 494 9 494 29 ("type-class" "object")}
      {Lisp-Entry "jazz.type?" define #f 499 9 499 19 ("jazz.Type" "%%is?" "%%object?" "and" "object")}
      {Lisp-Entry "jazz.structure-types" define #f 512 8 512 28 ()}
      {Lisp-Entry "jazz.register-structure-type" define #f 516 9 516 37 ("%%cons" "jazz.structure-types" "set!" "type" "test")}
      {Lisp-Entry "jazz.structure-type" define #f 520 9 520 28 ("%%cdr" "%%cdar" "%%caar" "jazz.Structure" "%%null?" "if" "jazz.structure-types" "scan" "iter" "let" "object")}
      {Lisp-Entry "jazz.Category" define-class ("class runtime") 534 27 534 40 ()}
      {Lisp-Entry "jazz.category?" define #f 537 9 537 23 ("jazz.category-type?" "jazz.type?" "and" "object")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Category") 542 21 542 37 ("%%get-category-ancestors" "type" "jazz.vector-memq?" "jazz.category-type?" "and" "subtype")}
      {Lisp-Entry "jazz.category-type?" generic/specific ("jazz.Category") 547 21 547 40 ()}
      {Lisp-Entry "jazz.emit-type" generic/specific ("jazz.Category") 551 21 551 35 ("type" "%%get-category-identifier" "environment" "source-declaration")}
      {Lisp-Entry "jazz.update-category" generic/specific ("jazz.Category~virtual-runtime") 555 30 555 50 ()}
      {Lisp-Entry "jazz.update-category" generic/specific ("jazz.Category") 558 21 558 41 ()}
      {Lisp-Entry "jazz.is?" define #f 562 9 562 17 ("%%is?" "%%boolean" "category" "object")}
      {Lisp-Entry "jazz.is-not?" define #f 566 9 566 21 ("%%is?" "%%not" "%%boolean" "category" "object")}
      {Lisp-Entry "jazz.get-category-identifier" define #f 570 9 570 37 ("%%get-category-identifier" "jazz.category?" "%%debug-assert" "category")}
      {Lisp-Entry "jazz.add-field" define #f 575 9 575 23 ("%%unspecified" "%%get-field-name" "%%set-category-field" "field" "category")}
      {Lisp-Entry "jazz.Class" define-class ("class runtime") 588 27 588 37 ()}
      {Lisp-Entry "jazz.new-class" define #f 591 9 591 23 ("%%class-dispatch" "jazz.initialize-slots" "jazz.create-class-tables" "%%get-category-descendants" "%%list->vector" "%%set-class-interface-table" "%%set-class-class-table" "%%get-class-core-vtable" "%%set-class-core-vtable" "%%set-class-core-virtual-names" "%%set-class-core-virtual-alist" "%%set-class-core-method-alist" "%%set-class-dispatch-table" "1" "%%get-class-level" "%%fx+" "%%set-class-level" "jazz.object-size" "%%set-class-instance-size" "%%get-class-instance-slots" "if" "%%set-class-instance-slots" "%%set-class-slots" "%%set-class-interfaces" "%%set-class-ascendant" "%%set-category-descendants" "%%set-category-ancestors" "0" "%%set-category-virtual-size" "eq?" "test:" "%%make-table" "%%set-category-fields" "%%set-category-identifier" "%%get-class-instance-size" "%%make-object" "add-classes" "%%get-interface-ascendants" "%%cons" "set!" "%%memq" "%%not" "else" "%%get-class-interfaces" "for-each" "%%when" "%%get-class-ascendant" "%%class?" "cond" "category" "add-interfaces" "ancestors" "let" "class" "compute-class-ancestors" "define" "interfaces" "ascendant" "identifier" "class-of-class")}
      {Lisp-Entry "jazz.class?" define #f 639 9 639 20 ("jazz.Class" "%%class-is?" "object")}
      {Lisp-Entry "jazz.class-of" define #f 643 9 643 22 ("%%class-of-impl" "expr")}
      {Lisp-Entry "jazz.class-subtype?" define #f 647 9 647 28 ("%%class-subtype?" "class" "target")}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Class") 651 21 651 34 ("class" "jazz.class-of" "%%class-subtype?" "object")}
      {Lisp-Entry "jazz.update-category" generic/specific ("jazz.Class") 655 21 655 41 ("class" "jazz.update-class")}
      {Lisp-Entry "jazz.slot-form?" define #f 659 9 659 24 ("slot" "'slot" "%%car" "%%eq?" "%%pair?" "and" "form")}
      {Lisp-Entry "jazz.new" define #f 664 9 664 17 ("0" "%%class-dispatch" "apply" "jazz.initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "rest" "class")}
      {Lisp-Entry "jazz.new0" define #f 672 9 672 18 ("0" "%%class-dispatch" "jazz.initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "class")}
      {Lisp-Entry "jazz.new1" define #f 680 9 680 18 ("0" "%%class-dispatch" "jazz.initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "arg1" "class")}
      {Lisp-Entry "jazz.new2" define #f 688 9 688 18 ("0" "%%class-dispatch" "jazz.initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "arg2" "arg1" "class")}
      {Lisp-Entry "jazz.nascent-new" define #f 696 9 696 25 ("jazz.initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "rest" "class")}
      {Lisp-Entry "jazz.iterate-descendants-tree" define #f 703 9 703 38 ("%%get-category-descendants" "for-each" "iter" "let" "proc" "class")}
      {Lisp-Entry "jazz.Object-Class" define-class ("class runtime") 717 27 717 44 ()}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Object-Class") 720 21 720 37 ("nextmethod" "class" "%%object-class?" "if" "subtype")}
      {Lisp-Entry "jazz.Boolean-Class" define-class ("class runtime") 746 27 746 45 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Boolean-Class") 749 21 749 34 ("%%boolean?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Boolean-Class") 753 21 753 40 ("bool" "'bool")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Boolean-Class") 757 21 757 35 (",value" "%%boolean?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Boolean" define-class ("class runtime") 764 27 764 39 ()}
      {Lisp-Entry "jazz.Char-Class" define-class ("class runtime") 775 27 775 42 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Char-Class") 778 21 778 34 ("%%char?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Char-Class") 782 21 782 40 ("char" "'char")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Char-Class") 786 21 786 35 (",value" "%%char?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Char" define-class ("class runtime") 793 27 793 36 ()}
      {Lisp-Entry "jazz.Numeric-Class" define-class ("class runtime") 804 27 804 45 ()}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Numeric-Class") 807 21 807 40 ("numeric" "'numeric")}
      {Lisp-Entry "jazz.Numeric" define-class ("class runtime") 814 27 814 39 ()}
      {Lisp-Entry "jazz.Number-Class" define-class ("class runtime") 825 27 825 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Number-Class") 828 21 828 34 ("%%number?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Number-Class") 832 21 832 40 ("number" "'number")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Number-Class") 836 21 836 35 (",value" "%%number?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Number" define-class ("class runtime") 843 27 843 38 ()}
      {Lisp-Entry "jazz.Complex-Class" define-class ("class runtime") 854 27 854 45 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Complex-Class") 857 21 857 34 ("%%complex?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Complex-Class") 861 21 861 40 ("complex" "'complex")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Complex-Class") 865 21 865 35 (",value" "%%complex?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Complex" define-class ("class runtime") 872 27 872 39 ()}
      {Lisp-Entry "jazz.Real-Class" define-class ("class runtime") 883 27 883 42 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Real-Class") 886 21 886 34 ("%%real?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Real-Class") 890 21 890 40 ("real" "'real")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Real-Class") 894 21 894 35 (",value" "%%real?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Real" define-class ("class runtime") 901 27 901 36 ()}
      {Lisp-Entry "jazz.Rational-Class" define-class ("class runtime") 912 27 912 46 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Rational-Class") 915 21 915 34 ("%%rational?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Rational-Class") 919 21 919 40 ("rational" "'rational")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Rational-Class") 923 21 923 35 (",value" "%%rational?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Rational" define-class ("class runtime") 930 27 930 40 ()}
      {Lisp-Entry "jazz.Integer-Class" define-class ("class runtime") 941 27 941 45 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Integer-Class") 944 21 944 34 ("%%integer?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Integer-Class") 948 21 948 40 ("int" "'int")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Integer-Class") 952 21 952 35 (",value" "%%integer?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Integer" define-class ("class runtime") 959 27 959 39 ()}
      {Lisp-Entry "jazz.Fixnum-Class" define-class ("class runtime") 970 27 970 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Fixnum-Class") 973 21 973 34 ("%%fixnum?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Fixnum-Class") 977 21 977 40 ("fx" "'fx")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Fixnum-Class") 981 21 981 35 (",value" "%%fixnum?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Fixnum" define-class ("class runtime") 988 27 988 38 ()}
      {Lisp-Entry "jazz.Flonum-Class" define-class ("class runtime") 999 27 999 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Flonum-Class") 1002 21 1002 34 ("%%flonum?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Flonum-Class") 1006 21 1006 40 ("fl" "'fl")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Flonum-Class") 1010 21 1010 35 (",value" "%%flonum?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Flonum" define-class ("class runtime") 1017 27 1017 38 ()}
      {Lisp-Entry "jazz.Sequence-Class" define-class ("class runtime") 1028 27 1028 46 ()}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Sequence-Class") 1031 21 1031 40 ("sequence" "'sequence")}
      {Lisp-Entry "jazz.Sequence" define-class ("class runtime") 1038 27 1038 40 ()}
      {Lisp-Entry "jazz.List-Class" define-class ("class runtime") 1049 27 1049 42 ()}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.List-Class") 1052 21 1052 40 ("list" "'list")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.List-Class") 1056 21 1056 35 ("%%pair?" ",value" "%%null?" "or" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.List" define-class ("class runtime") 1063 27 1063 36 ()}
      {Lisp-Entry "jazz.Null-Class" define-class ("class runtime") 1074 27 1074 42 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Null-Class") 1077 21 1077 34 ("%%null?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Null-Class") 1081 21 1081 40 ("null" "'null")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Null-Class") 1085 21 1085 35 (",value" "%%null?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Null" define-class ("class runtime") 1092 27 1092 36 ()}
      {Lisp-Entry "jazz.Pair-Class" define-class ("class runtime") 1103 27 1103 42 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Pair-Class") 1106 21 1106 34 ("%%pair?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Pair-Class") 1110 21 1110 40 ("pair" "'pair")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Pair-Class") 1114 21 1114 35 (",value" "%%pair?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Pair" define-class ("class runtime") 1121 27 1121 36 ()}
      {Lisp-Entry "jazz.String-Class" define-class ("class runtime") 1132 27 1132 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.String-Class") 1135 21 1135 34 ("%%string?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.String-Class") 1139 21 1139 40 ("string" "'string")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.String-Class") 1143 21 1143 35 (",value" "%%string?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.String" define-class ("class runtime") 1150 27 1150 38 ()}
      {Lisp-Entry "jazz.Vector-Class" define-class ("class runtime") 1161 27 1161 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Vector-Class") 1164 21 1164 34 ("%%vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Vector-Class") 1168 21 1168 40 ("vector" "'vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Vector-Class") 1172 21 1172 35 (",value" "%%vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Vector" define-class ("class runtime") 1179 27 1179 38 ()}
      {Lisp-Entry "jazz.S8Vector-Class" define-class ("class runtime") 1190 27 1190 46 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.S8Vector-Class") 1193 21 1193 34 ("%%s8vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.S8Vector-Class") 1197 21 1197 40 ("s8vector" "'s8vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.S8Vector-Class") 1201 21 1201 35 (",value" "%%s8vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.S8Vector" define-class ("class runtime") 1208 27 1208 40 ()}
      {Lisp-Entry "jazz.U8Vector-Class" define-class ("class runtime") 1219 27 1219 46 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.U8Vector-Class") 1222 21 1222 34 ("%%u8vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.U8Vector-Class") 1226 21 1226 40 ("u8vector" "'u8vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.U8Vector-Class") 1230 21 1230 35 (",value" "%%u8vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.U8Vector" define-class ("class runtime") 1237 27 1237 40 ()}
      {Lisp-Entry "jazz.S16Vector-Class" define-class ("class runtime") 1248 27 1248 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.S16Vector-Class") 1251 21 1251 34 ("%%s16vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.S16Vector-Class") 1255 21 1255 40 ("s16vector" "'s16vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.S16Vector-Class") 1259 21 1259 35 (",value" "%%s16vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.S16Vector" define-class ("class runtime") 1266 27 1266 41 ()}
      {Lisp-Entry "jazz.U16Vector-Class" define-class ("class runtime") 1277 27 1277 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.U16Vector-Class") 1280 21 1280 34 ("%%u16vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.U16Vector-Class") 1284 21 1284 40 ("u16vector" "'u16vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.U16Vector-Class") 1288 21 1288 35 (",value" "%%u16vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.U16Vector" define-class ("class runtime") 1295 27 1295 41 ()}
      {Lisp-Entry "jazz.S32Vector-Class" define-class ("class runtime") 1306 27 1306 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.S32Vector-Class") 1309 21 1309 34 ("%%s32vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.S32Vector-Class") 1313 21 1313 40 ("s32vector" "'s32vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.S32Vector-Class") 1317 21 1317 35 (",value" "%%s32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.S32Vector" define-class ("class runtime") 1324 27 1324 41 ()}
      {Lisp-Entry "jazz.U32Vector-Class" define-class ("class runtime") 1335 27 1335 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.U32Vector-Class") 1338 21 1338 34 ("%%u32vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.U32Vector-Class") 1342 21 1342 40 ("u32vector" "'u32vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.U32Vector-Class") 1346 21 1346 35 (",value" "%%u32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.U32Vector" define-class ("class runtime") 1353 27 1353 41 ()}
      {Lisp-Entry "jazz.S64Vector-Class" define-class ("class runtime") 1364 27 1364 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.S64Vector-Class") 1367 21 1367 34 ("%%s64vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.S64Vector-Class") 1371 21 1371 40 ("s64vector" "'s64vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.S64Vector-Class") 1375 21 1375 35 (",value" "%%s64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.S64Vector" define-class ("class runtime") 1382 27 1382 41 ()}
      {Lisp-Entry "jazz.U64Vector-Class" define-class ("class runtime") 1393 27 1393 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.U64Vector-Class") 1396 21 1396 34 ("%%u64vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.U64Vector-Class") 1400 21 1400 40 ("u64vector" "'u64vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.U64Vector-Class") 1404 21 1404 35 (",value" "%%u64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.U64Vector" define-class ("class runtime") 1411 27 1411 41 ()}
      {Lisp-Entry "jazz.F32Vector-Class" define-class ("class runtime") 1422 27 1422 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.F32Vector-Class") 1425 21 1425 34 ("%%f32vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.F32Vector-Class") 1429 21 1429 40 ("f32vector" "'f32vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.F32Vector-Class") 1433 21 1433 35 (",value" "%%f32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.F32Vector" define-class ("class runtime") 1440 27 1440 41 ()}
      {Lisp-Entry "jazz.F64Vector-Class" define-class ("class runtime") 1451 27 1451 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.F64Vector-Class") 1454 21 1454 34 ("%%f64vector?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.F64Vector-Class") 1458 21 1458 40 ("f64vector" "'f64vector")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.F64Vector-Class") 1462 21 1462 35 (",value" "%%f64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.F64Vector" define-class ("class runtime") 1469 27 1469 41 ()}
      {Lisp-Entry "jazz.Structure-Class" define-class ("class runtime") 1480 27 1480 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Structure-Class") 1483 21 1483 34 ("%%structure?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Structure-Class") 1487 21 1487 40 ("structure" "'structure")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Structure-Class") 1491 21 1491 35 (",value" "%%structure?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Structure" define-class ("class runtime") 1498 27 1498 41 ()}
      {Lisp-Entry "jazz.Port-Class" define-class ("class runtime") 1509 27 1509 42 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Port-Class") 1512 21 1512 34 ("%%port?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Port-Class") 1516 21 1516 40 ("port" "'port")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Port-Class") 1520 21 1520 35 (",value" "%%port?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Port" define-class ("class runtime") 1527 27 1527 36 ()}
      {Lisp-Entry "jazz.Continuation-Class" define-class ("class runtime") 1541 27 1541 50 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Continuation-Class") 1544 21 1544 34 ("%%continuation?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Continuation-Class") 1548 21 1548 40 ("continuation" "'continuation")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Continuation-Class") 1552 21 1552 35 (",value" "%%continuation?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Continuation" define-class ("class runtime") 1559 27 1559 44 ()}
      {Lisp-Entry "jazz.Procedure-Class" define-class ("class runtime") 1570 27 1570 47 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Procedure-Class") 1573 21 1573 34 ("%%procedure?" "object")}
      {Lisp-Entry "jazz.of-subtype?" generic/specific ("jazz.Procedure-Class") 1577 21 1577 37 ("class" "nextmethod" "or" "subtype")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Procedure-Class") 1583 21 1583 40 ("procedure" "'procedure")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Procedure-Class") 1587 21 1587 35 (",value" "%%procedure?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Procedure" define-class ("class runtime") 1594 27 1594 41 ()}
      {Lisp-Entry "jazz.Symbol-Class" define-class ("class runtime") 1605 27 1605 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Symbol-Class") 1608 21 1608 34 ("%%symbol?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Symbol-Class") 1612 21 1612 40 ("symbol" "'symbol")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Symbol-Class") 1616 21 1616 35 (",value" "%%symbol?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Symbol" define-class ("class runtime") 1623 27 1623 38 ()}
      {Lisp-Entry "jazz.Keyword-Class" define-class ("class runtime") 1634 27 1634 45 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Keyword-Class") 1637 21 1637 34 ("%%keyword?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Keyword-Class") 1641 21 1641 40 ("keyword" "'keyword")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Keyword-Class") 1645 21 1645 35 (",value" "%%keyword?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Keyword" define-class ("class runtime") 1652 27 1652 39 ()}
      {Lisp-Entry "jazz.Table-Class" define-class ("class runtime") 1663 27 1663 43 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Table-Class") 1666 21 1666 34 ("%%table?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Table-Class") 1670 21 1670 40 ("table" "'table")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Table-Class") 1674 21 1674 35 (",value" "%%table?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Table" define-class ("class runtime") 1681 27 1681 37 ()}
      {Lisp-Entry "jazz.Thread-Class" define-class ("class runtime") 1695 27 1695 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Thread-Class") 1698 21 1698 34 ("%%thread?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Thread-Class") 1702 21 1702 40 ("thread" "'thread")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Thread-Class") 1706 21 1706 35 (",value" "%%thread?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Thread" define-class ("class runtime") 1713 27 1713 38 ()}
      {Lisp-Entry "jazz.Promise-Class" define-class ("class runtime") 1727 27 1727 45 ()}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Promise-Class") 1730 21 1730 40 ("promise" "'promise")}
      {Lisp-Entry "jazz.Promise" define-class ("class runtime") 1737 27 1737 39 ()}
      {Lisp-Entry "jazz.Foreign-Class" define-class ("class runtime") 1748 27 1748 45 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Foreign-Class") 1751 21 1751 34 ("%%foreign?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Foreign-Class") 1755 21 1755 40 ("foreign" "'foreign")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Foreign-Class") 1759 21 1759 35 (",value" "%%foreign?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Foreign" define-class ("class runtime") 1766 27 1766 39 ()}
      {Lisp-Entry "jazz.Values-Class" define-class ("class runtime") 1777 27 1777 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Values-Class") 1780 21 1780 34 ("%%values?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Values-Class") 1784 21 1784 40 ("values" "'values")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Values-Class") 1788 21 1788 35 (",value" "%%values?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Values" define-class ("class runtime") 1795 27 1795 38 ()}
      {Lisp-Entry "jazz.EOF-Class" define-class ("class runtime") 1806 27 1806 41 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.EOF-Class") 1809 21 1809 34 ("%%eof-object?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.EOF-Class") 1813 21 1813 40 ("eof" "'eof")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.EOF-Class") 1817 21 1817 35 (",value" "%%eof-object?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.EOF" define-class ("class runtime") 1824 27 1824 35 ()}
      {Lisp-Entry "jazz.Unspecified-Class" define-class ("class runtime") 1835 27 1835 49 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Unspecified-Class") 1838 21 1838 34 ("%%unspecified?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Unspecified-Class") 1842 21 1842 40 ("unspecified" "'unspecified")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Unspecified-Class") 1846 21 1846 35 (",value" "%%unspecified?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Unspecified" define-class ("class runtime") 1853 27 1853 43 ()}
      {Lisp-Entry "jazz.Marker-Class" define-class ("class runtime") 1864 27 1864 44 ()}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Marker-Class") 1867 21 1867 34 ("jazz.marker?" "object")}
      {Lisp-Entry "jazz.emit-specifier" generic/specific ("jazz.Marker-Class") 1871 21 1871 40 ("marker" "'marker")}
      {Lisp-Entry "jazz.emit-test" generic/specific ("jazz.Marker-Class") 1875 21 1875 35 (",value" "jazz.marker?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Marker" define-class ("class runtime") 1882 27 1882 38 ()}
      {Lisp-Entry "jazz.subtypes" define #f 1895 12 1895 25 ("32" "%%make-vector")}
      {Lisp-Entry "jazz.specialtypes" define #f 1898 12 1898 29 ("16" "%%make-vector")}
      {Lisp-Entry "jazz.table-type" define #f 1902 12 1902 27 ("make-table" "%%structure-type")}
      {Lisp-Entry "jazz.port-type" define #f 1906 12 1906 26 ("open-output-string" "%%structure-type")}
      {Lisp-Entry "jazz.thread-type" define #f 1910 12 1910 28 ("current-thread" "%%structure-type")}
      {Lisp-Entry "jazz.Interface" define-class ("class runtime") 1963 27 1963 41 ()}
      {Lisp-Entry "jazz.new-interface" define #f 1966 9 1966 27 ("%%get-category-descendants" "%%set-category-descendants" "for-each" "%%list->vector" "%%set-category-ancestors" "1" "%%fx+" "set!" "jazz.new-interface-rank" "0" "eq?" "test:" "%%make-table" "jazz.allocate-interface" "let" "%%list" "%%get-category-ancestors" "%%vector->list" "ascendant" "lambda" "map" "%%cons" "append" "%%apply" "jazz.remove-duplicates" "interface" "compute-interface-ancestors" "define" "ascendants" "identifier" "class")}
      {Lisp-Entry "jazz.interface?" define #f 1983 9 1983 24 ("jazz.Interface" "%%class-is?" "object")}
      {Lisp-Entry "jazz.of-type?" generic/specific ("jazz.Interface") 1998 21 1998 34 ("jazz.class-of" "interface" "jazz.of-subtype?" "object")}
      {Lisp-Entry "jazz.update-category" generic/specific ("jazz.Interface") 2002 21 2002 41 ("interface" "jazz.update-interface")}
      {Lisp-Entry "jazz.update-interface" define #f 2006 9 2006 30 ("%%get-category-descendants" "descendant" "%%vector-set!" "%%get-method-implementation-tree" "%%get-method-node-implementation" "implementation" "%%get-method-implementation-rank" "implementation-rank" "for-each" "%%get-category-virtual-size" "%%vector-ref" "jazz.resize-vector" "implementation-table" "%%get-class-interface-table" "interface-table" "jazz.Class" "%%class-is?" "category" "iter" "%%not-null?" "let" "%%cons" "set!" "%%set-method-category-rank" "%%get-method-category-rank" "%%not" "jazz.virtual-method?" "and" "%%when" "field" "key" "lambda" "%%get-category-fields" "jazz.iterate-table" "added-methods" "%%get-interface-rank" "interface-rank" "let*" "update-interface-root-methods" "define" "interface")}
      {Lisp-Entry "jazz.Field" define-class ("class runtime") 2044 27 2044 37 ()}
      {Lisp-Entry "jazz.field?" define #f 2047 9 2047 20 ("jazz.Field" "%%class-is?" "object")}
      {Lisp-Entry "jazz.field-name" define #f 2051 9 2051 24 ("%%get-field-name" "field")}
      {Lisp-Entry "jazz.category-field" define #f 2055 9 2055 28 ("jazz.category-field" "and" "%%get-class-ascendant" "ascendant" "let" "%%get-category-field" "or" "field-name" "category")}
      {Lisp-Entry "jazz.require-object-field" define #f 2062 9 2062 34 ("%%get-category-identifier" "jazz.error" "%%not" "if" "jazz.category-field" "field" "%%get-object-class" "class" "let*" "name" "object")}
      {Lisp-Entry "jazz.Slot" define-class ("class runtime") 2078 27 2078 36 ()}
      {Lisp-Entry "jazz.new-slot" define #f 2081 9 2081 22 ("jazz.Slot" "jazz.allocate-slot" "slot-initialize" "slot-offset" "slot-name")}
      {Lisp-Entry "jazz.slot?" define #f 2085 9 2085 19 ("jazz.Slot" "%%class-is?" "object")}
      {Lisp-Entry "jazz.add-slot" define #f 2089 9 2089 22 ("1" "%%fx+" "%%set-class-instance-size" "%%when" "%%get-class-instance-slots" "%%set-class-instance-slots" "%%list" "%%get-class-slots" "%%append" "%%set-class-slots" "jazz.add-field" "jazz.new-slot" "slot" "and" "slot-offset" "%%get-class-instance-size" "instance-size" "let*" "%%get-category-field" "or" "slot-allocate?" "slot-initialize" "slot-name" "class")}
      {Lisp-Entry "jazz.remove-own-slots" define #f 2103 9 2103 30 ("%%length" "%%get-class-instance-size" "%%fx-" "%%set-class-instance-size" "if" "%%set-class-instance-slots" "%%set-class-slots" "%%get-class-instance-slots" "actual" "%%get-class-ascendant" "ascendant" "let" "class")}
      {Lisp-Entry "jazz.slot-value" define #f 2111 9 2111 24 ("jazz.find-slot-offset" "jazz.get-object-slot" "slot-name" "object")}
      {Lisp-Entry "jazz.set-slot-value" define #f 2115 9 2115 28 ("jazz.find-slot-offset" "jazz.set-object-slot" "value" "slot-name" "object")}
      {Lisp-Entry "jazz.find-slot-offset" define #f 2119 9 2119 30 ("%%get-slot-offset" "jazz.require-object-field" "slot" "let" "%%object?" "%%debug-assert" "slot-name" "object")}
      {Lisp-Entry "jazz.initialize-slots" define #f 2125 9 2125 30 ("%%object-set!" "%%when" "%%get-slot-initialize" "initialize" "%%get-slot-offset" "offset" "slot" "lambda" "for-each" "%%get-object-class" "%%get-class-instance-slots" "slots" "let" "object")}
      {Lisp-Entry "jazz.Property" define-class ("class runtime") 2143 27 2143 40 ()}
      {Lisp-Entry "jazz.new-property" define #f 2146 9 2146 26 ("jazz.Property" "jazz.allocate-property" "slot-setter" "slot-getter" "slot-initialize" "slot-offset" "slot-name")}
      {Lisp-Entry "jazz.property?" define #f 2150 9 2150 23 ("jazz.Property" "%%class-is?" "object")}
      {Lisp-Entry "jazz.property-getter" define #f 2154 9 2154 29 ("%%get-property-getter" "property")}
      {Lisp-Entry "jazz.property-setter" define #f 2158 9 2158 29 ("%%get-property-setter" "property")}
      {Lisp-Entry "jazz.all-properties" define #f 2162 9 2162 28 ("else" "%%cdr" "%%cons" "%%car" "jazz.property?" "%%null?" "cond" "%%get-class-instance-slots" "slots" "iter" "let" "category")}
      {Lisp-Entry "jazz.add-property" define #f 2169 9 2169 26 ("1" "%%fx+" "%%set-class-instance-size" "%%when" "%%get-class-instance-slots" "%%set-class-instance-slots" "%%list" "%%get-class-slots" "%%append" "%%set-class-slots" "jazz.add-field" "jazz.new-property" "slot" "and" "slot-offset" "%%get-class-instance-size" "instance-size" "let*" "%%get-category-field" "or" "slot-setter" "slot-getter" "slot-allocate?" "slot-initialize" "slot-name" "class")}
      {Lisp-Entry "jazz.Method" define-class ("class runtime") 2191 27 2191 38 ()}
      {Lisp-Entry "jazz.method?" define #f 2194 9 2194 21 ("jazz.Method" "%%class-is?" "object")}
      {Lisp-Entry "jazz.final-method?" define #f 2198 9 2198 27 ("final" "'final" "%%get-method-dispatch-type" "%%eq?" "jazz.Method" "%%class-is?" "and" "field")}
      {Lisp-Entry "jazz.virtual-method?" define #f 2203 9 2203 29 ("final" "'final" "%%get-method-dispatch-type" "%%neq?" "jazz.Method" "%%class-is?" "and" "field")}
      {Lisp-Entry "jazz.locate-method-owner" define #f 2208 9 2208 33 ("%%get-interface-ascendants" "jazz.Interface" "%%get-class-interfaces" "jazz.find-in" "%%get-class-ascendant" "or" "jazz.Class" "%%class-is?" "%%get-category-field" "%%not" "cond" "iter" "let" "method-name" "category")}
      {Lisp-Entry "jazz.iterate-class-overrides" define #f 2224 9 2224 37 ("%%class-dispatch" "%%neq?" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "category-rank" "interface" "'interface" "'class" "%%eq?" "or" "%%get-method-dispatch-type" "dispatch-type" "jazz.Method" "%%is?" "and" "field" "name" "lambda" "%%get-category-fields" "jazz.iterate-table-safe" "begin" "if" "ancestor" "iter" "%%get-class-ascendant" "ascendant" "let" "proc" "class")}
      {Lisp-Entry "jazz.update-method" define #f 2243 9 2243 27 ("jazz.add-method-node" "jazz.add-final-method" "final" "jazz.add-virtual-method" "interface" "%%get-method-dispatch-type" "case" "%%eq?" "if" "jazz.global-set!" "%%get-category-identifier" "%%compose-name" "method-locator" "%%get-category-field" "method" "jazz.locate-method-owner" "owner" "let" "method-implementation" "method-name" "class")}
      {Lisp-Entry "jazz.new-final-method" define #f 2260 9 2260 30 ("final" "'final" "jazz.Method" "jazz.allocate-method" "implementation" "name")}
      {Lisp-Entry "jazz.add-final-method" define #f 2264 9 2264 30 ("else" "%%eq?" "%%not" "cond" "jazz.locate-method-owner" "owner" "jazz.error" "%%set-method-implementation" "jazz.final-method?" "if" "%%get-category-field" "field" "update-final-method" "jazz.add-field" "jazz.new-final-method" "method" "let" "create-final-method" "define" "method-implementation" "method-name" "class")}
      {Lisp-Entry "jazz.new-virtual-method" define #f 2291 9 2291 32 ("jazz.Method" "jazz.allocate-method" "implementation-rank" "category-rank" "implementation-tree" "dispatch-type" "name")}
      {Lisp-Entry "jazz.add-virtual-method" define #f 2295 9 2295 32 ("else" "%%eq?" "%%not" "cond" "jazz.locate-method-owner" "owner" "%%get-method-implementation-rank" "jazz.error" "%%get-method-node-children" "%%set-method-node-next-implementation" "child" "lambda" "for-each" "%%set-method-node-implementation" "%%get-method-implementation-tree" "jazz.virtual-method?" "%%get-category-field" "field" "let" "update-virtual-method" "jazz.update-category" "jazz.add-field" "1" "%%fx+" "%%set-category-virtual-size" "%%set-method-implementation-rank" "%%get-category-virtual-size" "virtual-size" "jazz.new-virtual-method" "method" "jazz.new-method-node" "node" "interface" "'interface" "class" "'class" "jazz.Class" "%%class-is?" "if" "dispatch-type" "let*" "create-virtual-method" "define" "method-implementation" "method-name" "category")}
      {Lisp-Entry "jazz.add-method-node" define #f 2333 9 2333 29 ("error" "jazz.final-method?" "%%vector-set!" "%%vector-ref" "method-table" "%%get-class-interface-table" "interface" "%%get-class-class-table" "%%get-method-dispatch-type" "case" "dispatch-table" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "category-rank" "receive" "%%get-method-implementation-tree" "jazz.virtual-method?" "%%get-category-field" "field" "else" "jazz.error" "cond" "jazz.locate-method-owner" "owner" "%%get-category-descendants" "descendant" "%%memq" "%%not" "%%when" "map" "end-categories" "end-nodes" "start-node" "proc" "update-method-tree" "%%set-method-node-implementation" "values" "%%cons" "%%set-method-node-children" "%%set-method-node-next-implementation" "%%set-method-node-next-node" "for-each" "jazz.new-method-node" "new-node" "old-children" "%%assq" "or" "new-children" "assv" "child-class" "lambda" "jazz.partition" "partition" "%%cdr" "%%subtype?" "child-category" "%%car" "child" "let*" "%%null?" "%%get-method-node-children" "children" "sub-iter" "iter" "category" "create-method-node" "update-method-node" "%%get-method-node-category" "%%eq?" "if" "locate-most-specific-method-node" "node" "let" "root-node" "create/update-method-node" "define" "method-implementation" "method-name" "class")}
      {Lisp-Entry "jazz.Method-Node" define-class ("class runtime") 2418 27 2418 43 ()}
      {Lisp-Entry "jazz.new-method-node" define #f 2421 9 2421 29 ("jazz.Method-Node" "jazz.allocate-method-node" "%%get-method-node-implementation" "if" "next-implementation" "let" "children" "next-node" "implementation" "category")}
      {Lisp-Entry "jazz.call-into-incoherent" define #f 2426 9 2426 34 ("jazz.error" "rest")}
      {Lisp-Entry "jazz.call-into-abstract" define #f 2430 9 2430 32 ("jazz.error" "method" "class")}
      {Lisp-Entry "jazz.Queue" define-class ("class runtime") 2442 27 2442 37 ()}
      {Lisp-Entry "jazz.new-queue" define #f 2445 9 2445 23 ("jazz.Queue" "jazz.allocate-queue")}
      {Lisp-Entry "jazz.enqueue" define #f 2449 9 2449 21 ("jazz.enqueue-impl" "%%cons" "pair" "let" "object" "queue")}
      {Lisp-Entry "jazz.enqueue-list" define #f 2454 9 2454 26 ("jazz.enqueue-impl" "%%not-null?" "%%when" "lst" "queue")}
      {Lisp-Entry "jazz.enqueue-impl" define #f 2459 9 2459 26 ("else" "%%cdr" "%%pair?" "jazz.last-pair" "%%get-queue-head" "jazz.list-copy" "copy" "%%get-queue-shared?" "%%set-queue-head" "%%null?" "cond" "%%get-queue-tail" "let" "%%set-queue-shared?" "if" "%%set-queue-tail" "set-cdr!" "tail" "stitch" "define" "shared?" "lst" "queue")}
      {Lisp-Entry "jazz.dequeue" define #f 2482 9 2482 21 ("%%car" "%%set-queue-shared?" "%%set-queue-tail" "%%get-queue-tail" "%%eq?" "%%set-queue-head" "%%cdr" "next" "%%pair?" "%%when" "%%get-queue-head" "head" "let" "queue")}
      {Lisp-Entry "jazz.queue-list" define #f 2493 9 2493 24 ("%%get-queue-head" "queue")}
      {Lisp-Entry "jazz.reset-queue" define #f 2497 9 2497 25 ("%%set-queue-shared?" "%%set-queue-tail" "%%set-queue-head" "queue")}}})
"serial"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "serial.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.serial" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz.object->serial" define #f 42 13 42 32 ("object->serial-number" "obj")}
      {Lisp-Entry "jazz.serial->object" define #f 45 13 45 32 ("serial-number->object" "number")}
      {Lisp-Entry "jazz.object->serial-symbol" define #f 49 13 49 39 ("jazz.object->serial" "%%number->string" "%%string-append" "%%string->symbol" "obj")}
      {Lisp-Entry "jazz.serial-number" define #f 56 11 56 29 ("1")}
      {Lisp-Entry "jazz.serialized-objects" define #f 59 11 59 34 ("equal?" "test:" "%%make-table")}
      {Lisp-Entry "jazz.object->serial" define #f 62 12 62 31 ("%%table-set!" "1" "%%fx+" "set!" "jazz.serial-number" "number" "let" "jazz.serialized-objects" "%%table-ref" "or" "obj")}
      {Lisp-Entry "jazz.serial->object" define #f 69 12 69 31 ("%%car" "jazz.error" "%%null?" "continuation-return" "%%fx=" "if" "value" "key" "jazz.serialized-objects" "jazz.iterate-table" "return" "lambda" "continuation-capture" "rest" "number")}}})
"specific"
 ({Lisp-File-Entry {File core "src" "core" "generic" "runtime" "specific.scm"} 1288732032
    {Lisp-Entry "core.generic.runtime.specific" unit #f 38 16 38 45 ()
      {Lisp-Entry "jazz.new-specific" define #f 41 9 41 26 ("jazz.Specific" "jazz.allocate-specific" "implementation" "signature-proc")}}}
  {Lisp-File-Entry {File core "src" "core" "generic" "syntax" "specific.scm"} 1288732032
    {Lisp-Entry "core.generic.syntax.specific" unit #f 45 16 45 44 ("jazz.Specific" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Specific" define-class ("class") 48 19 48 32 ("%%set-specific-descendant-specifics" "%%get-specific-descendant-specifics" "descendant-specifics" "%%set-specific-ancestor-specifics" "%%get-specific-ancestor-specifics" "ancestor-specifics" "%%set-specific-implementation" "%%get-specific-implementation" "implementation" "%%set-specific-dynamic-signature" "%%get-specific-dynamic-signature" "dynamic-signature" "jazz.allocate-specific" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.Specific" define-class ("class runtime") 55 27 55 40 ()}
      {Lisp-Entry "jazz.define-specific" define-macro ("macro") 58 20 58 40 ("jazz.expand-define-specific" "%%apply" "rest")}}})
"string"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "string.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.string" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz.memstring" define #f 40 9 40 23 ("1" "%%fx+" "else" "%%string-ref" "%%eqv?" "%%fx=" "cond" "0" "n" "iter" "%%string-length" "len" "let" "string" "char")}}})
"symbol"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "symbol.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.symbol" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz.identifier-unit" define #f 45 9 45 29 ("0" "%%substring" "%%string->symbol" "%%not" "if" "jazz.string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "identifier")}
      {Lisp-Entry "jazz.identifier-name" define #f 54 9 54 29 ("%%string-length" "1" "%%fx+" "%%substring" "%%string->symbol" "%%not" "if" "jazz.string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "identifier")}
      {Lisp-Entry "jazz.specifier?" define #f 68 9 68 24 ("1" "%%fx-" "0" "%%string-ref" "%%eqv?" "2" "%%fx>" "%%string-length" "len" "%%symbol->string" "str" "let" "%%symbol?" "and" "expr")}
      {Lisp-Entry "jazz.specifier->name" define #f 77 9 77 29 ("%%symbol->string" "%%string->symbol" "%%string-length" "%%fx-" "1" "%%substring" "string" "lambda" "extract" "let" "specifier")}
      {Lisp-Entry "jazz.name->specifier" define #f 84 9 84 29 ("%%symbol->string" "%%string-append" "%%string->symbol" "name")}
      {Lisp-Entry "jazz.binding-specifier" define #f 88 9 88 31 ("%%car" "jazz.specifier?" "%%pair?" "and" "jazz.source-code" "%%cdr" "cdr-binding" "let" "binding")}
      {Lisp-Entry "jazz.enumerator?" define #f 100 9 100 25 ("0" "%%symbol->string" "%%string-ref" "%%eqv?" "%%symbol?" "and" "obj")}
      {Lisp-Entry "jazz.enumerator->symbol" define #f 105 9 105 32 ("%%string-length" "1" "%%substring" "%%string->symbol" "%%symbol->string" "name" "let" "obj")}}})
"syntax"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "syntax.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.syntax" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz.source?" define #f 40 9 40 21 ("%%source?" "obj")}
      {Lisp-Entry "jazz.source-code" define #f 44 9 44 25 ("%%source-code" "%%source?" "if" "expr")}
      {Lisp-Entry "jazz.source-locat" define #f 50 9 50 26 ("%%source-locat" "%%source?" "if" "expr")}
      {Lisp-Entry "jazz.desourcify" define #f 56 9 56 24 ("%%desourcify" "expr")}
      {Lisp-Entry "jazz.desourcify-all" define #f 60 9 60 28 ("%%box?" "%%vector?" "%%source?" "%%unbox" "%%box" "box" "desourcify-box" "%%vector-ref" "%%vector-set!" "begin" "%%fx<" "if" "1" "%%fx-" "i" "loop" "let" "0" "%%make-vector" "x" "%%vector-length" "len" "let*" "vect" "desourcify-vector" "else" "%%null?" "%%cdr" "%%car" "%%cons" "%%pair?" "cond" "lst" "desourcify-list" "%%source-code" "desourcify-all" "src" "desourcify-source" "define" "expr")}
      {Lisp-Entry "jazz.sourcify" define #f 102 9 102 22 ("%%sourcify" "src" "expr")}
      {Lisp-Entry "jazz.sourcify-if" define #f 106 9 106 25 ("jazz.sourcify" "jazz.source?" "if" "src" "expr")}
      {Lisp-Entry "jazz.sourcify-list" define #f 112 9 112 27 ("jazz.desourcify-all" "jazz.sourcify-if" "expr" "lambda" "map" "src" "lst")}
      {Lisp-Entry "jazz.locat-container" define #f 118 9 118 29 ("%%locat-container" "locat")}
      {Lisp-Entry "jazz.locat-position" define #f 122 9 122 28 ("%%locat-position" "locat")}
      {Lisp-Entry "jazz.locat->file/line/col" define #f 126 9 126 34 ("%%list" "%%filepos-col" "col" "%%filepos-line" "line" "%%locat-position" "%%position->filepos" "filepos" "if" "%%locat-container" "%%container->path" "and" "file" "let" "locat")}
      {Lisp-Entry "jazz.container->path" define #f 136 9 136 29 ("%%container->path" "container")}
      {Lisp-Entry "jazz.position->filepos" define #f 140 9 140 31 ("%%position->filepos" "position")}
      {Lisp-Entry "jazz.filepos-line" define #f 144 9 144 26 ("%%filepos-line" "filepos")}
      {Lisp-Entry "jazz.filepos-col" define #f 148 9 148 25 ("%%filepos-col" "filepos")}
      {Lisp-Entry "jazz.save-emit-if" define #f 157 9 157 26 ("jazz.present-source" "pretty-print" "port" "lambda" "jazz.kernel-platform" "jazz.platform-eol-encoding" "eol-encoding:" "jazz.binary-with-extension" "path:" "list" "call-with-output-file" "jazz.scheme-readtable" "current-readtable" "parameterize" "jazz.compiled-source" "jazz.save-emit?" "and" "%%when" "emit")}
      {Lisp-Entry "jazz.present-source" define #f 170 9 170 28 ("%%vector?" "%%source?" "%%vector-ref" "%%vector-set!" "begin" "%%fx<" "if" "%%fx-" "i" "loop" "0" "%%make-vector" "x" "%%vector-length" "len" "let*" "vect" "present-vector" "else" "%%null?" "%%cdr" "%%car" "%%cons" "%%pair?" "cond" "lst" "present-list" "%%filepos-col" "1" "%%filepos-line" "%%fx+" "jazz.present-source" "source" "'source" "%%vector" "%%source-locat" "%%locat-position" "pos" "jazz.source-code" "code" "let" "src" "present-src" "define" "obj")}}}
  {Lisp-File-Entry {File core "src" "core" "module" "syntax" "dialect" "syntax.scm"} 1288732032
    {Lisp-Entry "core.module.syntax.dialect.syntax" unit #f 37 16 37 49 ()
      {Lisp-Entry "jazz.Dialect" define-class ("class") 40 19 40 31 ("%%set-dialect-bindings" "%%get-dialect-bindings" "bindings" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "jazz.dialect-name" generic/specific ("jazz.Dialect~virtual") 44 22 44 39 ()}
      {Lisp-Entry "jazz.dialect-walker" generic/specific ("jazz.Dialect~virtual") 45 22 45 41 ()}}})
"unspecified"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "unspecified.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.unspecified" unit #f 37 16 37 45 ()
      {Lisp-Entry "jazz.unspecified" define #f 40 9 40 25 ("%%unspecified")}
      {Lisp-Entry "jazz.unspecified?" define #f 44 9 44 26 ("%%unspecified?" "expr")}
      {Lisp-Entry "jazz.specified?" define #f 48 9 48 24 ("%%unspecified?" "%%not" "expr")}}})
"vector"
 ({Lisp-File-Entry {File core "src" "core" "base" "runtime" "vector.scm"} 1288732032
    {Lisp-Entry "core.base.runtime.vector" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz.vector-for-each" define #f 40 9 40 29 ("1" "%%fx+" "%%vector-ref" "begin" "%%fx<" "if" "0" "n" "iter" "%%vector-length" "len" "let" "vector" "proc")}
      {Lisp-Entry "jazz.vector-memq?" define #f 49 9 49 26 ("1" "%%fx+" "%%vector-ref" "%%eq?" "%%fx<" "if" "0" "n" "iter" "%%vector-length" "len" "let" "vector" "obj")}
      {Lisp-Entry "jazz.resize-vector" define #f 59 9 59 27 ("%%vector-ref" "%%vector-set!" "0" "%%fx>=" "%%when" "1" "%%vector-length" "min" "%%fx-" "offset" "iter" "%%make-vector" "new-vector" "let" "size" "vector")}}})
