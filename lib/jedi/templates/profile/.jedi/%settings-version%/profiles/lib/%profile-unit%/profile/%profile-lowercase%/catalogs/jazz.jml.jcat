"Experiments"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "experiments" "Experiments.jazz"} 1288732033})
"JML-Element"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "model" "JML-Element.jazz"} 1288732033
    {Lisp-Entry "jazz.jml.model.JML-Element" module #f 37 18 37 44 ("jazz")
      {Lisp-Entry "JML-Element" class #f 44 7 44 18 ("initialize" "JML-Node")
        {Lisp-Entry "tag" slot #f 47 8 47 11 ()}
        {Lisp-Entry "get-tag" accessor #f 47 41 47 49 ()}
        {Lisp-Entry "properties" slot #f 48 8 48 18 ()}
        {Lisp-Entry "get-properties" accessor #f 48 44 48 52 ()}
        {Lisp-Entry "set-properties" accessor #f 48 44 48 52 ()}
        {Lisp-Entry "children" slot #f 49 8 49 16 ()}
        {Lisp-Entry "get-children" accessor #f 49 44 49 52 ()}
        {Lisp-Entry "set-children" accessor #f 49 44 49 52 ()}
        {Lisp-Entry "initialize" method #f 52 20 52 30 ("self" "set-parent-value" "child" "lambda" "for-each" "not-null?" "when" "children~self" "properties~self" "tag~self" "set!" "nextmethod" "children" "children:" "properties" "properties:" "tag" "parent")}
        {Lisp-Entry "print" method #f 63 20 63 25 ("tag" "format" "properties" "null?" "if" "lambda" "self" "print-unreadable" "readably" "printer")}
        {Lisp-Entry "clone" method #f 71 18 71 23 ("set-children" "properties" "set-properties" "tag" "JML-Element" "new" "clone" "let" "children" "children:" "parent" "parent:")}
        {Lisp-Entry "has-property?" method #f 83 18 83 31 ("not-found:" "key:" "properties" "getf" "neq?" "Box" "not-found" "symbolize-property" "symbol" "let" "property")}
        {Lisp-Entry "get-property" method #f 89 18 89 30 ("cddr" "cadr" "eq?" "car" "null?" "if" "properties" "scan" "iterate" "symbolize-property" "symbol" "let" "not-found" "property")}
        {Lisp-Entry "set-property" method #f 100 18 100 30 ("cddr" "cdr" "set-car!" "eq?" "car" "list" "append" "set!" "null?" "if" "properties" "scan" "iterate" "symbolize-property" "symbol" "let" "value" "property")}
        {Lisp-Entry "remove-property" method #f 111 18 111 33 ("get-output" "set!" "properties" "put" "neq?" "when" "value" "property" "lambda" "for-each-property" "List-Factory" "new" "fact" "symbolize-property" "symbol" "let" "target")}
        {Lisp-Entry "Flattened-Tags" definition #f 127 14 127 28 ("span" "input" "img" "div")}
        {Lisp-Entry "first-child" method #f 131 18 131 29 ("car" "children" "null?" "if")}
        {Lisp-Entry "remove-child" method #f 137 26 137 38 ("remove!" "children" "set!" "node")}
        {Lisp-Entry "add-child" method #f 141 26 141 35 ("list" "append!" "children" "set!" "node")}
        {Lisp-Entry "composite?" method #f 145 18 145 28 ("simple?" "not")}
        {Lisp-Entry "simple?" method #f 149 18 149 25 ("JML-Text" "sub" "lambda" "every?" "simple?" "Flattened-Tags" "get-tag" "memq?" "JML-Element" "is?" "car" "child" "length" "1" "=" "and" "or" "effective-children" "children" "let")}
        {Lisp-Entry "effective-children" method #f 161 11 161 29 ("children")}
        {Lisp-Entry "find-by" method #f 165 18 165 25 ("children" "find-if" "predicate")}
        {Lisp-Entry "find-node" method #f 169 18 169 27 ("get-tag" "eq?" "JML-Element" "is?" "and" "child" "lambda" "find-by" "tag")}
        {Lisp-Entry "find-name" method #f 176 26 176 35 ("'name" "get-property" "eq?" "JML-Element" "is?" "and" "child" "lambda" "find-by" "name")}
        {Lisp-Entry "find-property" method #f 183 18 183 31 ("get-property" "equal?" "JML-Element" "is?" "and" "child" "lambda" "find-by" "value" "property")}
        {Lisp-Entry "get-child-text" method #f 190 18 190 32 ("first-child" "get-text")}
        {Lisp-Entry "get-child-location" method #f 199 20 199 38 ("children" "get-rank" "properties" "length" "1" "+" "list" "child")}
        {Lisp-Entry "->jml" method #f 210 20 210 25 ("children->jml" "properties->jml" "tag->jml")}
        {Lisp-Entry "tag->jml" method #f 214 18 214 26 ("tag" "format" "string->symbol")}
        {Lisp-Entry "properties->jml" method #f 218 18 218 33 ("get-output" "properties" "put" "value" "lambda" "for-each-property" "List-Factory" "new" "fact" "let" "symbol->keyword" "property" "property->jml" "define")}
        {Lisp-Entry "children->jml" method #f 230 18 230 31 ("children" "->jml" "child" "lambda" "map")}}}})
"JML-Node"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "model" "JML-Node.jazz"} 1289506008
    {Lisp-Entry "jazz.jml.model.JML-Node" module #f 37 18 37 41 ("jazz")
      {Lisp-Entry "JML-Node" class #f 43 7 43 15 ("Object")
        {Lisp-Entry "parent" slot #f 46 8 46 14 ()}
        {Lisp-Entry "initialize" method #f 49 20 49 30 ("self" "add-child" "when" "parent~self" "set!" "nextmethod" "parent")}
        {Lisp-Entry "get-parent" method #f 61 18 61 28 ("parent")}
        {Lisp-Entry "set-parent" method #f 65 18 65 28 ("add-child" "set!" "self" "remove-child" "parent" "when" "value")}
        {Lisp-Entry "append-parent" method #f 73 18 73 31 ("append-child" "set!" "self" "remove-child" "parent" "when" "value")}
        {Lisp-Entry "set-parent-value" method #f 81 18 81 34 ("parent" "set!" "value")}
        {Lisp-Entry "get-toplevel" method #f 90 18 90 30 ("get-toplevel" "self" "parent" "not" "if")}
        {Lisp-Entry "for-each-parent" method #f 96 18 96 33 ("for-each-parent" "parent" "when" "proc")}
        {Lisp-Entry "for-each-ancestor" method #f 102 18 102 35 ("for-each-parent" "self" "proc")}
        {Lisp-Entry "get-location" method #f 112 18 112 30 ("self" "get-child-location" "get-location" "append" "parent" "not" "if")}
        {Lisp-Entry "get-child-location" method #f 119 26 119 44 ("child")}
        {Lisp-Entry "->jml" method #f 128 35 128 40 ()}
        {Lisp-Entry "pretty-print" method #f 137 18 137 30 ("car" "null?" "=" "children" "neq?" "length" "pres" "get-property" "7" "has-property?" "-" "pad" "not-null?" ":human" "case" "properties" "single-line?" "get-text" "text" "JML-Text" "if" "receive" "first?" "with-printer" "values" "self" "get-children" "1" "child" "for-each" "get-properties" "table-set!" "table-ref" "max" "'name" "eq?" "format" "cast" "value" "property" "for-each-property" "set!" ">" "not" "or" "2" "*" "cardinality" "+" "width" "cons" "symbol->string" "name" "get-tag" "tag" "let*" "JML-Element" "is?" "when" "level" "path" "node" "lambda" "iter" "letrec" "equal?" "test:" "make-table" "and" "maxes" "max-name" "max-tag" "let" "compute-maxes" "define" ":reader" "readably" "readably:" "align-properties?" "align-properties?:" "align-name?" "align-name?:" "space-properties?" "space-properties?:" "0" "base" "base:" "indent-first?" "indent-first?:" "printer")}}}})
"JML-Parser"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "parser" "JML-Parser.jazz"} 1290096006
    {Lisp-Entry "jazz.jml.parser.JML-Parser" module #f 37 18 37 44 ("jazz")
      {Lisp-Entry "JML-Parser" class #f 44 7 44 17 ("Object")
        {Lisp-Entry "preferences" slot #f 52 8 52 19 ()}
        {Lisp-Entry "get-preferences" accessor #f 52 27 52 35 ()}
        {Lisp-Entry "initialize" method #f 55 20 55 30 ("preferences~self" "set!" "nextmethod" "preferences" "preferences:")}
        {Lisp-Entry "parse" method #f 65 18 65 23 ("port?" "tree" "self" "class-of" "find-dispatch" "tag?" "get-alias" "cons" "append" "apply" "get-path" "path" "alias" "use-generator?" "use-generator?:" "parse-path" "Path" "parse-value" ":string" "jml" "JML-Text" "string?" "element" "for-each" "null/pair?" "nodes" "add-nodes" "queue-list" "parse-property" "keyword->symbol" "enqueue" "value" "property" "for-each-property" "new-queue" "queue" "set-properties" "parse-children" "children" "parse-properties" "properties" "JML-Element" "new" "node" "parse-jml-properties/children" "children-list" "properties-list" "receive" "let" "rest" "bind" "eq?" "and" "expand-pattern" "expansion" "tag->name" "tag" "car" "first" "let*" "pattern" "error" "else" "sub" "lambda" "map" "pair?" "parse-node" "tagged-expr?" "set-parent" "JML-Node" "is?" "not" "cond" "parse-noexpand" "parse-pattern" "pattern-expr?" "if" "object" "parse-any" "expr" "parent" "read" "parse-expr" "reader" "parse-reader" "define" "reader/expr")}
        {Lisp-Entry "tag-valid?" method #f 172 29 172 39 ("tag")}
        {Lisp-Entry "validate-tag" method #f 176 29 176 41 ("error" "tag-valid?" "unless" "tag")}
        {Lisp-Entry "get-alias" method #f 186 29 186 38 ("error" "rest" "name")}}}})
"JML-Preferences"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "preference" "JML-Preferences.jazz"} 1288732033
    {Lisp-Entry "jazz.jml.preference.JML-Preferences" module #f 37 18 37 53 ("jazz")
      {Lisp-Entry "JML-Preferences" class #f 45 7 45 22 ("2" "initialize" "Component")
        {Lisp-Entry "target" property #f 48 12 48 18 ()}
        {Lisp-Entry "get-target" accessor #f 48 51 48 59 ()}
        {Lisp-Entry "set-target" accessor #f 48 51 48 59 ()}
        {Lisp-Entry "jml-directory" property #f 49 12 49 25 ()}
        {Lisp-Entry "get-jml-directory" accessor #f 49 51 49 59 ()}
        {Lisp-Entry "set-jml-directory" accessor #f 49 51 49 59 ()}
        {Lisp-Entry "html-directory" property #f 50 12 50 26 ()}
        {Lisp-Entry "get-html-directory" accessor #f 50 51 50 59 ()}
        {Lisp-Entry "set-html-directory" accessor #f 50 51 50 59 ()}
        {Lisp-Entry "debug-tables?" property #f 51 12 51 25 ()}
        {Lisp-Entry "get-debug-tables?" accessor #f 51 51 51 59 ()}
        {Lisp-Entry "set-debug-tables?" accessor #f 51 51 51 59 ()}
        {Lisp-Entry "debug-colors?" property #f 52 12 52 25 ()}
        {Lisp-Entry "get-debug-colors?" accessor #f 52 51 52 59 ()}
        {Lisp-Entry "set-debug-colors?" accessor #f 52 51 52 59 ()}
        {Lisp-Entry "tab-size" property #f 53 12 53 20 ()}
        {Lisp-Entry "get-tab-size" accessor #f 53 51 53 59 ()}
        {Lisp-Entry "set-tab-size" accessor #f 53 51 53 59 ()}
        {Lisp-Entry "get-class-descriptor" method #f 61 25 61 45 ("JML-Preferences-Descriptor" "new")}}
      {Lisp-Entry "design" submodule #f 70 11 70 17 ()
        {Lisp-Entry "JML-Preferences-Descriptor" class #f 76 7 76 33 ("domain" "name:" "tab-size" "debug-colors?" "debug-tables?" "html-directory" "jml-directory" "target" "categorized:" "Image-Resource" "image:" "title:" "Component-Descriptor")}}}})
"JML-Renderer"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "renderer" "JML-Renderer.jazz"} 1288732033
    {Lisp-Entry "jazz.jml.renderer.JML-Renderer" module #f 37 18 37 48 ("jazz")
      {Lisp-Entry "JML-Renderer" class #f 40 7 40 19 ("Object")
        {Lisp-Entry "preferences" slot #f 43 8 43 19 ()}
        {Lisp-Entry "initialize" method #f 46 20 46 30 ("preferences~self" "set!" "nextmethod" "preferences")}
        {Lisp-Entry "render" method #f 56 26 56 32 ("printer" "jml")}
        {Lisp-Entry "render-node" method #f 60 26 60 37 ("printer" "level" "mix?" "simple?" "jml" "context")}}}})
"JML-Text"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "model" "JML-Text.jazz"} 1288732033
    {Lisp-Entry "jazz.jml.model.JML-Text" module #f 37 18 37 41 ("jazz")
      {Lisp-Entry "JML-Text" class #f 43 7 43 15 ("JML-Node")
        {Lisp-Entry "text" slot #f 46 8 46 12 ()}
        {Lisp-Entry "get-text" accessor #f 46 23 46 31 ()}
        {Lisp-Entry "set-text" accessor #f 46 23 46 31 ()}
        {Lisp-Entry "initialize" method #f 49 20 49 30 ("text~self" "set!" "nextmethod" "text" "parent")}
        {Lisp-Entry "print" method #f 54 20 54 25 ("text" "format" "lambda" "self" "print-unreadable" "readably" "printer")}
        {Lisp-Entry "->jml" method #f 65 20 65 25 ("text")}
        {Lisp-Entry "multi-line?" method #f 74 18 74 29 ("text" "find-in")}
        {Lisp-Entry "single-line?" method #f 78 18 78 30 ("multi-line?" "not")}}}})
"JML-Transformation"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "transformation" "JML-Transformation.jazz"} 1288732033
    {Lisp-Entry "jazz.jml.transformation.JML-Transformation" module #f 37 18 37 60 ("jazz")
      {Lisp-Entry "JML-Transformation" class #f 43 7 43 25 ("Object")
        {Lisp-Entry "parser" slot #f 46 8 46 14 ()}
        {Lisp-Entry "initialize" method #f 49 20 49 30 ("JML-Parser" "or" "new" "parser~self" "set!" "nextmethod" "parser-class" "parser-class:")}
        {Lisp-Entry "transform" method #f 59 26 59 35 ("transform-jml" "parser" "parse" "node")}
        {Lisp-Entry "transform-jml" method #f 63 18 63 31 ("get-children" "transform-jml" "map" "properties->jml" "tag->jml" "get-text" "JML-Text" "new-node" "class-of" "find-dispatch" "get-tag" "name->tag" "tag" "JML-Element" "is?" "and" "self" "parser" "parse" "if" "node-pattern" "pattern" "let" "transform-one" "define" "node")}}}})
"XHTML-Parser"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "xhtml" "XHTML-Parser.jazz"} 1288732033
    {Lisp-Entry "jazz.jml.xhtml.XHTML-Parser" module #f 37 18 37 45 ("jazz")
      {Lisp-Entry "XHTML-Parser" class #f 43 7 43 19 ("JML-Parser")
        {Lisp-Entry "Valid-Tags" definition #f 51 14 51 24 ("var" "ul" "u" "tt" "tr" "title" "thead" "th" "tfoot" "textarea" "td" "tbody" "table" "sup" "sub" "style" "strong" "strike" "span" "small" "select" "script" "samp" "s" "q" "pre" "param" "p" "option" "optgroup" "ol" "object" "noscript" "noframes" "meta" "menu" "map" "link" "li" "legend" "label" "kbd" "isindex" "ins" "input" "img" "iframe" "i" "html" "hr" "head" "h6" "h5" "h4" "h3" "h2" "h1" "frameset" "frame" "form" "font" "fieldset" "em" "dt" "dl" "div" "dir" "dfn" "del" "dd" "colgroup" "col" "code" "cite" "center" "caption" "button" "br" "body" "blockquote" "big" "bdo" "basefont" "base" "b" "area" "applet" "address" "acronym" "abbr" "a")}
        {Lisp-Entry "tag-valid?" method #f 145 20 145 30 ("Valid-Tags" "memq?" "tag")}}}})
"XHTML-Renderer"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "xhtml" "XHTML-Renderer.jazz"} 1288732033
    {Lisp-Entry "jazz.jml.xhtml.XHTML-Renderer" module #f 40 18 40 47 ("jazz")
      {Lisp-Entry "XHTML-Renderer" class #f 46 7 46 21 ("JML-Renderer")
        {Lisp-Entry "Empty-Tags" definition #f 54 14 54 24 ("param" "meta" "link" "input" "img" "hr" "frame" "col" "br" "basefont" "base" "area")}
        {Lisp-Entry "Mix-Tags" definition #f 57 14 57 22 ("td" "p")}
        {Lisp-Entry "Pre-Tags" definition #f 60 14 60 22 ("pre")}
        {Lisp-Entry "Separated-Tags" definition #f 63 14 63 28 ("frameset" "body" "head")}
        {Lisp-Entry "Separated2-Tags" definition #f 66 14 66 29 ("html")}
        {Lisp-Entry "render" method #f 75 20 75 26 ("0" "render-jml" "printer" "jml")}
        {Lisp-Entry "render-jml" method #f 79 11 79 21 ("render-node" "else" "render-text" "JML-Text" "typecase" "printer" "level" "inside-pre?" "mix?" "simple?" "jml" "context")}
        {Lisp-Entry "render-text" method #f 87 19 87 30 ("format" "255" ">" "if" "char->integer" "n" "c" "lambda" "iterate" "get-text" "text" "let" "printer" "jml" "context")}
        {Lisp-Entry "render-node" method #f 97 20 97 31 ("render-tag" "get-tag" "tag" "let" "self" "render" "JML-Node" "is-not?" "if" "printer" "level" "inside-pre?" "mix?" "simple?" "jml" "context")}
        {Lisp-Entry "render-tag" method #f 104 11 104 21 ("end-tag" "Separated2-Tags" "render-children" "1" "+" "else" "body" "html" "case" "new-level" "let" "Empty-Tags" "get-properties" "render-value" "render-string" ":string" "car" "eq?" "pair?" "null?" "if" "value" "property" "lambda" "for-each-property" "*" "unless" "output" "not" "Separated-Tags" "and" "when" "or" "Pre-Tags" "pre?" "Mix-Tags" "memq?" "mix?" "composite?" "preferences" "get-tab-size" "tab" "let*" "printer" "level" "inside-pre?" "parent-mix?" "simple?" "tag" "jml" "context")}
        {Lisp-Entry "render-string" method #f 141 19 141 32 ("cdr" "string" "lambda" "for-each" "output" "value" "property" "printer" "context")}
        {Lisp-Entry "render-value" method #f 149 19 149 31 ("output" "value" "property" "printer" "context")}
        {Lisp-Entry "render-children" method #f 153 11 153 26 ("get-children" "render-jml" "sub" "lambda" "for-each" "printer" "level" "inside-pre?" "mix?" "simple?" "jml" "context")}
        {Lisp-Entry "output" method #f 159 11 159 17 ("output-text" "format" "apply" "text" "let" "parameters" "format-string" "printer" "context")}
        {Lisp-Entry "output-text" method #f 164 19 164 30 ("format" "when" "text" "printer" "context")}
        {Lisp-Entry "end-tag" definition #f 169 15 169 22 ("format" "tag")}}}})
"_jml"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "_jml.jazz"} 1290091771
    {Lisp-Entry "jazz.jml" module #f 37 8 37 16 ("jazz")
      {Lisp-Entry "parse-jml" definition #f 52 20 52 29 ("parse" "preferences:" "JML-Parser" "parser" "JML-Preferences" "or" "new" "pref" "let*" "parser-class" "parser-class:" "preferences-class" "preferences-class:" "jml")}
      {Lisp-Entry "transform-jml" definition #f 63 20 63 33 ("transform" "transformation" "node")}
      {Lisp-Entry "render-jml" definition #f 72 20 72 30 ("render" "JML-Renderer" "renderer" "JML-Preferences" "or" "new" "pref" "let*" "renderer-class" "renderer-class:" "preferences-class" "preferences-class:" "printer" "node")}
      {Lisp-Entry "jml->form" definition #f 87 20 87 29 ("set-locator" "node->form" "form" "parse" "node" "JML-Parser" "new" "parser" "let*" "locator" "expr")}
      {Lisp-Entry "node->form" definition #f 95 21 95 31 ("cdr" "car" "set-children" "install" "'install" "client-form" "'client-form" "set-property" "begin" "null?" "trait-tag?" "set-parent-value" "get-children" "map" "children" "properties:" "'tag-reference" "tag-reference:" "tag-symbolic?:" "name:" "model:" "action:" "textual?:" "Form" "form" "'name" "get-property" "butlast" "string->symbol" "model" "'new" "else" "locate" "'locate" "modify" "'modify" "eq?" "cond" "action" "or" "" "'" "tag-locate?" "ends-with?" "!" "'!" "neq?" "and" "tag-modify?" "symbol->string" "tag-name" "get-tag" "tag" "let*" "JML-Text" "is?" "if" "parent" "node->form" "get-output" "get-properties" "put" "tag-reference" "tag-symbolic?" "name" "memq?" "not" "when" "value" "property" "lambda" "for-each-property" "List-Factory" "new" "fact" "let" "extract-node-properties" "define" "node")}
      {Lisp-Entry "form->node" definition #f 137 21 137 31 ("trait-tag?" "set-children" "set-properties" "get-children" "map" "properties" "JML-Element" "element" "" "'" "!" "'!" "'install" "install" "locate" "modify" "case" "symbol->string" "string-append" "string->symbol" "tag" "get-tag-symbolic?" "get-model" "model" "get-action" "action" "let*" "JML-Text" "is?" "parent" "form/parent->node" "get-output" "get-properties" "neq?" "field-name" "property?" "value" "property" "lambda" "for-each-property" "'tag-reference" "'name" "put" "and" "when" "get-tag-reference" "tag-reference" "get-name" "name" "List-Factory" "new" "fact" "symbolic?" "extract-form-properties" "form->node" "cons" "not" "if" "'client-form" "get-property" "client-form" "let" "children" "add-client-form" "define" "form")}
      {Lisp-Entry "construct-form" definition #f 184 20 184 34 ("setup-context" "jml->form" "form" "let" "locator" "expr")}
      {Lisp-Entry "locators-ref" definition #f 190 20 190 32 ("and" "table-ref" "locator" "let" "symbol" "locators")}
      {Lisp-Entry "*trait-tags*" define #f 195 8 195 20 ("Trait")}
      {Lisp-Entry "register-trait-tag" definition #f 199 20 199 38 ("cons" "*trait-tags*" "set!" "tag")}
      {Lisp-Entry "trait-tag?" definition #f 203 13 203 23 ("*trait-tags*" "memq?" "tag")}
      {Lisp-Entry "read-jml" definition #f 212 20 212 28 ("read" "jazz-readtable" "readtable:" "cr-lf" "'cr-lf" "eol-encoding:" "parse" "path:" "list" "call-with-input-file" "walk-for" "parameterize" "file")}
      {Lisp-Entry "load-jml" definition #f 218 20 218 28 ("read-jml" "parse" "JML-Preferences" "preferences:" "JML-Parser" "new" "parser" "let" "file")}}})
"_syntax"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "syntax" "_syntax.jazz"} 1290090528
    {Lisp-Entry "jazz.jml.syntax" module #f 37 18 37 33 ("jazz")
      {Lisp-Entry "<form>" macro ("macro") 49 15 49 21 ("locators-ref" "symbol" ",locators-code" "list->table" "locators" ",form" "',form" "construct-form" "locators-code" "table->list" ",reference" "',reference" "car" "pair" "map" "list" "'list" "cons" "locators-builder" "walk-references" "for-each" "process-value" "value" "name" "lambda" "for-each-property" "symbol->string" "last" "memv?" "" "!" "*" "install" "memq?" "or" "unless" "jazz.jml.parse.parse-jml-expr" "children" "properties" "tag" "receive" "process-form" "table-set!" "reference" "walk-reference" "eq?" "test:" "make-table" "references" "let" "gather-references" "define" "form")}
      {Lisp-Entry "form" macro ("macro") 86 15 86 19 ("self" "set!" "initialize" "nextmethod" "cons" "get-class-forms" "set-origin" "eval" "'eval" "walk-for" "eq?" "if" "get-class-form" "override" "method" ",form" "class-form" "class-self" "meta" "definition" "begin" "form")}
      {Lisp-Entry "pattern" macro ("macro") 116 15 116 22 (",@rest" "method" "rest")}}})
"autoload"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.jml" "src" "jazz" "jml" "autoload.jazz"} 1288732033
    {Lisp-Entry "jazz.jml.autoload" module #f 37 18 37 35 ("jazz")}})
"parse"
 ({Lisp-File-Entry {File jazz.jml "src" "jazz" "jml" "parse.jazz"} 1289506008
    {Lisp-Entry "jazz.jml.parse" module #f 37 8 37 22 ("jazz")
      {Lisp-Entry "tag?" definition #f 48 20 48 24 ("symbol->string" "tag-string?" "symbol?" "and" "expr")}
      {Lisp-Entry "tag-string?" definition #f 53 20 53 31 ("ends-with?" "starts-with?" "2" "string-length" ">" "and" "string")}
      {Lisp-Entry "tag->name" definition #f 59 20 59 29 ("symbol->string" "string->symbol" "string?" "if" "cardinality" "-" "1" "subseq" "string" "lambda" "extract" "let" "tag")}
      {Lisp-Entry "name->tag" definition #f 68 20 68 29 ("symbol->string" "string-append" "string->symbol" "name")}
      {Lisp-Entry "parse-jml-expr" definition #f 77 20 77 34 ("values" "parse-jml-properties/children" "children" "properties" "receive" "tag->name" "tag" "let" "rest" "first" "bind" "expr")}
      {Lisp-Entry "parse-jml-properties/children" definition #f 84 20 84 49 ("cdr" "cddr" "cadr" "enqueue" "new-queue" "set!" "when" "begin" "keyword?" "not" "and" "car" "element" "queue-list" "values" "null?" "if" "scan" "iterate" "content" "properties" "let" "list")}
      {Lisp-Entry "get-jml-property" definition #f 105 20 105 36 ("cddr" "set!" "cadr" "continuation-return" "car" "eqv?" "when" "not-null?" "while" "return" "lambda" "continuation-capture" "scan" "let" "not-found" "not-found:" "property" "list")}}})
