"JazzScheme-Server"
 ({Lisp-File-Entry {File jazz.website "src" "jazz" "website" "server" "JazzScheme-Server.jazz"} 1288732034
    {Lisp-Entry "jazz.website.server.JazzScheme-Server" module #f 37 18 37 55 ("jazz")
      {Lisp-Entry "JazzScheme-Server" class #f 43 7 43 24 ("Web-Server")}}})
"JazzScheme-Site"
 ({Lisp-File-Entry {File jazz.website "src" "jazz" "website" "server" "JazzScheme-Site.jazz"} 1288732034
    {Lisp-Entry "jazz.website.server.JazzScheme-Site" module #f 37 18 37 53 ("jazz")
      {Lisp-Entry "JazzScheme-Site" class #f 43 7 43 22 ("Object")}}})
"JazzWebsite-Transformation"
 ({Lisp-File-Entry {File jazz.website "src" "jazz" "website" "transformation" "JazzWebsite-Transformation.jazz"} 1290005243
    {Lisp-Entry "jazz.website.transformation.JazzWebsite-Transformation" module #f 37 18 37 72 ("jazz")
      {Lisp-Entry "JazzWebsite-Transformation" class #f 48 7 48 33 ("DocToHTML-Transformation")
        {Lisp-Entry "Generate-Manual?" definition #f 51 14 51 30 ()}
        {Lisp-Entry "anchors" slot #f 55 8 55 15 ()}
        {Lisp-Entry "anchor-names" slot #f 56 8 56 20 ()}
        {Lisp-Entry "next-section" slot #f 57 8 57 20 ()}
        {Lisp-Entry "<website>" method #f 65 12 65 21 ("process-website" "user-feedback" "node")}
        {Lisp-Entry "<division>" method #f 70 12 70 22 ("children->jml" ",title" "->string" "name:" "not" "if" "'title" "title" "'name" "get-property" "name" "let" "node")}
        {Lisp-Entry "<screenshot>" method #f 83 12 83 24 (",label" "align:" "class:" ",preview" "src:" ",image" "href:" "'image" "image" "'preview" "preview" "'label" "get-property" "label" "let" "node")}
        {Lisp-Entry "process-website" method #f 98 11 98 26 ("subsection" "subsections" "subsec" "memq?" ",path" "class:" "selected?" "path" "subsecs" "sec" "bind" "info" "manual-output" "navigation-output" "id:" ",title" "type:" "rel:" "href:" "'title" "title" "error" "else" "output-article" "article" "case" "JML-Element" "is?" "if" "for-each" "output" "section-content-output" ",html" "section-path" "format" "path:" "manual?" "'manual?" "not" "Generate-Manual?" "or" "section-output" "html" "'name" "get-property" "user-feedback" "next-section" "test:" "make-table" "anchors" "set!" "reset-section" "message-box" "->string" ":bulleted" "list" "message" "not-null?" "get-output" "ambiguities" "put" "1" "length" ">" "when" "lst" "name" "anchor-names" "iterate-table" "List-Factory" "new" "fact" "let" "validate-anchor-names" "process-section" "pages" "sections" "process-sections" "get-children" "'section" "get-tag" "eq?" "node" "collect-if" "cons" "section" "lambda" "map" "collect-sections" "define" "website")}
        {Lisp-Entry "section-path" definition #f 207 15 207 27 ("index" "'index" "home" "'home" "eq?" "if" "'name" "get-property" "name" "let" "section")}
        {Lisp-Entry "manual-output" method #f 219 11 219 24 ("summary-output" "summary" "toc-output" "toc" "index-output" "index?" "'index?" "if" "index" "manual-content-output" "content" "present-doc-title" "key:" "find-docs" "map" "append" "apply" "string<?" "sort" "'projects" "project-paths" "'title" "get-property" "title" "let*" "add-catalog" "Component-Catalog" "catalog" "get-name" "name" "project" "lambda" "for-each" "Cataloguer" "new" "cataloguer" "let" "projects" "new-projects-cataloguer" "define" "section")}
        {Lisp-Entry "manual-content-output" method #f 243 11 243 32 ("get-output" "project" "List-Factory" "new" "length" "0" "naturals" "+" "rank" "present-doc-title" "nu<?" "sort" "sorted" "effective-manual-doc-children" "children" "get-sort?" "and" "let*" "key" "sort?" "get-children" ",@rest" "rest" "example" "map" "get-examples" "examples" "put-sequence" "form->node" "->jml" "paragraphs" "tag" "bind" "get-description" "description" "virtual" "'virtual" "get-propagation" "eq?" "get-parameters" "or" "interface-doc" "get-interfaces" "interfaces" "get-ascendant" "ascendant" "get-name" "href:" "set!" "ascendant-doc" "for-each" "first?" "not-null?" "when" "get-ascendants" "collect" "ascendants" "get-definition" "present-text" "output-doc-examples" "Category-Doc" "is?" "if" "cons" "child" "lambda" "key:" "sort?:" "2" ",title" "1" "case" "present-toc-path" "format" "title" "let" "output-manual-doc-children" "output-doc-description" "get-effective-title" "class:" "put" "output-anchor" "error" "else" "output-manual-generic" "Generic-Doc" "output-manual-definition" "Definition-Doc" "output-manual-export" "Export-Doc" "output-manual-method" "Method-Doc" "output-manual-property" "Property-Doc" "output-manual-slot" "Slot-Doc" "output-manual-constant" "Constant-Doc" "output-manual-primitive" "Primitive-Doc" "output-manual-syntax" "Syntax-Doc" "output-manual-concept" "Concept-Doc" "output-manual-form" "Form-Doc" "output-manual-class" "Class-Doc" "output-manual-interface" "Interface-Doc" "output-manual-module" "Module-Doc" "output-manual-unit" "Unit-Doc" "output-manual-package" "Package-Doc" "output-manual-section" "Section-Doc" "output-manual-project" "Project-Doc" "typecase" "output" "path" "level" "doc" "output-manual-doc" "define" "projects" "cataloguer")}
        {Lisp-Entry "effective-manual-doc-children" method #f 457 11 457 40 ("get-output" "get-children" "put" "put-sequence" "find-docs" "docs" "get-path" "path" "let*" "Doc-Insert" "is?" "if" "child" "lambda" "for-each" "List-Factory" "new" "fact" "let" "doc")}
        {Lisp-Entry "find-docs" method #f 469 11 469 20 ("get-output" "find-docs" "'find-docs" "unimplemented" "else" "get-catalogs" "get-parent-project" "for-each" "get-project" "parent" "*" "equal?" "get-client" "null?" "cond" "assert" "find-catalog" "catalog" "read-form" "instantiate" "put" "get-extension" "ci=?" "file" "lambda" "iterate-directory" "exists?" "when" "jazz.website" "Directory" "reference-dir" "let" ":reference" "eq?" "list" "symbol?" "if" "rest" "name" "bind" "List-Factory" "new" "docs" "get-documentation-cataloguer" "cataloguer" "get-application" "appl" "let*" "path")}
        {Lisp-Entry "output-anchor" method #f 496 11 496 24 ("anchor-names" "table-add" "when" ",anchor" "name:" "put" "anchors" "register-anchor" "anchor" "get-name" "name" "let" "output" "doc")}
        {Lisp-Entry "register-anchor" method #f 504 11 504 26 ("table-set!" "increase!" "next-section" "format" "prog1" "->string" "if" "anchor" "let" "anchors" "name" "object")}
        {Lisp-Entry "<docterm>" method #f 510 12 510 21 (",term" "align:" ",body" "width:" "second" "body" "first" "term" "get-children" "children" "let" "node")}
        {Lisp-Entry "summary-output" method #f 525 11 525 25 ("list" "car" "get-children" "=" "docs" "index?" "'index?" "get-property" ",title" "style:" "user-feedback" "for-each" "Section-Doc" "set!" "Project-Doc" "typecase" "iter" "letrec" "has?" "key:" "string<?" "sort" "has-project-descendant?" "collect-if" "effective-manual-doc-children" "let" "length" "0" "naturals" "cons" "1" "+" "rank" "child" "lambda" "map" "null?" "if" ",text" ",anchor" "href:" "class:" "collect-summary-children" "children" "anchors" "table-ref" "anchor" "present-toc-path" "format" "text" "present-doc-title" "let*" "path" "level" "doc" "doc-summary-output" "define" "projects" "section" "title")}
        {Lisp-Entry "toc-output" method #f 575 11 575 21 ("list" "get-children" "docs" "name:" "user-feedback" "key:" "string<?" "sort" "Category-Doc" "Module-Doc" "Unit-Doc" "Package-Doc" "Section-Doc" "Project-Doc" "is?" "or" "collect-if" "effective-manual-doc-children" "let" "length" "0" "naturals" "cons" "+" "child" "lambda" "map" "null?" ",text" ",anchor" "href:" "class:" "3" "<=" "1" "=" "and" "if" "toc-prefix" "car" "rank" "collect-toc-children" "children" "anchors" "table-ref" "anchor" "present-toc-path" "format" "text" "present-doc-title" "title" "let*" "path" "level" "doc" "doc-toc-output" "define" "projects")}
        {Lisp-Entry "present-doc-title" definition #f 613 15 613 32 ("get-effective-title" "doc")}
        {Lisp-Entry "present-toc-path" definition #f 617 15 617 31 ("reverse" "->string" "map" "join" "path")}
        {Lisp-Entry "index-output" method #f 626 11 626 23 ("width:" "eq?" "test:" "make-table" "user-feedback" "alphabetic?" "get-output" "not-null?" "table-ref" "car" "letter-set" "process-letter-set" "List-Factory" "new" "alpha" "assv-value" "non-alpha" "alphabetic-partition" "let*" "letters" "index-navigator" "nu<?" "sort" "list" "cons" "set!" "get-effective-title" "get-name" "when" "anchors" "iterate-table" "lst" "third" "first" "upcase" "key:" "gather-anchors" "partition" "letters-partition" ",title" "href:" "format" "title" "doc" "info" "lambda" "for-each" "string" ",anchor" "name:" "class:" "colspan:" "put" "register-anchor" "anchor" "let" "infos" "char" "bind" "output" "letter-anchors" "letter" "output-letter" "define")}
        {Lisp-Entry "output-article" method #f 694 11 694 25 ("get-children" "error" "+" "output-article" "get-tag" "JML-Element" "is?" "node" "lambda" "for-each" "children->jml" "else" "class:" "2" ",title" "1" "case" "'title" "title" "->string" "name:" "not" "if" "'name" "get-property" "name" "let" "put" "description" "output-article-description" "define" "output" "level" "article")}}}})
"Website"
 ({Lisp-File-Entry {File jazz.website "src" "profile" "website" "Website.jazz"} 1288732034
    {Lisp-Entry "profile.website.Website" module #f 8 8 8 31 ("Website" "register-profile-class" "jazz")
      {Lisp-Entry "Website" class #f 30 7 30 14 ("Jedi-Profile")
        {Lisp-Entry "test" method #f 38 20 38 24 ("extract-doc")}
        {Lisp-Entry "test0" method #f 47 20 47 25 ("regenerate-jazzwebsite" "save" "Jazz-Text-View" "get-guest" "guest" "Host-View" "is?" "and" "when" "current-frame" "frame" "let")}}}})
"_website"
 ({Lisp-File-Entry {File jazz.website "src" "jazz" "website" "_website.jazz"} 1288732034
    {Lisp-Entry "jazz.website" module #f 37 8 37 20 ("jazz")}})
"autoload"
 ({Lisp-File-Entry {File jazz.website "src" "jazz" "website" "autoload.jazz"} 1288732034
    {Lisp-Entry "jazz.website.autoload" module #f 37 18 37 39 ("jazz")}})
