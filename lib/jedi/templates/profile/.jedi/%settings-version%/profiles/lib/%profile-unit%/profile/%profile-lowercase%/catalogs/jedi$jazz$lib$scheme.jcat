"_dialect"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "_dialect.scm"} 1296083298 scheme
    {Lisp-Entry "scheme.dialect" module #f 37 18 37 32 ("core")
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("scheme.dialect.runtime" "scheme.dialect.runtime-classes" "scheme.dialect.dialect" "syntax" "phase" "scheme.dialect.classes" "core.module")}
      {Lisp-Entry "export" anonymous #f 47 1 47 7 ("scheme.dialect.kernel")}}})
"_scheme"
 ({Lisp-File-Entry {File :context "src" "scheme" "_scheme.scm"} 1296083298 scheme
    {Lisp-Entry "scheme" module #f 37 8 37 14 ("core")
      {Lisp-Entry "export" anonymous #f 40 1 40 7 ("syntax" "phase" "scheme.dialect")}}})
"_syntax-rules"
 ({Lisp-File-Entry {File :context "src" "scheme" "syntax-rules" "_syntax-rules.scm"} 1299165943 scheme
    {Lisp-Entry "scheme.syntax-rules" module #f 37 8 37 27 ("scheme")
      {Lisp-Entry "jazz:generate-symbol" native #f 40 16 40 36 ()}
      {Lisp-Entry "jazz:source?" native #f 41 16 41 28 ()}
      {Lisp-Entry "jazz:error" native #f 42 16 42 26 ()}
      {Lisp-Entry "syntax-rules" define-macro #f 45 22 45 34 ("clause" ",_or" ",_er-macro-transformer" "res" ",many" ",_append" "=" "-" "d" "do" "many" ",ell-vars" ",_lambda" ",_map" "nest" "ell-vars" "ell-dim" "depth" ",t" ",_rename" "<=" "t" ">=" "cell" "f" "free" "free-vars" "source?" "syntactic-closure?" "caar" "id" "assoc-id" "ellipse-tail" "ellipse-depth" "ellipse-quote?" ",_strip-source-info" ",_equal?" ",_vector->list" ",_vector?" ",once" ",_pair?" ",_reverse" ",_null?" ",_if" "list" ",l" ",_cons" ",_lp" "_" ",w" ",_car" "once" "symbol->string" "ls-vars" "all-vars" "new-vars" "w" ",_list?" "error" "not" "ellipse?" "else" ",p" ",_quote" ",_compare" ",_and" "l" "cond" ",x" ",v" ",_let" "v" ",_begin" "expand-template" "k" "vars" "dim" ",_expr" ",_unwrap-syntactic-closure" ",_cdr" "p" "tmpl" "pat" "expand-pattern" "ls" "pred" "any" "number->string" "string-append" "1" "+" "set!" "next-v" "_compare" "_rename" "generate-symbol" "_expr" "list->vector" "_list->vector" "vector->list" "_vector->list" "reverse" "_reverse" "lp" "_lp" "list?" "_list?" "vector?" "_vector?" "map" "_map" "append" "_append" "apply" "_apply" "quote" "_quote" "null?" "_null?" "pair?" "_pair?" "cons" "_cons" "cdr" "_cdr" "car" "_car" "equal?" "_equal?" "eq?" "_eq?" "or" "_or" "and" "_and" "_if" "begin" "_begin" "let" "_let" "_lambda" "strip-syntactic-closures" "_strip-syntactic-closures" "strip-source-info" "_strip-source-info" "_unwrap-syntactic-closure" "er-macro-transformer" "_er-macro-transformer" "0" "count" "..." "ellipse" "cddr" "cdddr" "forms" "caddr" "if" "lits" "cadr" "identifier?" "srfi-46?" "unwrap-syntactic-closure" "let*" "identifier=?" "y" "compare" "make-syntactic-closure" "x" "rename" "define" "mac-env" "expr" "lambda" "rsc-macro-transformer")}}})
"classes"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "classes.scm"} 1299165942 scheme
    {Lisp-Entry "scheme.dialect.classes" unit #f 37 16 37 38 ()
      {Lisp-Entry "jazz:Define-Declaration" define-class ("class") 45 19 45 42 ("%%set-define-declaration-value" "%%get-define-declaration-value" "value" "%%get-define-declaration-signature" "signature" "jazz:allocate-define-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Define-Special-Form-Declaration" define-class ("class") 55 19 55 55 ("%%set-define-special-form-body" "%%get-define-special-form-body" "body" "%%set-define-special-form-signature" "%%get-define-special-form-signature" "signature" "jazz:allocate-define-special-form-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Define-Macro-Declaration" define-class ("class") 65 19 65 48 ("%%set-define-macro-body" "%%get-define-macro-body" "body" "%%set-define-macro-signature" "%%get-define-macro-signature" "signature" "jazz:allocate-define-macro-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Scheme-Dialect" define-class ("class") 75 19 75 38 ("jazz:allocate-scheme-dialect" "jazz:Object-Class" "bindings" "jazz:Dialect")}
      {Lisp-Entry "jazz:Scheme-Walker" define-class ("class") 84 19 84 37 ("jazz:allocate-scheme-walker" "jazz:Object-Class" "autoloads" "references" "variables" "literals" "errors" "warnings" "jazz:Walker")}}})
"dialect"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "dialect.scm"} 1299165951 scheme
    {Lisp-Entry "scheme.dialect.dialect" unit #f 37 16 37 38 ("jazz:Scheme-Walker" "jazz:Scheme-Dialect" "jazz:Define-Macro-Declaration" "jazz:Define-Special-Form-Declaration" "jazz:encapsulate-class" "jazz:Define-Declaration")
      {Lisp-Entry "jazz:Define-Declaration" define-class ("class runtime") 45 27 45 50 ()}
      {Lisp-Entry "jazz:new-define-declaration" define #f 48 9 48 36 ("jazz:setup-declaration" "uptodate" "private" "jazz:Define-Declaration" "jazz:allocate-define-declaration" "new-declaration" "let" "signature" "parent" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:Define-Declaration") 55 21 55 52 ("jazz:validate-arguments" "if" "declaration" "%%get-define-declaration-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Define-Declaration") 61 21 61 42 ("%%get-declaration-source" "jazz:new-define" "jazz:add-field" ",name" "jazz:register-define" "jazz:Module-Declaration" "%%is?" "if" "%%get-declaration-parent" "parent" "%%get-lexical-binding-name" "name" "%%get-lexical-binding-type" "jazz:emit-expression" "jazz:emit-type-cast" ",locator" "define" "begin" "jazz:sourcify-if" "%%get-define-declaration-value" "value" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Define-Declaration") 76 21 76 48 ("jazz:Any" "declaration" "%%get-declaration-locator" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz:walk-binding-validate-assignment" generic/specific ("jazz:Define-Declaration") 83 21 83 58 ("%%get-lexical-binding-name" "jazz:walk-error" "%%get-declaration-toplevel" "%%neq?" "%%when" "declaration" "nextmethod" "symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-binding-assignable?" generic/specific ("jazz:Define-Declaration") 89 21 89 50 ()}
      {Lisp-Entry "jazz:emit-binding-assignment" generic/specific ("jazz:Define-Declaration") 93 21 93 49 ("jazz:Any" "jazz:emit-expression" "jazz:sourcified-form" ",locator" "set!" "jazz:new-code" "declaration" "%%get-declaration-locator" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Define-Declaration") 101 21 101 42 ("%%get-define-declaration-value" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Define-Declaration") 107 21 107 35 ("expression" "%%get-define-declaration-value" "jazz:tree-fold" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Define-Special-Form-Declaration" define-class ("class runtime") 119 27 119 63 ()}
      {Lisp-Entry "jazz:new-define-special-form-declaration" define #f 122 9 122 49 ("jazz:setup-declaration" "uptodate" "public" "jazz:Define-Special-Form-Declaration" "jazz:allocate-define-special-form-declaration" "new-declaration" "let" "signature" "parent" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Define-Special-Form-Declaration") 128 21 128 50 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Define-Special-Form-Declaration") 132 21 132 50 ("%%cdr" "%%apply" "jazz:need-macro" "expander" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "jazz:walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Define-Special-Form-Declaration") 143 21 143 42 ("%%get-declaration-source" "jazz:emit-expression" "jazz:sourcified-form" "jazz:emit-signature" "%%cons" "jazz:define-special-form" "jazz:sourcify-if" "cons" "augmented-environment" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-define-special-form-body" "body" "%%get-define-special-form-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Define-Special-Form-Declaration") 156 21 156 42 ("%%get-define-special-form-body" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Define-Macro-Declaration" define-class ("class runtime") 170 27 170 56 ()}
      {Lisp-Entry "jazz:new-define-macro-declaration" define #f 173 9 173 42 ("jazz:setup-declaration" "uptodate" "public" "jazz:Define-Macro-Declaration" "jazz:allocate-define-macro-declaration" "new-declaration" "let" "signature" "parent" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Define-Macro-Declaration") 179 21 179 50 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Define-Macro-Declaration") 183 21 183 50 ("%%cdr" "%%apply" "jazz:need-macro" "expander" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "jazz:walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Define-Macro-Declaration") 194 21 194 42 ("%%get-declaration-source" "jazz:emit-expression" "jazz:sourcified-form" "jazz:emit-signature" "jazz:define-macro" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-define-macro-body" "body" "%%get-define-macro-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Define-Macro-Declaration") 207 21 207 42 ("%%get-define-macro-body" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Scheme-Dialect" define-class ("class runtime") 221 27 221 46 ()}
      {Lisp-Entry "jazz:new-scheme-dialect" define #f 224 9 224 32 ("jazz:Scheme-Dialect" "jazz:allocate-scheme-dialect")}
      {Lisp-Entry "jazz:dialect-name" generic/specific ("jazz:Scheme-Dialect") 228 21 228 38 ("scheme")}
      {Lisp-Entry "jazz:dialect-walker" generic/specific ("jazz:Scheme-Dialect") 232 21 232 40 ("jazz:new-scheme-walker")}
      {Lisp-Entry "jazz:Scheme-Walker" define-class ("class runtime") 244 27 244 45 ()}
      {Lisp-Entry "jazz:new-scheme-walker" define #f 247 9 247 31 ("eq?" "test:" "%%make-table" "jazz:new-queue" "jazz:Scheme-Walker" "jazz:allocate-scheme-walker")}
      {Lisp-Entry "jazz:runtime-export" generic/specific ("jazz:Scheme-Walker") 251 21 251 40 ("%%get-declaration-locator" "jazz:Define-Declaration" "%%is?" "if" "walker" "nextmethod" "or" "declaration")}
      {Lisp-Entry "jazz:walk-declaration" generic/specific ("jazz:Scheme-Walker") 263 21 263 42 ("nextmethod" "else" "jazz:walk-define-macro-declaration" "define-macro" "walker" "jazz:walk-define-declaration" "define" "case" "%%car" "first" "let" "jazz:source-code" "%%pair?" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walker-bindings" generic/specific ("jazz:Scheme-Walker") 278 21 278 41 ("walker" "nextmethod" "scheme" "jazz:get-dialect" "%%get-dialect-bindings" "append")}
      {Lisp-Entry "jazz:walk-define-declaration" define #f 288 9 288 37 ("jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz:new-define-declaration" "jazz:find-child-declaration" "or" "new-declaration" "jazz:walk-parameters" "and" "signature" "jazz:Any" "jazz:walk-specifier" "if" "type" "let" "jazz:Namespace-Declaration" "%%class-is?" "%%assert" "jazz:source-code" "%%cdr" "jazz:parse-define" "parameters" "value" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define" define #f 300 9 300 25 ("%%set-declaration-source" "jazz:walk" "%%set-define-declaration-value" "%%cons" "new-environment" "jazz:require-declaration" "new-declaration" "let*" "jazz:Namespace-Declaration" "%%class-is?" "%%assert" "jazz:source-code" "%%cdr" "jazz:parse-define" "parameters" "value" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:parse-define-special-form" define #f 315 9 315 39 ("values" "parameters" "jazz:Any" "type" "name" "%%cdr" "body" "%%car" "%%desourcify" "signature" "let*" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define-special-form-declaration" define #f 324 9 324 50 ("jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz:new-define-special-form-declaration" "jazz:find-child-declaration" "or" "new-declaration" "jazz:walk-parameters" "signature" "let" "jazz:source-code" "%%cdr" "jazz:parse-define-special-form" "body" "parameters" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define-special-form" define #f 334 9 334 38 ("%%set-declaration-source" "jazz:walk-body" "%%set-define-special-form-body" "%%set-define-special-form-signature" "jazz:walk-parameters" "augmented-environment" "signature" "jazz:require-declaration" "new-declaration" "let*" "jazz:source-code" "%%cdr" "jazz:parse-define-special-form" "body" "parameters" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:parse-define-macro" define #f 350 9 350 32 ("values" "parameters" "jazz:Any" "type" "name" "body" "%%car" "%%desourcify" "signature" "let*" "jazz:walk-error" "%%cdr" "%%not-null?" "and" "%%assertion" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define-macro-declaration" define #f 360 9 360 43 ("jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz:new-define-macro-declaration" "jazz:find-child-declaration" "or" "new-declaration" "jazz:walk-parameters" "signature" "let" "jazz:source-code" "%%cdr" "jazz:parse-define-macro" "body" "parameters" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define-macro" define #f 370 9 370 31 ("%%set-declaration-source" "jazz:walk-body" "%%set-define-macro-body" "%%set-define-macro-signature" "jazz:walk-parameters" "augmented-environment" "signature" "jazz:require-declaration" "new-declaration" "let*" "jazz:source-code" "%%cdr" "jazz:parse-define-macro" "body" "parameters" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-let-macro" define #f 386 9 386 28 ("jazz:walk-body" "begin" "%%append" "new-environment" "eval" "jazz:new-macro-form" "expander" "%%car" "name" "binding" "lambda" "map" "macro-forms" "%%cddr" "body" "%%cadr" "bindings" "let*" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-let-symbol" define #f 405 9 405 29 ("jazz:walk-body" "begin" "%%append" "new-environment" "eval" "jazz:new-macro-symbol" "setter" "getter" "%%car" "name" "binding" "lambda" "map" "macro-symbols" "%%cddr" "body" "%%cadr" "bindings" "let*" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-lambda" define #f 425 9 425 25 ("jazz:walk-body" "jazz:new-lambda" "unspecified" "%%list" "%%null?" "effective-body" "jazz:Any" "jazz:walk-specifier" "if" "type" "jazz:walk-parameters" "augmented-environment" "signature" "receive" "body" "specifier" "lambda" "%%cddr" "jazz:parse-specifier" "%%cadr" "%%desourcify" "parameters" "let" "jazz:walk-error" "jazz:source-code" "%%cdr" "%%not-null?" "%%assertion" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:parse-binding" define #f 442 9 442 27 ("jazz:new-variable" "values" "value" "jazz:walk-specifier" "if" "type" "rest" "specifier" "lambda" "jazz:parse-specifier" "%%car" "symbol" "let" "%%desourcify" "jazz:walk-error" "%%cdr" "jazz:source-code" "%%pair?" "and" "%%assertion" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-let" define #f 452 9 452 22 ("jazz:walk-body" "jazz:queue-list" "jazz:new-let" "set!" "jazz:walk" "%%cons" "jazz:enqueue" "jazz:parse-binding" "value" "variable" "receive" "continuation-capture" "binding-form" "lambda" "for-each" "jazz:new-queue" "expanded-bindings" "augmented-environment" "unspecified" "%%list" "effective-body" "%%null?" "or" "jazz:signature-named-let" "%%car" "%%pair?" "and" "jazz:source-code" "%%cddr" "body" "bindings" "bindings-src" "let*" "jazz:walk-named-let" "%%cadr" "%%symbol?" "if" "jazz:walk-error" "%%cdr" "%%not-null?" "%%assertion" "unwrap-syntactic-closure" "unwrapped" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-letstar" define #f 478 9 478 26 ("jazz:walk-body" "jazz:queue-list" "jazz:new-letstar" "set!" "jazz:walk" "%%cons" "jazz:enqueue" "jazz:parse-binding" "value" "variable" "receive" "continuation-capture" "binding-form" "lambda" "for-each" "jazz:new-queue" "expanded-bindings" "augmented-environment" "jazz:source-code" "%%cddr" "body" "%%cadr" "bindings" "let" "jazz:walk-error" "unwrap-syntactic-closure" "%%cdr" "%%not-null?" "%%assertion" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-letrec" define #f 496 9 496 25 ("jazz:walk-body" "jazz:queue-list" "jazz:new-letrec" "jazz:walk" "%%cons" "jazz:enqueue" "value" "continuation-capture" "variable" "for-each" "jazz:new-queue" "expanded-bindings" "%%append" "augmented-environment" "%%car" "jazz:new-variable" "binding-form" "lambda" "map" "new-variables" "let*" "jazz:source-code" "%%cddr" "body" "%%cadr" "bindings" "let" "jazz:walk-error" "unwrap-syntactic-closure" "%%cdr" "%%not-null?" "%%assertion" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-receive" define #f 515 9 515 26 ("jazz:walk-body" "jazz:walk" "continuation-capture" "jazz:new-receive" "%%append" "new-environment" "variables" "jazz:source-code" "body" "%%cddr" "expression" "%%cadr" "%%desourcify" "let*" "jazz:walk-error" "unwrap-syntactic-closure" "%%not-null?" "%%assertion" "jazz:new-variable" "jazz:enqueue" "jazz:Any" "jazz:walk-specifier" "type" "rest" "specifier" "lambda" "%%cdr" "jazz:parse-specifier" "%%car" "expr" "jazz:queue-list" "%%null?" "if" "scan" "iter" "jazz:new-queue" "queue" "let" "parameters" "walk-parameters" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-if" define #f 545 9 545 21 ("unspecified" "%%null?" "begin" "%%cons" "jazz:walk" "lambda" "continuation-capture" "jazz:new-if" "%%cdr" "no" "%%cddr" "%%car" "yes" "%%cadr" "test" "let" "%%desourcify" "jazz:walk-error" "3" "jazz:source-code" "%%length" "%%fx<" "if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-cond" define #f 565 9 565 23 ("jazz:queue-list" "jazz:new-cond" "jazz:walk-implicit-begin" "else" "%%cadr" "jazz:walk" "%%cons" "=>" "unwrap-syntactic-closure" "%%eq?" "%%not-null?" "and" "if" "jazz:enqueue" "continuation-capture" "body" "%%car" "test" "%%desourcify" "jazz:walk-error" "%%pair?" "%%assertion" "clause" "lambda" "for-each" "jazz:new-queue" "expanded-clauses" "jazz:source-code" "%%cdr" "clauses" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-case" define #f 586 9 586 23 ("jazz:walk-implicit-begin" "%%cons" "else" "unwrap-syntactic-closure" "%%eq?" "or" "unspecified" "%%list" "%%null?" "if" "effective-body" "%%cdr" "body" "tries" "%%car" "tries-src" "let*" "%%desourcify" "jazz:walk-error" "%%pair?" "%%assertion" "clause" "map" "jazz:walk" "lambda" "continuation-capture" "jazz:new-case" "%%cddr" "clauses" "jazz:source-code" "%%cadr" "target" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-and" define #f 607 9 607 22 ("jazz:source-code" "%%cdr" "jazz:walk-list" "jazz:new-and" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-or" define #f 611 9 611 21 ("jazz:source-code" "%%cdr" "jazz:walk-list" "jazz:new-or" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-begin" define #f 620 9 620 24 ("jazz:walk-list" "jazz:new-begin" "jazz:source-code" "%%cdr" "body" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-implicit-begin" define #f 625 9 625 33 ("jazz:walk-list" "jazz:new-begin" "unspecified" "jazz:walk" "%%null?" "if" "form-list" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-do" define #f 636 9 636 21 ("jazz:walk-body" "jazz:queue-list" "jazz:new-do" "%%cons" "jazz:enqueue" "%%null?" "if" "step" "jazz:walk" "init" "continuation-capture" "variable" "for-each" "jazz:new-queue" "expanded-bindings" "%%append" "augmented-environment" "jazz:new-variable" "binding-form" "lambda" "map" "new-variables" "let*" "body" "%%cdr" "result" "%%cddr" "%%car" "test" "%%cadr" "jazz:source-code" "bindings" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-named-let" define #f 662 9 662 28 ("jazz:walk-body" "jazz:queue-list" "jazz:new-named-let" "jazz:new-variable" "set!" "jazz:walk" "%%cons" "jazz:enqueue" "jazz:parse-binding" "value" "variable" "receive" "continuation-capture" "binding-form" "lambda" "for-each" "jazz:new-queue" "expanded-bindings" "augmented-environment" "%%cdr" "body" "%%cddr" "%%car" "%%desourcify" "bindings" "%%cadr" "jazz:source-code" "name" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:signature-named-let" define #f 682 9 682 33 (",@body" ",bindings" ",name" "jazz:sourcify-if" "jazz:walk-named-let" "%%cdr" "%%car" "jazz:source-code" "name" "let" "body" "bindings" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-delay" define #f 697 9 697 24 ("jazz:walk" "jazz:new-delay" "jazz:source-code" "%%cadr" "expression" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-quasiquote" define #f 707 9 707 29 ("jazz:new-quasiquote" "%%cdr" "%%cons" "%%cadr" "jazz:walk" "%%list" "unquote-splicing" "unquote" "%%eq?" "or" "%%car" "first" "let" "jazz:source-code" "%%pair?" "if" "walk" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "scheme" define ("dialect") 728 21 728 27 ("jazz:new-scheme-dialect")}
      {Lisp-Entry "define" define ("special") 732 28 732 34 ("jazz:walk-define" "scheme")}
      {Lisp-Entry "define-macro" define ("special") 733 28 733 40 ("jazz:walk-define-macro" "scheme")}
      {Lisp-Entry "define-special-form" define ("special") 734 28 734 47 ("jazz:walk-define-special-form" "scheme")}
      {Lisp-Entry "quote" define ("special") 735 28 735 33 ("jazz:walk-quote" "scheme")}
      {Lisp-Entry "if" define ("special") 736 28 736 30 ("jazz:walk-if" "scheme")}
      {Lisp-Entry "case" define ("special") 737 28 737 32 ("jazz:walk-case" "scheme")}
      {Lisp-Entry "cond" define ("special") 738 28 738 32 ("jazz:walk-cond" "scheme")}
      {Lisp-Entry "begin" define ("special") 739 28 739 33 ("jazz:walk-begin" "scheme")}
      {Lisp-Entry "lambda" define ("special") 740 28 740 34 ("jazz:walk-lambda" "scheme")}
      {Lisp-Entry "let" define ("special") 741 28 741 31 ("jazz:walk-let" "scheme")}
      {Lisp-Entry "let*" define ("special") 742 28 742 32 ("jazz:walk-letstar" "scheme")}
      {Lisp-Entry "letrec" define ("special") 743 28 743 34 ("jazz:walk-letrec" "scheme")}
      {Lisp-Entry "let-macro" define ("special") 744 28 744 37 ("jazz:walk-let-macro" "scheme")}
      {Lisp-Entry "let-symbol" define ("special") 745 28 745 38 ("jazz:walk-let-symbol" "scheme")}
      {Lisp-Entry "receive" define ("special") 746 28 746 35 ("jazz:walk-receive" "scheme")}
      {Lisp-Entry "set!" define ("special") 747 28 747 32 ("jazz:walk-setbang" "scheme")}
      {Lisp-Entry "and" define ("special") 748 28 748 31 ("jazz:walk-and" "scheme")}
      {Lisp-Entry "or" define ("special") 749 28 749 30 ("jazz:walk-or" "scheme")}
      {Lisp-Entry "do" define ("special") 750 28 750 30 ("jazz:walk-do" "scheme")}
      {Lisp-Entry "delay" define ("special") 751 28 751 33 ("jazz:walk-delay" "scheme")}
      {Lisp-Entry "quasiquote" define ("special") 752 28 752 38 ("jazz:walk-quasiquote" "scheme")}}})
"kernel"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "kernel.scm"} 1296083298 scheme
    {Lisp-Entry "scheme.dialect.kernel" module #f 37 18 37 39 ("core")
      {Lisp-Entry "eq?" native #f 55 8 55 11 ("object^object:bool")}
      {Lisp-Entry "eqv?" native #f 56 8 56 12 ("object^object:bool")}
      {Lisp-Entry "equal?" native #f 57 8 57 14 ("object^object:bool")}
      {Lisp-Entry "number?" native #f 70 8 70 15 ("object:bool")}
      {Lisp-Entry "complex?" native #f 71 8 71 16 ("object:bool")}
      {Lisp-Entry "real?" native #f 72 8 72 13 ("object:bool")}
      {Lisp-Entry "rational?" native #f 73 8 73 17 ("object:bool")}
      {Lisp-Entry "integer?" native #f 74 8 74 16 ("object:bool")}
      {Lisp-Entry "exact?" native #f 75 8 75 14 ("object:bool")}
      {Lisp-Entry "inexact?" native #f 76 8 76 16 ("object:bool")}
      {Lisp-Entry "=" native #f 77 8 77 9 ("number*:bool")}
      {Lisp-Entry "<" native #f 78 8 78 9 ("number*:bool")}
      {Lisp-Entry ">" native #f 79 8 79 9 ("number*:bool")}
      {Lisp-Entry "<=" native #f 80 8 80 10 ("number*:bool")}
      {Lisp-Entry ">=" native #f 81 8 81 10 ("number*:bool")}
      {Lisp-Entry "zero?" native #f 82 8 82 13 ("object:bool")}
      {Lisp-Entry "positive?" native #f 83 8 83 17 ("object:bool")}
      {Lisp-Entry "negative?" native #f 84 8 84 17 ("object:bool")}
      {Lisp-Entry "odd?" native #f 85 8 85 12 ("object:bool")}
      {Lisp-Entry "even?" native #f 86 8 86 13 ("object:bool")}
      {Lisp-Entry "max" native #f 87 8 87 11 ("number*:number")}
      {Lisp-Entry "min" native #f 88 8 88 11 ("number*:number")}
      {Lisp-Entry "+" native #f 89 8 89 9 ("number*:number")}
      {Lisp-Entry "*" native #f 90 8 90 9 ("number*:number")}
      {Lisp-Entry "-" native #f 91 8 91 9 ("number*:number")}
      {Lisp-Entry "/" native #f 92 8 92 9 ("number*:number")}
      {Lisp-Entry "abs" native #f 93 8 93 11 ("number:number")}
      {Lisp-Entry "quotient" native #f 94 8 94 16 ("number^number:number")}
      {Lisp-Entry "remainder" native #f 95 8 95 17 ("number^number:number")}
      {Lisp-Entry "modulo" native #f 96 8 96 14 ("number^number:number")}
      {Lisp-Entry "gcd" native #f 97 8 97 11 ("number*:number")}
      {Lisp-Entry "lcm" native #f 98 8 98 11 ("number*:number")}
      {Lisp-Entry "numerator" native #f 99 8 99 17 ("rational:number")}
      {Lisp-Entry "denominator" native #f 100 8 100 19 ("rational:number")}
      {Lisp-Entry "floor" native #f 101 8 101 13 ("real:real")}
      {Lisp-Entry "ceiling" native #f 102 8 102 15 ("real:real")}
      {Lisp-Entry "truncate" native #f 103 8 103 16 ("real:real")}
      {Lisp-Entry "round" native #f 104 8 104 13 ("real:real")}
      {Lisp-Entry "rationalize" native #f 105 8 105 19 ("number^number:number")}
      {Lisp-Entry "exp" native #f 106 8 106 11 ("number:number")}
      {Lisp-Entry "log" native #f 107 8 107 11 ("number:number")}
      {Lisp-Entry "sin" native #f 108 8 108 11 ("number:fl")}
      {Lisp-Entry "cos" native #f 109 8 109 11 ("number:fl")}
      {Lisp-Entry "tan" native #f 110 8 110 11 ("number:number")}
      {Lisp-Entry "asin" native #f 111 8 111 12 ("number:number")}
      {Lisp-Entry "acos" native #f 112 8 112 12 ("number:number")}
      {Lisp-Entry "atan" native #f 113 8 113 12 ("number^opt<number>:number")}
      {Lisp-Entry "sqrt" native #f 114 8 114 12 ("number:number")}
      {Lisp-Entry "expt" native #f 115 8 115 12 ("number^number:number")}
      {Lisp-Entry "make-rectangular" native #f 116 8 116 24 ("number^number:number")}
      {Lisp-Entry "make-polar" native #f 117 8 117 18 ("number^number:number")}
      {Lisp-Entry "real-part" native #f 118 8 118 17 ("number:number")}
      {Lisp-Entry "imag-part" native #f 119 8 119 17 ("number:number")}
      {Lisp-Entry "magnitude" native #f 120 8 120 17 ("number:number")}
      {Lisp-Entry "angle" native #f 121 8 121 13 ("number:number")}
      {Lisp-Entry "exact->inexact" native #f 122 8 122 22 ("number:number")}
      {Lisp-Entry "inexact->exact" native #f 123 8 123 22 ("number:number")}
      {Lisp-Entry "number->string" native #f 131 8 131 22 ("number:string")}
      {Lisp-Entry "string->number" native #f 132 8 132 22 ("string:number")}
      {Lisp-Entry "not" native #f 145 8 145 11 ("object:bool")}
      {Lisp-Entry "boolean?" native #f 146 8 146 16 ("object:bool")}
      {Lisp-Entry "pair?" native #f 154 8 154 13 ("object:bool")}
      {Lisp-Entry "cons" native #f 155 8 155 12 ("object^object:pair")}
      {Lisp-Entry "car" native #f 156 8 156 11 ("pair:object")}
      {Lisp-Entry "cdr" native #f 157 8 157 11 ("pair:object")}
      {Lisp-Entry "set-car!" native #f 158 8 158 16 ("pair:void")}
      {Lisp-Entry "set-cdr!" native #f 159 8 159 16 ("pair:void")}
      {Lisp-Entry "caar" native #f 160 8 160 12 ("pair:object")}
      {Lisp-Entry "cadr" native #f 161 8 161 12 ("pair:object")}
      {Lisp-Entry "cdar" native #f 162 8 162 12 ("pair:object")}
      {Lisp-Entry "cddr" native #f 163 8 163 12 ("pair:object")}
      {Lisp-Entry "caaar" native #f 164 8 164 13 ("pair:object")}
      {Lisp-Entry "caadr" native #f 165 8 165 13 ("pair:object")}
      {Lisp-Entry "cadar" native #f 166 8 166 13 ("pair:object")}
      {Lisp-Entry "caddr" native #f 167 8 167 13 ("pair:object")}
      {Lisp-Entry "cdaar" native #f 168 8 168 13 ("pair:object")}
      {Lisp-Entry "cdadr" native #f 169 8 169 13 ("pair:object")}
      {Lisp-Entry "cddar" native #f 170 8 170 13 ("pair:object")}
      {Lisp-Entry "cdddr" native #f 171 8 171 13 ("pair:object")}
      {Lisp-Entry "caaaar" native #f 172 8 172 14 ("pair:object")}
      {Lisp-Entry "caaadr" native #f 173 8 173 14 ("pair:object")}
      {Lisp-Entry "caadar" native #f 174 8 174 14 ("pair:object")}
      {Lisp-Entry "caaddr" native #f 175 8 175 14 ("pair:object")}
      {Lisp-Entry "cadaar" native #f 176 8 176 14 ("pair:object")}
      {Lisp-Entry "cadadr" native #f 177 8 177 14 ("pair:object")}
      {Lisp-Entry "caddar" native #f 178 8 178 14 ("pair:object")}
      {Lisp-Entry "cadddr" native #f 179 8 179 14 ("pair:object")}
      {Lisp-Entry "cdaaar" native #f 180 8 180 14 ("pair:object")}
      {Lisp-Entry "cdaadr" native #f 181 8 181 14 ("pair:object")}
      {Lisp-Entry "cdadar" native #f 182 8 182 14 ("pair:object")}
      {Lisp-Entry "cdaddr" native #f 183 8 183 14 ("pair:object")}
      {Lisp-Entry "cddaar" native #f 184 8 184 14 ("pair:object")}
      {Lisp-Entry "cddadr" native #f 185 8 185 14 ("pair:object")}
      {Lisp-Entry "cdddar" native #f 186 8 186 14 ("pair:object")}
      {Lisp-Entry "cddddr" native #f 187 8 187 14 ("pair:object")}
      {Lisp-Entry "null?" native #f 188 8 188 13 ("object:bool")}
      {Lisp-Entry "list?" native #f 189 8 189 13 ("object:bool")}
      {Lisp-Entry "list" native #f 190 8 190 12 ("object*:list")}
      {Lisp-Entry "length" native #f 191 8 191 14 ("list:int")}
      {Lisp-Entry "append" native #f 192 8 192 14 ("list*:list")}
      {Lisp-Entry "reverse" native #f 193 8 193 15 ("list:list")}
      {Lisp-Entry "list-tail" native #f 194 8 194 17 ("list:list")}
      {Lisp-Entry "list-ref" native #f 195 8 195 16 ("list:object")}
      {Lisp-Entry "memq" native #f 196 8 196 12 ("object^list:list+")}
      {Lisp-Entry "memv" native #f 197 8 197 12 ("object^list:list+")}
      {Lisp-Entry "member" native #f 198 8 198 14 ("object^list:list+")}
      {Lisp-Entry "assq" native #f 199 8 199 12 ("object^list:pair+")}
      {Lisp-Entry "assv" native #f 200 8 200 12 ("object^list:pair+")}
      {Lisp-Entry "assoc" native #f 201 8 201 13 ("object^list:pair+")}
      {Lisp-Entry "symbol?" native #f 209 8 209 15 ("object:bool")}
      {Lisp-Entry "symbol->string" native #f 210 8 210 22 ("symbol:string")}
      {Lisp-Entry "string->symbol" native #f 211 8 211 22 ("string:symbol")}
      {Lisp-Entry "char?" native #f 219 8 219 13 ("object:bool")}
      {Lisp-Entry "char=?" native #f 220 8 220 14 ("char^char:bool")}
      {Lisp-Entry "char<?" native #f 221 8 221 14 ("char^char:bool")}
      {Lisp-Entry "char>?" native #f 222 8 222 14 ("char^char:bool")}
      {Lisp-Entry "char<=?" native #f 223 8 223 15 ("char^char:bool")}
      {Lisp-Entry "char>=?" native #f 224 8 224 15 ("char^char:bool")}
      {Lisp-Entry "char-ci=?" native #f 225 8 225 17 ("char^char:bool")}
      {Lisp-Entry "char-ci<?" native #f 226 8 226 17 ("char^char:bool")}
      {Lisp-Entry "char-ci>?" native #f 227 8 227 17 ("char^char:bool")}
      {Lisp-Entry "char-ci<=?" native #f 228 8 228 18 ("char^char:bool")}
      {Lisp-Entry "char-ci>=?" native #f 229 8 229 18 ("char^char:bool")}
      {Lisp-Entry "char-alphabetic?" native #f 230 8 230 24 ("char:bool")}
      {Lisp-Entry "char-numeric?" native #f 231 8 231 21 ("char:bool")}
      {Lisp-Entry "char-whitespace?" native #f 232 8 232 24 ("char:bool")}
      {Lisp-Entry "char-upper-case?" native #f 233 8 233 24 ("char:bool")}
      {Lisp-Entry "char-lower-case?" native #f 234 8 234 24 ("char:bool")}
      {Lisp-Entry "char->integer" native #f 235 8 235 21 ("char:fx")}
      {Lisp-Entry "integer->char" native #f 236 8 236 21 ("fx:char")}
      {Lisp-Entry "char-upcase" native #f 237 8 237 19 ("char:char")}
      {Lisp-Entry "char-downcase" native #f 238 8 238 21 ("char:char")}
      {Lisp-Entry "string?" native #f 246 8 246 15 ("object:bool")}
      {Lisp-Entry "make-string" native #f 247 8 247 19 ("int^opt<char>:string")}
      {Lisp-Entry "string" native #f 248 8 248 14 ("char*:string")}
      {Lisp-Entry "string-length" native #f 249 8 249 21 ("string:int")}
      {Lisp-Entry "string-ref" native #f 250 8 250 18 ("string^int:char")}
      {Lisp-Entry "string-set!" native #f 251 8 251 19 ("string^int^char:void")}
      {Lisp-Entry "string=?" native #f 252 8 252 16 ("string^string:bool")}
      {Lisp-Entry "string-ci=?" native #f 253 8 253 19 ("string^string:bool")}
      {Lisp-Entry "string<?" native #f 254 8 254 16 ("string^string:bool")}
      {Lisp-Entry "string>?" native #f 255 8 255 16 ("string^string:bool")}
      {Lisp-Entry "string<=?" native #f 256 8 256 17 ("string^string:bool")}
      {Lisp-Entry "string>=?" native #f 257 8 257 17 ("string^string:bool")}
      {Lisp-Entry "string-ci<?" native #f 258 8 258 19 ("string^string:bool")}
      {Lisp-Entry "string-ci>?" native #f 259 8 259 19 ("string^string:bool")}
      {Lisp-Entry "string-ci<=?" native #f 260 8 260 20 ("string^string:bool")}
      {Lisp-Entry "string-ci>=?" native #f 261 8 261 20 ("string^string:bool")}
      {Lisp-Entry "substring" native #f 262 8 262 17 ("string^int^int:string")}
      {Lisp-Entry "string-append" native #f 263 8 263 21 ("string*:string")}
      {Lisp-Entry "string->list" native #f 264 8 264 20 ("string:list")}
      {Lisp-Entry "list->string" native #f 265 8 265 20 ("list:string")}
      {Lisp-Entry "string-copy" native #f 266 8 266 19 ("string:string")}
      {Lisp-Entry "string-fill!" native #f 267 8 267 20 ("string^char:void")}
      {Lisp-Entry "vector?" native #f 275 8 275 15 ("object:bool")}
      {Lisp-Entry "make-vector" native #f 276 8 276 19 ("int^opt<object>:vector")}
      {Lisp-Entry "vector" native #f 277 8 277 14 ("object*:vector")}
      {Lisp-Entry "vector-length" native #f 278 8 278 21 ("vector:int")}
      {Lisp-Entry "vector-ref" native #f 279 8 279 18 ("vector^int:object")}
      {Lisp-Entry "vector-set!" native #f 280 8 280 19 ("vector^int^object:void")}
      {Lisp-Entry "vector->list" native #f 281 8 281 20 ("vector:list")}
      {Lisp-Entry "list->vector" native #f 282 8 282 20 ("list:vector")}
      {Lisp-Entry "vector-fill!" native #f 283 8 283 20 ("vector^object:void")}
      {Lisp-Entry "procedure?" native #f 291 8 291 18 ("object:bool")}
      {Lisp-Entry "apply" native #f 292 8 292 13 ("procedure^object*:object")}
      {Lisp-Entry "map" native #f 293 8 293 11 ("procedure^list*:list")}
      {Lisp-Entry "for-each" native #f 294 8 294 16 ("procedure^list*:void")}
      {Lisp-Entry "force" native #f 295 8 295 13 ("promise:object")}
      {Lisp-Entry "call-with-current-continuation" native #f 296 8 296 38 ("procedure:object")}
      {Lisp-Entry "call/cc" native #f 297 8 297 15 ("procedure:object")}
      {Lisp-Entry "values" native #f 298 8 298 14 ("object*:object")}
      {Lisp-Entry "call-with-values" native #f 299 8 299 24 ("procedure^procedure:object")}
      {Lisp-Entry "dynamic-wind" native #f 300 8 300 20 ("procedure^procedure^procedure:object")}
      {Lisp-Entry "eval" native #f 308 8 308 12 ("object^object:object")}
      {Lisp-Entry "scheme-replace-report-environment" native #f 309 8 309 41 ("object:object")}
      {Lisp-Entry "null-environment" native #f 310 8 310 24 ("object:object")}
      {Lisp-Entry "interaction-environment" native #f 311 8 311 31 (":object")}
      {Lisp-Entry "call-with-input-file" native #f 324 8 324 28 ("string^procedure:object")}
      {Lisp-Entry "call-with-output-file" native #f 325 8 325 29 ("string^procedure:object")}
      {Lisp-Entry "input-port?" native #f 326 8 326 19 ("object:bool")}
      {Lisp-Entry "output-port?" native #f 327 8 327 20 ("object:bool")}
      {Lisp-Entry "current-input-port" native #f 328 8 328 26 (":port")}
      {Lisp-Entry "current-output-port" native #f 329 8 329 27 (":port")}
      {Lisp-Entry "with-input-from-file" native #f 330 8 330 28 ("string^procedure:object")}
      {Lisp-Entry "with-output-to-file" native #f 331 8 331 27 ("string^procedure:object")}
      {Lisp-Entry "open-input-file" native #f 332 8 332 23 ("string:port")}
      {Lisp-Entry "open-output-file" native #f 333 8 333 24 ("string:port")}
      {Lisp-Entry "close-input-port" native #f 334 8 334 24 ("port:void")}
      {Lisp-Entry "close-output-port" native #f 335 8 335 25 ("port:void")}
      {Lisp-Entry "read" native #f 343 8 343 12 ("opt<port>:object")}
      {Lisp-Entry "read-char" native #f 344 8 344 17 ("opt<port>:object")}
      {Lisp-Entry "peek-char" native #f 345 8 345 17 ("opt<port>:object")}
      {Lisp-Entry "eof-object?" native #f 346 8 346 19 ("object:bool")}
      {Lisp-Entry "char-ready?" native #f 347 8 347 19 ("opt<port>:bool")}
      {Lisp-Entry "write" native #f 355 8 355 13 ("object^opt<port>:void")}
      {Lisp-Entry "display" native #f 356 8 356 15 ("object^opt<port>:void")}
      {Lisp-Entry "newline" native #f 357 8 357 15 ("opt<port>:void")}
      {Lisp-Entry "write-char" native #f 358 8 358 18 ("char^opt<port>:void")}
      {Lisp-Entry "load" native #f 359 8 359 12 ("string:void")}
      {Lisp-Entry "transcript-on" native #f 360 8 360 21 ("string:void")}
      {Lisp-Entry "transcript-off" native #f 361 8 361 22 (":void")}
      {Lisp-Entry "make-syntactic-closure" native #f 367 8 367 30 ()}
      {Lisp-Entry "syntactic-closure?" native #f 368 8 368 26 ()}
      {Lisp-Entry "syntactic-closure-form" native #f 369 8 369 30 ()}
      {Lisp-Entry "unwrap-syntactic-closure" native #f 370 8 370 32 ()}
      {Lisp-Entry "strip-syntactic-closures" native #f 371 8 371 32 ()}
      {Lisp-Entry "strip-source-info" native #f 372 8 372 25 ()}
      {Lisp-Entry "identifier?" native #f 373 8 373 19 ()}
      {Lisp-Entry "identifier=?" native #f 374 8 374 20 ()}
      {Lisp-Entry "er-macro-transformer" native #f 375 8 375 28 ()}
      {Lisp-Entry "sc-macro-transformer" native #f 376 8 376 28 ()}
      {Lisp-Entry "rsc-macro-transformer" native #f 377 8 377 29 ()}}})
"runtime"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "runtime.scm"} 1299165959 scheme
    {Lisp-Entry "scheme.dialect.runtime" unit #f 37 16 37 38 ("jazz:Define" "jazz:encapsulate-class")
      {Lisp-Entry "jazz:Define" define-class ("class runtime") 45 27 45 38 ()}
      {Lisp-Entry "jazz:new-define" define #f 48 9 48 24 ("jazz:Define" "jazz:allocate-define" "locator" "name")}
      {Lisp-Entry "jazz:register-define" define #f 55 9 55 29 ("jazz:new-define" "jazz:register-module-entry" "locator" "name" "module-name")}}})
"runtime-classes"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "runtime-classes.scm"} 1299165960 scheme
    {Lisp-Entry "scheme.dialect.runtime-classes" unit #f 37 16 37 46 ()
      {Lisp-Entry "jazz:Define" define-class ("class") 45 19 45 30 ("%%get-define-locator" "locator" "jazz:allocate-define" "jazz:Object-Class" "name" "jazz:Field")}}})
