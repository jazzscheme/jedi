"_dialect"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "_dialect.scm"} 236918191. scheme
    {Lisp-Entry "scheme.dialect" module #f 37 18 37 32 ("core")
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("scheme.dialect.runtime" "scheme.dialect.runtime-classes" "scheme.dialect.dialect" "syntax" "phase" "scheme.dialect.classes" "core.module")}
      {Lisp-Entry "export" anonymous #f 47 1 47 7 ("scheme.dialect.kernel")}}})
"_scheme"
 ({Lisp-File-Entry {File :context "src" "scheme" "_scheme.scm"} 236918191. scheme
    {Lisp-Entry "scheme" module #f 37 8 37 14 ("core")
      {Lisp-Entry "export" anonymous #f 40 1 40 7 ("syntax" "phase" "scheme.dialect")}}})
"_syntax-rules"
 ({Lisp-File-Entry {File :context "src" "scheme" "syntax-rules" "_syntax-rules.scm"} 236918191. scheme
    {Lisp-Entry "scheme.syntax-rules" module #f 37 8 37 27 ("scheme")
      {Lisp-Entry "generate-symbol" native ("native") 40 16 40 36 ()}
      {Lisp-Entry "source?" native ("native") 41 16 41 28 ()}
      {Lisp-Entry "error" native ("native") 42 16 42 26 ()}
      {Lisp-Entry "syntax-rules" define-macro #f 45 22 45 34 ("clause" ",_or" ",_er-macro-transformer" "res" ",many" ",_append" "=" "-" "d" "do" "many" ",ell-vars" ",_lambda" ",_map" "nest" "ell-vars" "ell-dim" "depth" ",t" ",_rename" "<=" "t" ">=" "cell" "f" "free" "free-vars" "source?" "syntactic-closure?" "caar" "id" "assoc-id" "ellipse-tail" "ellipse-depth" "ellipse-quote?" ",_strip-source-info" ",_equal?" ",_vector->list" ",_vector?" ",once" ",_pair?" ",_reverse" ",_null?" ",_if" "list" ",l" ",_cons" ",_lp" "_" ",w" ",_car" "once" "symbol->string" "ls-vars" "all-vars" "new-vars" "w" ",_list?" "error" "not" "ellipse?" "else" ",p" ",_quote" ",_compare" ",_and" "l" "cond" ",x" ",v" ",_let" "v" ",_begin" "expand-template" "k" "vars" "dim" ",_expr" ",_unwrap-syntactic-closure" ",_cdr" "p" "tmpl" "pat" "expand-pattern" "ls" "pred" "any" "number->string" "string-append" "1" "+" "set!" "next-v" "_compare" "_rename" "generate-symbol" "_expr" "list->vector" "_list->vector" "vector->list" "_vector->list" "reverse" "_reverse" "lp" "_lp" "list?" "_list?" "vector?" "_vector?" "map" "_map" "append" "_append" "apply" "_apply" "quote" "_quote" "null?" "_null?" "pair?" "_pair?" "cons" "_cons" "cdr" "_cdr" "car" "_car" "equal?" "_equal?" "eq?" "_eq?" "or" "_or" "and" "_and" "_if" "begin" "_begin" "let" "_let" "_lambda" "strip-syntactic-closures" "_strip-syntactic-closures" "strip-source-info" "_strip-source-info" "_unwrap-syntactic-closure" "er-macro-transformer" "_er-macro-transformer" "0" "count" "..." "ellipse" "cddr" "cdddr" "forms" "caddr" "if" "lits" "cadr" "identifier?" "srfi-46?" "unwrap-syntactic-closure" "let*" "identifier=?" "y" "compare" "make-syntactic-closure" "x" "rename" "define" "mac-env" "expr" "lambda" "rsc-macro-transformer")}}})
"classes"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "classes.scm"} 236918191. scheme
    {Lisp-Entry "scheme.dialect.classes" unit #f 37 16 37 38 ()
      {Lisp-Entry "Define-Declaration" define-class ("class syntax") 45 19 45 42 ("%%set-define-declaration-value" "%%get-define-declaration-value" "value" "%%get-define-declaration-signature" "signature" "allocate-define-declaration" "jazz:allocate-define-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Define-Special-Form-Declaration" define-class ("class syntax") 55 19 55 55 ("%%set-define-special-form-body" "%%get-define-special-form-body" "body" "%%set-define-special-form-signature" "%%get-define-special-form-signature" "signature" "allocate-define-special-form-declaration" "jazz:allocate-define-special-form-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Define-Macro-Declaration" define-class ("class syntax") 65 19 65 48 ("%%set-define-macro-body" "%%get-define-macro-body" "body" "%%set-define-macro-signature" "%%get-define-macro-signature" "signature" "allocate-define-macro-declaration" "jazz:allocate-define-macro-declaration" "Object-Class" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "Declaration" "jazz:Declaration")}
      {Lisp-Entry "Scheme-Dialect" define-class ("class syntax") 75 19 75 38 ("allocate-scheme-dialect" "jazz:allocate-scheme-dialect" "Object-Class" "jazz:Object-Class" "bindings" "Dialect" "jazz:Dialect")}
      {Lisp-Entry "Scheme-Walker" define-class ("class syntax") 84 19 84 37 ("allocate-scheme-walker" "jazz:allocate-scheme-walker" "Object-Class" "jazz:Object-Class" "autoloads" "references" "variables" "literals" "errors" "warnings" "Walker" "jazz:Walker")}}})
"dialect"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "dialect.scm"} 236918191. scheme
    {Lisp-Entry "scheme.dialect.dialect" unit #f 37 16 37 38 ("Scheme-Walker" "jazz:Scheme-Walker" "Scheme-Dialect" "jazz:Scheme-Dialect" "Define-Macro-Declaration" "jazz:Define-Macro-Declaration" "Define-Special-Form-Declaration" "jazz:Define-Special-Form-Declaration" "encapsulate-class" "jazz:encapsulate-class" "Define-Declaration" "jazz:Define-Declaration")
      {Lisp-Entry "Define-Declaration" define-class ("class runtime") 45 27 45 50 ()}
      {Lisp-Entry "new-define-declaration" define #f 48 9 48 36 ("setup-declaration" "jazz:setup-declaration" "uptodate" "private" "Define-Declaration" "jazz:Define-Declaration" "allocate-define-declaration" "jazz:allocate-define-declaration" "new-declaration" "let" "signature" "parent" "type" "name")}
      {Lisp-Entry "walk-binding-validate-call" generic/specific ("jazz:Define-Declaration") 55 21 55 52 ("validate-arguments" "jazz:validate-arguments" "if" "declaration" "%%get-define-declaration-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific ("jazz:Define-Declaration") 61 21 61 42 ("%%get-declaration-source" "new-define" "jazz:new-define" "add-field" "jazz:add-field" ",name" "register-define" "jazz:register-define" "Module-Declaration" "jazz:Module-Declaration" "%%is?" "if" "%%get-declaration-parent" "parent" "%%get-lexical-binding-name" "name" "%%get-lexical-binding-type" "emit-expression" "jazz:emit-expression" "emit-type-cast" "jazz:emit-type-cast" ",locator" "define" "begin" "sourcify-if" "jazz:sourcify-if" "%%get-define-declaration-value" "value" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "emit-binding-reference" generic/specific ("jazz:Define-Declaration") 76 21 76 48 ("Any" "jazz:Any" "declaration" "%%get-declaration-locator" "new-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "walk-binding-validate-assignment" generic/specific ("jazz:Define-Declaration") 83 21 83 58 ("%%get-lexical-binding-name" "walk-error" "jazz:walk-error" "%%get-declaration-toplevel" "%%neq?" "%%when" "declaration" "nextmethod" "symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "walk-binding-assignable?" generic/specific ("jazz:Define-Declaration") 89 21 89 50 ()}
      {Lisp-Entry "emit-binding-assignment" generic/specific ("jazz:Define-Declaration") 93 21 93 49 ("Any" "jazz:Any" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" ",locator" "set!" "new-code" "jazz:new-code" "declaration" "%%get-declaration-locator" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "fold-declaration" generic/specific ("jazz:Define-Declaration") 101 21 101 42 ("%%get-define-declaration-value" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "tree-fold" generic/specific ("jazz:Define-Declaration") 107 21 107 35 ("expression" "%%get-define-declaration-value" "tree-fold" "jazz:tree-fold" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "Define-Special-Form-Declaration" define-class ("class runtime") 119 27 119 63 ()}
      {Lisp-Entry "new-define-special-form-declaration" define #f 122 9 122 49 ("setup-declaration" "jazz:setup-declaration" "uptodate" "public" "Define-Special-Form-Declaration" "jazz:Define-Special-Form-Declaration" "allocate-define-special-form-declaration" "jazz:allocate-define-special-form-declaration" "new-declaration" "let" "signature" "parent" "type" "name")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific ("jazz:Define-Special-Form-Declaration") 128 21 128 50 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific ("jazz:Define-Special-Form-Declaration") 132 21 132 50 ("%%cdr" "%%apply" "need-macro" "jazz:need-macro" "expander" "load-unit" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "walk-error" "jazz:walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific ("jazz:Define-Special-Form-Declaration") 143 21 143 42 ("%%get-declaration-source" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "emit-signature" "jazz:emit-signature" "%%cons" "define-special-form" "jazz:define-special-form" "sourcify-if" "jazz:sourcify-if" "cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-define-special-form-body" "body" "%%get-define-special-form-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "fold-declaration" generic/specific ("jazz:Define-Special-Form-Declaration") 156 21 156 42 ("%%get-define-special-form-body" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "Define-Macro-Declaration" define-class ("class runtime") 170 27 170 56 ()}
      {Lisp-Entry "new-define-macro-declaration" define #f 173 9 173 42 ("setup-declaration" "jazz:setup-declaration" "uptodate" "public" "Define-Macro-Declaration" "jazz:Define-Macro-Declaration" "allocate-define-macro-declaration" "jazz:allocate-define-macro-declaration" "new-declaration" "let" "signature" "parent" "type" "name")}
      {Lisp-Entry "walk-binding-expandable?" generic/specific ("jazz:Define-Macro-Declaration") 179 21 179 50 ()}
      {Lisp-Entry "walk-binding-expand-form" generic/specific ("jazz:Define-Macro-Declaration") 183 21 183 50 ("%%cdr" "%%apply" "need-macro" "jazz:need-macro" "expander" "load-unit" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "walk-error" "jazz:walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "emit-declaration" generic/specific ("jazz:Define-Macro-Declaration") 194 21 194 42 ("%%get-declaration-source" "emit-expression" "jazz:emit-expression" "sourcified-form" "jazz:sourcified-form" "emit-signature" "jazz:emit-signature" "define-macro" "jazz:define-macro" "sourcify-if" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "annotate-signature" "jazz:annotate-signature" "with-annotated-frame" "jazz:with-annotated-frame" "%%get-define-macro-body" "body" "%%get-define-macro-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "fold-declaration" generic/specific ("jazz:Define-Macro-Declaration") 207 21 207 42 ("%%get-define-macro-body" "fold-statement" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "Scheme-Dialect" define-class ("class runtime") 221 27 221 46 ()}
      {Lisp-Entry "new-scheme-dialect" define #f 224 9 224 32 ("Scheme-Dialect" "jazz:Scheme-Dialect" "allocate-scheme-dialect" "jazz:allocate-scheme-dialect")}
      {Lisp-Entry "dialect-name" generic/specific ("jazz:Scheme-Dialect") 228 21 228 38 ("scheme")}
      {Lisp-Entry "dialect-walker" generic/specific ("jazz:Scheme-Dialect") 232 21 232 40 ("new-scheme-walker" "jazz:new-scheme-walker")}
      {Lisp-Entry "Scheme-Walker" define-class ("class runtime") 244 27 244 45 ()}
      {Lisp-Entry "new-scheme-walker" define #f 247 9 247 31 ("eq?" "test:" "%%make-table" "new-queue" "jazz:new-queue" "Scheme-Walker" "jazz:Scheme-Walker" "allocate-scheme-walker" "jazz:allocate-scheme-walker")}
      {Lisp-Entry "runtime-export" generic/specific ("jazz:Scheme-Walker") 251 21 251 40 ("%%get-declaration-locator" "Define-Declaration" "jazz:Define-Declaration" "%%is?" "if" "walker" "nextmethod" "or" "declaration")}
      {Lisp-Entry "walk-declaration" generic/specific ("jazz:Scheme-Walker") 263 21 263 42 ("nextmethod" "else" "walk-define-macro-declaration" "jazz:walk-define-macro-declaration" "define-macro" "walker" "walk-define-declaration" "jazz:walk-define-declaration" "define" "case" "%%car" "first" "let" "source-code" "jazz:source-code" "%%pair?" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "walker-bindings" generic/specific ("jazz:Scheme-Walker") 278 21 278 41 ("walker" "nextmethod" "scheme" "get-dialect" "jazz:get-dialect" "%%get-dialect-bindings" "append")}
      {Lisp-Entry "walk-define-declaration" define #f 288 9 288 37 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-define-declaration" "jazz:new-define-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "walk-parameters" "jazz:walk-parameters" "and" "signature" "Any" "jazz:Any" "walk-specifier" "jazz:walk-specifier" "if" "type" "let" "Namespace-Declaration" "jazz:Namespace-Declaration" "%%class-is?" "%%assert" "source-code" "jazz:source-code" "%%cdr" "parse-define" "jazz:parse-define" "parameters" "value" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define" define #f 300 9 300 25 ("%%set-declaration-source" "walk" "jazz:walk" "%%set-define-declaration-value" "%%cons" "new-environment" "require-declaration" "jazz:require-declaration" "new-declaration" "let*" "Namespace-Declaration" "jazz:Namespace-Declaration" "%%class-is?" "%%assert" "source-code" "jazz:source-code" "%%cdr" "parse-define" "jazz:parse-define" "parameters" "value" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "parse-define-special-form" define #f 315 9 315 39 ("values" "parameters" "Any" "jazz:Any" "type" "name" "%%cdr" "body" "%%car" "%%desourcify" "signature" "let*" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define-special-form-declaration" define #f 324 9 324 50 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-define-special-form-declaration" "jazz:new-define-special-form-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "walk-parameters" "jazz:walk-parameters" "signature" "let" "source-code" "jazz:source-code" "%%cdr" "parse-define-special-form" "jazz:parse-define-special-form" "body" "parameters" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define-special-form" define #f 334 9 334 38 ("%%set-declaration-source" "walk-body" "jazz:walk-body" "%%set-define-special-form-body" "%%set-define-special-form-signature" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "require-declaration" "jazz:require-declaration" "new-declaration" "let*" "source-code" "jazz:source-code" "%%cdr" "parse-define-special-form" "jazz:parse-define-special-form" "body" "parameters" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "parse-define-macro" define #f 350 9 350 32 ("values" "parameters" "Any" "jazz:Any" "type" "name" "body" "%%car" "%%desourcify" "signature" "let*" "walk-error" "jazz:walk-error" "%%cdr" "%%not-null?" "and" "%%assertion" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define-macro-declaration" define #f 360 9 360 43 ("add-declaration-child" "jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "new-define-macro-declaration" "jazz:new-define-macro-declaration" "find-child-declaration" "jazz:find-child-declaration" "or" "new-declaration" "walk-parameters" "jazz:walk-parameters" "signature" "let" "source-code" "jazz:source-code" "%%cdr" "parse-define-macro" "jazz:parse-define-macro" "body" "parameters" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-define-macro" define #f 370 9 370 31 ("%%set-declaration-source" "walk-body" "jazz:walk-body" "%%set-define-macro-body" "%%set-define-macro-signature" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "require-declaration" "jazz:require-declaration" "new-declaration" "let*" "source-code" "jazz:source-code" "%%cdr" "parse-define-macro" "jazz:parse-define-macro" "body" "parameters" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-let-macro" define #f 386 9 386 28 ("walk-body" "jazz:walk-body" "begin" "%%append" "new-environment" "eval" "new-macro-form" "jazz:new-macro-form" "expander" "%%car" "name" "binding" "lambda" "map" "macro-forms" "%%cddr" "body" "%%cadr" "bindings" "let*" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-let-symbol" define #f 405 9 405 29 ("walk-body" "jazz:walk-body" "begin" "%%append" "new-environment" "eval" "new-macro-symbol" "jazz:new-macro-symbol" "setter" "getter" "%%car" "name" "binding" "lambda" "map" "macro-symbols" "%%cddr" "body" "%%cadr" "bindings" "let*" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-lambda" define #f 425 9 425 25 ("walk-body" "jazz:walk-body" "new-lambda" "jazz:new-lambda" "unspecified" "%%list" "%%null?" "effective-body" "Any" "jazz:Any" "walk-specifier" "jazz:walk-specifier" "if" "type" "walk-parameters" "jazz:walk-parameters" "augmented-environment" "signature" "receive" "body" "specifier" "lambda" "%%cddr" "parse-specifier" "jazz:parse-specifier" "%%cadr" "%%desourcify" "parameters" "let" "walk-error" "jazz:walk-error" "source-code" "jazz:source-code" "%%cdr" "%%not-null?" "%%assertion" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "parse-binding" define #f 442 9 442 27 ("new-variable" "jazz:new-variable" "values" "value" "walk-specifier" "jazz:walk-specifier" "if" "type" "rest" "specifier" "lambda" "parse-specifier" "jazz:parse-specifier" "%%car" "symbol" "let" "%%desourcify" "walk-error" "jazz:walk-error" "%%cdr" "source-code" "jazz:source-code" "%%pair?" "and" "%%assertion" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-let" define #f 452 9 452 22 ("walk-body" "jazz:walk-body" "queue-list" "jazz:queue-list" "new-let" "jazz:new-let" "set!" "walk" "jazz:walk" "%%cons" "enqueue" "jazz:enqueue" "parse-binding" "jazz:parse-binding" "value" "variable" "receive" "continuation-capture" "binding-form" "lambda" "for-each" "new-queue" "jazz:new-queue" "expanded-bindings" "augmented-environment" "unspecified" "%%list" "effective-body" "%%null?" "or" "signature-named-let" "jazz:signature-named-let" "%%car" "%%pair?" "and" "source-code" "jazz:source-code" "%%cddr" "body" "bindings" "bindings-src" "let*" "walk-named-let" "jazz:walk-named-let" "%%cadr" "%%symbol?" "if" "walk-error" "jazz:walk-error" "%%cdr" "%%not-null?" "%%assertion" "unwrap-syntactic-closure" "unwrapped" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-letstar" define #f 478 9 478 26 ("walk-body" "jazz:walk-body" "queue-list" "jazz:queue-list" "new-letstar" "jazz:new-letstar" "set!" "walk" "jazz:walk" "%%cons" "enqueue" "jazz:enqueue" "parse-binding" "jazz:parse-binding" "value" "variable" "receive" "continuation-capture" "binding-form" "lambda" "for-each" "new-queue" "jazz:new-queue" "expanded-bindings" "augmented-environment" "source-code" "jazz:source-code" "%%cddr" "body" "%%cadr" "bindings" "let" "walk-error" "jazz:walk-error" "unwrap-syntactic-closure" "%%cdr" "%%not-null?" "%%assertion" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-letrec" define #f 496 9 496 25 ("walk-body" "jazz:walk-body" "queue-list" "jazz:queue-list" "new-letrec" "jazz:new-letrec" "walk" "jazz:walk" "%%cons" "enqueue" "jazz:enqueue" "value" "continuation-capture" "variable" "for-each" "new-queue" "jazz:new-queue" "expanded-bindings" "%%append" "augmented-environment" "%%car" "new-variable" "jazz:new-variable" "binding-form" "lambda" "map" "new-variables" "let*" "source-code" "jazz:source-code" "%%cddr" "body" "%%cadr" "bindings" "let" "walk-error" "jazz:walk-error" "unwrap-syntactic-closure" "%%cdr" "%%not-null?" "%%assertion" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-receive" define #f 515 9 515 26 ("walk-body" "jazz:walk-body" "walk" "jazz:walk" "continuation-capture" "new-receive" "jazz:new-receive" "%%append" "new-environment" "variables" "source-code" "jazz:source-code" "body" "%%cddr" "expression" "%%cadr" "%%desourcify" "let*" "walk-error" "jazz:walk-error" "unwrap-syntactic-closure" "%%not-null?" "%%assertion" "new-variable" "jazz:new-variable" "enqueue" "jazz:enqueue" "Any" "jazz:Any" "walk-specifier" "jazz:walk-specifier" "type" "rest" "specifier" "lambda" "%%cdr" "parse-specifier" "jazz:parse-specifier" "%%symbol?" "%%assert" "%%car" "expr" "queue-list" "jazz:queue-list" "%%null?" "if" "scan" "iter" "new-queue" "jazz:new-queue" "queue" "let" "parameters" "walk-parameters" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-if" define #f 546 9 546 21 ("unspecified" "%%null?" "begin" "%%cons" "walk" "jazz:walk" "lambda" "continuation-capture" "new-if" "jazz:new-if" "%%cdr" "no" "%%cddr" "%%car" "yes" "%%cadr" "test" "let" "%%desourcify" "walk-error" "jazz:walk-error" "3" "source-code" "jazz:source-code" "%%length" "%%fx<" "if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-cond" define #f 566 9 566 23 ("queue-list" "jazz:queue-list" "new-cond" "jazz:new-cond" "walk-implicit-begin" "jazz:walk-implicit-begin" "else" "%%cadr" "walk" "jazz:walk" "%%cons" "=>" "unwrap-syntactic-closure" "%%eq?" "%%not-null?" "and" "if" "enqueue" "jazz:enqueue" "continuation-capture" "body" "%%car" "test" "%%desourcify" "walk-error" "jazz:walk-error" "%%pair?" "%%assertion" "clause" "lambda" "for-each" "new-queue" "jazz:new-queue" "expanded-clauses" "source-code" "jazz:source-code" "%%cdr" "clauses" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-case" define #f 587 9 587 23 ("walk-implicit-begin" "jazz:walk-implicit-begin" "%%cons" "else" "unwrap-syntactic-closure" "%%eq?" "or" "unspecified" "%%list" "%%null?" "if" "effective-body" "%%cdr" "body" "tries" "%%car" "tries-src" "let*" "%%desourcify" "walk-error" "jazz:walk-error" "%%pair?" "%%assertion" "clause" "map" "walk" "jazz:walk" "lambda" "continuation-capture" "new-case" "jazz:new-case" "%%cddr" "clauses" "source-code" "jazz:source-code" "%%cadr" "target" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-and" define #f 608 9 608 22 ("source-code" "jazz:source-code" "%%cdr" "walk-list" "jazz:walk-list" "new-and" "jazz:new-and" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-or" define #f 612 9 612 21 ("source-code" "jazz:source-code" "%%cdr" "walk-list" "jazz:walk-list" "new-or" "jazz:new-or" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-begin" define #f 621 9 621 24 ("walk-list" "jazz:walk-list" "new-begin" "jazz:new-begin" "source-code" "jazz:source-code" "%%cdr" "body" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-implicit-begin" define #f 626 9 626 33 ("walk-list" "jazz:walk-list" "new-begin" "jazz:new-begin" "unspecified" "walk" "jazz:walk" "%%null?" "if" "form-list" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-do" define #f 637 9 637 21 ("walk-body" "jazz:walk-body" "queue-list" "jazz:queue-list" "new-do" "jazz:new-do" "%%cons" "enqueue" "jazz:enqueue" "%%null?" "if" "step" "walk" "jazz:walk" "init" "continuation-capture" "variable" "for-each" "new-queue" "jazz:new-queue" "expanded-bindings" "%%append" "augmented-environment" "new-variable" "jazz:new-variable" "binding-form" "lambda" "map" "new-variables" "let*" "body" "%%cdr" "result" "%%cddr" "%%car" "test" "%%cadr" "source-code" "jazz:source-code" "bindings" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-named-let" define #f 663 9 663 28 ("walk-body" "jazz:walk-body" "queue-list" "jazz:queue-list" "new-named-let" "jazz:new-named-let" "new-variable" "jazz:new-variable" "set!" "walk" "jazz:walk" "%%cons" "enqueue" "jazz:enqueue" "parse-binding" "jazz:parse-binding" "value" "variable" "receive" "continuation-capture" "binding-form" "lambda" "for-each" "new-queue" "jazz:new-queue" "expanded-bindings" "augmented-environment" "%%cdr" "body" "%%cddr" "%%car" "%%desourcify" "bindings" "%%cadr" "source-code" "jazz:source-code" "name" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "signature-named-let" define #f 683 9 683 33 (",@body" ",bindings" ",name" "sourcify-if" "jazz:sourcify-if" "walk-named-let" "jazz:walk-named-let" "%%cdr" "%%car" "source-code" "jazz:source-code" "name" "let" "body" "bindings" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-delay" define #f 698 9 698 24 ("walk" "jazz:walk" "new-delay" "jazz:new-delay" "source-code" "jazz:source-code" "%%cadr" "expression" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "walk-quasiquote" define #f 708 9 708 29 ("new-quasiquote" "jazz:new-quasiquote" "%%cdr" "%%cons" "%%cadr" "jazz:walk" "%%list" "unquote-splicing" "unquote" "%%eq?" "or" "%%car" "first" "let" "source-code" "jazz:source-code" "%%pair?" "if" "walk" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "scheme" define ("dialect") 729 21 729 27 ("new-scheme-dialect" "jazz:new-scheme-dialect")}
      {Lisp-Entry "define" define ("special") 733 28 733 34 ("walk-define" "jazz:walk-define" "scheme")}
      {Lisp-Entry "define-macro" define ("special") 734 28 734 40 ("walk-define-macro" "jazz:walk-define-macro" "scheme")}
      {Lisp-Entry "define-special-form" define ("special") 735 28 735 47 ("walk-define-special-form" "jazz:walk-define-special-form" "scheme")}
      {Lisp-Entry "quote" define ("special") 736 28 736 33 ("walk-quote" "jazz:walk-quote" "scheme")}
      {Lisp-Entry "if" define ("special") 737 28 737 30 ("walk-if" "jazz:walk-if" "scheme")}
      {Lisp-Entry "case" define ("special") 738 28 738 32 ("walk-case" "jazz:walk-case" "scheme")}
      {Lisp-Entry "cond" define ("special") 739 28 739 32 ("walk-cond" "jazz:walk-cond" "scheme")}
      {Lisp-Entry "begin" define ("special") 740 28 740 33 ("walk-begin" "jazz:walk-begin" "scheme")}
      {Lisp-Entry "lambda" define ("special") 741 28 741 34 ("walk-lambda" "jazz:walk-lambda" "scheme")}
      {Lisp-Entry "let" define ("special") 742 28 742 31 ("walk-let" "jazz:walk-let" "scheme")}
      {Lisp-Entry "let*" define ("special") 743 28 743 32 ("walk-letstar" "jazz:walk-letstar" "scheme")}
      {Lisp-Entry "letrec" define ("special") 744 28 744 34 ("walk-letrec" "jazz:walk-letrec" "scheme")}
      {Lisp-Entry "let-macro" define ("special") 745 28 745 37 ("walk-let-macro" "jazz:walk-let-macro" "scheme")}
      {Lisp-Entry "let-symbol" define ("special") 746 28 746 38 ("walk-let-symbol" "jazz:walk-let-symbol" "scheme")}
      {Lisp-Entry "receive" define ("special") 747 28 747 35 ("walk-receive" "jazz:walk-receive" "scheme")}
      {Lisp-Entry "set!" define ("special") 748 28 748 32 ("walk-setbang" "jazz:walk-setbang" "scheme")}
      {Lisp-Entry "and" define ("special") 749 28 749 31 ("walk-and" "jazz:walk-and" "scheme")}
      {Lisp-Entry "or" define ("special") 750 28 750 30 ("walk-or" "jazz:walk-or" "scheme")}
      {Lisp-Entry "do" define ("special") 751 28 751 30 ("walk-do" "jazz:walk-do" "scheme")}
      {Lisp-Entry "delay" define ("special") 752 28 752 33 ("walk-delay" "jazz:walk-delay" "scheme")}
      {Lisp-Entry "quasiquote" define ("special") 753 28 753 38 ("walk-quasiquote" "jazz:walk-quasiquote" "scheme")}}})
"kernel"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "kernel.scm"} 236918209. scheme
    {Lisp-Entry "scheme.dialect.kernel" module #f 37 18 37 39 ("core")
      {Lisp-Entry "eq?" native ("native") 55 8 55 11 ("object^object:bool" "<object^object:bool>")}
      {Lisp-Entry "eqv?" native ("native") 56 8 56 12 ("object^object:bool" "<object^object:bool>")}
      {Lisp-Entry "equal?" native ("native") 57 8 57 14 ("object^object:bool" "<object^object:bool>")}
      {Lisp-Entry "number?" native ("native") 70 8 70 15 ("object:bool" "<object:bool>")}
      {Lisp-Entry "complex?" native ("native") 71 8 71 16 ("object:bool" "<object:bool>")}
      {Lisp-Entry "real?" native ("native") 72 8 72 13 ("object:bool" "<object:bool>")}
      {Lisp-Entry "rational?" native ("native") 73 8 73 17 ("object:bool" "<object:bool>")}
      {Lisp-Entry "integer?" native ("native") 74 8 74 16 ("object:bool" "<object:bool>")}
      {Lisp-Entry "exact?" native ("native") 75 8 75 14 ("object:bool" "<object:bool>")}
      {Lisp-Entry "inexact?" native ("native") 76 8 76 16 ("object:bool" "<object:bool>")}
      {Lisp-Entry "=" native ("native") 77 8 77 9 ("number*:bool" "<number*:bool>")}
      {Lisp-Entry "<" native ("native") 78 8 78 9 ("number*:bool" "<number*:bool>")}
      {Lisp-Entry ">" native ("native") 79 8 79 9 ("number*:bool" "<number*:bool>")}
      {Lisp-Entry "<=" native ("native") 80 8 80 10 ("number*:bool" "<number*:bool>")}
      {Lisp-Entry ">=" native ("native") 81 8 81 10 ("number*:bool" "<number*:bool>")}
      {Lisp-Entry "zero?" native ("native") 82 8 82 13 ("object:bool" "<object:bool>")}
      {Lisp-Entry "positive?" native ("native") 83 8 83 17 ("object:bool" "<object:bool>")}
      {Lisp-Entry "negative?" native ("native") 84 8 84 17 ("object:bool" "<object:bool>")}
      {Lisp-Entry "odd?" native ("native") 85 8 85 12 ("object:bool" "<object:bool>")}
      {Lisp-Entry "even?" native ("native") 86 8 86 13 ("object:bool" "<object:bool>")}
      {Lisp-Entry "max" native ("native") 87 8 87 11 ("number*:number" "<number*:number>")}
      {Lisp-Entry "min" native ("native") 88 8 88 11 ("number*:number" "<number*:number>")}
      {Lisp-Entry "+" native ("native") 89 8 89 9 ("number*:number" "<number*:number>")}
      {Lisp-Entry "*" native ("native") 90 8 90 9 ("number*:number" "<number*:number>")}
      {Lisp-Entry "-" native ("native") 91 8 91 9 ("number*:number" "<number*:number>")}
      {Lisp-Entry "/" native ("native") 92 8 92 9 ("number*:number" "<number*:number>")}
      {Lisp-Entry "abs" native ("native") 93 8 93 11 ("number:number" "<number:number>")}
      {Lisp-Entry "quotient" native ("native") 94 8 94 16 ("number^number:number" "<number^number:number>")}
      {Lisp-Entry "remainder" native ("native") 95 8 95 17 ("number^number:number" "<number^number:number>")}
      {Lisp-Entry "modulo" native ("native") 96 8 96 14 ("number^number:number" "<number^number:number>")}
      {Lisp-Entry "gcd" native ("native") 97 8 97 11 ("number*:number" "<number*:number>")}
      {Lisp-Entry "lcm" native ("native") 98 8 98 11 ("number*:number" "<number*:number>")}
      {Lisp-Entry "numerator" native ("native") 99 8 99 17 ("rational:number" "<rational:number>")}
      {Lisp-Entry "denominator" native ("native") 100 8 100 19 ("rational:number" "<rational:number>")}
      {Lisp-Entry "floor" native ("native") 101 8 101 13 ("real:real" "<real:real>")}
      {Lisp-Entry "ceiling" native ("native") 102 8 102 15 ("real:real" "<real:real>")}
      {Lisp-Entry "truncate" native ("native") 103 8 103 16 ("real:real" "<real:real>")}
      {Lisp-Entry "round" native ("native") 104 8 104 13 ("real:real" "<real:real>")}
      {Lisp-Entry "rationalize" native ("native") 105 8 105 19 ("number^number:number" "<number^number:number>")}
      {Lisp-Entry "exp" native ("native") 106 8 106 11 ("number:number" "<number:number>")}
      {Lisp-Entry "log" native ("native") 107 8 107 11 ("number:number" "<number:number>")}
      {Lisp-Entry "sin" native ("native") 108 8 108 11 ("number:fl" "<number:fl>")}
      {Lisp-Entry "cos" native ("native") 109 8 109 11 ("number:fl" "<number:fl>")}
      {Lisp-Entry "tan" native ("native") 110 8 110 11 ("number:number" "<number:number>")}
      {Lisp-Entry "asin" native ("native") 111 8 111 12 ("number:number" "<number:number>")}
      {Lisp-Entry "acos" native ("native") 112 8 112 12 ("number:number" "<number:number>")}
      {Lisp-Entry "atan" native ("native") 113 8 113 12 ("number^opt<number>:number" "<number^opt<number>:number>")}
      {Lisp-Entry "sqrt" native ("native") 114 8 114 12 ("number:number" "<number:number>")}
      {Lisp-Entry "expt" native ("native") 115 8 115 12 ("number^number:number" "<number^number:number>")}
      {Lisp-Entry "make-rectangular" native ("native") 116 8 116 24 ("number^number:number" "<number^number:number>")}
      {Lisp-Entry "make-polar" native ("native") 117 8 117 18 ("number^number:number" "<number^number:number>")}
      {Lisp-Entry "real-part" native ("native") 118 8 118 17 ("number:number" "<number:number>")}
      {Lisp-Entry "imag-part" native ("native") 119 8 119 17 ("number:number" "<number:number>")}
      {Lisp-Entry "magnitude" native ("native") 120 8 120 17 ("number:number" "<number:number>")}
      {Lisp-Entry "angle" native ("native") 121 8 121 13 ("number:number" "<number:number>")}
      {Lisp-Entry "exact->inexact" native ("native") 122 8 122 22 ("number:number" "<number:number>")}
      {Lisp-Entry "inexact->exact" native ("native") 123 8 123 22 ("number:number" "<number:number>")}
      {Lisp-Entry "number->string" native ("native") 131 8 131 22 ("number:string" "<number:string>")}
      {Lisp-Entry "string->number" native ("native") 132 8 132 22 ("string:number" "<string:number>")}
      {Lisp-Entry "not" native ("native") 145 8 145 11 ("object:bool" "<object:bool>")}
      {Lisp-Entry "boolean?" native ("native") 146 8 146 16 ("object:bool" "<object:bool>")}
      {Lisp-Entry "pair?" native ("native") 154 8 154 13 ("object:bool" "<object:bool>")}
      {Lisp-Entry "cons" native ("native") 155 8 155 12 ("object^object:pair" "<object^object:pair>")}
      {Lisp-Entry "car" native ("native") 156 8 156 11 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdr" native ("native") 157 8 157 11 ("pair:object" "<pair:object>")}
      {Lisp-Entry "set-car!" native ("native") 158 8 158 16 ("pair:void" "<pair:void>")}
      {Lisp-Entry "set-cdr!" native ("native") 159 8 159 16 ("pair:void" "<pair:void>")}
      {Lisp-Entry "caar" native ("native") 160 8 160 12 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cadr" native ("native") 161 8 161 12 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdar" native ("native") 162 8 162 12 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cddr" native ("native") 163 8 163 12 ("pair:object" "<pair:object>")}
      {Lisp-Entry "caaar" native ("native") 164 8 164 13 ("pair:object" "<pair:object>")}
      {Lisp-Entry "caadr" native ("native") 165 8 165 13 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cadar" native ("native") 166 8 166 13 ("pair:object" "<pair:object>")}
      {Lisp-Entry "caddr" native ("native") 167 8 167 13 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdaar" native ("native") 168 8 168 13 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdadr" native ("native") 169 8 169 13 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cddar" native ("native") 170 8 170 13 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdddr" native ("native") 171 8 171 13 ("pair:object" "<pair:object>")}
      {Lisp-Entry "caaaar" native ("native") 172 8 172 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "caaadr" native ("native") 173 8 173 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "caadar" native ("native") 174 8 174 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "caaddr" native ("native") 175 8 175 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cadaar" native ("native") 176 8 176 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cadadr" native ("native") 177 8 177 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "caddar" native ("native") 178 8 178 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cadddr" native ("native") 179 8 179 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdaaar" native ("native") 180 8 180 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdaadr" native ("native") 181 8 181 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdadar" native ("native") 182 8 182 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdaddr" native ("native") 183 8 183 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cddaar" native ("native") 184 8 184 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cddadr" native ("native") 185 8 185 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cdddar" native ("native") 186 8 186 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "cddddr" native ("native") 187 8 187 14 ("pair:object" "<pair:object>")}
      {Lisp-Entry "null?" native ("native") 188 8 188 13 ("object:bool" "<object:bool>")}
      {Lisp-Entry "list?" native ("native") 189 8 189 13 ("object:bool" "<object:bool>")}
      {Lisp-Entry "list" native ("native") 190 8 190 12 ("object*:list" "<object*:list>")}
      {Lisp-Entry "length" native ("native") 191 8 191 14 ("list:int" "<list:int>")}
      {Lisp-Entry "append" native ("native") 192 8 192 14 ("list*:list" "<list*:list>")}
      {Lisp-Entry "reverse" native ("native") 193 8 193 15 ("list:list" "<list:list>")}
      {Lisp-Entry "list-tail" native ("native") 194 8 194 17 ("list:list" "<list:list>")}
      {Lisp-Entry "list-ref" native ("native") 195 8 195 16 ("list:object" "<list:object>")}
      {Lisp-Entry "memq" native ("native") 196 8 196 12 ("object^list:list+" "<object^list:list+>")}
      {Lisp-Entry "memv" native ("native") 197 8 197 12 ("object^list:list+" "<object^list:list+>")}
      {Lisp-Entry "member" native ("native") 198 8 198 14 ("object^list:list+" "<object^list:list+>")}
      {Lisp-Entry "assq" native ("native") 199 8 199 12 ("object^list:pair+" "<object^list:pair+>")}
      {Lisp-Entry "assv" native ("native") 200 8 200 12 ("object^list:pair+" "<object^list:pair+>")}
      {Lisp-Entry "assoc" native ("native") 201 8 201 13 ("object^list:pair+" "<object^list:pair+>")}
      {Lisp-Entry "symbol?" native ("native") 209 8 209 15 ("object:bool" "<object:bool>")}
      {Lisp-Entry "symbol->string" native ("native") 210 8 210 22 ("symbol:string" "<symbol:string>")}
      {Lisp-Entry "string->symbol" native ("native") 211 8 211 22 ("string:symbol" "<string:symbol>")}
      {Lisp-Entry "char?" native ("native") 219 8 219 13 ("object:bool" "<object:bool>")}
      {Lisp-Entry "char=?" native ("native") 220 8 220 14 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char<?" native ("native") 221 8 221 14 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char>?" native ("native") 222 8 222 14 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char<=?" native ("native") 223 8 223 15 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char>=?" native ("native") 224 8 224 15 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char-ci=?" native ("native") 225 8 225 17 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char-ci<?" native ("native") 226 8 226 17 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char-ci>?" native ("native") 227 8 227 17 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char-ci<=?" native ("native") 228 8 228 18 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char-ci>=?" native ("native") 229 8 229 18 ("char^char:bool" "<char^char:bool>")}
      {Lisp-Entry "char-alphabetic?" native ("native") 230 8 230 24 ("char:bool" "<char:bool>")}
      {Lisp-Entry "char-numeric?" native ("native") 231 8 231 21 ("char:bool" "<char:bool>")}
      {Lisp-Entry "char-whitespace?" native ("native") 232 8 232 24 ("char:bool" "<char:bool>")}
      {Lisp-Entry "char-upper-case?" native ("native") 233 8 233 24 ("char:bool" "<char:bool>")}
      {Lisp-Entry "char-lower-case?" native ("native") 234 8 234 24 ("char:bool" "<char:bool>")}
      {Lisp-Entry "char->integer" native ("native") 235 8 235 21 ("char:fx" "<char:fx>")}
      {Lisp-Entry "integer->char" native ("native") 236 8 236 21 ("fx:char" "<fx:char>")}
      {Lisp-Entry "char-upcase" native ("native") 237 8 237 19 ("char:char" "<char:char>")}
      {Lisp-Entry "char-downcase" native ("native") 238 8 238 21 ("char:char" "<char:char>")}
      {Lisp-Entry "string?" native ("native") 246 8 246 15 ("object:bool" "<object:bool>")}
      {Lisp-Entry "make-string" native ("native") 247 8 247 19 ("int^opt<char>:string" "<int^opt<char>:string>")}
      {Lisp-Entry "string" native ("native") 248 8 248 14 ("char*:string" "<char*:string>")}
      {Lisp-Entry "string-length" native ("native") 249 8 249 21 ("string:int" "<string:int>")}
      {Lisp-Entry "string-ref" native ("native") 250 8 250 18 ("string^int:char" "<string^int:char>")}
      {Lisp-Entry "string-set!" native ("native") 251 8 251 19 ("string^int^char:void" "<string^int^char:void>")}
      {Lisp-Entry "string=?" native ("native") 252 8 252 16 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string-ci=?" native ("native") 253 8 253 19 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string<?" native ("native") 254 8 254 16 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string>?" native ("native") 255 8 255 16 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string<=?" native ("native") 256 8 256 17 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string>=?" native ("native") 257 8 257 17 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string-ci<?" native ("native") 258 8 258 19 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string-ci>?" native ("native") 259 8 259 19 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string-ci<=?" native ("native") 260 8 260 20 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "string-ci>=?" native ("native") 261 8 261 20 ("string^string:bool" "<string^string:bool>")}
      {Lisp-Entry "substring" native ("native") 262 8 262 17 ("string^int^int:string" "<string^int^int:string>")}
      {Lisp-Entry "string-append" native ("native") 263 8 263 21 ("string*:string" "<string*:string>")}
      {Lisp-Entry "string->list" native ("native") 264 8 264 20 ("string:list" "<string:list>")}
      {Lisp-Entry "list->string" native ("native") 265 8 265 20 ("list:string" "<list:string>")}
      {Lisp-Entry "string-copy" native ("native") 266 8 266 19 ("string:string" "<string:string>")}
      {Lisp-Entry "string-fill!" native ("native") 267 8 267 20 ("string^char:void" "<string^char:void>")}
      {Lisp-Entry "vector?" native ("native") 275 8 275 15 ("object:bool" "<object:bool>")}
      {Lisp-Entry "make-vector" native ("native") 276 8 276 19 ("int^opt<object>:vector" "<int^opt<object>:vector>")}
      {Lisp-Entry "vector" native ("native") 277 8 277 14 ("object*:vector" "<object*:vector>")}
      {Lisp-Entry "vector-append" native ("native") 278 8 278 21 ("vector^vector:vector" "<vector^vector:vector>")}
      {Lisp-Entry "vector-length" native ("native") 279 8 279 21 ("vector:int" "<vector:int>")}
      {Lisp-Entry "vector-ref" native ("native") 280 8 280 18 ("vector^int:object" "<vector^int:object>")}
      {Lisp-Entry "vector-set!" native ("native") 281 8 281 19 ("vector^int^object:void" "<vector^int^object:void>")}
      {Lisp-Entry "vector->list" native ("native") 282 8 282 20 ("vector:list" "<vector:list>")}
      {Lisp-Entry "list->vector" native ("native") 283 8 283 20 ("list:vector" "<list:vector>")}
      {Lisp-Entry "vector-fill!" native ("native") 284 8 284 20 ("vector^object:void" "<vector^object:void>")}
      {Lisp-Entry "subvector" native ("native") 285 8 285 17 ("vector^int^int:vector" "<vector^int^int:vector>")}
      {Lisp-Entry "procedure?" native ("native") 293 8 293 18 ("object:bool" "<object:bool>")}
      {Lisp-Entry "apply" native ("native") 294 8 294 13 ("procedure^object*:object" "<procedure^object*:object>")}
      {Lisp-Entry "map" native ("native") 295 8 295 11 ("procedure^list*:list" "<procedure^list*:list>")}
      {Lisp-Entry "for-each" native ("native") 296 8 296 16 ("procedure^list*:void" "<procedure^list*:void>")}
      {Lisp-Entry "force" native ("native") 297 8 297 13 ("promise:object" "<promise:object>")}
      {Lisp-Entry "call-with-current-continuation" native ("native") 298 8 298 38 ("procedure:object" "<procedure:object>")}
      {Lisp-Entry "call/cc" native ("native") 299 8 299 15 ("procedure:object" "<procedure:object>")}
      {Lisp-Entry "values" native ("native") 300 8 300 14 ("object*:object" "<object*:object>")}
      {Lisp-Entry "call-with-values" native ("native") 301 8 301 24 ("procedure^procedure:object" "<procedure^procedure:object>")}
      {Lisp-Entry "dynamic-wind" native ("native") 302 8 302 20 ("procedure^procedure^procedure:object" "<procedure^procedure^procedure:object>")}
      {Lisp-Entry "eval" native ("native") 310 8 310 12 ("object^object:object" "<object^object:object>")}
      {Lisp-Entry "scheme-replace-report-environment" native ("native") 311 8 311 41 ("object:object" "<object:object>")}
      {Lisp-Entry "null-environment" native ("native") 312 8 312 24 ("object:object" "<object:object>")}
      {Lisp-Entry "interaction-environment" native ("native") 313 8 313 31 (":object" "<:object>")}
      {Lisp-Entry "call-with-input-file" native ("native") 326 8 326 28 ("string^procedure:object" "<string^procedure:object>")}
      {Lisp-Entry "call-with-output-file" native ("native") 327 8 327 29 ("string^procedure:object" "<string^procedure:object>")}
      {Lisp-Entry "input-port?" native ("native") 328 8 328 19 ("object:bool" "<object:bool>")}
      {Lisp-Entry "output-port?" native ("native") 329 8 329 20 ("object:bool" "<object:bool>")}
      {Lisp-Entry "current-input-port" native ("native") 330 8 330 26 (":port" "<:port>")}
      {Lisp-Entry "current-output-port" native ("native") 331 8 331 27 (":port" "<:port>")}
      {Lisp-Entry "with-input-from-file" native ("native") 332 8 332 28 ("string^procedure:object" "<string^procedure:object>")}
      {Lisp-Entry "with-output-to-file" native ("native") 333 8 333 27 ("string^procedure:object" "<string^procedure:object>")}
      {Lisp-Entry "open-input-file" native ("native") 334 8 334 23 ("string:port" "<string:port>")}
      {Lisp-Entry "open-output-file" native ("native") 335 8 335 24 ("string:port" "<string:port>")}
      {Lisp-Entry "close-input-port" native ("native") 336 8 336 24 ("port:void" "<port:void>")}
      {Lisp-Entry "close-output-port" native ("native") 337 8 337 25 ("port:void" "<port:void>")}
      {Lisp-Entry "read" native ("native") 345 8 345 12 ("opt<port>:object" "<opt<port>:object>")}
      {Lisp-Entry "read-char" native ("native") 346 8 346 17 ("opt<port>:object" "<opt<port>:object>")}
      {Lisp-Entry "peek-char" native ("native") 347 8 347 17 ("opt<port>:object" "<opt<port>:object>")}
      {Lisp-Entry "eof-object?" native ("native") 348 8 348 19 ("object:bool" "<object:bool>")}
      {Lisp-Entry "char-ready?" native ("native") 349 8 349 19 ("opt<port>:bool" "<opt<port>:bool>")}
      {Lisp-Entry "write" native ("native") 357 8 357 13 ("object^opt<port>:void" "<object^opt<port>:void>")}
      {Lisp-Entry "display" native ("native") 358 8 358 15 ("object^opt<port>:void" "<object^opt<port>:void>")}
      {Lisp-Entry "newline" native ("native") 359 8 359 15 ("opt<port>:void" "<opt<port>:void>")}
      {Lisp-Entry "write-char" native ("native") 360 8 360 18 ("char^opt<port>:void" "<char^opt<port>:void>")}
      {Lisp-Entry "load" native ("native") 361 8 361 12 ("string:void" "<string:void>")}
      {Lisp-Entry "transcript-on" native ("native") 362 8 362 21 ("string:void" "<string:void>")}
      {Lisp-Entry "transcript-off" native ("native") 363 8 363 22 (":void" "<:void>")}
      {Lisp-Entry "make-syntactic-closure" native ("native") 371 8 371 30 ()}
      {Lisp-Entry "syntactic-closure?" native ("native") 372 8 372 26 ()}
      {Lisp-Entry "syntactic-closure-form" native ("native") 373 8 373 30 ()}
      {Lisp-Entry "unwrap-syntactic-closure" native ("native") 374 8 374 32 ()}
      {Lisp-Entry "strip-syntactic-closures" native ("native") 375 8 375 32 ()}
      {Lisp-Entry "strip-source-info" native ("native") 376 8 376 25 ()}
      {Lisp-Entry "identifier?" native ("native") 377 8 377 19 ()}
      {Lisp-Entry "identifier=?" native ("native") 378 8 378 20 ()}
      {Lisp-Entry "er-macro-transformer" native ("native") 379 8 379 28 ()}
      {Lisp-Entry "sc-macro-transformer" native ("native") 380 8 380 28 ()}
      {Lisp-Entry "rsc-macro-transformer" native ("native") 381 8 381 29 ()}
      {Lisp-Entry "open-input-string" native ("native") 389 8 389 25 ()}
      {Lisp-Entry "open-output-string" native ("native") 390 8 390 26 ()}
      {Lisp-Entry "get-output-string" native ("native") 391 8 391 25 ()}
      {Lisp-Entry "call-with-input-string" native ("native") 392 8 392 30 ()}
      {Lisp-Entry "with-input-from-string" native ("native") 393 8 393 30 ()}
      {Lisp-Entry "call-with-output-string" native ("native") 394 8 394 31 ()}
      {Lisp-Entry "with-output-to-string" native ("native") 395 8 395 29 ()}
      {Lisp-Entry "read-line" native ("native") 396 8 396 17 ()}
      {Lisp-Entry "table?" native ("native") 404 8 404 14 ()}
      {Lisp-Entry "make-table" native ("native") 405 8 405 18 ()}
      {Lisp-Entry "table-for-each" native ("native") 406 8 406 22 ()}
      {Lisp-Entry "table-ref" native ("native") 407 8 407 17 ()}
      {Lisp-Entry "table-set!" native ("native") 408 8 408 18 ()}
      {Lisp-Entry "table->list" native ("native") 409 8 409 19 ()}
      {Lisp-Entry "list->table" native ("native") 410 8 410 19 ()}
      {Lisp-Entry "iterate-table" native ("native") 411 8 411 26 ()}}})
"runtime"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "runtime.scm"} 236918191. scheme
    {Lisp-Entry "scheme.dialect.runtime" unit #f 37 16 37 38 ("Define" "jazz:Define" "encapsulate-class" "jazz:encapsulate-class")
      {Lisp-Entry "Define" define-class ("class runtime") 45 27 45 38 ()}
      {Lisp-Entry "new-define" define #f 48 9 48 24 ("Define" "jazz:Define" "allocate-define" "jazz:allocate-define" "locator" "name")}
      {Lisp-Entry "register-define" define #f 55 9 55 29 ("new-define" "jazz:new-define" "register-module-entry" "jazz:register-module-entry" "locator" "name" "module-name")}}})
"runtime-classes"
 ({Lisp-File-Entry {File :context "src" "scheme" "dialect" "runtime-classes.scm"} 236918191. scheme
    {Lisp-Entry "scheme.dialect.runtime-classes" unit #f 37 16 37 46 ()
      {Lisp-Entry "Define" define-class ("class syntax") 45 19 45 30 ("%%get-define-locator" "locator" "allocate-define" "jazz:allocate-define" "Object-Class" "jazz:Object-Class" "name" "Field" "jazz:Field")}}})
