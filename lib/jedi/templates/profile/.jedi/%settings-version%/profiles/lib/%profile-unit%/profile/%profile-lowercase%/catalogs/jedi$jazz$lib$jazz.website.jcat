"JazzScheme-Server"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "server" "JazzScheme-Server.jazz"} 1296083298 jazz
    {Lisp-Entry "jazz.website.server.JazzScheme-Server" module #f 37 18 37 55 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.network")}
      {Lisp-Entry "JazzScheme-Server" class #f 43 7 43 24 ("Web-Server")}}})
"JazzScheme-Site"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "server" "JazzScheme-Site.jazz"} 1296083298 jazz
    {Lisp-Entry "jazz.website.server.JazzScheme-Site" module #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.network")}
      {Lisp-Entry "JazzScheme-Site" class #f 43 7 43 22 ("Object")}}})
"JazzWebsite-Transformation"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "transformation" "JazzWebsite-Transformation.jazz"} 1297795124 jazz
    {Lisp-Entry "jazz.website.transformation.JazzWebsite-Transformation" module #f 37 18 37 72 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.website" "jazz.system" "jazz.library.component" "jazz.jml" "jazz.io" "jazz.doc" "jazz.catalog")}
      {Lisp-Entry "JazzWebsite-Transformation" class #f 49 7 49 33 ("DocToHTML-Transformation")
        {Lisp-Entry "anchors" slot #f 52 8 52 15 ()}
        {Lisp-Entry "anchor-names" slot #f 53 8 53 20 ()}
        {Lisp-Entry "next-section" slot #f 54 8 54 20 ()}
        {Lisp-Entry "website" method ("pattern") 62 12 62 19 ("process-website" "user-feedback" "node")}
        {Lisp-Entry "division" method ("pattern") 67 12 67 20 ("children->jml" ",title" "b" "p" "->string" "name:" "a" "not" "if" "span" "title" "get-property" "name" "let" "node")}
        {Lisp-Entry "screenshot" method ("pattern") 80 12 80 22 (",label" "align" "align:" "class" "class:" ",preview" "src" "src:" "img" ",image" "href" "href:" "a" "div" "image" "preview" "get-property" "label" "let" "node")}
        {Lisp-Entry "process-website" method #f 95 11 95 26 ("subsection" "subsections" "subsec" "memq?" "b" ",path" "class" "class:" "a" "selected?" "subsecs" "sec" "bind" "info" "p" "manual-output" "navigation-output" "h1" "id" "id:" "div" "body" ",title" "type" "type:" "rel" "rel:" "href" "href:" "link" "head" "title" "error" "else" "output-article" "article" "case" "JML-Element" "is?" "if" "for-each" "output" "section-content-output" ",html" "section-path" "format" "path" "path:" "page" "manual?" "not" "generate-manual?" "or" "section-output" "html" "get-property" "user-feedback" "next-section" "test" "test:" "make-table" "anchors" "set!" "reset-section" "message-box" "->string" ":bulleted" "list" "message" "not-null?" "get-output" "ambiguities" "put" "1" "length" ">" "when" "lst" "name" "anchor-names" "iterate-table" "List-Factory" "new" "fact" "let" "validate-anchor-names" "process-section" "pages" "sections" "process-sections" "get-children" "get-tag" "eq?" "node" "collect-if" "cons" "section" "lambda" "map" "collect-sections" "define" "website")}
        {Lisp-Entry "section-path" definition #f 204 15 204 27 ("index" "home" "eq?" "if" "get-property" "name" "let" "section")}
        {Lisp-Entry "manual-output" method #f 216 11 216 24 ("summary-output" "summary" "toc-output" "toc" "index-output" "index?" "if" "index" "manual-content-output" "content" "present-doc-title" "key" "key:" "find-docs" "map" "append" "apply" "string<?" "sort" "project-paths" "get-property" "title" "let*" "add-catalog" "Component-Catalog" "catalog" "get-name" "name" "project" "lambda" "for-each" "Cataloguer" "new" "cataloguer" "let" "projects" "new-projects-cataloguer" "define" "section")}
        {Lisp-Entry "manual-content-output" method #f 240 11 240 32 ("get-output" "project" "List-Factory" "new" "length" "0" "naturals" "+" "rank" "present-doc-title" "nu<?" "sort" "sorted" "effective-manual-doc-children" "children" "get-sort?" "and" "let*" "get-children" ",@rest" "rest" "example" "map" "node" "get-examples" "examples" "put-sequence" "form->node" "->jml" "paragraphs" "tag" "bind" "get-description" "description" "virtual" "get-propagation" "eq?" "get-parameters" "or" "i" "b" "interface-doc" "get-interfaces" "interfaces" "get-ascendant" "ascendant" "get-name" "href" "href:" "a" "set!" "ascendant-doc" "for-each" "first?" "p" "not-null?" "when" "get-ascendants" "collect" "ascendants" "get-definition" "present-text" "output-doc-examples" "span" "docterm" "Category-Doc" "is?" "if" "cons" "child" "lambda" "key" "key:" "sort?" "sort?:" "h4" "2" ",title" "1" "case" "present-toc-path" "format" "title" "let" "output-manual-doc-children" "output-doc-description" "get-effective-title" "class" "class:" "h3" "put" "output-anchor" "error" "else" "output-manual-generic" "Generic-Doc" "output-manual-definition" "Definition-Doc" "output-manual-export" "Export-Doc" "output-manual-method" "Method-Doc" "output-manual-property" "Property-Doc" "output-manual-slot" "Slot-Doc" "output-manual-constant" "Constant-Doc" "output-manual-primitive" "Primitive-Doc" "output-manual-syntax" "Syntax-Doc" "output-manual-concept" "Concept-Doc" "output-manual-form" "Form-Doc" "output-manual-class" "Class-Doc" "output-manual-interface" "Interface-Doc" "output-manual-module" "Module-Doc" "output-manual-unit" "Unit-Doc" "output-manual-package" "Package-Doc" "output-manual-section" "Section-Doc" "output-manual-project" "Project-Doc" "typecase" "output" "path" "level" "doc" "output-manual-doc" "define" "projects" "cataloguer")}
        {Lisp-Entry "effective-manual-doc-children" method #f 454 11 454 40 ("get-output" "get-children" "put" "put-sequence" "find-docs" "docs" "get-path" "path" "let*" "Doc-Insert" "is?" "if" "child" "lambda" "for-each" "List-Factory" "new" "fact" "let" "doc")}
        {Lisp-Entry "find-docs" method #f 466 11 466 20 ("get-output" "find-docs" "unimplemented" "else" "get-catalogs" "get-parent-project" "for-each" "get-project" "parent" "*" "equal?" "get-client" "null?" "cond" "assert" "find-catalog" "catalog" "read-form" "instantiate" "put" "get-extension" "ci=?" "file" "lambda" "iterate-directory" "exists?" "when" "website" "jazz" "jazz.website" "Directory" "reference-dir" "let" ":reference" "eq?" "list" "symbol?" "if" "rest" "name" "bind" "List-Factory" "new" "docs" "get-documentation-cataloguer" "cataloguer" "get-application" "appl" "let*" "path")}
        {Lisp-Entry "output-anchor" method #f 493 11 493 24 ("anchor-names" "table-add" "when" ",anchor" "name:" "a" "put" "anchors" "register-anchor" "anchor" "get-name" "name" "let" "output" "doc")}
        {Lisp-Entry "register-anchor" method #f 501 11 501 26 ("table-set!" "increase!" "next-section" "format" "prog1" "->string" "if" "anchor" "let" "anchors" "name" "object")}
        {Lisp-Entry "docterm" method ("pattern") 507 12 507 19 (",term" "align" "align:" ",body" "td" "tr" "width" "width:" "table" "second" "body" "first" "term" "get-children" "children" "let" "node")}
        {Lisp-Entry "summary-output" method #f 522 11 522 25 ("list" "car" "get-children" "=" "docs" "p" "index?" "get-property" ",title" "h3" "style" "style:" "user-feedback" "for-each" "Section-Doc" "set!" "Project-Doc" "typecase" "iter" "has?" "key" "key:" "string<?" "sort" "has-project-descendant?" "collect-if" "effective-manual-doc-children" "let" "length" "0" "naturals" "cons" "1" "+" "rank" "child" "lambda" "map" "null?" "if" ",text" ",anchor" "href" "href:" "a" "class" "class:" "div" "collect-summary-children" "children" "anchors" "table-ref" "anchor" "present-toc-path" "format" "text" "present-doc-title" "let*" "path" "level" "doc" "doc-summary-output" "define" "projects" "section" "title")}
        {Lisp-Entry "toc-output" method #f 572 11 572 21 ("list" "get-children" "docs" "h3" "name" "name:" "user-feedback" "key" "key:" "string<?" "sort" "Category-Doc" "Module-Doc" "Unit-Doc" "Package-Doc" "Section-Doc" "Project-Doc" "is?" "or" "collect-if" "effective-manual-doc-children" "let" "length" "0" "naturals" "cons" "+" "child" "lambda" "map" "null?" ",text" ",anchor" "href" "href:" "a" "class" "class:" "div" "3" "<=" "1" "=" "and" "if" "toc-prefix" "car" "rank" "collect-toc-children" "children" "anchors" "table-ref" "anchor" "present-toc-path" "format" "text" "present-doc-title" "title" "let*" "path" "level" "doc" "doc-toc-output" "define" "projects")}
        {Lisp-Entry "present-doc-title" definition #f 610 15 610 32 ("get-effective-title" "doc")}
        {Lisp-Entry "present-toc-path" definition #f 614 15 614 31 ("reverse" "->string" "map" "join" "path")}
        {Lisp-Entry "index-output" method #f 623 11 623 23 ("width" "width:" "table" "h3" "eq?" "test" "test:" "make-table" "user-feedback" "alphabetic?" "get-output" "br" "not-null?" "b" "table-ref" "car" "letter-set" "process-letter-set" "List-Factory" "new" "alpha" "assv-value" "non-alpha" "alphabetic-partition" "let*" "letters" "index-navigator" "nu<?" "sort" "list" "cons" "set!" "get-effective-title" "get-name" "when" "anchors" "iterate-table" "lst" "third" "first" "upcase" "key" "key:" "gather-anchors" "partition" "letters-partition" ",title" "code" "href" "href:" "format" "title" "doc" "info" "lambda" "for-each" "string" ",anchor" "name" "name:" "a" "class" "class:" "div" "colspan" "colspan:" "td" "tr" "put" "register-anchor" "anchor" "let" "infos" "char" "bind" "output" "letter-anchors" "letter" "output-letter" "define")}
        {Lisp-Entry "output-article" method #f 691 11 691 25 ("get-children" "error" "+" "output-article" "get-tag" "JML-Element" "is?" "node" "lambda" "for-each" "children->jml" "else" "class" "class:" "h4" "2" ",title" "h3" "1" "case" "title" "->string" "name:" "a" "not" "if" "get-property" "name" "let" "div" "put" "description" "output-article-description" "define" "output" "level" "article")}}}})
"Website"
 ({Lisp-File-Entry {File :context "src" "profile" "website" "Website.jazz"} 1296141671 jazz
    {Lisp-Entry "profile.website.Website" module #f 8 8 8 31 ("Website" "register-profile-class" "jazz")
      {Lisp-Entry "import" anonymous #f 11 1 11 7 ("time" "jedi" "jazz.website" "jazz.ui.view" "jazz.ui.dialog" "jazz.ui.clipboard" "jazz.ui" "jazz.system" "jazz.profile" "jazz.platform" "jazz.network" "jazz.library" "jazz.jml" "jazz.io" "jazz.editor.jazz" "irregex")}
      {Lisp-Entry "Website" class #f 29 7 29 14 ("Jedi-Profile")
        {Lisp-Entry "test" method #f 37 20 37 24 ("extract-doc")}
        {Lisp-Entry "regenerate" method #f 46 11 46 21 ("regenerate-jazzwebsite" "save" "Jazz-Text-View" "get-guest" "guest" "Host-View" "is?" "and" "when" "current-frame" "frame" "let")}
        {Lisp-Entry "test9" method #f 55 20 55 25 ("regenerate" "generate-manual?" "parameterize")}
        {Lisp-Entry "test0" method #f 60 20 60 25 ("regenerate")}}}})
"_website"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "_website.jazz"} 1296083298 jazz
    {Lisp-Entry "jazz.website" module #f 37 8 37 20 ("jazz")
      {Lisp-Entry "export" anonymous #f 40 1 40 7 ("jazz.website.autoload")}
      {Lisp-Entry "generate-manual?" definition #f 48 19 48 35 ("make-parameter")}}})
"autoload"
 ({Lisp-File-Entry {File :context "src" "jazz" "website" "autoload.jazz"} 1296083298 jazz
    {Lisp-Entry "jazz.website.autoload" module #f 37 18 37 39 ("jazz")
      {Lisp-Entry "export" anonymous #f 40 1 40 7 ("JazzWebsite-Transformation" "jazz.website.transformation.JazzWebsite-Transformation" "JazzScheme-Site" "jazz.website.server.JazzScheme-Site" "JazzScheme-Server" "autoload" "jazz.website.server.JazzScheme-Server")}}})
