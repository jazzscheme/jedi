"Dispatcher"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "runtime" "Dispatcher.jazz"} 1296083296 jazz
    {Lisp-Entry "Dispatcher" class #f 47 7 47 17 ("Object")
      {Lisp-Entry "dag-root" property #f 50 12 50 20 ()}
      {Lisp-Entry "get-dag-root" accessor #f 50 31 50 39 ()}
      {Lisp-Entry "set-dag-root" accessor #f 50 31 50 39 ()}
      {Lisp-Entry "Root-Signature" definition #f 53 14 53 28 ("root-signature")}
      {Lisp-Entry "initialize" method #f 57 11 57 21 ("Root-Signature" "Dispatch-Node" "new" "dag-root" "set!" "nextmethod")}
      {Lisp-Entry "insert-signature" method #f 62 18 62 34 ("insert-node" "else" "proper-list?" "not" "category-identifier" "error" "locate-node" "cond" "List" "get-type" "and" "get-typeref" "typeref" "let" "parameter" "lambda" "accumulate" "standardize-signature" "define" "category" "signature" "procedure" "symbol")}
      {Lisp-Entry "insert-node" method #f 81 18 81 29 ("get-specific-nodes" "add-specific-node" "remove-specific-node" "add-generic-node" "remove-generic-node" "get-signature" "can-call-with?" "neq?" "and" "when" "specific" "generic" "lambda" "for-each" "Dispatch-Node" "new" "node" "gather-generics" "generics" "let*" "signature" "procedure")}
      {Lisp-Entry "remove-node" method #f 98 18 98 29 ("remove-generic-node" "get-generic-nodes" "remove-specific-node" "get-specific-nodes" "add-generic-node" "add-specific-node" "specific" "generic" "lambda" "for-each" "node")}
      {Lisp-Entry "locate-node" method #f 113 18 113 29 ("first" "get-signature" "equal?" "length" "1" "=" "and" "if" "gather-generics" "matching" "let" "signature")}
      {Lisp-Entry "gather-generics" method #f 121 18 121 33 ("dag-root" "cons" "memq?" "not" "and" "get-specific-nodes" "set!" "can-call-with?" "when" "child-node" "lambda" "for-each" "no-match?" "walk-node" "iter" "define" "generics" "let" "parameter-types")}
      {Lisp-Entry "find-generics" method #f 137 18 137 31 ("dag-root" "car" "eq?" "if" "gather-generics" "generics" "let" "parameter-types")}}
    {Lisp-Entry "Dispatch-Node" class #f 149 7 149 20 ("initialize" "Object")
      {Lisp-Entry "procedure" property #f 152 12 152 21 ()}
      {Lisp-Entry "get-procedure" accessor #f 152 52 152 60 ()}
      {Lisp-Entry "set-procedure" accessor #f 152 52 152 60 ()}
      {Lisp-Entry "signature" property #f 153 12 153 21 ()}
      {Lisp-Entry "get-signature" accessor #f 153 52 153 60 ()}
      {Lisp-Entry "set-signature" accessor #f 153 52 153 60 ()}
      {Lisp-Entry "generic-nodes" property #f 154 12 154 25 ()}
      {Lisp-Entry "get-generic-nodes" accessor #f 154 52 154 60 ()}
      {Lisp-Entry "set-generic-nodes" accessor #f 154 52 154 60 ()}
      {Lisp-Entry "specific-nodes" property #f 155 12 155 26 ()}
      {Lisp-Entry "get-specific-nodes" accessor #f 155 52 155 60 ()}
      {Lisp-Entry "set-specific-nodes" accessor #f 155 52 155 60 ()}
      {Lisp-Entry "initialize" method #f 158 11 158 21 ("generic-nodes" "signature" "procedure" "set!" "nextmethod" "gen" "sig" "proc")}
      {Lisp-Entry "print" method #f 165 11 165 16 ("category-identifier" "map" "format" "Root-Signature" "signature" "eq?" "if" "lambda" "self" "print-unreadable" "readably" "output")}
      {Lisp-Entry "can-call-with?" method #f 173 11 173 25 ("null?" "finally" "return" "Java" "can-cast-into?" "not" "and" "when" "r2" "parameter-type" "r1" "remainder" "in" "data-type" "for" "loop" "Root-Signature" "signature" "eq?" "if" "sig")}
      {Lisp-Entry "add-generic-node" method #f 184 11 184 27 ("cons" "set-generic-nodes" "equal?" "generic" "lambda" "generic-nodes" "find-in" "unless" "get-signature" "sig" "let" "node")}
      {Lisp-Entry "add-specific-node" method #f 192 11 192 28 ("cons" "set-specific-nodes" "equal?" "specific" "lambda" "specific-nodes" "find-in" "unless" "get-signature" "sig" "let" "node")}
      {Lisp-Entry "remove-generic-node" method #f 200 11 200 30 ("generic-nodes" "remove" "set-generic-nodes" "generic")}
      {Lisp-Entry "remove-specific-node" method #f 204 11 204 31 ("specific-nodes" "remove" "set-specific-nodes" "specific")}}})
"_base"
 ({Lisp-File-Entry {File :context "src" "core" "base" "_base.scm"} 1296083296 scheme
    {Lisp-Entry "core.base" unit #f 37 6 37 15 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.base.runtime" "syntax" "phase" "core.base.syntax")}}})
"_builder"
 ({Lisp-File-Entry {File :context "src" "core" "unit" "builder" "_builder.scm"} 1299164353 scheme
    {Lisp-Entry "core.unit.builder" unit #f 38 16 38 33 ()
      {Lisp-Entry "require" anonymous #f 41 1 41 8 ("core.module" "core.base")}
      {Lisp-Entry "jazz:manifest-references-valid?" define #f 50 9 50 40 ("%%manifest-references" "references" "%%manifest-version" "manifest" "private" "%%get-declaration-access" "%%neq?" "%%get-declaration-toplevel" "%%get-lexical-binding-name" "else" "jazz:find-declaration" "cond" "declaration" "symbols" "iter" "%%pair?" "found" "symbol" "jazz:every?" "error?:" "jazz:outline-module" "module-declaration" "%%not" "%%continuation-return" "%%cdr" "%%memq" "recompile-symbol" "%%car" "%%eq?" "%%symbol?" "recompile-reference" "jazz:some?" "and" "if" "jazz:version-recompile-references" "recompile-references" "jazz-version" "jazz:for-each-higher-jazz-version" "return" "lambda" "%%continuation-capture" "module-references" "module-locator" "recompile-reference?" "lst" "version" "module-references-valid?" "jazz:load-manifest" "jazz:manifest-pathname" "manifest-filepath" "%%resource-package" "jazz:digest-pathname" "digest-filepath" "let" "get-manifest" "define" "bin")}
      {Lisp-Entry "jazz:compile-unit-internal" define #f 113 9 113 35 ("force?:" "ld-options:" "cc-options:" "options:" "jazz:compile-source" "jazz:requested-unit-resource" "jazz:requested-unit-name" "parameterize" "manifest" "lib-uptodate?" "bin-uptodate?" "obj-uptodate?" "lib" "bin" "obj" "src" "lambda" "jazz:with-unit-resources" "force?" "ld-options" "cc-options" "options" "#!key" "unit-name")}
      {Lisp-Entry "jazz:custom-compile-unit-internal" define #f 123 9 123 42 ("jazz:compile-unit" "force?:" "unit:" "%%product-descriptor" "if" "%%product-build" "and" "build" "jazz:find-unit-product" "product" "let" "force?" "#!key" "unit-name")}
      {Lisp-Entry "jazz:find-unit-product" define #f 132 9 132 31 ("continuation-return" "eq?" "if" "phase" "declaration" "sub-unit" "jazz:for-each-subunit" "unit" "jazz:ill-formed-field-error" "jazz:cond-expand-each" "update" "jazz:product-descriptor-update" "update-descriptor" "jazz:get-product" "product" "jazz:product-descriptor-name" "product-name" "let*" "product-descriptor" "for-each" "return" "lambda" "continuation-capture" "%%package-products" "products" "%%resource-package" "package" "jazz:find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "jazz:wrap-single-host-cc-options" define #f 155 8 155 40 ("string-append" "jazz:debug-user?" "or" "if" "str" "lambda" "shell-command" "zero?" "else" "windows" "cond-expand" "gcc-4-2?" "let")}
      {Lisp-Entry "jazz:compile-source" define #f 164 9 164 28 ("unit-name:" "ld-options:" "cc-options:" "options:" "jazz:compile-file" "compile" "jazz:walk-for" "parameterize" "lambda" "%%resource-extension" "jazz:with-extension-reader" "jazz:create-directories" "jazz:create-build-package" "build-package" "jazz:resource-build-dir" "bindir" "jazz:resource-pathname" "pathname" "%%resource-package" "package" "jazz:link-objects?" "if" "update-bin?" "not" "update-obj?" "jazz:wrap-single-host-cc-options" "jazz:compile-options" "jazz:manifest-references-valid?" "or" "and" "references-valid?" "let" "force?" "ld-options" "cc-options" "options" "#!key" "manifest-name" "bin-uptodate?" "obj-uptodate?" "bin" "obj" "src")}
      {Lisp-Entry "jazz:compile-file" define #f 183 9 183 26 ("force-output" "newline" "display" "jazz:push-changed-units" "%%resource-path" "path" "jazz:dry-run?" "dry?" "jazz:link-libraries?" "will-compile?" "jazz:link-objects?" "or" "will-link?" "DLL" "jazz:obliterate-PE-timestamp" "windows" "case" "=" "jazz:resource-build-dir" "dyn" "##gambc-cc" "exit-status" "warnings?:" "%%list" "link-flat" "linkfile" "bin-o1" "link-o1" "jazz:probe-numbered-pathname" "begin" "jazz:build-single-objects?" "determine-o1" "1" "jazz:for-each-numbered-pathname" "delete-o1-files" "delete-file" "exc" "lambda" "with-exception-catcher" "file" "delete-o1-file" "jazz:update-manifest-compile-time" "else" "jazz:Unit-Declaration" "jazz:generate-reference-list" "jazz:Module-Declaration" "%%is?" "cond" "jazz:get-catalog-entry" "module-declaration" "references" "src-filepath" "jazz:manifest-pathname" "manifest-filepath" "jazz:digest-pathname" "digest-filepath" "update-manifest" "jazz:error" "cc-options:" "obj" "%%cons" "compile-file" "module-name:" "options:" "output:" "compile-file-to-c" "and" "not" "if" "-1" "##gensym-counter" "set!" "jazz:compiled-source" "0" "jazz:generate-symbol-counter" "jazz:generate-symbol-context" "jazz:generate-symbol-for" "parameterize" "string-append" "bin-c" "jazz:resource-pathname" "src-pathname" "%%symbol->string" "%%string-append" "unique-module-name" "let" "compile" "jazz:binary-with-extension" "bin-pathname-base" "unit-uniqueness-prefix" "define" "jazz:kernel-platform" "platform" "unit-name" "ld-options" "cc-options" "options" "#!key" "build-package" "update-bin?" "update-obj?" "bin" "src")}
      {Lisp-Entry "jazz:build-unit-internal" define #f 282 9 282 33 ("jazz:compile-unit" "phase" "declaration" "lambda" "jazz:for-each-subunit" "unit-name")}
      {Lisp-Entry "jazz:get-subunit-names-internal" define #f 293 9 293 40 ("jazz:for-each-subunit" "%%cons" "set!" "phase" "declaration" "unit-name" "lambda" "proc" "sub-units" "let*" "parent-name")}
      {Lisp-Entry "jazz:for-each-subunit" define #f 301 9 301 30 ("%%get-module-declaration-exports" "%%get-module-invoice-phase" "%%get-declaration-reference-name" "name" "%%get-module-invoice-module" "reference" "export" "%%get-module-declaration-requires" "%%get-unit-declaration-requires" "for-each" "jazz:Unit-Declaration" "jazz:is?" "jazz:error" "jazz:descendant-unit?" "and" "protected" "%%get-declaration-access" "%%eq?" "or" "jazz:outline-unit" "declaration" "%%cons" "set!" "begin" "%%memq" "%%not" "if" "feature-requirement" "lambda" "jazz:parse-require" "require" "process-require" "define" "toplevel?" "phase" "unit-name" "iter" "subunits" "let" "proc" "parent-name")}}})
"_class"
 ({Lisp-File-Entry {File :context "src" "core" "class" "_class.scm"} 1296083296 scheme
    {Lisp-Entry "core.class" unit #f 37 6 37 16 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.class.runtime" "syntax" "phase" "core.class.syntax" "core.base")}}})
"_dialect"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "dialect" "_dialect.scm"} 1299164370 scheme
    {Lisp-Entry "core.module.syntax.dialect" unit #f 37 16 37 42 ("jazz:encapsulate-class" "jazz:Dialect")
      {Lisp-Entry "jazz:Dialect" define-class ("class runtime") 40 27 40 39 ()}
      {Lisp-Entry "jazz:dialect-name" generic/specific ("jazz:Dialect~virtual-runtime") 43 30 43 47 ()}
      {Lisp-Entry "jazz:dialect-walker" generic/specific ("jazz:Dialect~virtual-runtime") 44 30 44 49 ()}
      {Lisp-Entry "jazz:dialect-name" generic/specific ("jazz:Dialect") 47 21 47 38 ()}
      {Lisp-Entry "jazz:dialect-walker" generic/specific ("jazz:Dialect") 51 21 51 40 ()}
      {Lisp-Entry "jazz:Dialects" define #f 63 8 63 21 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:get-dialect" define #f 67 9 67 25 ("jazz:Dialects" "%%table-ref" "name")}
      {Lisp-Entry "jazz:require-dialect" define #f 71 9 71 29 ("jazz:error" "jazz:get-dialect" "or" "name")}
      {Lisp-Entry "jazz:register-dialect" define #f 76 9 76 30 ("jazz:Dialects" "%%table-set!" "dialect" "name")}
      {Lisp-Entry "jazz:define-dialect" define-macro ("macro") 80 20 80 39 (",dialect" ",name" "jazz:register-dialect" "dialect" "name")}
      {Lisp-Entry "jazz:register-binding" define #f 89 9 89 30 ("%%get-dialect-bindings" "%%cons" "%%set-dialect-bindings" "jazz:get-dialect" "dialect" "let" "binding" "dialect-name")}
      {Lisp-Entry "jazz:define-walker-special" define-macro ("macro") 94 20 94 46 (",method" ",name" "jazz:new-special-form" ",dialect-name" "jazz:register-binding" "method" "dialect-name" "name")}
      {Lisp-Entry "jazz:define-walker-syntax" define-macro ("macro") 98 20 98 45 (",method" ",name" "jazz:new-syntax-form" ",dialect-name" "jazz:register-binding" "method" "dialect-name" "name")}
      {Lisp-Entry "jazz:define-walker-macro" define-macro ("macro") 102 20 102 44 (",method" ",name" "jazz:new-macro-form" ",dialect-name" "jazz:register-binding" "method" "dialect-name" "name")}}})
"_exception"
 ({Lisp-File-Entry {File :context "src" "core" "exception" "_exception.scm"} 1296083296 scheme
    {Lisp-Entry "core.exception" unit #f 37 6 37 20 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.exception.runtime.error" "core.exception.runtime.exception" "core.exception.syntax.classes" "core.class")}}})
"_generic"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "_generic.scm"} 1296083296 scheme
    {Lisp-Entry "core.generic" unit #f 37 6 37 18 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.generic.runtime" "syntax" "phase" "core.generic.syntax" "core.class")}}})
"_module"
 ({Lisp-File-Entry {File :context "src" "core" "module" "_module.scm"} 1296083296 scheme
    {Lisp-Entry "core.module" unit #f 37 6 37 17 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.module.initialize" "core.module.runtime" "core.module.runtime.autoload" "core.module.syntax" "core.exception" "core.generic" "core.class")}}})
"_runtime"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "_runtime.scm"} 1296083296 scheme
    {Lisp-Entry "core.base.runtime" unit #f 37 16 37 33 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.base.runtime.vector" "core.base.runtime.unspecified" "core.base.runtime.syntax" "core.base.runtime.symbol" "core.base.runtime.string" "core.base.runtime.serial" "core.base.runtime.reader" "core.base.runtime.error" "core.base.runtime.exception" "core.base.runtime.list" "core.base.runtime.keyword" "core.base.runtime.boolean")}}}
  {Lisp-File-Entry {File :context "src" "core" "class" "runtime" "_runtime.scm"} 1296083296 scheme
    {Lisp-Entry "core.class.runtime" unit #f 37 16 37 34 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.class.runtime.output" "core.class.runtime.output-hook" "core.class.runtime.runtime")}}}
  {Lisp-File-Entry {File :context "src" "core" "generic" "runtime" "_runtime.scm"} 1296083296 scheme
    {Lisp-Entry "core.generic.runtime" unit #f 37 16 37 36 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.generic.runtime.generic" "core.generic.runtime.specific")}}}
  {Lisp-File-Entry {File :context "src" "core" "module" "runtime" "_runtime.scm"} 1299164371 scheme
    {Lisp-Entry "core.module.runtime" unit #f 37 16 37 35 ("jazz:Runtime-Reference" "jazz:Native" "jazz:Module" "jazz:encapsulate-class")
      {Lisp-Entry "jazz:Module" define-class ("class") 45 19 45 30 ("%%get-module-entries" "entries" "%%get-module-exports" "exports" "%%get-module-access" "access" "%%get-module-name" "name" "jazz:allocate-module" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Module" define-class ("class runtime") 52 27 52 38 ()}
      {Lisp-Entry "jazz:new-module" define #f 55 9 55 24 ("eq?" "test:" "%%make-table" "jazz:Module" "jazz:allocate-module" "access" "name")}
      {Lisp-Entry "jazz:Native" define-class ("class") 67 19 67 30 ("%%get-native-symbol" "symbol" "jazz:allocate-native" "jazz:Object-Class" "name" "jazz:Field")}
      {Lisp-Entry "jazz:Native" define-class ("class runtime") 71 27 71 38 ()}
      {Lisp-Entry "jazz:new-native" define #f 74 9 74 24 ("jazz:Native" "jazz:allocate-native" "symbol" "name")}
      {Lisp-Entry "jazz:register-native" define #f 81 9 81 29 ("jazz:new-native" "jazz:register-module-entry" "symbol" "name" "module-name")}
      {Lisp-Entry "jazz:Runtime-Reference" define-class ("class") 90 19 90 41 ("%%get-runtime-reference-serialization" "serialization" "%%get-runtime-reference-resolver" "resolver" "jazz:allocate-runtime-reference" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Runtime-Reference" define-class ("class runtime") 95 27 95 49 ()}
      {Lisp-Entry "jazz:new-runtime-reference" define #f 98 9 98 35 ("jazz:Runtime-Reference" "jazz:allocate-runtime-reference" "serialization" "resolver")}
      {Lisp-Entry "jazz:resolve-runtime-reference" define #f 105 9 105 39 ("%%get-runtime-reference-resolver" "resolver" "let" "jazz:Runtime-Reference" "%%is?" "%%debug-assert" "runtime-reference")}
      {Lisp-Entry "jazz:serialize-runtime-reference" define #f 111 9 111 41 ("%%get-runtime-reference-serialization" "jazz:Runtime-Reference" "%%is?" "%%debug-assert" "runtime-reference")}
      {Lisp-Entry "jazz:deserialize-runtime-reference" define #f 116 9 116 43 ("jazz:error" "else" "module-public" "module-private" "case" "%%pair?" "if" "or" "jazz:module-ref" "%%cddr" "%%car" "name" "module-name" "deserialize-module-public" "jazz:global-ref" "%%cadr" "locator" "let" "lambda" "jazz:new-runtime-reference" "deserialize-module-private" "define" "serialization")}
      {Lisp-Entry "jazz:Modules" define #f 144 8 144 20 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:get-modules" define #f 148 9 148 25 ("jazz:Modules")}
      {Lisp-Entry "jazz:register-module" define #f 152 9 152 29 ("jazz:Modules" "%%cdr" "%%car" "pair" "%%table-set!" "info" "jazz:require-module" "jazz:iterate-table" "module-name" "lambda" "for-each" "%%get-module-exports" "exports" "jazz:new-module" "jazz:get-module" "or" "module" "let" "exported-symbols" "exported-modules" "access" "name")}
      {Lisp-Entry "jazz:get-module" define #f 169 9 169 24 ("jazz:Modules" "%%table-ref" "name")}
      {Lisp-Entry "jazz:require-module" define #f 173 9 173 28 ("jazz:error" "jazz:get-module" "or" "jazz:load-unit" "name")}
      {Lisp-Entry "jazz:get-module-entry" define #f 179 9 179 30 ("jazz:get-module" "%%get-module-entries" "%%table-ref" "entry-name" "module-name")}
      {Lisp-Entry "jazz:set-module-entry" define #f 182 9 182 30 ("jazz:get-module" "%%get-module-entries" "%%table-set!" "entry" "entry-name" "module-name")}
      {Lisp-Entry "jazz:register-module-entry" define #f 185 9 185 35 ("jazz:set-module-entry" "entry" "entry-name" "module-name")}
      {Lisp-Entry "jazz:module-get" define #f 189 9 189 24 ("jazz:load-unit" "locator" "unit-name" "jazz:bind" "jazz:global-ref" "%%symbol?" "if" "%%get-module-exports" "%%table-ref" "info" "jazz:require-module" "module" "let" "not-found" "#!key" "name" "module-name")}
      {Lisp-Entry "jazz:module-ref" define #f 201 8 201 23 ("jazz:error" "%%eq?" "if" "not-found:" "jazz:module-get" "obj" "name" "module-name" "lambda" "box" "not-found" "let")}
      {Lisp-Entry "jazz:module-set!" define #f 210 9 210 25 ("jazz:error" "jazz:load-unit" "locator" "unit-name" "jazz:bind" "jazz:global-set!" "%%symbol?" "if" "%%get-module-exports" "%%table-ref" "info" "jazz:require-module" "module" "let" "value" "name" "module-name")}
      {Lisp-Entry "jazz:type-error" define #f 227 9 227 24 ("jazz:error" "type" "value")}
      {Lisp-Entry "jazz:dispatch-error" define #f 231 9 231 28 ("%%get-category-identifier" "%%get-field-name" "jazz:error" "category" "value" "field")}}})
"_syntax"
 ({Lisp-File-Entry {File :context "src" "core" "base" "syntax" "_syntax.scm"} 1296083296 scheme
    {Lisp-Entry "core.base.syntax" unit #f 37 16 37 32 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.base.syntax.macros")}}}
  {Lisp-File-Entry {File :context "src" "core" "class" "syntax" "_syntax.scm"} 1296083296 scheme
    {Lisp-Entry "core.class.syntax" unit #f 37 16 37 33 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.class.syntax.classes" "core.class.syntax.define-method" "core.class.syntax.define-method-expander" "core.class.syntax.define-class" "core.class.syntax.class" "core.class.syntax.object" "core.class.syntax.error")}}}
  {Lisp-File-Entry {File :context "src" "core" "generic" "syntax" "_syntax.scm"} 1296083296 scheme
    {Lisp-Entry "core.generic.syntax" unit #f 37 16 37 35 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.generic.syntax.specific" "core.generic.syntax.generic" "core.generic.syntax.expander")}}}
  {Lisp-File-Entry {File :context "src" "core" "module" "syntax" "_syntax.scm"} 1296083296 scheme
    {Lisp-Entry "core.module.syntax" unit #f 37 16 37 34 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.module.syntax.module" "core.module.syntax.walker.register" "core.module.syntax.walker.ffi" "core.module.syntax.walker.expression" "core.module.syntax.walker" "core.module.syntax.dialect" "core.module.syntax.dialect.syntax" "core.module.syntax.classes")}}})
"_unit"
 ({Lisp-File-Entry {File :context "src" "core" "unit" "_unit.scm"} 1296083296 scheme
    {Lisp-Entry "core.unit" unit #f 37 6 37 15 ()
      {Lisp-Entry "require" anonymous #f 40 1 40 8 ("core.unit.builder")}}})
"_walker"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "walker" "_walker.scm"} 1299179569 scheme
    {Lisp-Entry "core.module.syntax.walker" unit #f 59 16 59 41 ("jazz:Core-Walker" "jazz:Core-Dialect" "jazz:Analysis-Data" "jazz:Walk-Failed-Special" "jazz:Assignment" "jazz:Constant" "jazz:Call" "jazz:Begin" "jazz:Internal-Define" "jazz:Body" "jazz:Reference-Reification" "jazz:Binding-Reference" "jazz:Expression" "jazz:Walker" "jazz:Code" "jazz:Annotated-Frame" "jazz:Restricted-Binding" "jazz:Annotated-Variable" "jazz:Syntactic-Closure" "jazz:Define-Local-Syntax-Form" "jazz:Define-Syntax-Form" "jazz:Syntax-Form" "jazz:Macro-Form" "jazz:Special-Form" "jazz:Form-Binding" "jazz:Macro-Symbol" "jazz:Local-Variable-Binding" "jazz:Dynamic-Self-Binding" "jazz:Self-Binding" "jazz:Rest-Parameter" "jazz:Named-Parameter" "jazz:Optional-Parameter" "jazz:Dynamic-Parameter" "jazz:Parameter" "jazz:NextMethod-Variable" "jazz:Variable" "jazz:Symbol-Binding" "jazz:Signature" "jazz:Walk-Frame" "jazz:Unresolved-Error" "jazz:Walk-Error" "jazz:Walk-Warning" "jazz:Walk-Problems" "jazz:Walk-Problem" "jazz:Walk-Location" "jazz:Walk-Context" "jazz:Define-Local-Syntax-Declaration" "jazz:Define-Syntax-Declaration" "jazz:Syntax-Declaration" "jazz:Local-Macro-Declaration" "jazz:Macro-Declaration" "Unspecified" "EOF" "Values" "Foreign" "Promise" "Thread" "Table" "F64Vector" "F32Vector" "U64Vector" "S64Vector" "U32Vector" "S32Vector" "U16Vector" "S16Vector" "U8Vector" "S8Vector" "Vector" "Keyword" "Symbol" "String" "Procedure" "Continuation" "Port" "Pair" "Null" "List" "Flonum" "Fixnum" "Integer" "Rational" "Real" "Complex" "Number" "Char" "Boolean" "Object" "jazz:primitive-declarations" "void" "jazz:Unspecified" "unspecified" "jazz:EOF" "eof" "jazz:Values" "values" "jazz:Foreign" "foreign" "jazz:Promise" "promise" "jazz:Thread" "thread" "jazz:Table" "table" "jazz:F64Vector" "f64vector" "jazz:F32Vector" "f32vector" "jazz:U64Vector" "u64vector" "jazz:S64Vector" "s64vector" "jazz:U32Vector" "u32vector" "jazz:S32Vector" "s32vector" "jazz:U16Vector" "u16vector" "jazz:S16Vector" "s16vector" "jazz:U8Vector" "u8vector" "jazz:S8Vector" "s8vector" "jazz:Vector" "vector" "jazz:Keyword" "keyword" "jazz:Symbol" "symbol" "jazz:String" "string" "jazz:Procedure" "procedure" "jazz:Continuation" "continuation" "jazz:Port" "port" "jazz:Pair" "pair" "jazz:Null" "null" "jazz:List" "list" "jazz:Flonum" "fl" "jazz:Fixnum" "fx" "jazz:Integer" "int" "jazz:Rational" "rational" "jazz:Real" "real" "jazz:Complex" "complex" "jazz:Number" "number" "jazz:Char" "char" "jazz:Boolean" "bool" "jazz:Object" "object" "any" "jazz:primitive-types" "%%table-set!" "jazz:Any" "jazz:Any-Class" "type" "lambda" "jazz:object-declaration?" "set!" "jazz:Nillable-Type" "jazz:Template-Type" "jazz:Union-Type" "jazz:Complement-Type" "jazz:Restriction-Type" "jazz:Values-Type" "jazz:Category-Type" "jazz:Function-Type" "jazz:Rest-Type" "jazz:Key-Type" "jazz:Opt-Type" "jazz:Void" "jazz:Void-Class" "jazz:Literal" "jazz:Autoload-Declaration" "jazz:Export-Syntax-Declaration" "jazz:Export-Declaration" "jazz:Import-Invoice" "jazz:Export-Invoice" "jazz:Module-Invoice" "jazz:Module-Declaration" "jazz:Namespace-Declaration" "jazz:Unit-Declaration" "jazz:Autoload-Reference" "jazz:Export-Reference" "jazz:Module-Reference" "jazz:Declaration-Reference" "jazz:Declaration" "jazz:Lexical-Binding" "jazz:encapsulate-class" "jazz:Walk-Binding")
      {Lisp-Entry "jazz:analysis-mode?" define #f 68 8 68 27 ("make-parameter")}
      {Lisp-Entry "jazz:analysis-data" define #f 73 8 73 26 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:private-access" define #f 83 8 83 27 ("0")}
      {Lisp-Entry "jazz:public-access" define #f 87 8 87 26 ("1")}
      {Lisp-Entry "jazz:protected-access" define #f 91 8 91 29 ("2")}
      {Lisp-Entry "jazz:make-access-lookups" define #f 95 9 95 33 ("eq?" "test:" "%%make-table" "%%vector-set!" "begin" "%%fx<=" "if" "0" "n" "iter" "1" "%%fx+" "%%make-vector" "lookups" "let" "access-level")}
      {Lisp-Entry "jazz:Walk-Binding" define-class ("class runtime") 110 27 110 44 ()}
      {Lisp-Entry "jazz:emit-type" generic/specific ("jazz:Walk-Binding") 113 21 113 35 ("type" "jazz:emit-binding-reference" "jazz:sourcified-form" "environment" "source-declaration")}
      {Lisp-Entry "jazz:specifiable?" generic/specific ("jazz:Walk-Binding") 117 21 117 38 ()}
      {Lisp-Entry "jazz:walk-binding-lookup" generic/specific ("jazz:Walk-Binding~virtual-runtime") 121 30 121 54 ("source-declaration" "symbol")}
      {Lisp-Entry "jazz:walk-binding-referenced" generic/specific ("jazz:Walk-Binding~virtual-runtime") 122 30 122 58 ()}
      {Lisp-Entry "jazz:emit-binding-symbol" generic/specific ("jazz:Walk-Binding~virtual-runtime") 123 30 123 54 ("environment" "source-declaration")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Walk-Binding~virtual-runtime") 124 30 124 57 ("environment" "source-declaration")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:Walk-Binding~virtual-runtime") 125 30 125 61 ("form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-binding-call" generic/specific ("jazz:Walk-Binding~virtual-runtime") 126 30 126 52 ("environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "jazz:emit-inlined-binding-call" generic/specific ("jazz:Walk-Binding~virtual-runtime") 127 30 127 60 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "jazz:walk-binding-validate-assignment" generic/specific ("jazz:Walk-Binding~virtual-runtime") 128 30 128 67 ("symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-binding-assignable?" generic/specific ("jazz:Walk-Binding~virtual-runtime") 129 30 129 59 ()}
      {Lisp-Entry "jazz:emit-binding-assignment" generic/specific ("jazz:Walk-Binding~virtual-runtime") 130 30 130 58 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:walk-binding-walkable?" generic/specific ("jazz:Walk-Binding~virtual-runtime") 131 30 131 57 ()}
      {Lisp-Entry "jazz:walk-binding-walk-form" generic/specific ("jazz:Walk-Binding~virtual-runtime") 132 30 132 57 ("form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Walk-Binding~virtual-runtime") 133 30 133 59 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Walk-Binding~virtual-runtime") 134 30 134 59 ("form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-binding-lookup" generic/specific ("jazz:Walk-Binding") 137 21 137 45 ("source-declaration" "symbol")}
      {Lisp-Entry "jazz:walk-binding-referenced" generic/specific ("jazz:Walk-Binding") 141 21 141 49 ("jazz:unspecified")}
      {Lisp-Entry "jazz:emit-binding-symbol" generic/specific ("jazz:Walk-Binding") 145 21 145 45 ("binding" "jazz:error" "environment" "source-declaration")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Walk-Binding") 149 21 149 48 ("binding" "jazz:error" "environment" "source-declaration")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:Walk-Binding") 153 21 153 52 ("jazz:unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-binding-call" generic/specific ("jazz:Walk-Binding") 157 21 157 43 ("jazz:call-return-type" "jazz:codes-forms" "jazz:emit-binding-reference" "jazz:sourcified-form2" "jazz:new-code" "binding" "%%get-lexical-binding-type" "type" "let" "environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "jazz:emit-inlined-binding-call" generic/specific ("jazz:Walk-Binding") 166 21 166 51 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "jazz:walk-binding-validate-assignment" generic/specific ("jazz:Walk-Binding") 170 21 170 58 ("%%get-lexical-binding-name" "jazz:walk-error" "binding" "jazz:walk-binding-assignable?" "%%not" "%%when" "symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-binding-assignable?" generic/specific ("jazz:Walk-Binding") 175 21 175 50 ()}
      {Lisp-Entry "jazz:emit-binding-assignment" generic/specific ("jazz:Walk-Binding") 179 21 179 49 ("jazz:unspecified" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:walk-binding-walkable?" generic/specific ("jazz:Walk-Binding") 183 21 183 48 ()}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Walk-Binding") 187 21 187 50 ()}
      {Lisp-Entry "jazz:call-return-type" define #f 194 9 194 30 ("jazz:Any" "%%get-function-type-result" "jazz:Function-Type" "%%is?" "if" "operator-type")}
      {Lisp-Entry "jazz:Lexical-Binding" define-class ("class runtime") 205 27 205 47 ()}
      {Lisp-Entry "jazz:resolve-binding" generic/specific ("jazz:Lexical-Binding~virtual-runtime") 208 30 208 50 ()}
      {Lisp-Entry "jazz:resolve-binding" generic/specific ("jazz:Lexical-Binding") 211 21 211 41 ("binding")}
      {Lisp-Entry "jazz:print-object" generic/specific ("jazz:Lexical-Binding") 215 21 215 38 ("jazz:object->serial" "%%get-lexical-binding-name" "binding" "%%get-object-class" "%%get-category-identifier" "jazz:format" "detail" "output")}
      {Lisp-Entry "jazz:walk-binding-lookup" generic/specific ("jazz:Lexical-Binding") 222 21 222 45 ("binding" "%%get-lexical-binding-name" "%%eq?" "if" "source-declaration" "symbol")}
      {Lisp-Entry "jazz:get-lexical-binding-name" define #f 228 9 228 38 ("%%get-lexical-binding-name" "binding")}
      {Lisp-Entry "jazz:get-lexical-binding-hits" define #f 232 9 232 38 ("%%set-lexical-binding-hits" "eq?" "test:" "%%make-table" "table" "let" "%%get-lexical-binding-hits" "or" "binding")}
      {Lisp-Entry "jazz:emit-binding-symbol" generic/specific ("jazz:Lexical-Binding") 239 21 239 45 ("binding" "%%get-lexical-binding-name" "environment" "declaration")}
      {Lisp-Entry "jazz:Declaration" define-class ("class runtime") 251 27 251 43 ()}
      {Lisp-Entry "jazz:setup-declaration" define #f 254 9 254 31 ("%%get-declaration-toplevel" "%%set-declaration-toplevel" "%%get-declaration-locator" "%%compose-reference" "%%not" "if" "%%set-declaration-locator" "%%get-lexical-binding-name" "name" "%%get-declaration-parent" "parent" "let" "new-declaration")}
      {Lisp-Entry "jazz:get-declaration-path" define #f 261 9 261 34 ("jazz:reverse!" "%%cons" "%%list" "%%not" "if" "%%get-declaration-parent" "parent" "%%get-lexical-binding-name" "name" "let" "iter" "define" "declaration")}
      {Lisp-Entry "jazz:walk-binding-lookup" generic/specific ("jazz:Declaration") 272 21 272 45 ("jazz:private-access" "binding" "jazz:lookup-declaration" "source-declaration" "symbol")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:Declaration") 276 21 276 52 ("declaration" "%%get-lexical-binding-name" "jazz:walk-error" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:lookup-declaration" generic/specific ("jazz:Declaration~virtual-runtime") 280 30 280 53 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz:lookup-declaration" generic/specific ("jazz:Declaration") 283 21 283 44 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz:get-declaration-inclusions" generic/specific ("jazz:Declaration~virtual-runtime") 287 30 287 61 ()}
      {Lisp-Entry "jazz:get-declaration-inclusions" generic/specific ("jazz:Declaration") 290 21 290 52 ()}
      {Lisp-Entry "jazz:get-nextmethod-signature" generic/specific ("jazz:Declaration~virtual-runtime") 294 30 294 59 ()}
      {Lisp-Entry "jazz:get-nextmethod-signature" generic/specific ("jazz:Declaration") 297 21 297 50 ("declaration" "jazz:error")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Declaration~virtual-runtime") 301 30 301 51 ("environment")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Declaration") 304 21 304 42 ("declaration" "jazz:error" "environment")}
      {Lisp-Entry "jazz:expand-referenced-declaration" generic/specific ("jazz:Declaration~virtual-runtime") 308 30 308 64 ()}
      {Lisp-Entry "jazz:expand-referenced-declaration" generic/specific ("jazz:Declaration") 311 21 311 55 ()}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Declaration~virtual-runtime") 315 30 315 51 ("s" "k" "f")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Declaration") 318 21 318 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:declaration-result" define #f 322 9 322 32 ("jazz:unspecified" "eval" "jazz:walk-for" "%%eq?" "if")}
      {Lisp-Entry "jazz:Declaration-Reference" define-class ("class runtime") 336 27 336 53 ()}
      {Lisp-Entry "jazz:resolve-reference" generic/specific ("jazz:Declaration-Reference~virtual-runtime") 339 30 339 52 ("module-declaration")}
      {Lisp-Entry "jazz:resolve-reference" generic/specific ("jazz:Declaration-Reference") 342 21 342 43 ("%%set-declaration-reference-declaration" "uptodate" "public" "jazz:new-export-declaration" "declaration" "let" "%%get-declaration-reference-name" "jazz:parse-exported-symbol" "symbol" "name" "receive" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "jazz:Module-Reference" define-class ("class runtime") 358 27 358 48 ()}
      {Lisp-Entry "jazz:new-module-reference" define #f 361 9 361 34 ("jazz:Module-Reference" "jazz:allocate-module-reference" "declaration" "name")}
      {Lisp-Entry "jazz:resolve-reference" generic/specific ("jazz:Module-Reference") 365 21 365 43 ("%%set-declaration-reference-declaration" "%%get-declaration-reference-name" "jazz:outline-module" "declaration" "let" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "jazz:Export-Reference" define-class ("class runtime") 380 27 380 48 ()}
      {Lisp-Entry "jazz:new-export-reference" define #f 383 9 383 34 ("jazz:Export-Reference" "jazz:allocate-export-reference" "module-reference" "declaration" "name")}
      {Lisp-Entry "jazz:resolve-reference" generic/specific ("jazz:Export-Reference") 387 21 387 43 ("%%set-declaration-reference-declaration" "uptodate" "public" "jazz:new-export-declaration" "declaration" "%%get-lexical-binding-name" "jazz:compose-reference" "locator" "let" "%%get-declaration-reference-name" "jazz:parse-exported-symbol" "symbol" "name" "receive" "declaration-reference" "%%get-declaration-reference-declaration" "or" "module-declaration")}
      {Lisp-Entry "jazz:parse-exported-symbol" define #f 396 9 396 35 ("jazz:reference-name" "values" "jazz:composite-reference?" "if" "name" "module-declaration")}
      {Lisp-Entry "jazz:Autoload-Reference" define-class ("class runtime") 410 27 410 50 ()}
      {Lisp-Entry "jazz:new-autoload-reference" define #f 413 9 413 36 ("jazz:Autoload-Reference" "jazz:allocate-autoload-reference" "module-reference" "declaration" "name")}
      {Lisp-Entry "jazz:resolve-autoload-reference" define #f 417 9 417 40 ("%%set-declaration-reference-declaration" "%%assert" "jazz:new-autoload-declaration" "declaration" "jazz:Any" "type" "%%get-declaration-reference-name" "name" "let*" "%%get-declaration-reference-declaration" "or" "exported-module-reference" "module-declaration" "declaration-reference")}
      {Lisp-Entry "jazz:Unit-Declaration" define-class ("class runtime") 435 27 435 48 ()}
      {Lisp-Entry "jazz:new-unit-declaration" define #f 438 9 438 34 ("jazz:setup-declaration" "uptodate" "jazz:Unit-Declaration" "jazz:allocate-unit-declaration" "new-declaration" "let" "requires" "parent" "access" "name")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Unit-Declaration") 444 21 444 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Namespace-Declaration" define-class ("class runtime") 456 27 456 53 ()}
      {Lisp-Entry "jazz:lookup-declaration" generic/specific ("jazz:Namespace-Declaration") 459 21 459 44 ("%%get-access-lookup" "%%table-ref" "found" "jazz:get-analysis-data" "%%set-analysis-data-autoload-reference" "jazz:Autoload-Declaration" "%%is?" "jazz:get-lexical-binding-hits" "hits-table" "let" "jazz:analysis-mode?" "add-to-hits" "%%get-declaration-locator" "%%table-set!" "%%get-module-declaration-walker-references" "references-table" "module-declaration" "let*" "%%get-declaration-toplevel" "namespace-declaration" "%%neq?" "and" "%%when" "declaration" "add-to-module-references" "define" "source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Namespace-Declaration") 481 21 481 42 ("%%get-namespace-declaration-body" "jazz:fold-statements" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:get-private-lookup" define #f 488 9 488 32 ("jazz:private-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "jazz:get-public-lookup" define #f 491 9 491 31 ("jazz:public-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "jazz:get-protected-lookup" define #f 494 9 494 34 ("jazz:protected-access" "%%get-access-lookup" "namespace-declaration")}
      {Lisp-Entry "jazz:Module-Declaration" define-class ("class runtime") 504 27 504 50 ()}
      {Lisp-Entry "jazz:new-module-declaration" define #f 507 9 507 36 ("jazz:setup-declaration" "eq?" "test:" "%%make-table" "jazz:new-queue" "jazz:public-access" "jazz:make-access-lookups" "uptodate" "jazz:Module-Declaration" "jazz:allocate-module-declaration" "new-declaration" "let" "dialect-invoice" "dialect-name" "walker" "parent" "access" "name")}
      {Lisp-Entry "jazz:add-module-require" define #f 513 9 513 32 ("%%list" "%%get-module-declaration-requires" "%%append" "%%set-module-declaration-requires" "jazz:load-unit" "syntax" "%%eq?" "%%when" "phase" "feature-requirement" "unit-name" "lambda" "jazz:parse-require" "require" "module-declaration")}
      {Lisp-Entry "jazz:add-module-import" define #f 521 9 521 31 ("jazz:table-merge-reporting-conflicts!" "jazz:public-access" "imported" "imported-module-declaration" "%%get-module-invoice-only" "only" "jazz:private-access" "%%get-access-lookup" "private" "%%list" "%%append" "%%set-module-declaration-imports" "jazz:find-module-invoice" "%%get-module-declaration-imports" "imports" "if" "%%get-lexical-binding-name" "jazz:load-unit" "%%get-module-invoice-module" "let" "syntax" "%%get-module-invoice-phase" "%%eq?" "%%when" "new" "actual" "merge-invoice" "define" "register?" "module-invoice" "module-declaration")}
      {Lisp-Entry "jazz:add-module-export" define #f 545 9 545 31 ("key" "table-for-each" "jazz:table-merge-reporting-conflicts!" "exported-table" "exported-module-declaration" "let*" "else" "jazz:resolve-autoload-reference" "exported-module-reference" "%%get-declaration-reference-name" "jazz:reference-name" "name" "declaration-reference" "lambda" "for-each" "cond" "autoload" "%%get-module-invoice-only" "only" "jazz:public-access" "%%get-access-lookup" "public" "%%list" "%%set-module-declaration-exports" "jazz:find-module-invoice" "%%get-module-declaration-exports" "exports" "%%get-lexical-binding-name" "jazz:load-unit" "%%get-module-invoice-module" "jazz:resolve-reference" "syntax" "%%get-module-invoice-phase" "%%eq?" "%%get-declaration-locator" "%%table-set!" "%%get-module-declaration-walker-references" "references-table" "%%get-declaration-toplevel" "%%neq?" "and" "declaration" "add-to-module-references" "%%append" "if" "%%set-export-invoice-autoload" "%%when" "new-autoload" "%%get-export-invoice-autoload" "actual-autoload" "let" "new" "actual" "merge-invoice" "define" "module-invoice" "module-declaration")}
      {Lisp-Entry "jazz:table-merge-reporting-conflicts!" define #f 593 9 593 46 ("%%get-lexical-binding-name" "jazz:error" "%%null?" "conflicts" "%%fx+" "%%fx=" "%%not" "%%table-merge!" "add-count" "%%table-length" "table-count" "%%list" "%%cons" "set!" "%%neq?" "%%when" "actual-locator" "value-locator" "%%table-ref" "actual" "value" "key" "lambda" "jazz:iterate-table" "lst" "let" "find-actual-conflicts" "%%get-declaration-locator" "else" "jazz:autoload-declaration-locator-heuristic" "jazz:Autoload-Declaration" "%%get-export-declaration-symbol" "jazz:Export-Declaration" "%%is?" "cond" "decl" "effective-declaration-locator" "define" "add" "table" "suffix" "module-declaration")}
      {Lisp-Entry "jazz:generate-reference-list" define #f 627 9 627 37 ("%%cdar" "%%pair?" "map" "declarations" "%%caar" "%%get-declaration-locator" "module-locator" "out" "%%table->list" "in" "%%table-ref" "%%table-set!" "%%get-declaration-toplevel" "module" "jazz:resolve-binding" "resolved-declaration" "locator" "lambda" "%%get-module-declaration-walker-references" "jazz:iterate-table" "eq?" "test:" "%%make-table" "partition" "%%get-lexical-binding-name" "%%get-declaration-parent" "%%eq?" "composite-identifier" "iter" "declaration" "root-declaration" "compose-name" "%%cdr" "else" "%%cons" "%%car" "%%list" "cond" "sorted" "item" "merge-sorted" "cdr" "%%string=?" "and" "%%string<?" "string2" "car" "%%symbol->string" "string1" "let" "%%null?" "or" "if" "name2" "name1" "lesser" "define" "module-declaration")}
      {Lisp-Entry "jazz:lookup-declaration" generic/specific ("jazz:Module-Declaration") 672 21 672 44 ("nextmethod" "declaration" "%%get-module-declaration-imports" "%%set-import-invoice-hit?" "%%table-ref" "jazz:public-access" "%%get-access-lookup" "imported" "%%get-module-invoice-module" "imported-module-declaration" "let" "module-invoice" "lambda" "for-each" "jazz:analysis-mode?" "%%when" "source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Module-Declaration") 684 21 684 42 (",@body-expansion" ",@variables-expansion" ",@literals-expansion" ",@autoloads-expansion" ",@inclusions-expansion" ",@registration-expansion" "%%get-module-declaration-imports" "%%cadr" "%%symbol->string" "%%string<?" "y" "x" "jazz:queue-list" "jazz:sort" "jazz:enqueue-list" ",symbol-name" ",name" "jazz:register-autoload" "jazz:compose-reference" "symbol-name" "jazz:reference-name" "name" "decl" "%%get-declaration-reference-name" "names" "auto" "%%get-module-declaration-exports" "%%get-lexical-binding-name" "syntax" "%%get-module-invoice-phase" "%%get-module-invoice-module" "jazz:resolve-reference" "module-declaration" "and" "%%get-export-invoice-autoload" "autoload" "%%get-module-invoice-only" "only" "module-invoice" "%%get-module-declaration-requires" "phase" "feature-requirement" "jazz:parse-require" "spec" "lambda" "for-each" "core" "%%neq?" "%%get-module-declaration-dialect-name" "dialect-name" "core.module" ",unit-name" "jazz:load-unit" "jazz:enqueue" "%%table-set!" "%%table-ref" "%%not" "%%when" "unit-name" "enqueue-load-unit" "define" "eq?" "test:" "%%make-table" "load-units" "jazz:new-queue" "queue" "module" "jazz:declares" "else" "eval" "jazz:walk-for" "case" "begin" "jazz:emit-module-registration" "registration-expansion" "jazz:emit-module-autoloads" "autoloads-expansion" "jazz:emit-module-variables" "variables-expansion" "jazz:emit-module-literals" "literals-expansion" "jazz:emit-module-inclusions" "inclusions-expansion" "declaration" "%%get-namespace-declaration-body" "jazz:emit-namespace-statements" "body-expansion" "let" "environment")}
      {Lisp-Entry "jazz:get-module-proclaim" define #f 753 9 753 33 ("%%get-module-declaration-proclaims" "%%table-ref" "default" "proclaim-name" "module-declaration")}
      {Lisp-Entry "jazz:set-module-proclaim" define #f 757 9 757 33 ("%%get-module-declaration-proclaims" "%%table-set!" "value" "proclaim-name" "module-declaration")}
      {Lisp-Entry "jazz:all-warnings" define #f 761 8 761 25 ("optimizations")}
      {Lisp-Entry "jazz:proclaim" define #f 765 9 765 22 ("jazz:remove!" "else" "%%cons" "jazz:set-module-proclaim" "jazz:get-module-proclaim" "module-warnings" "jazz:error" "%%memq" "%%not" "cond" "warning" "lambda" "for-each" "jazz:all-warnings" "%%null?" "warnings" "warn" "case" "receive" "not" "%%eq?" "if" "parse-clause" "values" "%%cdr" "parameters" "%%car" "kind" "let" "%%pair?" "%%assert" "not?" "parse-not" "define" "clause" "module-declaration")}
      {Lisp-Entry "jazz:get-module-warn?" define #f 798 9 798 30 ("warn" "jazz:get-module-proclaim" "%%memq" "warning-name" "module-declaration")}
      {Lisp-Entry "jazz:Module-Invoice" define-class ("class runtime") 810 27 810 46 ()}
      {Lisp-Entry "jazz:find-module-invoice" define #f 816 9 816 33 ("%%eq?" "and" "invoice" "lambda" "jazz:find-if" "%%get-module-invoice-phase" "target-phase" "%%get-module-invoice-name" "target-name" "let" "target" "invoices")}
      {Lisp-Entry "jazz:Export-Invoice" define-class ("class runtime") 830 27 830 46 ()}
      {Lisp-Entry "jazz:new-export-invoice" define #f 833 9 833 32 ("jazz:Export-Invoice" "jazz:allocate-export-invoice" "autoload" "only" "version" "phase" "module" "name")}
      {Lisp-Entry "jazz:Import-Invoice" define-class ("class runtime") 845 27 845 46 ()}
      {Lisp-Entry "jazz:new-import-invoice" define #f 848 9 848 32 ("jazz:Import-Invoice" "jazz:allocate-import-invoice" "only" "version" "phase" "module" "name")}
      {Lisp-Entry "jazz:Export-Declaration" define-class ("class runtime") 860 27 860 50 ()}
      {Lisp-Entry "jazz:new-export-declaration" define #f 863 9 863 36 ("jazz:setup-declaration" "jazz:Export-Declaration" "jazz:allocate-export-declaration" "new-declaration" "let" "symbol" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:Export-Declaration") 869 21 869 52 ("jazz:unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Export-Declaration") 873 21 873 42 (",symbol" ",name" "jazz:register-native" "jazz:Module-Declaration" "%%is?" "%%assert" "%%get-declaration-parent" "parent" "%%get-export-declaration-symbol" "symbol" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Export-Declaration") 881 21 881 48 ("jazz:Any" "declaration" "%%get-export-declaration-symbol" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Export-Declaration") 888 21 888 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Export-Syntax-Declaration" define-class ("class runtime") 900 27 900 57 ()}
      {Lisp-Entry "jazz:new-export-syntax-declaration" define #f 903 9 903 43 ("jazz:setup-declaration" "jazz:Export-Syntax-Declaration" "jazz:allocate-export-syntax-declaration" "new-declaration" "let" "symbol" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:Export-Syntax-Declaration") 909 21 909 52 ("jazz:unspecified" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Export-Syntax-Declaration") 913 21 913 42 ("begin" "environment")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Export-Syntax-Declaration") 917 21 917 48 ("jazz:Any" "declaration" "%%get-export-syntax-declaration-symbol" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Export-Syntax-Declaration") 924 21 924 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Autoload-Declaration" define-class ("class runtime") 936 27 936 52 ()}
      {Lisp-Entry "jazz:new-autoload-declaration" define #f 939 9 939 38 ("jazz:setup-declaration" "uptodate" "public" "jazz:Autoload-Declaration" "jazz:allocate-autoload-declaration" "new-declaration" "let" "exported-module" "module-declaration" "parent" "type" "name")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Autoload-Declaration") 945 21 945 37 ("declaration" "jazz:resolve-binding" "jazz:of-subtype?" "subtype")}
      {Lisp-Entry "jazz:specifiable?" generic/specific ("jazz:Autoload-Declaration") 950 21 950 38 ()}
      {Lisp-Entry "jazz:resolve-binding" generic/specific ("jazz:Autoload-Declaration") 955 21 955 41 ("%%set-autoload-declaration-declaration" "%%get-declaration-locator" "jazz:error" "%%assertion" "jazz:public-access" "jazz:lookup-declaration" "decl" "%%get-lexical-binding-name" "name" "%%get-autoload-declaration-module" "%%get-autoload-declaration-exported-module" "jazz:resolve-reference" "exported-module" "let*" "declaration" "%%get-autoload-declaration-declaration" "or")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:Autoload-Declaration") 965 21 965 52 ("declaration" "jazz:resolve-binding" "jazz:walk-binding-validate-call" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Autoload-Declaration") 969 21 969 48 ("jazz:autoload-locator" "jazz:new-code" "declaration" "jazz:resolve-binding" "referenced-declaration" "let" "environment" "source-declaration")}
      {Lisp-Entry "jazz:autoload-declaration-locator-heuristic" define #f 979 9 979 52 ("%%get-lexical-binding-name" "%%get-autoload-declaration-exported-module" "%%get-declaration-reference-name" "jazz:compose-reference" "declaration")}
      {Lisp-Entry "jazz:autoload-locator" define #f 983 9 983 30 ("%%get-declaration-locator" "%%symbol->string" "%%string-append" "%%string->symbol" "referenced-declaration")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Autoload-Declaration") 988 21 988 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Literal" define-class ("class runtime") 1000 27 1000 39 ()}
      {Lisp-Entry "jazz:new-literal" define #f 1003 9 1003 25 ("jazz:Literal" "jazz:allocate-literal" "arguments" "name")}
      {Lisp-Entry "jazz:Void-Class" define-class ("class runtime") 1015 27 1015 42 ()}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Void-Class") 1018 21 1018 37 ("subtype")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Void-Class") 1022 21 1022 40 ("void")}
      {Lisp-Entry "jazz:Void" define-class ("class runtime") 1029 27 1029 36 ()}
      {Lisp-Entry "jazz:Opt-Type" define-class ("class runtime") 1040 27 1040 40 ()}
      {Lisp-Entry "jazz:new-opt-type" define #f 1043 9 1043 26 ("jazz:Opt-Type" "jazz:allocate-opt-type" "type")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Opt-Type") 1047 21 1047 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-opt-type-type" "jazz:emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "jazz:Key-Type" define-class ("class runtime") 1060 27 1060 40 ()}
      {Lisp-Entry "jazz:new-key-type" define #f 1063 9 1063 26 ("jazz:Key-Type" "jazz:allocate-key-type" "type" "key")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Key-Type") 1067 21 1067 40 ("%%symbol->string" "%%keyword->string" "%%string-append" "%%string->symbol" "%%get-key-type-type" "jazz:emit-specifier" "type-specifier" "type" "%%get-key-type-key" "key" "let")}
      {Lisp-Entry "jazz:Rest-Type" define-class ("class runtime") 1081 27 1081 41 ()}
      {Lisp-Entry "jazz:new-rest-type" define #f 1084 9 1084 27 ("jazz:Rest-Type" "jazz:allocate-rest-type" "type")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Rest-Type") 1088 21 1088 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-rest-type-type" "jazz:emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "jazz:Function-Type" define-class ("class runtime") 1104 27 1104 45 ()}
      {Lisp-Entry "jazz:new-function-type" define #f 1107 9 1107 31 ("jazz:Function-Type" "jazz:allocate-function-type" "%%length" "mandatory" "let" "result" "rest" "named" "optional" "positional")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Function-Type") 1112 21 1112 37 ("jazz:Function-Type" "%%get-object-class" "%%eq?" "jazz:Procedure" "jazz:of-subtype?" "or" "subtype")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Function-Type") 1117 21 1117 40 ("get-output-string" "%%string->symbol" "%%get-function-type-result" "%%not" "%%when" "%%get-function-type-rest" "rest" "%%get-function-type-positional" "jazz:emit-specifier" "display" "write-char" "set!" "if" "type" "lambda" "for-each" "first?" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz:emit-check" generic/specific ("jazz:Function-Type") 1136 21 1136 36 ("jazz:Procedure" "jazz:type-error" ",value" "%%procedure?" "%%not" "if" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Category-Type" define-class ("class runtime") 1152 27 1152 45 ()}
      {Lisp-Entry "jazz:new-category-type" define #f 1155 9 1155 31 ("jazz:Category-Type" "jazz:allocate-category-type" "declaration")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Category-Type") 1160 21 1160 37 ("subtype")}
      {Lisp-Entry "jazz:emit-check" generic/specific ("jazz:Category-Type") 1164 21 1164 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Category-Type") 1168 21 1168 40 ("get-output-string" "%%string->symbol" "type" "%%get-category-type-declaration" "jazz:emit-specifier" "write-char" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz:Values-Type" define-class ("class runtime") 1185 27 1185 43 ()}
      {Lisp-Entry "jazz:new-values-type" define #f 1188 9 1188 29 ("jazz:Values-Type" "jazz:allocate-values-type" "types")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Values-Type") 1192 21 1192 40 ("get-output-string" "%%string->symbol" "%%get-values-type-types" "jazz:emit-specifier" "set!" "if" "type" "lambda" "for-each" "first?" "write-char" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz:Restriction-Type" define-class ("class runtime") 1215 27 1215 48 ()}
      {Lisp-Entry "jazz:new-restriction-type" define #f 1218 9 1218 34 ("jazz:Restriction-Type" "jazz:allocate-restriction-type" "type" "base")}
      {Lisp-Entry "jazz:Complement-Type" define-class ("class runtime") 1230 27 1230 47 ()}
      {Lisp-Entry "jazz:new-complement-type" define #f 1233 9 1233 33 ("jazz:Complement-Type" "jazz:allocate-complement-type" "type")}
      {Lisp-Entry "jazz:Union-Type" define-class ("class runtime") 1245 27 1245 42 ()}
      {Lisp-Entry "jazz:new-union-type" define #f 1248 9 1248 28 ("jazz:Union-Type" "jazz:allocate-union-type" "types")}
      {Lisp-Entry "jazz:Template-Type" define-class ("class runtime") 1263 27 1263 45 ()}
      {Lisp-Entry "jazz:new-template-type" define #f 1266 9 1266 31 ("jazz:Template-Type" "jazz:allocate-template-type" "types" "class")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Template-Type") 1270 21 1270 40 ("get-output-string" "%%string->symbol" "%%get-template-type-types" "set!" "if" "lambda" "for-each" "first?" "write-char" "type" "%%get-template-type-class" "jazz:emit-specifier" "display" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz:Nillable-Type" define-class ("class runtime") 1293 27 1293 45 ()}
      {Lisp-Entry "jazz:new-nillable-type" define #f 1296 9 1296 31 ("jazz:Nillable-Type" "jazz:allocate-nillable-type" "type")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Nillable-Type") 1300 21 1300 37 ("type" "%%get-nillable-type-type" "jazz:Boolean" "jazz:of-subtype?" "or" "subtype")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Nillable-Type") 1305 21 1305 40 ("%%symbol->string" "%%string-append" "%%string->symbol" "type" "%%get-nillable-type-type" "jazz:emit-specifier" "type-specifier" "let")}
      {Lisp-Entry "jazz:emit-check" generic/specific ("jazz:Nillable-Type") 1310 21 1310 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:object-declaration?" define #f 1323 8 1323 32 ()}
      {Lisp-Entry "jazz:Any-Class" define-class ("class runtime") 1335 27 1335 41 ()}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Any-Class") 1338 21 1338 37 ("subtype")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Any-Class") 1342 21 1342 40 ("any")}
      {Lisp-Entry "jazz:emit-check" generic/specific ("jazz:Any-Class") 1346 21 1346 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Any" define-class ("class runtime") 1353 27 1353 35 ()}
      {Lisp-Entry "jazz:emit-type-cast" define #f 1370 13 1370 32 ("%%fixnum->flonum" "%%fixnum?" ",value" "jazz:Flonum" "%%eq?" "jazz:generate-symbol" "value" "let" "jazz:sourcified-form" "%%get-code-type" "%%subtype?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "jazz:emit-type-cast" define #f 1382 12 1382 31 ("jazz:emit-check" "begin" "%%fixnum->flonum" "%%fixnum?" ",value" "jazz:Flonum" "jazz:generate-symbol" "value" "let" "jazz:sourcified-form" "%%get-code-type" "%%subtype?" "jazz:Void" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "jazz:emit-parameter-cast" define #f 1403 13 1403 37 ("%%fixnum->flonum" "set!" ",parameter" "%%fixnum?" "jazz:Flonum" "jazz:sourcified-form" "parameter" "let" "jazz:object-declaration?" "%%object-class?" "jazz:Any" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "jazz:emit-parameter-cast" define #f 1413 12 1413 36 ("jazz:emit-check" "%%fixnum->flonum" "set!" ",parameter" "%%fixnum?" "jazz:Flonum" "jazz:sourcified-form" "parameter" "let" "jazz:object-declaration?" "%%object-class?" "jazz:Any" "%%eq?" "%%not" "or" "if" "environment" "source-declaration" "type" "code")}
      {Lisp-Entry "jazz:parse-specifier" define #f 1443 9 1443 29 ("%%cdr" "%%car" "jazz:source-code" "jazz:specifier?" "%%pair?" "and" "if" "proc" "lst")}
      {Lisp-Entry "jazz:walk-specifier" define #f 1449 9 1449 28 ("%%cons" "%%list" "atomic?" "jazz:new-function-type" "rest" "named" "optional" "positional" "lambda" "jazz:butlast" "jazz:Rest-Type" "%%class-is?" "jazz:last" "last" "%%null?" "proc" "types" "split-parameters" "result" "parameters" "new-function-type" "jazz:new-template-type" "jazz:new-values-type" "values" "jazz:new-category-type" "category" "jazz:new-key-type" "%%string->keyword" "key" "jazz:new-opt-type" "opt" "%%eq?" "jazz:new-rest-type" "jazz:new-nillable-type" "case" "parse-atomic" "write-char" "get-output-string" "%%string->symbol" "%%eof-object?" "open-output-string" "output" "parse-name" "else" "cond" "next" "parse" "jazz:enqueue" "jazz:queue-list" "begin" "iter" "jazz:new-queue" "queue" "terminator" "separator" "parse-until" "jazz:specifiable?" "%%assertion" "jazz:lookup-reference" "jazz:lookup-primitive-type" "or" "type" "name" "lookup-type" "%%eqv?" "consume" "1" "%%fx+" "set!" "read-char" "c" "readc" "peek-char" "peekc" "jazz:walk-error" "jazz:error" "%%not" "if" "%%substring" "jazz:format" "error-message" "message" "ill-formed" "define" "0" "at" "open-input-string" "input" "%%symbol->string" "string" "let" "specifier" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:specifier->type" define #f 1591 9 1591 29 ("jazz:walk-specifier" "if" "specifier" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:type->specifier" define #f 1597 9 1597 29 ("jazz:name->specifier" "jazz:specifier?" "if" "jazz:emit-specifier" "symbol" "let" "type")}
      {Lisp-Entry "jazz:primitive-types" define #f 1609 8 1609 28 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:lookup-primitive-type" define #f 1654 9 1654 35 ("jazz:primitive-types" "%%table-ref" "name")}
      {Lisp-Entry "jazz:primitive-declarations" define #f 1658 8 1658 35 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:patch-type-until-unification" define #f 1702 9 1702 42 ("jazz:public-access" "jazz:lookup-declaration" "jazz:get-catalog-entry" "module-declaration" "jazz.dialect.language.functional" "jazz.dialect.language.object" "Object" "%%eq?" "module-name" "if" "jazz:primitive-declarations" "%%table-ref" "name" "let" "type")}
      {Lisp-Entry "jazz:Macro-Declaration" define-class ("class runtime") 1718 27 1718 49 ()}
      {Lisp-Entry "jazz:new-macro-declaration" define #f 1721 9 1721 35 ("jazz:setup-declaration" "jazz:Macro-Declaration" "jazz:allocate-macro-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Macro-Declaration") 1727 21 1727 50 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Macro-Declaration") 1731 21 1731 50 ("%%cdr" "%%apply" "jazz:need-macro" "expander" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "jazz:walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Macro-Declaration") 1742 21 1742 42 ("%%get-declaration-source" "jazz:emit-expression" "jazz:sourcified-form" "jazz:emit-signature" "jazz:define-macro" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-macro-declaration-body" "body" "%%get-macro-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Macro-Declaration") 1755 21 1755 42 ("%%get-macro-declaration-body" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Local-Macro-Declaration" define-class ("class runtime") 1769 27 1769 55 ()}
      {Lisp-Entry "jazz:new-local-macro-declaration" define #f 1772 9 1772 41 ("jazz:setup-declaration" "jazz:Local-Macro-Declaration" "jazz:allocate-macro-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:need-local-macro" define #f 1777 9 1777 30 ("jazz:error" "%%get-module-declaration-local-macros" "%%table-ref" "or" "name" "module-declaration")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Local-Macro-Declaration") 1781 21 1781 50 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Local-Macro-Declaration") 1784 21 1784 50 ("%%cdr" "%%apply" "jazz:need-local-macro" "expander" "%%get-declaration-parent" "parent" "binding" "%%get-declaration-locator" "locator" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Local-Macro-Declaration") 1791 21 1791 42 ("begin" "environment")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Local-Macro-Declaration") 1795 21 1795 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Syntax-Declaration" define-class ("class runtime") 1807 27 1807 50 ()}
      {Lisp-Entry "jazz:new-syntax-declaration" define #f 1810 9 1810 36 ("jazz:setup-declaration" "jazz:Syntax-Declaration" "jazz:allocate-syntax-declaration" "new-declaration" "let" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Syntax-Declaration") 1816 21 1816 50 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Syntax-Declaration") 1820 21 1820 50 ("jazz:need-macro" "expander" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "jazz:walk-error" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Syntax-Declaration") 1830 21 1830 42 ("%%get-declaration-source" "jazz:emit-expression" "jazz:sourcified-form" "jazz:emit-signature" "jazz:define-macro" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-syntax-declaration-body" "body" "%%get-syntax-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Syntax-Declaration") 1843 21 1843 42 ("%%get-syntax-declaration-body" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Define-Syntax-Declaration" define-class ("class runtime") 1857 27 1857 57 ()}
      {Lisp-Entry "jazz:new-define-syntax-declaration" define #f 1860 9 1860 43 ("jazz:setup-declaration" "jazz:Define-Syntax-Declaration" "jazz:allocate-define-syntax-declaration" "new-declaration" "let" "syntax-form" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Define-Syntax-Declaration") 1866 21 1866 42 ("%%get-declaration-source" "jazz:register-macro" "jazz:emit-expression" "jazz:sourcified-form" "jazz:new-define-syntax-form" "tmp" ",current-unit-name" "jazz:outline-module" "else" "cons" "x" "=>" "jazz" "cond" "core" "scheme" "jazz:get-dialect" "%%get-dialect-bindings" "jazz:new-walk-frame" "%%list" "env" "let*" ",locator" "define" "jazz:sourcify-if" "%%get-declaration-toplevel" "current-unit-name" "%%cons" "augmented-environment" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-syntax-declaration-body" "body" "%%get-syntax-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Define-Syntax-Declaration") 1904 21 1904 50 ("%%get-define-syntax-form-environment" "macro-environment" "%%get-syntax-form-expander" "expander" "jazz:need-macro" "define-syntax-form" "let*" "jazz:load-unit" "%%get-declaration-parent" "parent-declaration" "jazz:walk-warning" "%%get-declaration-toplevel" "%%eq?" "if" "binding" "%%get-declaration-locator" "locator" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Define-Local-Syntax-Declaration" define-class ("class runtime") 1924 27 1924 63 ()}
      {Lisp-Entry "jazz:new-define-local-syntax-declaration" define #f 1926 9 1926 49 ("jazz:setup-declaration" "jazz:Define-Local-Syntax-Declaration" "jazz:allocate-define-local-syntax-declaration" "new-declaration" "let" "syntax-form" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Define-Local-Syntax-Declaration") 1931 21 1931 50 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Define-Local-Syntax-Declaration") 1934 21 1934 50 ("%%get-define-local-syntax-form-environment" "macro-environment" "%%get-syntax-form-expander" "expander" "let" "%%get-declaration-parent" "jazz:need-local-macro" "define-local-syntax-form" "binding" "%%get-declaration-locator" "locator" "let*" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Define-Local-Syntax-Declaration") 1941 21 1941 42 ("begin" "environment")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Define-Local-Syntax-Declaration") 1944 21 1944 42 ("declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:Walk-Context" define-class ("class runtime") 1955 27 1955 44 ()}
      {Lisp-Entry "jazz:new-walk-context" define #f 1958 9 1958 30 ("jazz:Walk-Context" "jazz:allocate-walk-context" "pathname" "locator" "policy")}
      {Lisp-Entry "jazz:walk-context" define #f 1962 8 1962 25 ("make-parameter")}
      {Lisp-Entry "jazz:get-walk-context" define #f 1966 9 1966 30 ("jazz:walk-context")}
      {Lisp-Entry "jazz:need-walk-context" define #f 1970 9 1970 31 ("jazz:error" "jazz:walk-context" "or")}
      {Lisp-Entry "jazz:get-walk-policy" define #f 1975 9 1975 29 ("%%get-walk-context-policy" "%%not" "if" "jazz:get-walk-context" "context" "let")}
      {Lisp-Entry "jazz:get-walk-locator" define #f 1982 9 1982 30 ("%%get-walk-context-locator" "%%not" "if" "jazz:get-walk-context" "context" "let")}
      {Lisp-Entry "jazz:get-walk-pathname" define #f 1989 9 1989 31 ("%%get-walk-context-pathname" "%%not" "if" "jazz:get-walk-context" "context" "let")}
      {Lisp-Entry "jazz:Walk-Location" define-class ("class runtime") 2004 27 2004 45 ()}
      {Lisp-Entry "jazz:new-walk-location" define #f 2007 9 2007 31 ("jazz:Walk-Location" "jazz:allocate-walk-location" "path" "locat" "declaration-locator" "unit-locator")}
      {Lisp-Entry "jazz:walk-location" define #f 2011 9 2011 27 ("%%locat-container" "%%container->path" "if" "%%get-declaration-locator" "jazz:get-walk-locator" "jazz:new-walk-location" "locat" "declaration" "walker")}
      {Lisp-Entry "jazz:Walk-Problem" define-class ("class runtime") 2027 27 2027 44 ()}
      {Lisp-Entry "jazz:Walk-Problems" define-class ("class runtime") 2038 27 2038 45 ()}
      {Lisp-Entry "jazz:new-walk-problems" define #f 2041 9 2041 31 ("jazz:Walk-Problems" "jazz:allocate-walk-problems" "errors" "warnings" "message")}
      {Lisp-Entry "jazz:get-detail" generic/specific ("jazz:Walk-Problems") 2045 21 2045 36 ("jazz:partition-walk-problems-unit" "jazz:partition-walk-problems-declaration" "jazz:queue-list" "declaration-details" "1" "%%fx+" "%%substring" "%%fx=" "declaration-locator" "jazz:new-queue" "unit-details" "or" "%%symbol->string" "%%string-length" "-1" "%%not" "if" "prefix" "unit-locator" "jazz:bind" "partition" "map" "%%get-walk-problems-errors" "%%get-walk-problems-warnings" "%%append" "all" "let" "%%get-walk-problem-location" "jazz:present-exception" "jazz:new-exception-detail" "jazz:enqueue" "problem" "lambda" "for-each" "queue" "problems" "add-details" "define")}
      {Lisp-Entry "jazz:Walk-Warning" define-class ("class runtime") 2081 27 2081 44 ()}
      {Lisp-Entry "jazz:new-walk-warning" define #f 2084 9 2084 30 ("jazz:Walk-Warning" "jazz:allocate-walk-warning" "message" "location")}
      {Lisp-Entry "jazz:Walk-Error" define-class ("class runtime") 2096 27 2096 42 ()}
      {Lisp-Entry "jazz:new-walk-error" define #f 2099 9 2099 28 ("jazz:Walk-Error" "jazz:allocate-walk-error" "message" "location")}
      {Lisp-Entry "jazz:Unresolved-Error" define-class ("class runtime") 2111 27 2111 48 ()}
      {Lisp-Entry "jazz:new-unresolved-error" define #f 2114 9 2114 34 ("jazz:Unresolved-Error" "jazz:allocate-unresolved-error" "symbol" "location")}
      {Lisp-Entry "jazz:present-exception" generic/specific ("jazz:Unresolved-Error") 2118 21 2118 43 ("error" "%%get-unresolved-error-symbol" "jazz:format")}
      {Lisp-Entry "jazz:Walk-Frame" define-class ("class runtime") 2131 27 2131 42 ()}
      {Lisp-Entry "jazz:new-walk-frame" define #f 2134 9 2134 28 ("jazz:Walk-Frame" "jazz:allocate-walk-frame" "%%table-set!" "%%get-lexical-binding-name" "name" "binding" "lambda" "for-each" "eq?" "test:" "%%make-table" "table" "let" "bindings")}
      {Lisp-Entry "jazz:walk-binding-lookup" generic/specific ("jazz:Walk-Frame") 2143 21 2143 45 ("binding" "%%get-walk-frame-bindings" "%%table-ref" "source-declaration" "symbol")}
      {Lisp-Entry "jazz:Signature" define-class ("class runtime") 2155 27 2155 41 ()}
      {Lisp-Entry "jazz:new-signature" define #f 2158 9 2158 27 ("jazz:Signature" "jazz:allocate-signature" "%%length" "mandatory" "let" "rest" "named" "optional" "positional")}
      {Lisp-Entry "jazz:only-positional?" define #f 2163 9 2163 30 ("%%get-signature-rest" "%%not" "%%get-signature-named" "%%get-signature-optional" "%%null?" "and" "signature")}
      {Lisp-Entry "jazz:Symbol-Binding" define-class ("class runtime") 2177 27 2177 46 ()}
      {Lisp-Entry "jazz:emit-binding-symbol" generic/specific ("jazz:Symbol-Binding") 2180 21 2180 45 ("%%get-lexical-binding-name" "unwrap-syntactic-closure" "binding" "%%get-symbol-binding-gensym" "or" "environment" "declaration")}
      {Lisp-Entry "jazz:Variable" define-class ("class runtime") 2193 27 2193 40 ()}
      {Lisp-Entry "jazz:new-variable" define #f 2196 9 2196 26 ("0" "jazz:Variable" "jazz:allocate-variable" "jazz:error" "jazz:variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "jazz:variable-name-valid?" define #f 2201 9 2201 34 ("%%get-syntactic-closure-form" "syntactic-closure?" "if" "jazz:specifier?" "%%not" "%%symbol?" "and" "variable-name-valid-symbol?" "define" "name")}
      {Lisp-Entry "jazz:walk-binding-referenced" generic/specific ("jazz:Variable") 2212 21 2212 49 ("1" "%%get-variable-reference-count" "%%fx+" "binding" "%%set-variable-reference-count")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Variable") 2216 21 2216 48 ("jazz:find-annotated-type" "binding" "jazz:emit-binding-symbol" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz:walk-binding-assignable?" generic/specific ("jazz:Variable") 2223 21 2223 50 ()}
      {Lisp-Entry "jazz:emit-binding-assignment" generic/specific ("jazz:Variable") 2227 21 2227 49 ("jazz:Any" "jazz:sourcified-form" "jazz:emit-binding-symbol" "set!" "jazz:new-code" "%%get-code-type" "jazz:extend-annotated-type" "jazz:Annotated-Variable" "%%class-is?" "%%when" "binding" "jazz:find-annotated" "annotated-type" "annotated-variable" "annotated-frame" "receive" "jazz:emit-expression" "value-code" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:NextMethod-Variable" define-class ("class runtime") 2247 27 2247 51 ()}
      {Lisp-Entry "jazz:new-nextmethod-variable" define #f 2250 9 2250 37 ("0" "jazz:NextMethod-Variable" "jazz:allocate-nextmethod-variable" "jazz:error" "jazz:variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:NextMethod-Variable") 2255 21 2255 48 ("jazz:Any" "jazz:sourcified-form" ",name" "apply" "rest" "lambda" "if" "jazz:new-code" "jazz:*self*" "self" "binding" "%%get-lexical-binding-name" "name" "let" "environment" "source-declaration")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:NextMethod-Variable") 2266 21 2266 52 ("declaration" "jazz:validate-arguments" "if" "jazz:get-nextmethod-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-binding-call" generic/specific ("jazz:NextMethod-Variable") 2272 21 2272 43 ("jazz:call-return-type" "jazz:codes-forms" "jazz:sourcified-form" ",name" "jazz:new-code" "if" "jazz:*self*" "self" "%%get-lexical-binding-type" "type" "binding" "%%get-lexical-binding-name" "name" "let" "environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "jazz:Parameter" define-class ("class runtime") 2298 27 2298 41 ()}
      {Lisp-Entry "jazz:new-parameter" define #f 2301 9 2301 27 ("0" "jazz:Parameter" "jazz:allocate-parameter" "jazz:error" "jazz:variable-name-valid?" "%%assertion" "type" "name")}
      {Lisp-Entry "jazz:emit-parameter" generic/specific ("jazz:Parameter~virtual-runtime") 2306 30 2306 49 ("environment" "declaration")}
      {Lisp-Entry "jazz:emit-parameter" generic/specific ("jazz:Parameter") 2309 21 2309 40 ("parameter" "jazz:emit-binding-symbol" "environment" "declaration")}
      {Lisp-Entry "jazz:Dynamic-Parameter" define-class ("class runtime") 2321 27 2321 49 ()}
      {Lisp-Entry "jazz:new-dynamic-parameter" define #f 2324 9 2324 35 ("0" "jazz:Dynamic-Parameter" "jazz:allocate-dynamic-parameter" "class" "type" "name")}
      {Lisp-Entry "jazz:emit-parameter" generic/specific ("jazz:Dynamic-Parameter") 2328 21 2328 40 ("jazz:emit-binding-symbol" "jazz:emit-expression" "jazz:sourcified-form" "%%list" "parameter" "%%get-dynamic-parameter-class" "class" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:Optional-Parameter" define-class ("class runtime") 2341 27 2341 50 ()}
      {Lisp-Entry "jazz:new-optional-parameter" define #f 2344 9 2344 36 ("0" "jazz:Optional-Parameter" "jazz:allocate-optional-parameter" "default" "type" "name")}
      {Lisp-Entry "jazz:emit-parameter" generic/specific ("jazz:Optional-Parameter") 2348 21 2348 40 ("jazz:emit-expression" "jazz:sourcified-form" "jazz:emit-binding-symbol" "%%list" "parameter" "%%get-optional-parameter-default" "default" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:Named-Parameter" define-class ("class runtime") 2361 27 2361 47 ()}
      {Lisp-Entry "jazz:new-named-parameter" define #f 2364 9 2364 33 ("0" "jazz:Named-Parameter" "jazz:allocate-named-parameter" "default" "type" "name")}
      {Lisp-Entry "jazz:emit-parameter" generic/specific ("jazz:Named-Parameter") 2368 21 2368 40 ("jazz:emit-expression" "jazz:sourcified-form" "%%get-lexical-binding-name" "%%list" "parameter" "%%get-named-parameter-default" "default" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:emit-binding-symbol" generic/specific ("jazz:Named-Parameter") 2373 21 2373 45 ("parameter" "%%get-lexical-binding-name" "environment" "declaration")}
      {Lisp-Entry "jazz:Rest-Parameter" define-class ("class runtime") 2385 27 2385 46 ()}
      {Lisp-Entry "jazz:new-rest-parameter" define #f 2388 9 2388 32 ("0" "jazz:Rest-Parameter" "jazz:allocate-rest-parameter" "type" "name")}
      {Lisp-Entry "jazz:emit-parameter" generic/specific ("jazz:Rest-Parameter") 2392 21 2392 40 ("parameter" "jazz:emit-binding-symbol" "environment" "declaration")}
      {Lisp-Entry "jazz:Self-Binding" define-class ("class runtime") 2407 27 2407 44 ()}
      {Lisp-Entry "jazz:new-self-binding" define #f 2410 9 2410 30 ("self" "jazz:Self-Binding" "jazz:allocate-self-binding" "type")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Self-Binding") 2414 21 2414 48 ("%%get-declaration-parent" "self" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz:Dynamic-Self-Binding" define-class ("class runtime") 2429 27 2429 52 ()}
      {Lisp-Entry "jazz:new-dynamic-self-binding" define #f 2432 9 2432 38 ("self" "jazz:Dynamic-Self-Binding" "jazz:allocate-dynamic-self-binding" "code" "type")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Dynamic-Self-Binding") 2436 21 2436 48 ("%%get-declaration-parent" "declaration" "%%get-dynamic-self-binding-code" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz:*self*" define #f 2451 8 2451 19 ("make-parameter")}
      {Lisp-Entry "jazz:Local-Variable-Binding" define-class ("class runtime") 2460 27 2460 54 ()}
      {Lisp-Entry "jazz:new-local-variable-binding" define #f 2463 9 2463 40 ("jazz:Local-Variable-Binding" "jazz:allocate-local-variable-binding" "variable" "type")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Local-Variable-Binding") 2467 21 2467 48 ("jazz:Any" "declaration" "%%get-local-variable-binding-variable" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz:Macro-Symbol" define-class ("class runtime") 2482 27 2482 44 ()}
      {Lisp-Entry "jazz:new-macro-symbol" define #f 2485 9 2485 30 ("jazz:Macro-Symbol" "jazz:allocate-macro-symbol" "setter" "getter" "name")}
      {Lisp-Entry "jazz:Form-Binding" define-class ("class runtime") 2514 27 2514 44 ()}
      {Lisp-Entry "jazz:special-forms" define #f 2525 8 2525 26 ()}
      {Lisp-Entry "jazz:add-special-form" define #f 2529 9 2529 30 ("%%cons" "jazz:special-forms" "set!" "special-form" "symbol")}
      {Lisp-Entry "jazz:find-special-form" define #f 2533 9 2533 31 ("symbol")}
      {Lisp-Entry "jazz:Special-Form" define-class ("class runtime") 2540 27 2540 44 ()}
      {Lisp-Entry "jazz:new-special-form" define #f 2543 9 2543 30 ("jazz:Special-Form" "jazz:allocate-special-form" "walk" "name")}
      {Lisp-Entry "jazz:walk-binding-walkable?" generic/specific ("jazz:Special-Form") 2547 21 2547 48 ()}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Special-Form") 2551 21 2551 48 ("binding" "%%get-lexical-binding-name" "environment" "source-declaration")}
      {Lisp-Entry "jazz:walk-binding-walk-form" generic/specific ("jazz:Special-Form") 2555 21 2555 48 ("jazz:find-special-form" "%%symbol?" "if" "walk" "binding" "%%get-special-form-walk" "walk-proc/symbol" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Macro-Form" define-class ("class runtime") 2572 27 2572 42 ()}
      {Lisp-Entry "jazz:new-macro-form" define #f 2575 9 2575 28 ("jazz:Macro-Form" "jazz:allocate-macro-form" "expander" "name")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Macro-Form") 2579 21 2579 50 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Macro-Form") 2583 21 2583 50 ("%%cdr" "apply" "binding" "%%get-macro-form-expander" "expander" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Syntax-Form" define-class ("class runtime") 2597 27 2597 43 ()}
      {Lisp-Entry "jazz:new-syntax-form" define #f 2600 9 2600 29 ("jazz:Syntax-Form" "jazz:allocate-syntax-form" "expander" "name")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Syntax-Form") 2604 21 2604 50 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Syntax-Form") 2608 21 2608 50 ("binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Define-Syntax-Form" define-class ("class runtime") 2621 27 2621 50 ()}
      {Lisp-Entry "jazz:new-define-syntax-form" define #f 2624 9 2624 36 ("jazz:Define-Syntax-Form" "jazz:allocate-define-syntax-form" "environment" "expander" "name")}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Define-Syntax-Form") 2628 21 2628 50 ("%%get-define-syntax-form-environment" "macro-environment" "binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Define-Local-Syntax-Form" define-class ("class runtime") 2642 27 2642 56 ()}
      {Lisp-Entry "jazz:new-define-local-syntax-form" define #f 2645 9 2645 42 ("jazz:Define-Local-Syntax-Form" "jazz:allocate-define-local-syntax-form" "environment" "expander" "name")}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Define-Local-Syntax-Form") 2649 21 2649 50 ("%%get-define-local-syntax-form-environment" "macro-environment" "binding" "%%get-syntax-form-expander" "expander" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Syntactic-Closure" define-class ("class runtime") 2663 27 2663 49 ()}
      {Lisp-Entry "syntactic-closure?" define #f 2666 9 2666 27 ("jazz:Syntactic-Closure" "%%class-is?" "x")}
      {Lisp-Entry "make-syntactic-closure" define #f 2670 9 2670 31 ("jazz:Syntactic-Closure" "jazz:allocate-syntactic-closure" "%%source-code" "%%source?" "and" "%%pair?" "%%symbol?" "or" "if" "form" "vars" "env")}
      {Lisp-Entry "syntactic-closure-form" define #f 2679 9 2679 31 ("%%get-syntactic-closure-form" "sc")}
      {Lisp-Entry "unwrap-syntactic-closure" define #f 2683 9 2683 33 ("else" "%%source-code" "%%source?" "%%get-syntactic-closure-form" "unwrap-syntactic-closure" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "strip-syntactic-closures" define #f 2691 9 2691 33 ("else" "%%vector->list" "%%list->vector" "%%vector?" "%%cdr" "%%car" "cons" "%%pair?" "%%source-code" "%%source?" "%%get-syntactic-closure-form" "strip-syntactic-closures" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "strip-source-info" define #f 2704 9 2704 26 ("else" "%%vector->list" "%%list->vector" "%%vector?" "%%cdr" "%%car" "cons" "%%pair?" "%%source-code" "strip-source-info" "%%source?" "cond" "x")}
      {Lisp-Entry "identifier?" define #f 2714 9 2714 20 ("symbol?" "else" "%%source-code" "%%source?" "syntactic-closure-form" "identifier?" "syntactic-closure?" "cond" "x")}
      {Lisp-Entry "identifier=?" define #f 2721 9 2721 21 ("not" "and" "y^" "unwrap-syntactic-closure" "x^" "let" "eq?" "or" "%%get-lexical-binding-name" "jazz:Lexical-Binding" "%%class-is?" "binding-name" "jazz:walk-binding-lookup" "binding" "lambda" "jazz:find-in" "jazz:composite-reference?" "if" "environment" "symbol" "lookup-identifier" "define" "y" "y-env" "x" "x-env")}
      {Lisp-Entry "sc-macro-transformer" define #f 2743 8 2743 28 ("make-syntactic-closure" "mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "rsc-macro-transformer" define #f 2749 8 2749 29 ("mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "er-macro-transformer" define #f 2755 8 2755 28 ("identifier=?" "y" "x" "compare" "cons" "set!" "make-syntactic-closure" "name" "else" "cdr" "=>" "assq" "cond" "identifier" "renames" "rename" "let" "mac-env" "use-env" "expr" "f" "lambda")}
      {Lisp-Entry "jazz:Annotated-Variable" define-class ("class runtime") 2779 27 2779 50 ()}
      {Lisp-Entry "jazz:new-annotated-variable" define #f 2782 9 2782 36 ("jazz:Annotated-Variable" "jazz:allocate-annotated-variable" "type" "declared-type" "variable")}
      {Lisp-Entry "jazz:Restricted-Binding" define-class ("class runtime") 2794 27 2794 50 ()}
      {Lisp-Entry "jazz:new-restricted-binding" define #f 2797 9 2797 36 ("jazz:Restricted-Binding" "jazz:allocate-restricted-binding" "type" "binding")}
      {Lisp-Entry "jazz:Annotated-Frame" define-class ("class runtime") 2809 27 2809 47 ()}
      {Lisp-Entry "jazz:new-annotated-frame" define #f 2812 9 2812 33 ("jazz:Annotated-Frame" "jazz:allocate-annotated-frame" "reset" "variables")}
      {Lisp-Entry "jazz:inspect-annotated-variable" define #f 2820 9 2820 40 ("%%get-annotated-variable-type" "%%get-annotated-variable-variable" ":variable" "%%get-restricted-binding-type" "%%get-restricted-binding-binding" "%%get-lexical-binding-name" ":restricted" "jazz:Restricted-Binding" "%%class-is?" "if" "jazz:object->serial-symbol" "serial" "let" "variable")}
      {Lisp-Entry "jazz:inspect-annotated-frame" define #f 2831 9 2831 37 ("%%get-annotated-frame-variables" "jazz:inspect-annotated-variable" "map" ":frame" "frame")}
      {Lisp-Entry "jazz:inspect-annotated-environment" define #f 2836 9 2836 43 ("jazz:inspect-annotated-frame" "map" ":environment" "environment")}
      {Lisp-Entry "jazz:Code" define-class ("class runtime") 2846 27 2846 36 ()}
      {Lisp-Entry "jazz:new-code" define #f 2849 9 2849 22 ("jazz:Code" "jazz:allocate-code" "source" "type" "form")}
      {Lisp-Entry "jazz:codes-forms" define #f 2856 9 2856 25 ("jazz:sourcified-form" "code" "lambda" "map" "codes")}
      {Lisp-Entry "jazz:codes-types" define #f 2862 9 2862 25 ("%%get-code-type" "code" "lambda" "map" "codes")}
      {Lisp-Entry "jazz:sourcify-code" define #f 2869 9 2869 27 ("%%get-code-type" "%%get-code-form" "jazz:new-code" "%%source?" "%%not" "or" "if" "src" "code")}
      {Lisp-Entry "jazz:sourcified-form" define #f 2878 9 2878 29 ("jazz:sourcify-if" "%%get-code-source" "src" "%%get-code-form" "form" "let" "code")}
      {Lisp-Entry "jazz:sourcified-form2" define #f 2885 9 2885 30 ("jazz:sourcify-if" "%%get-code-form" "form" "let" "src" "code")}
      {Lisp-Entry "jazz:annotate-signature" define #f 2895 9 2895 32 ("jazz:queue-list" "%%when" "for-each" "jazz:new-annotated-variable" "jazz:enqueue" "jazz:Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "parameter" "annotate" "define" "jazz:new-queue" "queue" "%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "let" "signature")}
      {Lisp-Entry "jazz:annotate-inlined-signature" define #f 2914 9 2914 40 ("jazz:queue-list" "jazz:new-annotated-variable" "jazz:enqueue" "%%get-code-type" "or" "type" "%%get-lexical-binding-type" "declared-type" "argument" "parameter" "lambda" "for-each" "jazz:new-queue" "queue" "%%get-signature-positional" "positional" "let" "arguments" "signature")}
      {Lisp-Entry "jazz:annotate-bindings" define #f 2926 9 2926 31 ("jazz:new-annotated-variable" "jazz:Void" "or" "type" "%%get-lexical-binding-type" "declared-type" "%%cdr" "value" "%%car" "variable" "let" "binding" "lambda" "map" "bindings")}
      {Lisp-Entry "jazz:annotate-receive" define #f 2936 9 2936 30 ("jazz:new-annotated-variable" "jazz:Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "let" "parameter" "lambda" "map" "parameters")}
      {Lisp-Entry "jazz:annotate-internal-defines" define #f 2944 9 2944 39 ("jazz:new-annotated-variable" "jazz:Any" "or" "type" "%%get-lexical-binding-type" "declared-type" "%%get-internal-define-variable" "variable" "let" "internal-define" "lambda" "map" "internal-defines")}
      {Lisp-Entry "jazz:with-annotated-frame" define #f 2953 9 2953 34 ("jazz:new-annotated-frame" "set!" "k" "lambda" "continuation-capture" "reset" "let" "proc" "variables")}
      {Lisp-Entry "jazz:find-annotated" define #f 2961 9 2961 28 ("%%get-annotated-variable-type" "%%get-annotated-variable-variable" "%%cdr" "set!" "%%not" "begin" "%%get-restricted-binding-type" "values" "%%eq?" "jazz:Declaration" "and" "%%get-restricted-binding-binding" "binding" "jazz:Restricted-Binding" "annotated-variable" "else" "list" "jazz:Variable" "%%get-annotated-frame-variables" "jazz:Annotated-Frame" "%%class-is?" "cond" "variables" "iter-variables" "or" "%%car" "annotated-frame" "%%null?" "if" "frames" "iter-frames" "type" "let" "environment" "variable")}
      {Lisp-Entry "jazz:find-annotated-type" define #f 2993 9 2993 33 ("%%get-lexical-binding-type" "info" "let" "jazz:find-annotated" "type" "variable" "frame" "receive" "jazz:Variable" "%%class-is?" "if" "environment" "binding")}
      {Lisp-Entry "jazz:extend-annotated-type" define #f 3006 9 3006 35 ("continuation-return" "%%get-annotated-frame-reset" "reset" "jazz:Any" "extended-type" "%%subtype?" "%%not" "%%when" "%%set-annotated-variable-type" "jazz:Void" "%%eq?" "if" "%%get-annotated-variable-type" "actual-type" "%%get-annotated-variable-declared-type" "declared-type" "let" "new-type" "variable" "frame")}
      {Lisp-Entry "jazz:extend-type" define #f 3029 9 3029 25 ("else" "%%subtype?" "jazz:Void" "%%eq?" "jazz:Any" "%%not" "or" "cond" "type2" "type1")}
      {Lisp-Entry "jazz:extend-types" define #f 3043 9 3043 26 ("%%cdr" "jazz:extend-types" "%%car" "jazz:extend-type" "jazz:Void" "%%null?" "if" "types")}
      {Lisp-Entry "jazz:type-union" define #f 3049 9 3049 24 ("jazz:new-union-type" "types")}
      {Lisp-Entry "jazz:type-difference" define #f 3053 9 3053 29 ("type2" "type1")}
      {Lisp-Entry "jazz:Walker" define-class ("class runtime") 3062 27 3062 38 ()}
      {Lisp-Entry "jazz:*raise-walk-problems?*" define #f 3070 8 3070 35 ("make-parameter")}
      {Lisp-Entry "jazz:walk-warning" define #f 3074 9 3074 26 ("jazz:new-walk-warning" "jazz:walker-warning" "jazz:format" "apply" "message" "jazz:source-locat" "jazz:walk-location" "location" "let" "rest" "fmt-string" "src" "declaration" "walker")}
      {Lisp-Entry "jazz:walk-error" define #f 3080 9 3080 24 ("jazz:new-walk-error" "jazz:walker-error" "jazz:format" "apply" "message" "jazz:source-locat" "jazz:walk-location" "location" "let" "rest" "fmt-string" "src" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-unresolved" define #f 3086 9 3086 29 ("jazz:source-code" "jazz:new-unresolved-error" "jazz:walker-error" "jazz:source-locat" "jazz:walk-location" "location" "let" "symbol-src" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walker-warning" define #f 3091 9 3091 28 ("%%list" "%%get-walker-warnings" "%%append" "%%set-walker-warnings" "jazz:warnings?" "raise" "jazz:*raise-walk-problems?*" "cond" "warning" "walker")}
      {Lisp-Entry "jazz:walker-error" define #f 3098 9 3098 26 ("jazz:validate-walk-problems" "jazz:unspecified" "continuation-return" "jazz:delay-reporting?" "and" "if" "%%list" "%%get-walker-errors" "%%append" "%%set-walker-errors" "else" "raise" "jazz:*raise-walk-problems?*" "cond" "error" "resume" "walker")}
      {Lisp-Entry "jazz:validate-walk-problems" define #f 3108 9 3108 36 ("jazz:new-walk-problems" "raise" "get-output-string" "message" "jazz:partition-walk-problems-unit" "jazz:partition-walk-problems-declaration" "jazz:present-exception" "problem" "1" "%%fx+" "%%substring" "%%fx=" "toplevel?" "declaration-locator" "%%symbol->string" "%%string-length" "-1" "%%not" "if" "prefix" "problems" "unit-locator" "jazz:bind" "partition" "lambda" "for-each" "jazz:format" "%%append" "all" "open-output-string" "output" "%%not-null?" "or" "%%when" "%%get-walker-errors" "errors" "%%get-walker-warnings" "warnings" "let" "walker")}
      {Lisp-Entry "jazz:partition-walk-problems-unit" define #f 3136 9 3136 42 ("assv" "%%get-walk-problem-location" "%%get-walk-location-unit-locator" "problem" "lambda" "jazz:partition" "problems")}
      {Lisp-Entry "jazz:partition-walk-problems-declaration" define #f 3143 9 3143 49 ("assoc" "%%get-walk-problem-location" "%%get-walk-location-declaration-locator" "%%symbol->string" "problem" "lambda" "jazz:partition" "problems")}
      {Lisp-Entry "jazz:parse-modifiers" define #f 3155 9 3155 29 ("%%cdar" "%%cons" "%%reverse" "values" "%%apply" "res" "lp" "modifiers" "let" "jazz:walk-error" "lambda" "=>" "%%eq?" "to" "from" "names" "get-modifier" "%%car" "jazz:source-code" "%%pair?" "and" "if" "ls" "skip-modifiers" "%%cdr" "else" "%%caar" "%%memq" "%%null?" "cond" "x" "is-modifier?" "define" "rest" "infos" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:parse-unit-declaration" define #f 3186 9 3186 36 ("jazz:new-unit-declaration" "jazz:error" "%%neq?" "jazz:requested-unit-name" "access" "name" "%%desourcify" "jazz:filter-features" "jazz:listify" "map" "append" "set!" "require" "%%eq?" "%%pair?" "and" "expr" "lambda" "for-each" "requires" "body" "collect-requires" "%%cdr" "%%cddr" "%%cadr" "public" "protected" "%%memq" "if" "%%car" "jazz:source-code" "first" "let" "proc" "rest" "parse" "define" "partial-form")}
      {Lisp-Entry "jazz:parse-module" define #f 3215 9 3215 26 ("%%symbol?" "%%assert" "%%cddr" "body" "%%cadr" "dialect-name" "name" "access" "receive" "%%cdr" "values" "public" "protected" "%%memq" "if" "%%car" "jazz:source-code" "first" "let" "rest" "parse-modifiers" "define" "partial-form")}
      {Lisp-Entry "jazz:parse-script" define #f 3233 9 3233 26 ("values" "%%cdr" "body" "%%car" "jazz:source-code" "dialect-name" "let" "partial-form")}
      {Lisp-Entry "jazz:parse-module-invoice" define #f 3240 9 3240 34 ("%%reverse" "values" "%%cdar" "begin" "%%caar" "%%eq?" "if" "%%cons" "set!" "%%not" "and" "%%while" "autoload" "only" "phase" "load" "version" "%%cdr" "scan" "%%car" "name" "let" "jazz:error" "%%pair?" "%%assertion" "specification")}
      {Lisp-Entry "jazz:parse-module-declaration" define #f 3280 9 3280 38 ("jazz:walk-module-declaration" "jazz:dialect-walker" "walker" "jazz:require-dialect" "dialect" "jazz:load-dialect-invoice" "dialect-invoice" "let*" "jazz:new-walk-context" "jazz:walk-context" "parameterize" "jazz:error" "%%neq?" "jazz:requested-unit-name" "and" "if" "jazz:parse-module" "body" "dialect-name" "access" "name" "receive" "partial-form")}
      {Lisp-Entry "jazz:walk-module-declaration" define #f 3291 9 3291 37 ("jazz:validate-walk-problems" "jazz:walker-environment" "%%cons" "jazz:walk-declarations" "%%set-module-declaration-walker" "jazz:add-module-import" "%%when" "jazz:new-module-declaration" "or" "declaration" "let" "body" "dialect-invoice" "dialect-name" "access" "name" "actual" "walker")}
      {Lisp-Entry "jazz:walk-module-export" define #f 3302 9 3302 32 ("jazz:new-autoload-reference" "jazz:new-export-reference" "symbol" "lambda" "map" "%%not" "if" "jazz:new-export-invoice" "jazz:new-module-reference" "module-reference" "let" "jazz:parse-module-invoice" "module-autoload" "module-only" "module-version" "module-phase" "module-load" "module-name" "receive" "export" "walker")}
      {Lisp-Entry "jazz:expand-module-source" define #f 3321 9 3321 34 ("jazz:walk-module" "jazz:emit-declaration" "partial-form")}
      {Lisp-Entry "jazz:expand-script-source" define #f 3325 9 3325 34 ("jazz:walk-script" "jazz:emit-declaration" "partial-form")}
      {Lisp-Entry "jazz:rename-identifier-conflicts" define #f 3329 9 3329 41 ("list" "or" "%%cdr" "symbol->string" "jazz:generate-symbol" "%%set-symbol-binding-gensym" "%%get-symbol-binding-gensym" "jazz:Variable" "not" "and" "eq?" "same?" "binding" "found?" "%%car" "ls" "lp2" "pair?" "e" "lp1" "let" "%%get-lexical-binding-name" "unwrap-syntactic-closure" "sym" "%%get-reference-binding" "var" "let*" "jazz:Binding-Reference" "%%is?" "cond" "child-seed" "env" "seed" "x" "lambda" "jazz:tree-fold-list" "environment" "expressions")}
      {Lisp-Entry "jazz:walk-module" define #f 3367 9 3367 25 ("%%set-namespace-declaration-body" "jazz:rename-identifier-conflicts" "jazz:validate-walk-problems" "jazz:walk-namespace" "jazz:walker-environment" "%%cons" "environment" "jazz:set-catalog-entry" "jazz:walk-module-declaration" "let" "lambda" "jazz:call-with-catalog-entry-lock" "declaration" "jazz:get-catalog-entry" "actual" "resume" "jazz:dialect-walker" "walker" "jazz:require-dialect" "dialect" "jazz:load-dialect-invoice" "dialect-invoice" "let*" "jazz:new-walk-context" "jazz:walk-context" "parameterize" "jazz:error" "%%neq?" "jazz:requested-unit-name" "and" "if" "jazz:parse-module" "body" "dialect-name" "access" "name" "receive" "partial-form")}
      {Lisp-Entry "jazz:walk-script" define #f 3390 9 3390 25 ("%%set-namespace-declaration-body" "jazz:rename-identifier-conflicts" "jazz:validate-walk-problems" "jazz:walk-namespace" "jazz:walker-environment" "%%cons" "environment" "public" "jazz:walk-module-declaration" "declaration" "resume" "jazz:dialect-walker" "walker" "jazz:require-dialect" "dialect" "jazz:load-dialect-invoice" "dialect-invoice" "let*" "jazz:new-walk-context" "jazz:walk-context" "parameterize" "jazz:parse-script" "body" "dialect-name" "receive" "script" "gensym" "name" "let" "partial-form")}
      {Lisp-Entry "jazz:cond-expand" define #f 3407 9 3407 25 ("begin" "else" "jazz:feature-satisfied?" "feature-requirement" "%%desourcify" "%%symbol?" "%%not" "or" "clause" "jazz:error" "%%null?" "%%cdr" "scan" "iter" "let" "cond-expand" "%%car" "%%eq?" "jazz:source-code" "%%pair?" "and" "if" "cont" "form-src")}
      {Lisp-Entry "jazz:walk-namespace" define #f 3427 9 3427 28 ("jazz:queue-list" "jazz:walk" "jazz:enqueue" "%%when" "expr?" "expr-src" "jazz:cond-expand" "continuation-capture" "form-src" "lambda" "for-each" "jazz:new-queue" "queue" "let" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:load-dialect-invoice" define #f 3440 9 3440 34 ("syntax" "jazz:outline-module" "jazz:new-import-invoice" "core" "%%eq?" "jazz:error" "%%symbol?" "%%not" "if" "dialect-name")}
      {Lisp-Entry "jazz:emit-module-inclusions" define #f 3453 9 3453 36 ("jazz:expand-referenced-declaration" "lambda" "map" "%%get-module-declaration-inclusions" "jazz:enqueue" "jazz:queue-list" "%%not" "%%when" "jazz:get-declaration-inclusions" "for-each" "declaration" "collect-declarations" "jazz:new-queue" "queue" "let" "%%cdr" "%%car" "%%get-lexical-binding-name" "%%eq?" "%%null?" "if" "lst" "name" "find-name" "define" "module-declaration")}
      {Lisp-Entry "jazz:emit-module-literals" define #f 3477 9 3477 34 ("%%get-module-declaration-walker-literals" "jazz:emit-expression" "jazz:sourcified-form" ",name" "define" "%%cdr" "value" "%%car" "name" "let" "info" "lambda" "map" "module-declaration")}
      {Lisp-Entry "jazz:emit-module-variables" define #f 3485 9 3485 35 ("%%get-module-declaration-walker-variables" "jazz:queue-list" ",value" ",symbol" "jazz:define-variable" "%%cdr" "value" "%%car" "symbol" "let" "variable" "lambda" "map" "module-declaration")}
      {Lisp-Entry "jazz:emit-module-autoloads" define #f 3493 9 3493 35 ("%%cadr" "%%symbol->string" "%%string<?" "y" "x" "jazz:queue-list" "jazz:sort" "%%get-module-declaration-walker-autoloads" "jazz:emit-binding-reference" "jazz:sourcified-form" "set!" "%%get-declaration-toplevel" "%%get-declaration-locator" "jazz:load-unit" "begin" "if" "loaded?" ",locator" "define" "jazz:enqueue" "%%table-set!" "%%table-ref" "%%not" "%%when" "jazz:autoload-locator" "locator" "jazz:resolve-binding" "referenced-declaration" "autoload-declaration" "lambda" "for-each" "eq?" "test:" "%%make-table" "locators" "jazz:new-queue" "queue" "let" "environment" "module-declaration")}
      {Lisp-Entry "jazz:emit-module-registration" define #f 3514 9 3514 38 ("%%car" "%%cons" "if" "jazz:runtime-export" "export" "jazz:Autoload-Declaration" "%%is?" "%%get-declaration-toplevel" "%%eq?" "or" "decl" "name" "jazz:public-access" "%%get-access-lookup" "jazz:iterate-table-safe" "%%get-module-declaration-walker" "walker" "%%symbol->string" "%%string<?" "y" "x" "jazz:queue-list" "jazz:sort" "%%get-module-declaration-exports" "%%get-module-invoice-name" "jazz:enqueue" "%%not" "and" "%%get-export-invoice-autoload" "autoload" "%%get-module-invoice-only" "only" "syntax" "%%get-module-invoice-phase" "%%neq?" "%%when" "module-invoice" "lambda" "for-each" "jazz:new-queue" "queue" "let" "%%get-declaration-access" "%%get-lexical-binding-name" "jazz:register-module" "environment" "declaration")}
      {Lisp-Entry "jazz:runtime-export" generic/specific ("jazz:Walker~virtual-runtime") 3538 30 3538 49 ("declaration")}
      {Lisp-Entry "jazz:runtime-export" generic/specific ("jazz:Walker") 3541 21 3541 40 ("else" "%%get-declaration-toplevel" "%%cons" "jazz:resolve-binding" "referenced-declaration" "let" "jazz:Autoload-Declaration" "%%get-declaration-locator" "jazz:Export-Declaration" "%%is?" "cond" "declaration")}
      {Lisp-Entry "jazz:walker-bindings" generic/specific ("jazz:Walker~virtual-runtime") 3557 30 3557 50 ()}
      {Lisp-Entry "jazz:walker-bindings" generic/specific ("jazz:Walker") 3560 21 3560 41 ("core" "jazz:get-dialect" "%%get-dialect-bindings")}
      {Lisp-Entry "jazz:walker-environment" generic/specific ("jazz:Walker~virtual-runtime") 3564 30 3564 53 ()}
      {Lisp-Entry "jazz:walker-environment" generic/specific ("jazz:Walker") 3567 21 3567 44 ("walker" "jazz:walker-bindings" "jazz:new-walk-frame" "%%list")}
      {Lisp-Entry "jazz:walk-declaration" generic/specific ("jazz:Walker~virtual-runtime") 3582 30 3582 51 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-declaration" generic/specific ("jazz:Walker") 3585 21 3585 42 ("else" "jazz:walk-define-local-syntax-declaration" "define-local-syntax" "jazz:walk-define-syntax-declaration" "define-syntax" "jazz:walk-syntax-declaration" "syntax" "jazz:walk-local-macro-declaration" "local-macro" "jazz:walk-macro-declaration" "macro" "jazz:walk-native-syntax-declaration" "native-syntax" "jazz:walk-native-declaration" "native" "jazz:walk-import-declaration" "import" "jazz:walk-export-declaration" "export" "walker" "jazz:walk-require-declaration" "require" "case" "%%car" "first" "let" "jazz:source-code" "%%pair?" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-declarations" define #f 3603 9 3603 31 ("jazz:walk-declaration" "jazz:source-code" "%%cdr" "jazz:begin-form?" "if" "jazz:expand-macros" "expansion" "let" "%%when" "expr?" "expr" "jazz:cond-expand" "continuation-capture" "form-src" "lambda" "for-each" "walk" "define" "forms" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:add-declaration-child" define #f 3620 9 3620 35 ("jazz:public-access" "private" "%%get-declaration-access" "%%neq?" "jazz:private-access" "%%get-access-lookup" "%%table-set!" "%%get-namespace-declaration-children" "jazz:enqueue" "jazz:find-child-declaration" "%%not" "%%when" "%%get-lexical-binding-name" "name" "let" "child" "namespace-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:require-declaration" define #f 3646 9 3646 33 ("jazz:error" "%%assertion" "jazz:find-declaration" "declaration" "let" "name" "namespace-declaration")}
      {Lisp-Entry "jazz:find-declaration" define #f 3652 9 3652 30 ("jazz:private-access" "%%get-access-lookup" "%%table-ref" "name" "namespace-declaration")}
      {Lisp-Entry "jazz:find-child-declaration" define #f 3656 9 3656 36 ("%%get-namespace-declaration-children" "jazz:queue-list" "%%get-lexical-binding-name" "%%eq?" "decl" "lambda" "jazz:find-if" "name" "namespace-declaration")}
      {Lisp-Entry "jazz:begin-form?" define #f 3662 9 3662 25 ("begin" "%%car" "%%eq?" "jazz:source-code" "%%pair?" "and" "form")}
      {Lisp-Entry "jazz:define-form?" define #f 3667 9 3667 26 ("define" "%%car" "%%eq?" "jazz:source-code" "%%pair?" "and" "form")}
      {Lisp-Entry "jazz:register-autoload-declaration" define #f 3677 9 3677 43 ("%%cons" "%%set-module-declaration-walker-autoloads" "%%memq" "%%not" "%%when" "%%get-module-declaration-walker-autoloads" "declarations" "let" "autoload-declaration" "module-declaration")}
      {Lisp-Entry "jazz:lookup-reference" define #f 3688 9 3688 30 ("jazz:walk-unresolved" "jazz:lookup-symbol" "or" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Expression" define-class ("class runtime") 3698 27 3698 42 ()}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Expression~virtual-runtime") 3701 30 3701 50 ("environment" "declaration")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Expression") 3704 21 3704 41 ("expression" "jazz:error" "environment" "declaration")}
      {Lisp-Entry "jazz:emit-call" generic/specific ("jazz:Expression~virtual-runtime") 3708 30 3708 44 ("environment" "declaration" "arguments")}
      {Lisp-Entry "jazz:emit-call" generic/specific ("jazz:Expression") 3711 21 3711 35 ("jazz:Any" "jazz:codes-forms" "expression" "jazz:emit-expression" "jazz:sourcified-form" "jazz:new-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Expression~virtual-runtime") 3718 30 3718 50 ("s" "k" "f")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Expression") 3721 21 3721 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:emit-expressions" define #f 3725 9 3725 30 ("jazz:emit-expression" "expression" "lambda" "map" "environment" "declaration" "expressions")}
      {Lisp-Entry "jazz:fold-expressions" define #f 3731 9 3731 30 ("%%cdr" "jazz:fold-expressions" "%%car" "jazz:fold-expression" "%%null?" "if" "seed" "s" "k" "f" "expressions")}
      {Lisp-Entry "jazz:tree-fold-list" define #f 3738 9 3738 28 ("car" "jazz:tree-fold" "cdr" "jazz:tree-fold-list" "null?" "if" "environment" "seed" "here" "up" "down" "ls")}
      {Lisp-Entry "jazz:Binding-Reference" define-class ("class runtime") 3752 27 3752 49 ()}
      {Lisp-Entry "jazz:new-binding-reference" define #f 3755 9 3755 35 ("jazz:Binding-Reference" "jazz:allocate-binding-reference" "binding" "symbol-src")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Binding-Reference") 3759 21 3759 41 ("%%get-expression-source" "expression" "%%get-reference-binding" "jazz:emit-binding-reference" "jazz:sourcify-code" "environment" "declaration")}
      {Lisp-Entry "jazz:emit-call" generic/specific ("jazz:Binding-Reference") 3764 21 3764 35 ("%%get-expression-source" "expression" "%%get-reference-binding" "jazz:emit-binding-call" "jazz:sourcify-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Binding-Reference") 3769 21 3769 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Reference-Reification" define-class ("class runtime") 3781 27 3781 53 ()}
      {Lisp-Entry "jazz:new-reference-reification" define #f 3784 9 3784 39 ("jazz:Reference-Reification" "jazz:allocate-reference-reification" "resolver" "reference" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Reference-Reification") 3788 21 3788 41 ("jazz:Any" ",serialization" "jazz:emit-expression" "%%get-code-form" "jazz:new-runtime-reference" "jazz:new-code" "serialization" "jazz:Binding-Reference" "%%assert" "%%get-lambda-body" "%%get-body-expressions" "%%get-reference-reification-resolver" "resolver" "%%cdr" "%%table-ref" "jazz:public-access" "%%get-access-lookup" "imported" "%%get-module-invoice-module" "imported-module-declaration" "%%car" "module-invoice" "%%null?" "%%get-module-declaration-imports" "scan" "iter" "symbol" ",import" "find-import" "import" "%%get-lexical-binding-name" "%%get-declaration-locator" "module-private" "%%eq?" "jazz:Declaration" "%%is?" "%%get-reference-binding" "binding" "%%get-declaration-toplevel" "module" ",name" ",module-name" "module-public" "jazz:break-reference" "name" "module-name" "receive" "jazz:composite-reference?" "if" "expression" "%%get-reference-reification-reference" "reified-reference" "let" "reference" "determine-serialization" "define" "environment" "declaration")}
      {Lisp-Entry "jazz:Body" define-class ("class runtime") 3837 27 3837 36 ()}
      {Lisp-Entry "jazz:new-body" define #f 3840 9 3840 22 ("jazz:Body" "jazz:allocate-body" "expressions" "internal-defines")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Body") 3844 21 3844 41 ("jazz:Any" "jazz:emit-expressions" "jazz:codes-forms" "%%append" "jazz:new-code" "%%cons" "augmented-environment" "frame" "lambda" "jazz:annotate-internal-defines" "jazz:with-annotated-frame" "%%get-body-expressions" "expressions" "expression" "%%get-body-internal-defines" "internal-defines" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Body") 3857 21 3857 41 ("%%get-body-expressions" "%%get-body-internal-defines" "jazz:fold-statements" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Body") 3863 21 3863 35 ("%%get-body-internal-defines" "%%get-body-expressions" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Internal-Define" define-class ("class runtime") 3884 27 3884 47 ()}
      {Lisp-Entry "jazz:new-internal-define" define #f 3887 9 3887 33 ("jazz:Internal-Define" "jazz:allocate-internal-define" "value" "variable")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Internal-Define") 3891 21 3891 41 ("jazz:Any" "jazz:emit-expression" "jazz:sourcified-form" "jazz:emit-binding-symbol" "define" "jazz:new-code" "%%get-internal-define-value" "value" "expression" "%%get-internal-define-variable" "variable" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Internal-Define") 3901 21 3901 41 ("%%get-internal-define-value" "jazz:fold-statement" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Internal-Define") 3907 21 3907 35 ("%%get-internal-define-value" "jazz:tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Begin" define-class ("class runtime") 3925 27 3925 37 ()}
      {Lisp-Entry "jazz:new-begin" define #f 3928 9 3928 23 ("jazz:Begin" "jazz:allocate-begin" "expressions" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Begin") 3932 21 3932 41 ("%%get-expression-source" "%%get-code-type" "jazz:sourcified-form" "begin" "jazz:new-code" "jazz:emit-statements-code" "code" "expression" "%%get-begin-expressions" "expressions" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Begin") 3941 21 3941 41 ("%%get-begin-expressions" "jazz:fold-statements" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Begin") 3946 21 3946 35 ("%%get-begin-expressions" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:emit-specialized-call" define-macro ("variable") 3964 22 3964 48 ()}
      {Lisp-Entry "jazz:emit-primitive-new-call" define-macro ("variable") 3965 22 3965 50 ()}
      {Lisp-Entry "jazz:emit-primitive-call" define-macro ("variable") 3966 22 3966 46 ()}
      {Lisp-Entry "jazz:emit-inlined-call" define-macro ("variable") 3967 22 3967 44 ()}
      {Lisp-Entry "jazz:Call" define-class ("class runtime") 3970 27 3970 36 ()}
      {Lisp-Entry "jazz:new-call" define #f 3973 9 3973 22 ("jazz:Call" "jazz:allocate-call" "arguments" "operator" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Call") 3977 21 3977 41 ("%%get-expression-source" "jazz:emit-call" "jazz:emit-inlined-call" "jazz:emit-primitive-call" "jazz:emit-primitive-new-call" "jazz:emit-specialized-call" "or" "jazz:sourcify-code" "jazz:emit-expressions" "arguments-codes" "%%get-declaration-locator" "jazz:Declaration" "%%get-reference-binding" "binding" "jazz:Binding-Reference" "%%class-is?" "if" "locator" "%%get-call-arguments" "arguments" "expression" "%%get-call-operator" "operator" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Call") 3996 21 3996 41 ("%%get-call-arguments" "jazz:fold-expressions" "%%get-call-operator" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Call") 4002 21 4002 35 ("%%get-call-arguments" "%%get-call-operator" "cons" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Constant" define-class ("class runtime") 4021 27 4021 40 ()}
      {Lisp-Entry "jazz:new-constant" define #f 4024 9 4024 26 ("jazz:Constant" "jazz:allocate-constant" "type" "expansion")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Constant") 4028 21 4028 41 ("%%get-expression-type" "expression" "%%get-constant-expansion" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Constant") 4035 21 4035 41 ("%%get-constant-expansion" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Assignment" define-class ("class runtime") 4049 27 4049 42 ()}
      {Lisp-Entry "jazz:new-assignment" define #f 4052 9 4052 28 ("jazz:Assignment" "jazz:allocate-assignment" "value" "binding")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Assignment") 4056 21 4056 41 ("%%get-assignment-value" "expression" "%%get-assignment-binding" "jazz:emit-binding-assignment" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Assignment") 4060 21 4060 41 ("%%get-assignment-value" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Assignment") 4066 21 4066 35 ("%%get-assignment-value" "jazz:tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Walk-Failed-Special" define-class ("class runtime") 4081 27 4081 51 ()}
      {Lisp-Entry "jazz:new-walk-failed-special" define #f 4084 9 4084 37 ("jazz:Walk-Failed-Special" "jazz:allocate-walk-failed" "answer")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Walk-Failed-Special") 4088 21 4088 41 ("jazz:Boolean" "jazz:new-code" "expression" "%%get-walk-failed-special-answer" "answer" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Walk-Failed-Special") 4096 21 4096 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Analysis-Data" define-class ("class runtime") 4108 27 4108 45 ()}
      {Lisp-Entry "jazz:new-analysis-data" define #f 4111 9 4111 31 ("jazz:Analysis-Data" "jazz:allocate-analysis-data")}
      {Lisp-Entry "jazz:get-analysis-data" define #f 4118 9 4118 31 ("%%table-set!" "jazz:new-analysis-data" "data" "let" "jazz:analysis-data" "%%table-ref" "or" "locator")}
      {Lisp-Entry "jazz:emit-namespace-statements" define #f 4130 9 4130 39 ("jazz:queue-list" "jazz:sourcified-form" "jazz:emit-expression" "code" "jazz:emit-declaration" "jazz:enqueue" "jazz:Declaration" "%%class-is?" "if" "statement" "lambda" "for-each" "jazz:new-queue" "queue" "let" "environment" "declaration" "statements")}
      {Lisp-Entry "jazz:emit-statements-code" define #f 4142 9 4142 34 ("jazz:new-code" "jazz:sourcified-form" "%%get-code-type" "set!" "jazz:emit-expression" "code" "jazz:emit-declaration" "jazz:Declaration" "%%class-is?" "if" "statement" "lambda" "map" "emited" "last-type" "let" "environment" "declaration" "statements")}
      {Lisp-Entry "jazz:fold-statement" define #f 4155 9 4155 28 ("jazz:fold-expression" "jazz:fold-declaration" "jazz:Declaration" "%%class-is?" "if" "s" "k" "f" "statement")}
      {Lisp-Entry "jazz:fold-statements" define #f 4161 9 4161 29 ("%%cdr" "jazz:fold-statements" "%%car" "jazz:fold-statement" "%%null?" "if" "seed" "s" "k" "f" "statements")}
      {Lisp-Entry "jazz:walk" define #f 4173 9 4173 18 ("jazz:walk-constant" "else" "%%get-syntactic-closure-form" "%%get-syntactic-closure-environment" "append" "jazz:walk" "syntactic-closure?" "jazz:walk-form" "%%pair?" "jazz:walk-symbol" "identifier?" "cond" "jazz:source-code" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-list" define #f 4185 9 4185 23 ("jazz:queue-list" "jazz:walk" "jazz:enqueue" "continuation-capture" "form" "lambda" "for-each" "jazz:new-queue" "queue" "let" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-body" define #f 4195 9 4195 23 ("jazz:queue-list" "map" "jazz:enqueue" "jazz:new-variable" "%%symbol?" "signature" "jazz:walk-error" "%%pair?" "%%assertion" "%%desourcify" "internal-body" "internal-define" "augmented-environment" "jazz:new-queue" "variables" "jazz:walk-list" "jazz:new-body" "%%car" "%%eq?" "%%null?" "or" "scan" "iter" "expressions" "else" "defines" "%%cons" "jazz:define-form?" "jazz:error" "%%neq?" "set!" "%%not" "substate" "sub" "lambda" "for-each" "state" "jazz:begin-form?" "cond" "form" "process" "internal-defines" "jazz:walk" "jazz:new-internal-define" "jazz:Any" "jazz:walk-specifier" "if" "type" "let" "jazz:source-code" "%%cdr" "jazz:parse-define" "parameters" "value" "specifier" "name" "receive" "variable" "form-src" "walk-internal-define" "define" "form-list" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:parse-define" define #f 4245 9 4245 26 (",@body" ",@specifier-list" ",parameters" "%%list" "specifier-list" "body" "%%desourcify" "parameters" "values" "specifier" "lambda" "%%cdr" "jazz:parse-specifier" "name" "let" "%%car" "jazz:source-code" "%%symbol?" "if" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-quote" define #f 4264 9 4264 24 ("jazz:walk-constant" "jazz:Null" "quote" "jazz:new-constant" "%%null?" "if" "%%cadr" "expression" "strip-syntactic-closures" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-keyword" define #f 4272 9 4272 26 ("jazz:Keyword" "jazz:new-constant" "keyword" "walker")}
      {Lisp-Entry "jazz:walk-enumerator" define #f 4276 9 4276 29 ("jazz:Symbol" "quote" "%%list" "jazz:new-constant" "enumerator" "walker")}
      {Lisp-Entry "jazz:walk-constant" define #f 4280 9 4280 27 ("jazz:walk-literal/constant" "else" "jazz:Pair" "jazz:scheme-pair-literal?" "jazz:Any" "#!void" "#!rest" "#!key" "#!optional" "%%eq?" "%%box?" "or" "jazz:Null" "%%null?" "jazz:Values" "%%values?" "jazz:F64Vector" "%%f64vector?" "jazz:F32Vector" "%%f32vector?" "jazz:U64Vector" "%%u64vector?" "jazz:S64Vector" "%%s64vector?" "jazz:U32Vector" "%%u32vector?" "jazz:S32Vector" "%%s32vector?" "jazz:U16Vector" "%%u16vector?" "jazz:S16Vector" "%%s16vector?" "jazz:U8Vector" "%%u8vector?" "jazz:S8Vector" "%%s8vector?" "jazz:Vector" "%%vector?" "jazz:Symbol" ",form-src" "quote" "%%symbol?" "jazz:Number" "%%number?" "jazz:Flonum" "%%flonum?" "jazz:Fixnum" "%%fixnum?" "jazz:Keyword" "%%keyword?" "jazz:String" "%%string?" "jazz:Char" "%%char?" "jazz:Boolean" "jazz:new-constant" "%%boolean?" "cond" "jazz:source-code" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:scheme-pair-literal?" define #f 4336 9 4336 34 ("%%cdr" "%%car" "%%pair?" "and" "%%vector?" "%%symbol?" "%%number?" "%%keyword?" "%%string?" "%%char?" "%%boolean?" "%%null?" "or" "expr" "scheme-data?" "define" "form")}
      {Lisp-Entry "jazz:walk-literal/constant" define #f 4358 9 4358 35 ("jazz:lookup-reference" "jazz:new-constant" "jazz:identifier-name" "jazz:reference-name" "jazz:composite-reference?" "jazz:class-of" "%%get-category-identifier" "if" "literal-type" "%%set-cdr!" "%%get-module-declaration-walker-literals" "%%set-module-declaration-walker-literals" "info" "jazz:generate-global-symbol" "locator" "jazz:walk-error" "else" "%%cdr" "cons" "%%pair?" ",arg" "quote" "arg" "lambda" "map" ",constructor-reference" "%%desourcify" "jazz:require-literal-constructor" "%%car" "constructor-reference" "%%get-literal-arguments" "arguments" "%%get-literal-name" "name" "cond" "jazz:walk" "jazz:walker-environment" "%%cons" "walk-literal/constant" "define" "jazz:Literal" "%%is?" "literal?" "%%get-declaration-toplevel" "module-declaration" "let" "literal/constant" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:make-symbolic-chars" define #f 4393 9 4393 33 ("eq?" "test:" "%%cdr" "integer->char" "%%car" "%%cons" "pair" "lambda" "map" "%%list->table" "alist")}
      {Lisp-Entry "jazz:Symbolic-Chars" define #f 4401 8 4401 27 ("#xA9" "copyright" "#x7F" "delete" "#x7D" "close-brace" "#x7B" "open-brace" "#x60" "backquote" "#x5F" "underscore" "#x5E" "exponential" "#x5D" "close-bracket" "#x5C" "backslash" "#x5B" "open-bracket" "#x40" "at" "#x3F" "question-mark" "#x3B" "semi-colon" "#x3A" "colon" "#x2F" "slash" "#x2E" "period" "#x2D" "minus" "#x2C" "comma" "#x2B" "plus" "#x2A" "times" "#x29" "close-parenthesis" "#x28" "open-parenthesis" "#x27" "quote" "#x26" "ampersand" "#x23" "sharp" "#x22" "double-quote" "#x21" "exclamation-point" "#x20" "space" "#x1F" "down-arrow" "#x1E" "up-arrow" "#x1D" "right-arrow" "#x1C" "left-arrow" "#x1B" "escape" "#x0D" "return" "#x0C" "page-down" "#x0B" "page-up" "#x0A" "linefeed" "#x09" "tab" "#x08" "backspace" "#x05" "info" "#x04" "end" "#x03" "enter" "#x01" "home" "#x00" "zero" "jazz:make-symbolic-chars")}
      {Lisp-Entry "jazz:symbolic-char" define #f 4449 9 4449 27 ("jazz:Symbolic-Chars" "%%table-ref" "name")}
      {Lisp-Entry "jazz:register-variable" define #f 4458 9 4458 31 ("%%get-module-declaration-walker-variables" "jazz:enqueue" "%%cons" "variable" "jazz:generate-global-symbol" "symbol" "%%get-declaration-toplevel" "module-declaration" "let" "value" "suffix" "declaration")}
      {Lisp-Entry "jazz:walk-symbol" generic/specific ("jazz:Walker~virtual-runtime") 4471 30 4471 46 ("symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-symbol" generic/specific ("jazz:Walker") 4474 21 4474 37 ("jazz:walk-symbol-reference" "else" "walker" "jazz:walk-enumerator" "jazz:enumerator?" "cond" "jazz:source-code" "symbol" "let" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-setbang" define #f 4482 9 4482 26 ("jazz:walk-symbol-assignment" "%%symbol?" "%%cddr" "%%car" "value" "%%cadr" "variable" "let" "%%desourcify" "jazz:walk-error" "3" "jazz:source-code" "%%length" "%%fx=" "%%not" "if" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:special-form-name?" define #f 4492 9 4492 32 ("cdr" "jazz:special-form-name?" "jazz:Special-Form" "%%class-is?" "jazz:object?" "car" "jazz:walk-binding-lookup" "binding" "let" "or" "eq?" "not" "pair?" "and" "end" "ls" "symbol")}
      {Lisp-Entry "jazz:lookup-symbol" define #f 4502 9 4502 27 ("jazz:lookup-analyse" "jazz:analysis-mode?" "jazz:register-autoload-declaration" "module" "jazz:Declaration" "%%class-is?" "jazz:source-code" "syntactic-closure-form" "%%get-syntactic-closure-environment" "syntactic-closure?" "jazz:walk-warning" "%%get-declaration-locator" "referenced-locator" "deprecated" "%%get-declaration-compatibility" "%%eq?" "referenced-declaration" "validate-compatibility" "%%cdr" "%%car" "jazz:walk-binding-lookup" "or" "%%pair?" "and" "env" "lp" "unwrap-syntactic-closure" "raw-symbol" "jazz:composite-reference?" "lookup" "jazz:walk-error" "jazz:new-module-reference" "%%get-declaration-toplevel" "jazz:new-autoload-declaration" "jazz:Autoload-Declaration" "%%is?" "if" "jazz:public-access" "jazz:lookup-declaration" "decl" "jazz:outline-module" "exported-module-reference" "let" "jazz:break-reference" "name" "module-name" "receive" "symbol" "lookup-composite" "define" "symbol-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:lookup-analyse" generic/specific ("jazz:Walker~virtual-runtime") 4543 30 4543 49 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "jazz:lookup-analyse" generic/specific ("jazz:Walker") 4546 21 4546 40 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "jazz:walk-symbol-reference" define #f 4555 9 4555 35 ("jazz:walk-free-reference" "jazz:new-binding-reference" "jazz:walk-binding-referenced" "jazz:Variable" "%%class-is?" "begin" "if" "jazz:lookup-symbol" "binding" "let" "symbol-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-free-reference" generic/specific ("jazz:Walker~virtual-runtime") 4565 30 4565 54 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-free-reference" generic/specific ("jazz:Walker") 4568 21 4568 45 ("walker" "jazz:walk-unresolved" "symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-symbol-assignment" generic/specific ("jazz:Walker~virtual-runtime") 4577 30 4577 57 ("value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-symbol-assignment" generic/specific ("jazz:Walker") 4580 21 4580 48 ("jazz:walk-free-assignment" "jazz:walk" "jazz:new-assignment" "jazz:walk-binding-validate-assignment" "begin" "if" "walker" "jazz:lookup-symbol" "binding" "let" "value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-free-assignment" generic/specific ("jazz:Walker~virtual-runtime") 4589 30 4589 55 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-free-assignment" generic/specific ("jazz:Walker") 4592 21 4592 46 ("walker" "jazz:walk-unresolved" "symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-form" generic/specific ("jazz:Walker~virtual-runtime") 4601 30 4601 44 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-form" generic/specific ("jazz:Walker") 4604 21 4604 35 ("jazz:walk-call" "jazz:walk" "jazz:walk-binding-expand-form" "expansion" "jazz:walk-binding-expandable?" "jazz:walk-binding-walk-form" "jazz:walk-binding-walkable?" "if" "else" "and" "%%get-reference-binding" "ref" "jazz:Binding-Reference" "jazz:Declaration" "jazz:Special-Form" "%%class-is?" "or" "walker" "jazz:lookup-symbol" "identifier?" "cond" "binding" "%%car" "jazz:source-code" "procedure-expr" "let" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:expand-macros" define #f 4635 9 4635 27 ("jazz:expand-macros" "jazz:walk-binding-expand-form" "expansion" "%%symbol?" "%%car" "procedure-expr" "jazz:source-code" "%%pair?" "%%not" "jazz:walk-binding-expandable?" "and" "if" "jazz:lookup-symbol" "binding" "let" "symbol" "lookup-macro-form" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-call" define #f 4657 9 4657 23 ("jazz:walk-list" "jazz:walk" "lambda" "continuation-capture" "jazz:new-call" "jazz:desourcify-all" "jazz:walk-binding-validate-call" "if" "%%cdr" "arguments" "jazz:source-code" "%%car" "operator" "let" "form-src" "procedure-binding" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:validate-arguments" generic/specific ("jazz:Walker~virtual-runtime") 4669 30 4669 53 ("form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "jazz:validate-arguments" generic/specific ("jazz:Walker") 4672 21 4672 44 ("%%fx<" "walker" "jazz:walk-error" "%%fx>" "%%not" "and" "cond" "%%get-signature-named" "%%get-signature-optional" "%%not-null?" "or" "rest?" "%%get-lexical-binding-name" "name" "%%length" "passed" "%%get-signature-rest" "rest" "%%get-signature-mandatory" "mandatory" "let" "form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "jazz:walk-require-declaration" define #f 4692 9 4692 38 ("jazz:listify" "jazz:add-module-require" "require" "lambda" "jazz:load-unit" "for-each" "eval" "jazz:walk-for" "%%eq?" "%%when" "%%cdr" "jazz:filter-features" "requires" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-require" define #f 4704 9 4704 26 ("jazz:new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-export-declaration" define #f 4713 9 4713 37 ("jazz:add-module-export" "export-invoice" "for-each" "jazz:filter-features" "export-invoices" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "jazz:walk-module-export" "export" "%%cdr" "jazz:new-export-reference" "symbol" "lambda" "map" "jazz:new-export-invoice" "%%list" "if" "%%append" "module-exports" "%%assq" "symbols-exports" "assv" "symbol?" "jazz:partition" "partition" "let" "exports" "walk-exports" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-export" define #f 4735 9 4735 25 ("jazz:new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-import-declaration" define #f 4744 9 4744 37 ("jazz:add-module-import" "%%get-lexical-binding-name" "jazz:load-unit" "%%get-module-invoice-module" "import-invoice" "for-each" "eval" "jazz:walk-for" "%%eq?" "%%when" "%%cdr" "jazz:filter-features" "import-invoices" "%%get-declaration-toplevel" "module-declaration" "%%desourcify" "form" "let" "jazz:listify" "imports" "walk-imports" "jazz:new-export-reference" "symbol" "lambda" "map" "%%not" "if" "jazz:new-import-invoice" "jazz:parse-module-invoice" "module-autoload" "module-only" "module-version" "module-phase" "module-load" "module-name" "receive" "jazz:walk-unresolved" "error?:" "jazz:outline-module" "or" "name" "jazz:lookup-module" "import" "jazz:walk-module-import" "define" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-import" define #f 4780 9 4780 25 ("jazz:new-begin" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:native-modifiers" define #f 4789 8 4789 29 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "jazz:native-keywords" define #f 4793 8 4793 28 ()}
      {Lisp-Entry "jazz:parse-native" define #f 4797 9 4797 26 ("values" "%%null?" "%%assert" "specifier" "lambda" "%%cdr" "jazz:parse-specifier" "%%car" "name" "let" "jazz:native-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-native-declaration" define #f 4806 9 4806 37 ("jazz:add-declaration-child" "effective-declaration" "jazz:new-export-declaration" "jazz:find-child-declaration" "or" "new-declaration" "jazz:Any" "jazz:walk-specifier" "if" "type" "jazz:parse-exported-symbol" "symbol" "%%cdr" "jazz:parse-native" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-native" define #f 4817 9 4817 25 ("jazz:require-declaration" "jazz:parse-exported-symbol" "symbol" "%%cdr" "jazz:parse-native" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:native-syntax-modifiers" define #f 4829 8 4829 36 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "jazz:native-syntax-keywords" define #f 4833 8 4833 35 ()}
      {Lisp-Entry "jazz:parse-native-syntax" define #f 4837 9 4837 33 ("values" "%%null?" "%%assert" "specifier" "lambda" "%%cdr" "jazz:parse-specifier" "%%car" "name" "let" "jazz:native-syntax-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-native-syntax-declaration" define #f 4846 9 4846 44 ("jazz:add-declaration-child" "effective-declaration" "jazz:new-export-syntax-declaration" "jazz:find-child-declaration" "or" "new-declaration" "jazz:Any" "jazz:walk-specifier" "if" "type" "jazz:parse-exported-symbol" "symbol" "%%cdr" "jazz:parse-native-syntax" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-native-syntax" define #f 4857 9 4857 32 ("jazz:require-declaration" "jazz:parse-exported-symbol" "symbol" "%%cdr" "jazz:parse-native-syntax" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:macro-modifiers" define #f 4869 8 4869 28 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "jazz:parse-macro" define #f 4874 9 4874 25 ("values" "parameters" "jazz:Any" "type" "%%desourcify" "name" "%%cdr" "body" "%%car" "jazz:source-code" "signature" "let*" "jazz:macro-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-macro-declaration" define #f 4884 9 4884 36 ("jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz:new-macro-declaration" "jazz:find-child-declaration" "or" "new-declaration" "jazz:walk-parameters" "signature" "let" "jazz:source-code" "%%cdr" "jazz:parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-macro" define #f 4894 9 4894 24 ("%%set-declaration-source" "jazz:walk-body" "%%set-macro-declaration-body" "%%set-macro-declaration-signature" "jazz:walk-parameters" "augmented-environment" "signature" "jazz:require-declaration" "new-declaration" "let*" "jazz:source-code" "%%cdr" "jazz:parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:register-local-macro" define #f 4910 9 4910 34 ("%%get-module-declaration-local-macros" "%%table-set!" "macro" "name" "module-declaration")}
      {Lisp-Entry "jazz:walk-local-macro-declaration" define #f 4914 9 4914 42 ("jazz:add-declaration-child" "effective-declaration" "jazz:emit-expression" "jazz:sourcified-form" "jazz:emit-signature" "eval" "%%cons" "let" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-declaration-locator" "jazz:register-local-macro" "%%set-declaration-source" "%%set-local-macro-declaration-body" "%%set-local-macro-declaration-signature" "jazz:walk-body" "walked-body" "jazz:new-local-macro-declaration" "jazz:find-child-declaration" "or" "new-declaration" "let*" "jazz:walk-parameters" "augmented-environment" "signature" "jazz:source-code" "%%cdr" "jazz:parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-local-macro" define #f 4933 9 4933 30 ("jazz:require-declaration" "jazz:source-code" "%%cdr" "jazz:parse-macro" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:syntax-modifiers" define #f 4943 8 4943 29 ("uptodate" "undocumented" "deprecated" "public" "package" "protected" "private")}
      {Lisp-Entry "jazz:parse-syntax" define #f 4948 9 4948 26 ("values" "parameters" "jazz:Any" "type" "%%desourcify" "name" "%%cdr" "body" "%%car" "jazz:source-code" "signature" "let*" "jazz:syntax-modifiers" "jazz:parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-syntax-declaration" define #f 4958 9 4958 37 ("jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz:new-syntax-declaration" "jazz:find-child-declaration" "or" "new-declaration" "jazz:walk-parameters" "signature" "let" "jazz:source-code" "%%cdr" "jazz:parse-syntax" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-syntax" define #f 4968 9 4968 25 ("%%set-declaration-source" "jazz:walk-body" "%%set-syntax-declaration-body" "%%set-syntax-declaration-signature" "jazz:walk-parameters" "augmented-environment" "signature" "jazz:require-declaration" "new-declaration" "let*" "jazz:source-code" "%%cdr" "jazz:parse-syntax" "body" "parameters" "compatibility" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define-syntax-declaration" define #f 4984 9 4984 44 ("jazz:add-declaration-child" "effective-declaration" "%%set-declaration-source" "jazz:Any" "jazz:new-define-syntax-declaration" "jazz:find-child-declaration" "or" "new-declaration" "%%car" "name" "let" "jazz:source-code" "%%cdr" "jazz:syntax-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define-syntax" define #f 4995 9 4995 32 ("%%set-declaration-source" "jazz:walk-body" "%%set-syntax-declaration-body" "%%set-syntax-declaration-signature" "jazz:walk-parameters" "augmented-environment" "signature" "jazz:require-declaration" "new-declaration" "body" "%%car" "name" "let*" "jazz:source-code" "%%cdr" "jazz:syntax-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define-local-syntax-declaration" define #f 5013 9 5013 50 ("jazz:add-declaration-child" "effective-declaration" "jazz:emit-expression" "jazz:sourcified-form" "car" "eval" "jazz:new-define-local-syntax-form" "else" "cons" "x" "=>" "jazz" "cond" "core" "scheme" "jazz:get-dialect" "%%get-dialect-bindings" "jazz:new-walk-frame" "%%list" "env" "%%get-declaration-toplevel" "current-unit-name" "%%cons" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-declaration-locator" "jazz:register-local-macro" "%%set-declaration-source" "%%set-syntax-declaration-body" "jazz:walk-body" "walked-body" "jazz:Any" "jazz:new-define-local-syntax-declaration" "jazz:find-child-declaration" "or" "new-declaration" "let*" "jazz:walk-parameters" "augmented-environment" "signature" "body" "%%car" "name" "let" "jazz:source-code" "%%cdr" "jazz:syntax-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-define-local-syntax" define #f 5050 9 5050 38 ("%%car" "jazz:require-declaration" "jazz:source-code" "%%cdr" "jazz:syntax-modifiers" "jazz:parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-let-syntax" define #f 5060 9 5060 29 ("jazz:walk-list" "jazz:new-begin" "jazz:new-define-syntax-form" "%%get-code-form" "eval" "expander" "jazz:walk" "jazz:emit-expression" "expander-src" "value" "%%car" "jazz:source-code" "name" "binding" "lambda" "map" "append" "augmented-environment" "let" "jazz:walk-error" "%%pair?" "%%null?" "or" "%%assertion" "%%cddr" "body" "bindings" "unwrap-syntactic-closure" "%%cadr" "bindings-src" "let*" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-letrec-syntax" define #f 5084 9 5084 32 ("jazz:walk-let-syntax" "apply" "args")}
      {Lisp-Entry "jazz:walk-reference" define #f 5093 9 5093 28 ("jazz:walk" "jazz:new-reference-reification" ",reference-src" "lambda" "resolver" "jazz:source-code" "%%cadr" "reference-src" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-parameters" define #f 5109 9 5109 29 ("values" "jazz:queue-list" "append" "jazz:new-signature" "signature" "jazz:List" "jazz:new-rest-parameter" "parameter-expression" "%%symbol?" "%%null?" "jazz:new-named-parameter" "keyword-parameter" "%%keyword->string" "%%string->symbol" "%%eq?" "%%cddr" "jazz:new-optional-parameter" "optional-parameter" "default" "1" "%%length" "%%fx=" "jazz:new-parameter" "positional-parameter" "jazz:walk-specifier" "type" "rest" "lambda" "jazz:parse-specifier" "%%cdr" "jazz:enqueue" "jazz:walk" "jazz:Any" "jazz:new-dynamic-parameter" "dynamic-parameter" "%%cadr" "variable" "jazz:specifier->name" "code" "specifier" "memq" "jazz:desourcify" "jazz:walk-error" "%%not" "parameter-src" "let*" "case" "section" "allowed?" "positional" "optional" "else" "keyword" "%%keyword?" "dynamic" "jazz:specifier?" "or" "cond" "%%car" "jazz:source-code" "first" "%%pair?" "if" "parameter" "parameter-section" "%%cons" "set!" "%%when" "expression" "augment-environment" "sections" "scan" "iterate-parameters" "define" "keywords" "optionals" "positionals" "jazz:new-queue" "dynamics" "augmented-environment" "let" "walk?" "extended?" "parameters" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-signature-casts" define #f 5215 9 5215 34 ("jazz:queue-list" "%%get-signature-named" "%%get-signature-optional" "%%get-signature-positional" "for-each" "jazz:enqueue" "jazz:new-queue" "set!" "%%not" "begin" "jazz:emit-binding-reference" "jazz:emit-parameter-cast" "cast" "jazz:Any" "%%neq?" "and" "if" "%%get-lexical-binding-type" "type" "parameter" "process" "define" "queue" "let" "environment" "source-declaration" "signature")}
      {Lisp-Entry "jazz:emit-signature" define #f 5237 9 5237 28 ("jazz:queue-list" "#!rest" "#!key" "#!optional" "%%null?" "%%not" "%%when" "for-each" "jazz:emit-parameter" "jazz:enqueue" "parameter" "emit" "define" "jazz:new-queue" "queue" "%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "let" "environment" "declaration" "signature")}
      {Lisp-Entry "jazz:walk-walk-failed" define #f 5263 9 5263 30 ("jazz:new-walk-failed-special" "jazz:walk" "jazz:*raise-walk-problems?*" "parameterize" "jazz:Error" "jazz:is?" "%%is?" "if" "%%object?" "and" "exc" "lambda" "jazz:with-exception-filter" "answer" "jazz:error" "else" "jazz:Walk-Error" ":error" "jazz:Walk-Warning" ":warning" "%%car" "%%eq?" "jazz:Walk-Problem" "%%null?" "cond" "problem-subclass" "%%cddr" "rest" "%%desourcify" "%%cadr" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Catalog" define #f 5296 8 5296 20 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:get-catalog" define #f 5300 9 5300 25 ("jazz:Catalog")}
      {Lisp-Entry "jazz:get-catalog-entry" define #f 5304 9 5304 31 ("jazz:Catalog" "%%table-ref" "unit-name")}
      {Lisp-Entry "jazz:set-catalog-entry" define #f 5308 9 5308 31 ("jazz:Catalog" "%%table-set!" "entry" "unit-name")}
      {Lisp-Entry "jazz:set-catalog-entry-status" define #f 5312 9 5312 38 ("%%cons" "jazz:set-catalog-entry" "%%cdr" "%%pair?" "if" "jazz:get-catalog-entry" "entry" "declaration" "let" "status" "unit-name")}
      {Lisp-Entry "jazz:release-catalog-entries" define #f 5320 9 5320 37 ("%%cdr" "jazz:set-catalog-entry" "%%pair?" "if" "entry" "unit-name" "lambda" "jazz:Catalog" "jazz:iterate-table")}
      {Lisp-Entry "jazz:call-with-catalog-entry-lock" define #f 5327 9 5327 42 ("jazz:get-catalog-entry" "%%pair?" "if" "jazz:pop-load-stack" ":walk" "jazz:push-load-stack" ":walking" "jazz:set-catalog-entry-status" "dynamic-wind" "lambda" "jazz:call-with-load-lock" "thunk" "unit-name")}
      {Lisp-Entry "jazz:outline-feedback" define #f 5341 8 5341 29 ("make-parameter")}
      {Lisp-Entry "jazz:outline-unit" define #f 5345 9 5345 26 ("jazz:set-catalog-entry" "jazz:error" "jazz:outline-feedback" "feedback" "jazz:call-with-catalog-entry-lock" "or" "jazz:Load-Stack" "cdr" "map" "jazz:circular-dependency-error" "declaration" "%%pair?" "status" "jazz:get-catalog-entry" "entry" "not" "jazz:parse-module-declaration" "module" "%%cdr" "jazz:parse-unit-declaration" "unit" "case" "%%car" "jazz:source-code" "kind" "0" "jazz:generate-symbol-counter" "jazz:generate-symbol-context" "jazz:generate-symbol-for" "interpret" "jazz:walk-for" "jazz:requested-unit-resource" "jazz:requested-unit-name" "parameterize" "read-literals?:" "jazz:read-toplevel-form" "form" "lambda" "jazz:resource-pathname" "jazz:outline-verbose?" "jazz:with-verbose" "%%not" "and" "if" "jazz:find-unit-src" "src" "let" "load-toplevel-declaration" "define" "error?" "use-catalog?" "#!key" "unit-name")}
      {Lisp-Entry "jazz:outline-module" define #f 5388 9 5388 28 ("jazz:Module-Declaration" "%%class-is?" "%%assert" "%%not" "if" "error?:" "jazz:outline-unit" "declaration" "let" "error?" "#!key" "unit-name")}
      {Lisp-Entry "jazz:read-literals?" define #f 5396 8 5396 27 ("make-parameter")}
      {Lisp-Entry "jazz:read-toplevel-form" define #f 5400 9 5400 32 ("%%not" "module" "unit" "%%memq" "jazz:source-code" "%%pair?" "and" "%%cdr" "%%not-null?" "extraneous?" "%%car" "form-src" "jazz:error" "%%null?" "if" "jazz:read-source-all" "all" "jazz:read-literals?" "parameterize" "port" "eol-encoding:" "char-encoding:" "path:" "%%list" "call-with-input-file" "cr-lf" "eol-encoding" "jazz:resource-char-encoding" "char-encoding" "lambda" "jazz:pathname-extension" "jazz:with-extension-reader" "jazz:resource-pathname" "source" "let" "read-literals?" "#!key" "resource")}
      {Lisp-Entry "jazz:walk-unit" define #f 5421 9 5421 23 ("%%cdr" "jazz:walk-module" "module" "unit" "%%car" "jazz:source-code" "case" "jazz:read-toplevel-form" "form" "0" "jazz:generate-symbol-counter" "jazz:generate-symbol-context" "jazz:generate-symbol-for" "interpret" "jazz:walk-for" "jazz:requested-unit-resource" "jazz:requested-unit-name" "parameterize" "jazz:find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "jazz:Core-Dialect" define-class ("class runtime") 5442 27 5442 44 ()}
      {Lisp-Entry "jazz:new-core-dialect" define #f 5445 9 5445 30 ("jazz:Core-Dialect" "jazz:allocate-core-dialect")}
      {Lisp-Entry "jazz:dialect-name" generic/specific ("jazz:Core-Dialect") 5449 21 5449 38 ("core")}
      {Lisp-Entry "jazz:dialect-walker" generic/specific ("jazz:Core-Dialect") 5453 21 5453 40 ("jazz:new-core-walker")}
      {Lisp-Entry "jazz:Core-Walker" define-class ("class runtime") 5465 27 5465 43 ()}
      {Lisp-Entry "jazz:new-core-walker" define #f 5468 9 5468 29 ("eq?" "test:" "%%make-table" "jazz:new-queue" "jazz:Core-Walker" "jazz:allocate-core-walker")}}})
"autoload"
 ({Lisp-File-Entry {File :context "src" "core" "module" "runtime" "autoload.scm"} 1299164380 scheme
    {Lisp-Entry "core.module.runtime.autoload" unit #f 41 16 41 44 ()
      {Lisp-Entry "jazz:Autoloads" define #f 44 8 44 22 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:get-autoloads" define #f 48 9 48 27 ("jazz:Autoloads")}
      {Lisp-Entry "jazz:get-autoload" define #f 52 9 52 26 ("jazz:Autoloads" "%%table-ref" "name")}
      {Lisp-Entry "jazz:set-autoload" define #f 56 9 56 26 ("%%cons" "jazz:Autoloads" "%%table-set!" "loader" "unit-name" "name")}
      {Lisp-Entry "jazz:require-autoload" define #f 60 9 60 30 ("jazz:error" "jazz:get-autoload" "or" "name")}
      {Lisp-Entry "jazz:register-autoload" define #f 65 9 65 31 ("jazz:error" "jazz:set-autoload" "%%car" "%%eq?" "%%not" "or" "if" "jazz:get-autoload" "actual" "let" "loader" "unit-name" "name")}
      {Lisp-Entry "jazz:autoload" define #f 72 9 72 22 ("%%cdr" "jazz:require-autoload" "autoload-info" "let" "name")}
      {Lisp-Entry "jazz:autoreload" define #f 77 9 77 24 ("%%cdr" "%%car" "jazz:reload-unit" "jazz:require-autoload" "autoload-info" "let" "name")}}})
"boolean"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "boolean.scm"} 1299164380 scheme
    {Lisp-Entry "core.base.runtime.boolean" unit #f 37 16 37 41 ()
      {Lisp-Entry "jazz:boolean" define #f 40 9 40 21 ("%%boolean" "expr")}
      {Lisp-Entry "jazz:not-null?" define #f 44 9 44 23 ("%%not-null?" "expr")}}})
"class"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "class.scm"} 1299164381 scheme
    {Lisp-Entry "core.class.syntax.class" unit #f 37 16 37 39 ()
      {Lisp-Entry "jazz:category-identifier" define #f 40 8 40 32 ("jazz:object-size")}
      {Lisp-Entry "jazz:category-fields" define #f 43 8 43 28 ("1" "jazz:category-identifier" "%%fx+")}
      {Lisp-Entry "jazz:category-virtual-size" define #f 46 8 46 34 ("1" "jazz:category-fields" "%%fx+")}
      {Lisp-Entry "jazz:category-ancestors" define #f 49 8 49 31 ("1" "jazz:category-virtual-size" "%%fx+")}
      {Lisp-Entry "jazz:category-descendants" define #f 52 8 52 33 ("1" "jazz:category-ancestors" "%%fx+")}
      {Lisp-Entry "jazz:class-ascendant" define #f 55 8 55 28 ("1" "jazz:category-descendants" "%%fx+")}
      {Lisp-Entry "jazz:class-interfaces" define #f 58 8 58 29 ("1" "jazz:class-ascendant" "%%fx+")}
      {Lisp-Entry "jazz:class-slots" define #f 61 8 61 24 ("1" "jazz:class-interfaces" "%%fx+")}
      {Lisp-Entry "jazz:class-instance-slots" define #f 64 8 64 33 ("1" "jazz:class-slots" "%%fx+")}
      {Lisp-Entry "jazz:class-instance-size" define #f 67 8 67 32 ("1" "jazz:class-instance-slots" "%%fx+")}
      {Lisp-Entry "jazz:class-level" define #f 70 8 70 24 ("1" "jazz:class-instance-size" "%%fx+")}
      {Lisp-Entry "jazz:class-dispatch-table" define #f 73 8 73 33 ("1" "jazz:class-level" "%%fx+")}
      {Lisp-Entry "jazz:class-core-method-alist" define #f 76 8 76 36 ("1" "jazz:class-dispatch-table" "%%fx+")}
      {Lisp-Entry "jazz:class-core-virtual-alist" define #f 79 8 79 37 ("1" "jazz:class-core-method-alist" "%%fx+")}
      {Lisp-Entry "jazz:class-core-virtual-names" define #f 82 8 82 37 ("1" "jazz:class-core-virtual-alist" "%%fx+")}
      {Lisp-Entry "jazz:class-core-vtable" define #f 85 8 85 30 ("1" "jazz:class-core-virtual-names" "%%fx+")}
      {Lisp-Entry "jazz:class-class-table" define #f 88 8 88 30 ("1" "jazz:class-core-vtable" "%%fx+")}
      {Lisp-Entry "jazz:class-interface-table" define #f 91 8 91 34 ("1" "jazz:class-class-table" "%%fx+")}
      {Lisp-Entry "jazz:class-size" define #f 95 8 95 23 ("1" "jazz:class-interface-table" "%%fx+")}
      {Lisp-Entry "%%get-category-identifier" define-macro ("macro") 99 20 99 45 ("jazz:category-identifier" ",jazz:category-identifier" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-identifier" define-macro ("macro") 103 20 103 45 (",identifier" "jazz:category-identifier" ",jazz:category-identifier" ",category" "%%object-set!" "identifier" "category")}
      {Lisp-Entry "%%get-category-fields" define-macro ("macro") 107 20 107 41 ("jazz:category-fields" ",jazz:category-fields" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-fields" define-macro ("macro") 111 20 111 41 (",fields" "jazz:category-fields" ",jazz:category-fields" ",category" "%%object-set!" "fields" "category")}
      {Lisp-Entry "%%get-category-virtual-size" define-macro ("macro") 115 20 115 47 ("jazz:category-virtual-size" ",jazz:category-virtual-size" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-virtual-size" define-macro ("macro") 119 20 119 47 (",virtual-size" "jazz:category-virtual-size" ",jazz:category-virtual-size" ",category" "%%object-set!" "virtual-size" "category")}
      {Lisp-Entry "%%get-category-ancestors" define-macro ("macro") 123 20 123 44 ("jazz:category-ancestors" ",jazz:category-ancestors" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-ancestors" define-macro ("macro") 127 20 127 44 (",ancestors" "jazz:category-ancestors" ",jazz:category-ancestors" ",category" "%%object-set!" "ancestors" "category")}
      {Lisp-Entry "%%get-category-descendants" define-macro ("macro") 131 20 131 46 ("jazz:category-descendants" ",jazz:category-descendants" ",category" "%%object-ref" "category")}
      {Lisp-Entry "%%set-category-descendants" define-macro ("macro") 135 20 135 46 (",descendants" "jazz:category-descendants" ",jazz:category-descendants" ",category" "%%object-set!" "descendants" "category")}
      {Lisp-Entry "%%get-class-ascendant" define-macro ("macro") 139 20 139 41 ("jazz:class-ascendant" ",jazz:class-ascendant" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-ascendant" define-macro ("macro") 143 20 143 41 (",ascendant" "jazz:class-ascendant" ",jazz:class-ascendant" ",class" "%%object-set!" "ascendant" "class")}
      {Lisp-Entry "%%get-class-interfaces" define-macro ("macro") 147 20 147 42 ("jazz:class-interfaces" ",jazz:class-interfaces" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-interfaces" define-macro ("macro") 151 20 151 42 (",interfaces" "jazz:class-interfaces" ",jazz:class-interfaces" ",class" "%%object-set!" "interfaces" "class")}
      {Lisp-Entry "%%get-class-slots" define-macro ("macro") 155 20 155 37 ("jazz:class-slots" ",jazz:class-slots" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-slots" define-macro ("macro") 159 20 159 37 (",slots" "jazz:class-slots" ",jazz:class-slots" ",class" "%%object-set!" "slots" "class")}
      {Lisp-Entry "%%get-class-instance-slots" define-macro ("macro") 163 20 163 46 ("jazz:class-instance-slots" ",jazz:class-instance-slots" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-instance-slots" define-macro ("macro") 167 20 167 46 (",slots" "jazz:class-instance-slots" ",jazz:class-instance-slots" ",class" "%%object-set!" "slots" "class")}
      {Lisp-Entry "%%get-class-instance-size" define-macro ("macro") 171 20 171 45 ("jazz:class-instance-size" ",jazz:class-instance-size" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-instance-size" define-macro ("macro") 175 20 175 45 (",size" "jazz:class-instance-size" ",jazz:class-instance-size" ",class" "%%object-set!" "size" "class")}
      {Lisp-Entry "%%get-class-level" define-macro ("macro") 179 20 179 37 ("jazz:class-level" ",jazz:class-level" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-level" define-macro ("macro") 183 20 183 37 (",size" "jazz:class-level" ",jazz:class-level" ",class" "%%object-set!" "size" "class")}
      {Lisp-Entry "%%get-class-dispatch-table" define-macro ("macro") 187 20 187 46 ("jazz:class-dispatch-table" ",jazz:class-dispatch-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-dispatch-table" define-macro ("macro") 191 20 191 46 (",vtable" "jazz:class-dispatch-table" ",jazz:class-dispatch-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-method-alist" define-macro ("macro") 195 20 195 49 ("jazz:class-core-method-alist" ",jazz:class-core-method-alist" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-method-alist" define-macro ("macro") 199 20 199 49 (",vtable" "jazz:class-core-method-alist" ",jazz:class-core-method-alist" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-virtual-alist" define-macro ("macro") 203 20 203 50 ("jazz:class-core-virtual-alist" ",jazz:class-core-virtual-alist" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-virtual-alist" define-macro ("macro") 207 20 207 50 (",vtable" "jazz:class-core-virtual-alist" ",jazz:class-core-virtual-alist" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-virtual-names" define-macro ("macro") 211 20 211 50 ("jazz:class-core-virtual-names" ",jazz:class-core-virtual-names" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-virtual-names" define-macro ("macro") 215 20 215 50 (",vtable" "jazz:class-core-virtual-names" ",jazz:class-core-virtual-names" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-core-vtable" define-macro ("macro") 219 20 219 43 ("jazz:class-core-vtable" ",jazz:class-core-vtable" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-core-vtable" define-macro ("macro") 223 20 223 43 (",vtable" "jazz:class-core-vtable" ",jazz:class-core-vtable" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-class-table" define-macro ("macro") 227 20 227 43 ("jazz:class-class-table" ",jazz:class-class-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-class-table" define-macro ("macro") 231 20 231 43 (",vtable" "jazz:class-class-table" ",jazz:class-class-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-class-interface-table" define-macro ("macro") 235 20 235 47 ("jazz:class-interface-table" ",jazz:class-interface-table" ",class" "%%object-ref" "class")}
      {Lisp-Entry "%%set-class-interface-table" define-macro ("macro") 239 20 239 47 (",vtable" "jazz:class-interface-table" ",jazz:class-interface-table" ",class" "%%object-set!" "vtable" "class")}
      {Lisp-Entry "%%get-object-class" define-macro ("macro") 243 20 243 38 ("jazz:object-class" ",jazz:object-class" ",object" "%%object-ref" "object")}
      {Lisp-Entry "%%set-object-class" define-macro ("macro") 247 20 247 38 (",class" "jazz:object-class" ",jazz:object-class" ",object" "%%object-set!" "class" "object")}
      {Lisp-Entry "%%final-dispatch" define-macro ("macro") 251 20 251 36 ("implementation" "class")}
      {Lisp-Entry "%%class-dispatch" define-macro ("macro") 255 20 255 36 (",implementation-rank" ",class-level" ",class" "%%get-class-class-table" "%%vector-ref" "implementation-rank" "class-level" "class")}
      {Lisp-Entry "%%interface-dispatch" define-macro ("macro") 259 20 259 40 (",implementation-rank" ",interface-rank" ",class" "%%get-class-interface-table" "%%vector-ref" "implementation-rank" "interface-rank" "class")}
      {Lisp-Entry "%%class-of-impl" define-macro ("macro") 268 24 268 39 ("%%scheme-class-of-impl" "else" ",obj" "%%c-class-of-impl" "compile" "jazz:walk-for" "case" "obj")}
      {Lisp-Entry "%%c-class-of-impl" define-macro ("macro") 275 24 275 41 ("jazz:structure-type" "jazz:specialtypes" "jazz:Char" "jazz:Fixnum" "jazz:subtypes" ",obj" "#<<end-of-c-code\n{\n    ___SCMOBJ obj = ___ARG1;\n    if (___MEM_ALLOCATED(obj))\n    {\n        int subtype = (*___UNTAG(obj) & ___SMASK) >> ___HTB;\n        if (subtype == ___sJAZZ)\n            ___RESULT = ___VECTORREF(obj,0);\n        else if (subtype == ___sSTRUCTURE)\n            ___RESULT = ___FAL;\n        else\n            ___RESULT = ___BODY_AS(___ARG2,___tSUBTYPED)[subtype];\n    }\n    else if (___FIXNUMP(obj))\n        ___RESULT = ___ARG3;\n    else if (obj >= 0)\n        ___RESULT = ___ARG4;\n    else\n        ___RESULT = ___BODY_AS(___ARG5,___tSUBTYPED)[___INT(___FAL - obj)];\n}\nend-of-c-code\n" "##c-code" "extended-bindings" "declare" "let" "or" "obj")}
      {Lisp-Entry "%%scheme-class-of-impl" define-macro ("macro") 307 24 307 46 ("jazz:error" "jazz:structure-type" "or" "else" "jazz:Marker" "jazz:marker?" "jazz:Unspecified" "%%unspecified?" "jazz:EOF" "%%eof-object?" "jazz:Values" "%%values?" "jazz:Foreign" "%%foreign?" "jazz:Procedure" "%%procedure?" "jazz:Continuation" "%%continuation?" "jazz:Port" "%%port?" "jazz:Keyword" "%%keyword?" "jazz:Symbol" "%%symbol?" "jazz:F64Vector" "%%f64vector?" "jazz:F32Vector" "%%f32vector?" "jazz:U64Vector" "%%u64vector?" "jazz:S64Vector" "%%s64vector?" "jazz:U32Vector" "%%u32vector?" "jazz:S32Vector" "%%s32vector?" "jazz:U16Vector" "%%u16vector?" "jazz:S16Vector" "%%s16vector?" "jazz:U8Vector" "%%u8vector?" "jazz:S8Vector" "%%s8vector?" "jazz:Vector" "%%vector?" "jazz:String" "%%string?" "jazz:Pair" "%%pair?" "jazz:Null" "%%null?" "jazz:Number" "%%number?" "jazz:Complex" "%%complex?" "jazz:Real" "%%real?" "jazz:Rational" "%%rational?" "jazz:Integer" "%%integer?" "jazz:Flonum" "%%flonum?" "jazz:Fixnum" "%%fixnum?" "jazz:Char" "%%char?" "jazz:Boolean" "%%boolean?" "%%get-object-class" ",obj" "%%object?" "cond" "obj")}
      {Lisp-Entry "%%class-of-impl" define-macro ("macro") 347 24 347 39 (",obj" "%%scheme-class-of-impl" "obj")}}})
"classes"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "classes.scm"} 1299164384 scheme
    {Lisp-Entry "core.class.syntax.classes" unit #f 37 16 37 41 ("jazz:Category" "jazz:Type" "jazz:Object")
      {Lisp-Entry "jazz:Object" define-class ("class") 45 19 45 30 ()}
      {Lisp-Entry "jazz:print-object" generic/specific ("jazz:Object~virtual") 49 22 49 39 ("detail" "output")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Object~virtual") 50 22 50 36 ("environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Type" define-class ("class") 58 19 58 28 ("jazz:Object")}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Type~virtual") 62 22 62 35 ("object")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Type~virtual") 63 22 63 38 ("subtype")}
      {Lisp-Entry "jazz:specifiable?" generic/specific ("jazz:Type~virtual") 64 22 64 39 ()}
      {Lisp-Entry "jazz:category-type?" generic/specific ("jazz:Type~virtual") 65 22 65 41 ()}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Type~virtual") 66 22 66 41 ()}
      {Lisp-Entry "jazz:emit-type" generic/specific ("jazz:Type~virtual") 67 22 67 36 ("environment" "source-declaration")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Type~virtual") 68 22 68 36 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:emit-check" generic/specific ("jazz:Type~virtual") 69 22 69 37 ("environment" "source-declaration" "value")}
      {Lisp-Entry "%%subtype?" define-macro ("macro") 72 20 72 30 (",target" ",type" "jazz:of-subtype?" "type" "target")}
      {Lisp-Entry "%%subcategory?" define-macro ("macro") 76 20 76 34 (",target" "%%get-category-ancestors" ",category" "jazz:vector-memq?" "category" "target")}
      {Lisp-Entry "%%subclass?" define-macro ("macro") 80 20 80 31 (",target" "%%get-category-ancestors" ",class" "jazz:vector-memq?" "class" "target")}
      {Lisp-Entry "%%is?" define-macro ("macro") 84 20 84 25 (",object" ",type" "jazz:of-type?" "type" "object")}
      {Lisp-Entry "%%is-not?" define-macro ("macro") 88 20 88 29 (",type" ",object" "%%is?" "%%not" "type" "object")}
      {Lisp-Entry "jazz:Category" define-class ("class") 97 19 97 32 ("descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Type")}
      {Lisp-Entry "jazz:update-category" generic/specific ("jazz:Category~virtual") 105 22 105 42 ()}
      {Lisp-Entry "jazz:Class" define-class ("class") 113 19 113 29 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "jazz:allocate-class" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Category")}
      {Lisp-Entry "%%class-subtype?" define-macro ("macro") 129 20 129 36 ("%%get-category-ancestors" "%%vector-ref" "%%eq?" ",trg" "%%fx>=" "and" ",cls" "%%get-class-level" "class-level" "let" "cls" "trg" "lambda" "jazz:with-uniqueness" "class" "target")}
      {Lisp-Entry "%%class-is?" define-macro ("macro") 139 20 139 31 (",class" ",object" "jazz:class-of" "%%class-subtype?" "class" "object")}
      {Lisp-Entry "%%category-is?" define-macro ("macro") 143 20 143 34 (",category" ",object" "%%is?" "category" "object")}
      {Lisp-Entry "%%class?" define-macro ("macro") 147 20 147 28 ("jazz:Class" ",object" "%%class-is?" "object")}
      {Lisp-Entry "%%object-class?" define-macro ("macro") 151 20 151 35 ("jazz:Object" ",object" "%%eq?" "object")}
      {Lisp-Entry "jazz:Object-Class" define-class ("class") 160 19 160 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Boolean-Class" define-class ("class") 169 19 169 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Char-Class" define-class ("class") 170 19 170 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Numeric-Class" define-class ("class") 171 19 171 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Number-Class" define-class ("class") 172 19 172 36 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Numeric-Class")}
      {Lisp-Entry "jazz:Complex-Class" define-class ("class") 173 19 173 37 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Number-Class")}
      {Lisp-Entry "jazz:Real-Class" define-class ("class") 174 19 174 34 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Complex-Class")}
      {Lisp-Entry "jazz:Rational-Class" define-class ("class") 175 19 175 38 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Real-Class")}
      {Lisp-Entry "jazz:Integer-Class" define-class ("class") 176 19 176 37 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Rational-Class")}
      {Lisp-Entry "jazz:Fixnum-Class" define-class ("class") 177 19 177 36 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Integer-Class")}
      {Lisp-Entry "jazz:Flonum-Class" define-class ("class") 178 19 178 36 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Real-Class")}
      {Lisp-Entry "jazz:Sequence-Class" define-class ("class") 179 19 179 38 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:List-Class" define-class ("class") 180 19 180 34 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:Null-Class" define-class ("class") 181 19 181 34 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:List-Class")}
      {Lisp-Entry "jazz:Pair-Class" define-class ("class") 182 19 182 34 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:List-Class")}
      {Lisp-Entry "jazz:String-Class" define-class ("class") 183 19 183 36 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:Vector-Class" define-class ("class") 184 19 184 36 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:S8Vector-Class" define-class ("class") 185 19 185 38 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:U8Vector-Class" define-class ("class") 186 19 186 38 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:S16Vector-Class" define-class ("class") 187 19 187 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:U16Vector-Class" define-class ("class") 188 19 188 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:S32Vector-Class" define-class ("class") 189 19 189 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:U32Vector-Class" define-class ("class") 190 19 190 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:S64Vector-Class" define-class ("class") 191 19 191 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:U64Vector-Class" define-class ("class") 192 19 192 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:F32Vector-Class" define-class ("class") 193 19 193 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:F64Vector-Class" define-class ("class") 194 19 194 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:Structure-Class" define-class ("class") 195 19 195 39 ("jazz:Class" "interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Sequence-Class")}
      {Lisp-Entry "jazz:Port-Class" define-class ("class") 196 19 196 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Continuation-Class" define-class ("class") 197 19 197 42 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Procedure-Class" define-class ("class") 198 19 198 39 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Symbol-Class" define-class ("class") 199 19 199 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Keyword-Class" define-class ("class") 200 19 200 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Table-Class" define-class ("class") 201 19 201 35 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Thread-Class" define-class ("class") 202 19 202 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Promise-Class" define-class ("class") 203 19 203 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Foreign-Class" define-class ("class") 204 19 204 37 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Values-Class" define-class ("class") 205 19 205 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:EOF-Class" define-class ("class") 206 19 206 33 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Unspecified-Class" define-class ("class") 207 19 207 41 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Marker-Class" define-class ("class") 208 19 208 36 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Boolean" define-class ("class") 211 19 211 31 ("jazz:Boolean-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Char" define-class ("class") 212 19 212 28 ("jazz:Char-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Numeric" define-class ("class") 213 19 213 31 ("jazz:Numeric-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Number" define-class ("class") 214 19 214 30 ("jazz:Number-Class" "jazz:Numeric")}
      {Lisp-Entry "jazz:Complex" define-class ("class") 215 19 215 31 ("jazz:Complex-Class" "jazz:Number")}
      {Lisp-Entry "jazz:Real" define-class ("class") 216 19 216 28 ("jazz:Real-Class" "jazz:Complex")}
      {Lisp-Entry "jazz:Rational" define-class ("class") 217 19 217 32 ("jazz:Rational-Class" "jazz:Real")}
      {Lisp-Entry "jazz:Integer" define-class ("class") 218 19 218 31 ("jazz:Integer-Class" "jazz:Rational")}
      {Lisp-Entry "jazz:Fixnum" define-class ("class") 219 19 219 30 ("jazz:Fixnum-Class" "jazz:Integer")}
      {Lisp-Entry "jazz:Flonum" define-class ("class") 220 19 220 30 ("jazz:Flonum-Class" "jazz:Real")}
      {Lisp-Entry "jazz:Sequence" define-class ("class") 221 19 221 32 ("jazz:Sequence-Class" "jazz:Object")}
      {Lisp-Entry "jazz:List" define-class ("class") 222 19 222 28 ("jazz:List-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:Null" define-class ("class") 223 19 223 28 ("jazz:Null-Class" "jazz:List")}
      {Lisp-Entry "jazz:Pair" define-class ("class") 224 19 224 28 ("jazz:Pair-Class" "jazz:List")}
      {Lisp-Entry "jazz:String" define-class ("class") 225 19 225 30 ("jazz:String-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:Vector" define-class ("class") 226 19 226 30 ("jazz:Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:S8Vector" define-class ("class") 227 19 227 32 ("jazz:S8Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:U8Vector" define-class ("class") 228 19 228 32 ("jazz:U8Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:S16Vector" define-class ("class") 229 19 229 33 ("jazz:S16Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:U16Vector" define-class ("class") 230 19 230 33 ("jazz:U16Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:S32Vector" define-class ("class") 231 19 231 33 ("jazz:S32Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:U32Vector" define-class ("class") 232 19 232 33 ("jazz:U32Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:S64Vector" define-class ("class") 233 19 233 33 ("jazz:S64Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:U64Vector" define-class ("class") 234 19 234 33 ("jazz:U64Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:F32Vector" define-class ("class") 235 19 235 33 ("jazz:F32Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:F64Vector" define-class ("class") 236 19 236 33 ("jazz:F64Vector-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:Structure" define-class ("class") 237 19 237 33 ("jazz:Structure-Class" "jazz:Sequence")}
      {Lisp-Entry "jazz:Port" define-class ("class") 238 19 238 28 ("jazz:Port-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Continuation" define-class ("class") 239 19 239 36 ("jazz:Continuation-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Procedure" define-class ("class") 240 19 240 33 ("jazz:Procedure-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Symbol" define-class ("class") 241 19 241 30 ("jazz:Symbol-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Keyword" define-class ("class") 242 19 242 31 ("jazz:Keyword-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Table" define-class ("class") 243 19 243 29 ("jazz:Table-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Thread" define-class ("class") 244 19 244 30 ("jazz:Thread-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Promise" define-class ("class") 245 19 245 31 ("jazz:Promise-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Foreign" define-class ("class") 246 19 246 31 ("jazz:Foreign-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Values" define-class ("class") 247 19 247 30 ("jazz:Values-Class" "jazz:Object")}
      {Lisp-Entry "jazz:EOF" define-class ("class") 248 19 248 27 ("jazz:EOF-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Unspecified" define-class ("class") 249 19 249 35 ("jazz:Unspecified-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Marker" define-class ("class") 250 19 250 30 ("jazz:Marker-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Interface" define-class ("class") 258 19 258 33 ("%%get-interface-rank" "rank" "%%get-interface-ascendants" "ascendants" "jazz:allocate-interface" "jazz:Object-Class" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Category")}
      {Lisp-Entry "jazz:Field" define-class ("class") 268 19 268 29 ("%%get-field-name" "name" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "%%get-category-field" define-macro ("macro") 272 20 272 40 (",field-name" ",category" "%%get-category-fields" "%%table-ref" "field-name" "category")}
      {Lisp-Entry "%%set-category-field" define-macro ("macro") 276 20 276 40 (",field" ",field-name" ",category" "%%get-category-fields" "%%table-set!" "field" "field-name" "category")}
      {Lisp-Entry "jazz:Slot" define-class ("class") 285 19 285 28 ("%%set-slot-initialize" "%%get-slot-initialize" "initialize" "%%get-slot-offset" "offset" "jazz:allocate-slot" "jazz:Object-Class" "name" "jazz:Field")}
      {Lisp-Entry "jazz:Property" define-class ("class") 295 19 295 32 ("%%set-property-setter" "%%get-property-setter" "setter" "%%set-property-getter" "%%get-property-getter" "getter" "jazz:allocate-property" "jazz:Object-Class" "initialize" "offset" "name" "jazz:Slot")}
      {Lisp-Entry "jazz:Method" define-class ("class") 305 19 305 30 ("%%set-method-implementation-rank" "%%get-method-implementation-rank" "implementation-rank" "%%set-method-category-rank" "%%get-method-category-rank" "category-rank" "%%set-method-implementation-tree" "%%get-method-implementation-tree" "implementation-tree" "%%set-method-implementation" "%%get-method-implementation" "implementation" "%%set-method-dispatch-type" "%%get-method-dispatch-type" "dispatch-type" "jazz:allocate-method" "jazz:Object-Class" "name" "jazz:Field")}
      {Lisp-Entry "jazz:Method-Node" define-class ("class") 318 19 318 35 ("%%set-method-node-children" "%%get-method-node-children" "children" "%%set-method-node-next-implementation" "%%get-method-node-next-implementation" "next-implementation" "%%set-method-node-next-node" "%%get-method-node-next-node" "next-node" "%%set-method-node-implementation" "%%get-method-node-implementation" "implementation" "%%set-method-node-category" "%%get-method-node-category" "category" "jazz:allocate-method-node" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Queue" define-class ("class") 331 19 331 29 ("%%set-queue-shared?" "%%get-queue-shared?" "shared?" "%%set-queue-tail" "%%get-queue-tail" "tail" "%%set-queue-head" "%%get-queue-head" "head" "jazz:allocate-queue" "jazz:Object-Class" "jazz:Object")}}}
  {Lisp-File-Entry {File :context "src" "core" "exception" "syntax" "classes.scm"} 1299164383 scheme
    {Lisp-Entry "core.exception.syntax.classes" unit #f 37 16 37 45 ("jazz:Exception")
      {Lisp-Entry "jazz:Exception" define-class ("class") 45 19 45 33 ("jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:present-exception" generic/specific ("jazz:Exception~virtual") 49 22 49 44 ()}
      {Lisp-Entry "jazz:get-message" generic/specific ("jazz:Exception~virtual") 50 22 50 38 ()}
      {Lisp-Entry "jazz:get-detail" generic/specific ("jazz:Exception~virtual") 51 22 51 37 ()}
      {Lisp-Entry "jazz:Exception-Detail" define-class ("class") 59 19 59 40 ("%%get-exception-detail-children" "children" "%%get-exception-detail-location" "location" "%%get-exception-detail-title" "title" "%%get-exception-detail-icon" "icon" "jazz:allocate-exception-detail" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:System-Exception" define-class ("class") 71 19 71 40 ("%%get-system-exception-exception" "exception" "jazz:Object-Class" "jazz:Exception")}
      {Lisp-Entry "jazz:Error" define-class ("class") 80 19 80 29 ("%%get-error-message" "message" "jazz:allocate-error" "jazz:Object-Class" "jazz:Exception")}}}
  {Lisp-File-Entry {File :context "src" "core" "module" "syntax" "classes.scm"} 1299175700 scheme
    {Lisp-Entry "core.module.syntax.classes" unit #f 37 16 37 42 ("jazz:Expression" "jazz:Parameter" "jazz:Walker" "jazz:Declaration-Reference" "jazz:Declaration" "jazz:Lexical-Binding" "jazz:Walk-Binding")
      {Lisp-Entry "jazz:Walk-Binding" define-class ("class") 45 19 45 36 ("jazz:Object-Class" "jazz:Type")}
      {Lisp-Entry "jazz:walk-binding-lookup" generic/specific ("jazz:Walk-Binding~virtual") 49 22 49 46 ("source-declaration" "symbol")}
      {Lisp-Entry "jazz:walk-binding-referenced" generic/specific ("jazz:Walk-Binding~virtual") 50 22 50 50 ()}
      {Lisp-Entry "jazz:emit-binding-symbol" generic/specific ("jazz:Walk-Binding~virtual") 51 22 51 46 ("environment" "source-declaration")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:Walk-Binding~virtual") 52 22 52 49 ("environment" "source-declaration")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:Walk-Binding~virtual") 53 22 53 53 ("form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-binding-call" generic/specific ("jazz:Walk-Binding~virtual") 54 22 54 44 ("environment" "source-declaration" "arguments" "binding-src")}
      {Lisp-Entry "jazz:emit-inlined-binding-call" generic/specific ("jazz:Walk-Binding~virtual") 55 22 55 52 ("environment" "source-declaration" "call" "arguments")}
      {Lisp-Entry "jazz:walk-binding-validate-assignment" generic/specific ("jazz:Walk-Binding~virtual") 56 22 56 59 ("symbol-src" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-binding-assignable?" generic/specific ("jazz:Walk-Binding~virtual") 57 22 57 51 ()}
      {Lisp-Entry "jazz:emit-binding-assignment" generic/specific ("jazz:Walk-Binding~virtual") 58 22 58 50 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:walk-binding-walkable?" generic/specific ("jazz:Walk-Binding~virtual") 59 22 59 49 ()}
      {Lisp-Entry "jazz:walk-binding-walk-form" generic/specific ("jazz:Walk-Binding~virtual") 60 22 60 49 ("form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:walk-binding-expandable?" generic/specific ("jazz:Walk-Binding~virtual") 61 22 61 51 ()}
      {Lisp-Entry "jazz:walk-binding-expand-form" generic/specific ("jazz:Walk-Binding~virtual") 62 22 62 51 ("form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz:Lexical-Binding" define-class ("class") 70 19 70 39 ("%%set-lexical-binding-hits" "%%get-lexical-binding-hits" "hits" "%%get-lexical-binding-type" "type" "%%get-lexical-binding-name" "name" "jazz:Object-Class" "jazz:Walk-Binding")}
      {Lisp-Entry "jazz:resolve-binding" generic/specific ("jazz:Lexical-Binding~virtual") 76 22 76 42 ()}
      {Lisp-Entry "jazz:Declaration" define-class ("class") 84 19 84 35 ("%%set-declaration-source" "%%get-declaration-source" "source" "%%set-declaration-locator" "%%get-declaration-locator" "locator" "%%set-declaration-parent" "%%get-declaration-parent" "parent" "%%set-declaration-toplevel" "%%get-declaration-toplevel" "toplevel" "%%get-declaration-attributes" "attributes" "%%get-declaration-compatibility" "compatibility" "%%get-declaration-access" "access" "jazz:Object-Class" "hits" "type" "name" "jazz:Lexical-Binding")}
      {Lisp-Entry "jazz:lookup-declaration" generic/specific ("jazz:Declaration~virtual") 94 22 94 45 ("source-declaration" "access" "symbol")}
      {Lisp-Entry "jazz:update-declaration" generic/specific ("jazz:Declaration~virtual") 95 22 95 45 ("new-declaration")}
      {Lisp-Entry "jazz:get-declaration-inclusions" generic/specific ("jazz:Declaration~virtual") 96 22 96 53 ()}
      {Lisp-Entry "jazz:get-nextmethod-signature" generic/specific ("jazz:Declaration~virtual") 97 22 97 51 ()}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:Declaration~virtual") 98 22 98 43 ("environment")}
      {Lisp-Entry "jazz:expand-referenced-declaration" generic/specific ("jazz:Declaration~virtual") 99 22 99 56 ()}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:Declaration~virtual") 100 22 100 43 ("s" "k" "f")}
      {Lisp-Entry "jazz:Declaration-Reference" define-class ("class") 108 19 108 45 ("%%set-declaration-reference-declaration" "%%get-declaration-reference-declaration" "declaration" "%%get-declaration-reference-name" "name" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:resolve-reference" generic/specific ("jazz:Declaration-Reference~virtual") 113 22 113 44 ("module-declaration")}
      {Lisp-Entry "jazz:Module-Reference" define-class ("class") 121 19 121 40 ("jazz:allocate-module-reference" "jazz:Object-Class" "declaration" "name" "jazz:Declaration-Reference")}
      {Lisp-Entry "jazz:Export-Reference" define-class ("class") 130 19 130 40 ("%%get-export-reference-module-reference" "module-reference" "jazz:allocate-export-reference" "jazz:Object-Class" "declaration" "name" "jazz:Declaration-Reference")}
      {Lisp-Entry "jazz:Autoload-Reference" define-class ("class") 139 19 139 42 ("jazz:allocate-autoload-reference" "jazz:Object-Class" "module-reference" "declaration" "name" "jazz:Export-Reference")}
      {Lisp-Entry "jazz:Unit-Declaration" define-class ("class") 148 19 148 40 ("%%set-unit-declaration-requires" "%%get-unit-declaration-requires" "requires" "jazz:allocate-unit-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Namespace-Declaration" define-class ("class") 157 19 157 45 ("%%set-namespace-declaration-body" "%%get-namespace-declaration-body" "body" "%%get-namespace-declaration-children" "children" "%%get-namespace-declaration-lookups" "lookups" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "%%get-access-lookup" define-macro ("macro") 163 20 163 39 (",access" ",namespace-declaration" "%%get-namespace-declaration-lookups" "%%vector-ref" "access" "namespace-declaration")}
      {Lisp-Entry "jazz:Module-Declaration" define-class ("class") 172 19 172 42 ("%%get-module-declaration-local-macros" "local-macros" "%%set-module-declaration-inclusions" "%%get-module-declaration-inclusions" "inclusions" "%%get-module-declaration-proclaims" "proclaims" "%%set-module-declaration-imports" "%%get-module-declaration-imports" "imports" "%%set-module-declaration-exports" "%%get-module-declaration-exports" "exports" "%%set-module-declaration-requires" "%%get-module-declaration-requires" "requires" "%%get-module-declaration-dialect-invoice" "dialect-invoice" "%%get-module-declaration-dialect-name" "dialect-name" "%%set-module-declaration-walker" "%%get-module-declaration-walker" "walker" "jazz:allocate-module-declaration" "jazz:Object-Class" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Namespace-Declaration")}
      {Lisp-Entry "jazz:Module-Invoice" define-class ("class") 189 19 189 38 ("%%get-module-invoice-rename" "rename" "%%get-module-invoice-prefix" "prefix" "%%get-module-invoice-except" "except" "%%get-module-invoice-only" "only" "%%get-module-invoice-version" "version" "%%get-module-invoice-phase" "phase" "%%get-module-invoice-module" "module" "%%get-module-invoice-name" "name" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Export-Invoice" define-class ("class") 205 19 205 38 ("%%set-export-invoice-autoload" "%%get-export-invoice-autoload" "autoload" "jazz:allocate-export-invoice" "jazz:Object-Class" "rename" "prefix" "except" "only" "version" "phase" "module" "name" "jazz:Module-Invoice")}
      {Lisp-Entry "jazz:Import-Invoice" define-class ("class") 214 19 214 38 ("%%set-import-invoice-hit?" "%%get-import-invoice-hit?" "hit?" "jazz:allocate-import-invoice" "jazz:Object-Class" "rename" "prefix" "except" "only" "version" "phase" "module" "name" "jazz:Module-Invoice")}
      {Lisp-Entry "jazz:Export-Declaration" define-class ("class") 223 19 223 42 ("%%get-export-declaration-symbol" "symbol" "jazz:allocate-export-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Export-Syntax-Declaration" define-class ("class") 232 19 232 49 ("%%get-export-syntax-declaration-symbol" "symbol" "jazz:allocate-export-syntax-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Autoload-Declaration" define-class ("class") 241 19 241 44 ("%%set-autoload-declaration-declaration" "%%get-autoload-declaration-declaration" "declaration" "%%get-autoload-declaration-exported-module" "exported-module" "%%get-autoload-declaration-module" "module" "jazz:allocate-autoload-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Literal" define-class ("class") 252 19 252 31 ("%%get-literal-arguments" "arguments" "%%get-literal-name" "name" "jazz:allocate-literal" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Macro-Declaration" define-class ("class") 262 19 262 41 ("%%set-macro-declaration-body" "%%get-macro-declaration-body" "body" "%%set-macro-declaration-signature" "%%get-macro-declaration-signature" "signature" "jazz:allocate-macro-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Local-Macro-Declaration" define-class ("class") 272 19 272 47 ("%%set-local-macro-declaration-body" "%%get-local-macro-declaration-body" "body" "%%set-local-macro-declaration-signature" "%%get-local-macro-declaration-signature" "signature" "jazz:allocate-local-macro-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Syntax-Declaration" define-class ("class") 282 19 282 42 ("%%set-syntax-declaration-body" "%%get-syntax-declaration-body" "body" "%%set-syntax-declaration-signature" "%%get-syntax-declaration-signature" "signature" "jazz:allocate-syntax-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Define-Syntax-Declaration" define-class ("class") 292 19 292 49 ("jazz:allocate-define-syntax-declaration" "jazz:Object-Class" "body" "signature" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Syntax-Declaration")}
      {Lisp-Entry "jazz:Define-Local-Syntax-Declaration" define-class ("class") 301 19 301 55 ("jazz:allocate-define-local-syntax-declaration" "jazz:Object-Class" "body" "signature" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Syntax-Declaration")}
      {Lisp-Entry "jazz:Void-Class" define-class ("class") 310 19 310 34 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Void" define-class ("class") 314 19 314 28 ("jazz:Void-Class" "jazz:Type")}
      {Lisp-Entry "jazz:Opt-Type" define-class ("class") 323 19 323 32 ("%%get-opt-type-type" "type" "jazz:allocate-opt-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Key-Type" define-class ("class") 332 19 332 32 ("%%get-key-type-type" "type" "%%get-key-type-key" "key" "jazz:allocate-key-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Rest-Type" define-class ("class") 342 19 342 33 ("%%get-rest-type-type" "type" "jazz:allocate-rest-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Function-Type" define-class ("class") 351 19 351 37 ("%%get-function-type-result" "result" "%%get-function-type-rest" "rest" "%%get-function-type-named" "named" "%%get-function-type-optional" "optional" "%%get-function-type-positional" "positional" "%%get-function-type-mandatory" "mandatory" "jazz:allocate-function-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Category-Type" define-class ("class") 365 19 365 37 ("%%get-category-type-declaration" "declaration" "jazz:allocate-category-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Values-Type" define-class ("class") 374 19 374 35 ("%%get-values-type-types" "types" "jazz:allocate-values-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Restriction-Type" define-class ("class") 383 19 383 40 ("%%get-restriction-type-type" "type" "%%get-restriction-type-base" "base" "jazz:allocate-restriction-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Complement-Type" define-class ("class") 393 19 393 39 ("%%get-complement-type-type" "type" "jazz:allocate-complement-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Union-Type" define-class ("class") 402 19 402 34 ("%%get-union-type-types" "types" "jazz:allocate-union-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Template-Type" define-class ("class") 411 19 411 37 ("%%get-template-type-types" "types" "%%get-template-type-class" "class" "jazz:allocate-template-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Nillable-Type" define-class ("class") 421 19 421 37 ("%%get-nillable-type-type" "type" "jazz:allocate-nillable-type" "jazz:Class" "jazz:Type")}
      {Lisp-Entry "jazz:Any-Class" define-class ("class") 430 19 430 33 ("interface-table" "class-table" "core-vtable" "core-virtual-names" "core-virtual-alist" "core-method-alist" "dispatch-table" "level" "instance-size" "instance-slots" "slots" "interfaces" "ascendant" "descendants" "ancestors" "virtual-size" "fields" "name" "jazz:Class")}
      {Lisp-Entry "jazz:Any" define-class ("class") 434 19 434 27 ("jazz:Any-Class" "jazz:Type")}
      {Lisp-Entry "jazz:C-Type-Declaration" define-class ("class") 443 19 443 42 ("%%get-c-type-declaration-declare" "declare" "%%get-c-type-declaration-scheme-to-c" "scheme-to-c" "%%get-c-type-declaration-c-to-scheme" "c-to-scheme" "%%get-c-type-declaration-inclusions" "inclusions" "%%set-c-type-declaration-pointer-types" "%%get-c-type-declaration-pointer-types" "pointer-types" "%%get-c-type-declaration-base-type" "base-type" "%%get-c-type-declaration-expansion" "expansion" "%%get-c-type-declaration-kind" "kind" "jazz:allocate-c-type-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:C-Definition-Declaration" define-class ("class") 459 19 459 48 ("%%set-c-definition-declaration-body" "%%get-c-definition-declaration-body" "body" "%%get-c-definition-declaration-scope" "scope" "%%get-c-definition-declaration-c-name" "c-name" "%%get-c-definition-declaration-result-type" "result-type" "%%get-c-definition-declaration-parameter-types" "parameter-types" "%%set-c-definition-declaration-signature" "%%get-c-definition-declaration-signature" "signature" "jazz:allocate-c-definition-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:Walker" define-class ("class") 473 19 473 30 ("%%set-walker-autoloads" "%%get-walker-autoloads" "autoloads" "%%get-walker-references" "references" "%%get-walker-variables" "variables" "%%set-walker-literals" "%%get-walker-literals" "literals" "%%set-walker-errors" "%%get-walker-errors" "errors" "%%set-walker-warnings" "%%get-walker-warnings" "warnings" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:walker-bindings" generic/specific ("jazz:Walker~virtual") 482 22 482 42 ()}
      {Lisp-Entry "jazz:walker-environment" generic/specific ("jazz:Walker~virtual") 483 22 483 45 ()}
      {Lisp-Entry "jazz:walk-declaration" generic/specific ("jazz:Walker~virtual") 484 22 484 43 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-free-reference" generic/specific ("jazz:Walker~virtual") 485 22 485 46 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-symbol-assignment" generic/specific ("jazz:Walker~virtual") 486 22 486 49 ("value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-free-assignment" generic/specific ("jazz:Walker~virtual") 487 22 487 47 ("symbol-src" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-symbol" generic/specific ("jazz:Walker~virtual") 488 22 488 38 ("symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-form" generic/specific ("jazz:Walker~virtual") 489 22 489 36 ("form" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:validate-proclaim" generic/specific ("jazz:Walker~virtual") 490 22 490 44 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:validate-arguments" generic/specific ("jazz:Walker~virtual") 491 22 491 45 ("form-src" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "jazz:runtime-export" generic/specific ("jazz:Walker~virtual") 492 22 492 41 ("declaration")}
      {Lisp-Entry "jazz:lookup-analyse" generic/specific ("jazz:Walker~virtual") 493 22 493 41 ("referenced-declaration" "symbol-src" "declaration")}
      {Lisp-Entry "%%get-module-declaration-walker-literals" define #f 497 9 497 49 ("%%get-module-declaration-walker" "%%get-walker-literals" "lib-decl")}
      {Lisp-Entry "%%set-module-declaration-walker-literals" define #f 499 9 499 49 ("%%get-module-declaration-walker" "%%set-walker-literals" "value" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-variables" define #f 501 9 501 50 ("%%get-module-declaration-walker" "%%get-walker-variables" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-references" define #f 503 9 503 51 ("%%get-module-declaration-walker" "%%get-walker-references" "lib-decl")}
      {Lisp-Entry "%%get-module-declaration-walker-autoloads" define #f 505 9 505 50 ("%%get-module-declaration-walker" "%%get-walker-autoloads" "lib-decl")}
      {Lisp-Entry "%%set-module-declaration-walker-autoloads" define #f 507 9 507 50 ("%%get-module-declaration-walker" "%%set-walker-autoloads" "value" "lib-decl")}
      {Lisp-Entry "jazz:Walk-Context" define-class ("class") 516 19 516 36 ("%%get-walk-context-pathname" "pathname" "%%get-walk-context-locator" "locator" "%%get-walk-context-policy" "policy" "jazz:allocate-walk-context" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Walk-Location" define-class ("class") 527 19 527 37 ("%%get-walk-location-path" "path" "%%get-walk-location-locat" "locat" "%%get-walk-location-declaration-locator" "declaration-locator" "%%get-walk-location-unit-locator" "unit-locator" "jazz:allocate-walk-location" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Walk-Problem" define-class ("class") 539 19 539 36 ("%%get-walk-problem-location" "location" "jazz:Object-Class" "message" "jazz:Error")}
      {Lisp-Entry "jazz:Walk-Problems" define-class ("class") 548 19 548 37 ("%%get-walk-problems-errors" "errors" "%%get-walk-problems-warnings" "warnings" "jazz:allocate-walk-problems" "jazz:Object-Class" "message" "jazz:Error")}
      {Lisp-Entry "jazz:Walk-Warning" define-class ("class") 558 19 558 36 ("jazz:allocate-walk-warning" "jazz:Object-Class" "location" "message" "jazz:Walk-Problem")}
      {Lisp-Entry "jazz:Walk-Error" define-class ("class") 567 19 567 34 ("jazz:allocate-walk-error" "jazz:Object-Class" "location" "message" "jazz:Walk-Problem")}
      {Lisp-Entry "jazz:Unresolved-Error" define-class ("class") 576 19 576 40 ("%%get-unresolved-error-symbol" "symbol" "jazz:allocate-unresolved-error" "jazz:Object-Class" "location" "message" "jazz:Walk-Error")}
      {Lisp-Entry "jazz:Walk-Frame" define-class ("class") 585 19 585 34 ("%%get-walk-frame-bindings" "bindings" "jazz:allocate-walk-frame" "jazz:Object-Class" "jazz:Walk-Binding")}
      {Lisp-Entry "jazz:Signature" define-class ("class") 594 19 594 33 ("%%get-signature-rest" "rest" "%%get-signature-named" "named" "%%get-signature-optional" "optional" "%%get-signature-positional" "positional" "%%get-signature-mandatory" "mandatory" "jazz:allocate-signature" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Symbol-Binding" define-class ("class") 607 19 607 38 ("%%set-symbol-binding-gensym" "%%get-symbol-binding-gensym" "gensym" "jazz:Object-Class" "hits" "type" "name" "jazz:Lexical-Binding")}
      {Lisp-Entry "jazz:Variable" define-class ("class") 616 19 616 32 ("%%set-variable-reference-count" "%%get-variable-reference-count" "reference-count" "jazz:allocate-variable" "jazz:Object-Class" "gensym" "hits" "type" "name" "jazz:Symbol-Binding")}
      {Lisp-Entry "jazz:NextMethod-Variable" define-class ("class") 625 19 625 43 ("jazz:allocate-nextmethod-variable" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz:Variable")}
      {Lisp-Entry "jazz:Parameter" define-class ("class") 634 19 634 33 ("jazz:allocate-parameter" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz:Variable")}
      {Lisp-Entry "jazz:emit-parameter" generic/specific ("jazz:Parameter~virtual") 638 22 638 41 ("environment" "declaration")}
      {Lisp-Entry "jazz:Dynamic-Parameter" define-class ("class") 646 19 646 41 ("%%get-dynamic-parameter-class" "class" "jazz:allocate-dynamic-parameter" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz:Parameter")}
      {Lisp-Entry "jazz:Optional-Parameter" define-class ("class") 655 19 655 42 ("%%set-optional-parameter-default" "%%get-optional-parameter-default" "default" "jazz:allocate-optional-parameter" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz:Parameter")}
      {Lisp-Entry "jazz:Named-Parameter" define-class ("class") 664 19 664 39 ("%%set-named-parameter-default" "%%get-named-parameter-default" "default" "jazz:allocate-named-parameter" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz:Parameter")}
      {Lisp-Entry "jazz:Rest-Parameter" define-class ("class") 673 19 673 38 ("jazz:allocate-rest-parameter" "jazz:Object-Class" "reference-count" "gensym" "hits" "type" "name" "jazz:Parameter")}
      {Lisp-Entry "jazz:Self-Binding" define-class ("class") 682 19 682 36 ("jazz:allocate-self-binding" "jazz:Object-Class" "hits" "type" "name" "jazz:Lexical-Binding")}
      {Lisp-Entry "jazz:Dynamic-Self-Binding" define-class ("class") 691 19 691 44 ("%%get-dynamic-self-binding-code" "code" "jazz:allocate-dynamic-self-binding" "jazz:Object-Class" "hits" "type" "name" "jazz:Lexical-Binding")}
      {Lisp-Entry "jazz:Local-Variable-Binding" define-class ("class") 700 19 700 46 ("%%get-local-variable-binding-variable" "variable" "jazz:allocate-local-variable-binding" "jazz:Object-Class" "hits" "type" "name" "jazz:Lexical-Binding")}
      {Lisp-Entry "jazz:Macro-Symbol" define-class ("class") 709 19 709 36 ("%%get-macro-symbol-setter" "setter" "%%get-macro-symbol-getter" "getter" "jazz:allocate-macro-symbol" "jazz:Object-Class" "gensym" "hits" "type" "name" "jazz:Symbol-Binding")}
      {Lisp-Entry "jazz:Form-Binding" define-class ("class") 719 19 719 36 ("jazz:Object-Class" "hits" "type" "name" "jazz:Lexical-Binding")}
      {Lisp-Entry "jazz:Special-Form" define-class ("class") 728 19 728 36 ("%%get-special-form-walk" "walk" "jazz:allocate-special-form" "jazz:Object-Class" "hits" "type" "name" "jazz:Form-Binding")}
      {Lisp-Entry "jazz:Macro-Form" define-class ("class") 737 19 737 34 ("%%get-macro-form-expander" "expander" "jazz:allocate-macro-form" "jazz:Object-Class" "hits" "type" "name" "jazz:Form-Binding")}
      {Lisp-Entry "jazz:Syntax-Form" define-class ("class") 746 19 746 35 ("%%get-syntax-form-expander" "expander" "jazz:allocate-syntax-form" "jazz:Object-Class" "hits" "type" "name" "jazz:Form-Binding")}
      {Lisp-Entry "jazz:Define-Syntax-Form" define-class ("class") 755 19 755 42 ("%%get-define-syntax-form-environment" "environment" "jazz:allocate-define-syntax-form" "jazz:Object-Class" "expander" "hits" "type" "name" "jazz:Syntax-Form")}
      {Lisp-Entry "jazz:Define-Local-Syntax-Form" define-class ("class") 764 19 764 48 ("%%get-define-local-syntax-form-environment" "environment" "jazz:allocate-define-local-syntax-form" "jazz:Object-Class" "expander" "hits" "type" "name" "jazz:Syntax-Form")}
      {Lisp-Entry "jazz:Syntactic-Closure" define-class ("class") 773 19 773 41 ("%%get-syntactic-closure-form" "form" "%%get-syntactic-closure-variables" "variables" "%%get-syntactic-closure-environment" "environment" "jazz:allocate-syntactic-closure" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Annotated-Variable" define-class ("class") 784 19 784 42 ("%%set-annotated-variable-type" "%%get-annotated-variable-type" "type" "%%get-annotated-variable-declared-type" "declared-type" "%%get-annotated-variable-variable" "variable" "jazz:allocate-annotated-variable" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Restricted-Binding" define-class ("class") 795 19 795 42 ("%%get-restricted-binding-type" "type" "%%get-restricted-binding-binding" "binding" "jazz:allocate-restricted-binding" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Annotated-Frame" define-class ("class") 805 19 805 39 ("%%get-annotated-frame-reset" "reset" "%%get-annotated-frame-variables" "variables" "jazz:allocate-annotated-frame" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Code" define-class ("class") 815 19 815 28 ("%%get-code-source" "source" "%%get-code-type" "type" "%%get-code-form" "form" "jazz:allocate-code" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Access" define-class ("class") 827 19 827 30 ("%%get-access-context" "context" "%%get-access-name" "name" "jazz:allocate-access" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Expression" define-class ("class") 837 19 837 34 ("%%get-expression-source" "source" "%%get-expression-type" "type" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Expression~virtual") 842 22 842 42 ("environment" "declaration")}
      {Lisp-Entry "jazz:emit-call" generic/specific ("jazz:Expression~virtual") 843 22 843 36 ("environment" "declaration" "arguments")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Expression~virtual") 844 22 844 42 ("s" "k" "f")}
      {Lisp-Entry "jazz:Proclaim" define-class ("class") 852 19 852 32 ("%%get-proclaim-clauses" "clauses" "jazz:allocate-proclaim" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Constant" define-class ("class") 861 19 861 32 ("%%get-constant-expansion" "expansion" "jazz:allocate-constant" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Delay" define-class ("class") 870 19 870 29 ("%%get-delay-expression" "expression" "jazz:allocate-delay" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Quasiquote" define-class ("class") 879 19 879 34 ("%%get-quasiquote-form" "form" "jazz:allocate-quasiquote" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Binding-Reference" define-class ("class") 888 19 888 41 ("%%get-reference-binding" "binding" "jazz:allocate-binding-reference" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Reference-Reification" define-class ("class") 897 19 897 45 ("%%get-reference-reification-resolver" "resolver" "%%get-reference-reification-reference" "reference" "jazz:allocate-reference-reification" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Method-Reference" define-class ("class") 907 19 907 40 ("jazz:allocate-method-reference" "jazz:Object-Class" "binding" "source" "type" "jazz:Binding-Reference")}
      {Lisp-Entry "jazz:Assignment" define-class ("class") 916 19 916 34 ("%%get-assignment-value" "value" "%%get-assignment-binding" "binding" "jazz:allocate-assignment" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Lambda" define-class ("class") 926 19 926 30 ("%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "jazz:allocate-lambda" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Let" define-class ("class") 936 19 936 27 ("%%get-let-body" "body" "%%get-let-bindings" "bindings" "jazz:allocate-let" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Named-Let" define-class ("class") 946 19 946 33 ("%%get-named-let-variable" "variable" "jazz:allocate-named-let" "jazz:Object-Class" "body" "bindings" "source" "type" "jazz:Let")}
      {Lisp-Entry "jazz:Letstar" define-class ("class") 955 19 955 31 ("%%get-letstar-body" "body" "%%get-letstar-bindings" "bindings" "jazz:allocate-letstar" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Letrec" define-class ("class") 965 19 965 30 ("%%get-letrec-body" "body" "%%get-letrec-bindings" "bindings" "jazz:allocate-letrec" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Receive" define-class ("class") 975 19 975 31 ("%%get-receive-body" "body" "%%get-receive-expression" "expression" "%%get-receive-variables" "variables" "jazz:allocate-receive" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Body" define-class ("class") 986 19 986 28 ("%%get-body-expressions" "expressions" "%%get-body-internal-defines" "internal-defines" "jazz:allocate-body" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Internal-Define" define-class ("class") 996 19 996 39 ("%%get-internal-define-value" "value" "%%get-internal-define-variable" "variable" "jazz:allocate-internal-define" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Begin" define-class ("class") 1006 19 1006 29 ("%%get-begin-expressions" "expressions" "jazz:allocate-begin" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Do" define-class ("class") 1015 19 1015 26 ("%%get-do-body" "body" "%%get-do-result" "result" "%%get-do-test" "test" "%%get-do-bindings" "bindings" "jazz:allocate-do" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Call" define-class ("class") 1027 19 1027 28 ("%%get-call-arguments" "arguments" "%%get-call-operator" "operator" "jazz:allocate-call" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:If" define-class ("class") 1037 19 1037 26 ("%%get-if-no" "no" "%%get-if-yes" "yes" "%%get-if-test" "test" "jazz:allocate-if" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Cond" define-class ("class") 1048 19 1048 28 ("%%get-cond-clauses" "clauses" "jazz:allocate-cond" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Case" define-class ("class") 1057 19 1057 28 ("%%get-case-clauses" "clauses" "%%get-case-target" "target" "jazz:allocate-case" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:And" define-class ("class") 1067 19 1067 27 ("%%get-and-expressions" "expressions" "jazz:allocate-and" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Or" define-class ("class") 1076 19 1076 26 ("%%get-or-expressions" "expressions" "jazz:allocate-or" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Declare" define-class ("class") 1085 19 1085 31 ("%%get-declare-declarations" "declarations" "jazz:allocate-declare" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:C-Include" define-class ("class") 1094 19 1094 33 ("%%get-c-include-name" "name" "jazz:allocate-c-include" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:C-Declare" define-class ("class") 1103 19 1103 33 ("%%get-c-declare-code" "code" "jazz:allocate-c-declare" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:C-Named-Declare-Declaration" define-class ("class") 1112 19 1112 51 ("%%get-c-named-declare-declaration-code" "code" "jazz:allocate-c-named-declare-declaration" "jazz:Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz:Declaration")}
      {Lisp-Entry "jazz:C-Initialize" define-class ("class") 1121 19 1121 36 ("%%get-c-initialize-code" "code" "jazz:allocate-c-initialize" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:C-Function" define-class ("class") 1130 19 1130 34 ("%%get-c-function-expansion" "expansion" "jazz:allocate-c-function" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Parameterize" define-class ("class") 1139 19 1139 36 ("%%get-parameterize-body" "body" "%%get-parameterize-bindings" "bindings" "jazz:allocate-parameterize" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Time-Special" define-class ("class") 1149 19 1149 36 ("%%get-time-special-expressions" "expressions" "jazz:allocate-time" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Walk-Failed-Special" define-class ("class") 1158 19 1158 43 ("%%get-walk-failed-special-answer" "answer" "jazz:allocate-walk-failed" "jazz:Object-Class" "source" "type" "jazz:Expression")}
      {Lisp-Entry "jazz:Analysis-Data" define-class ("class") 1167 19 1167 37 ("%%set-analysis-data-declaration-references" "%%get-analysis-data-declaration-references" "declaration-references" "%%set-analysis-data-autoload-reference" "%%get-analysis-data-autoload-reference" "autoload-reference" "jazz:allocate-analysis-data" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Core-Dialect" define-class ("class") 1177 19 1177 36 ("jazz:allocate-core-dialect" "jazz:Object-Class" "bindings" "jazz:Dialect")}
      {Lisp-Entry "jazz:Core-Walker" define-class ("class") 1186 19 1186 35 ("jazz:allocate-core-walker" "jazz:Object-Class" "autoloads" "references" "variables" "literals" "errors" "warnings" "jazz:Walker")}}})
"define-class"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "define-class.scm"} 1299179879 scheme
    {Lisp-Entry "core.class.syntax.define-class" unit #f 37 16 37 46 ()
      {Lisp-Entry "jazz:define-class" define-macro ("macro") 40 20 40 37 (",inherited-slot-names" ",',inherited-slot-names" "jazz:validate-inherited-slots" "jazz:reference-name" "jazz:set-core-class" ",instance-size" ",',instance-size" ",slot-names" ",',slot-names" ",ascendant-accessor" ",',ascendant-accessor" "eq?" "test:" "%%make-table" ",class-accessor" ",',class-accessor" "jazz:new-core-class" ",',name" "%%string-append" "%%string->symbol" "jazz:naturals" "%%object-set!" "value" ",slot-setter" ",rank" "%%object-ref" "jazz:expected-error" "jazz:object-of-class?" "%%core-assertion" "object" ",slot-getter" "%%cddr" "slot-setter" "%%cadr" "slot-getter" "%%car" "let" "rank" "slot" "%%object" "%%list" ",@all-variables" "class" ",constructor" "jazz:define-macro" ",name" "jazz:define-variable" "jazz:debug-core?" "begin" "jazz:object-size" "%%fx+" "instance-size" "all-length" "%%symbol->string" "jazz:generate-symbol" "slot-name" "lambda" "all-variables" "%%append" "all-slot-names" "car" "map" "slot-names" "%%length" "ascendant-size" "ascendant-accessor" "%%null?" "if" "class-accessor" "let*" "proc" "jazz:parse-define-class" "define" "slots" "constructor" "class-name" "inherited-slot-names" "ascendant-name" "name")}
      {Lisp-Entry "jazz:define-class-runtime" define-macro ("macro") 95 20 95 45 ("%%symbol->string" "%%string-append" "%%string->symbol" "name")}}})
"define-method"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "define-method.scm"} 1299164384 scheme
    {Lisp-Entry "core.class.syntax.define-method" unit #f 37 16 37 47 ()
      {Lisp-Entry "jazz:define-virtual" define-macro ("macro") 40 20 40 39 ("jazz:expand-define-virtual" "%%car" "%%null?" "if" "bootstrap-type?" "let" "rest" "signature")}
      {Lisp-Entry "jazz:define-virtual-runtime" define-macro ("macro") 45 20 45 47 ("jazz:expand-define-virtual-runtime" "signature")}
      {Lisp-Entry "jazz:define-method" define-macro ("macro") 49 20 49 38 ("jazz:expand-define-method" "body" "signature")}}})
"define-method-expander"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "define-method-expander.scm"} 1299164384 scheme
    {Lisp-Entry "core.class.syntax.define-method-expander" unit #f 37 16 37 56 ()
      {Lisp-Entry "jazz:expand-define-virtual" define #f 40 9 40 35 ("obj" "lambda" "jazz:with-uniqueness" ",rank-name" "%%get-object-class" "%%get-class-core-vtable" "%%vector-ref" "jazz:format" "jazz:error" ",class-name" ",is-test" "%%core-assertion" "%%list" "%%symbol?" ",@extra-parameters" ",object-parameter" ",name" "jazz:define-macro" "%%class-is?" "jazz:bootstrap-type?" "if" "is-test" "jazz:method-rank-name" "rank-name" "jazz:method-implementation-name" "implementation-name" "extra-parameters" "%%cadr" "object-parameter" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "bootstrap-type?" "signature")}
      {Lisp-Entry "jazz:expand-define-virtual-runtime" define #f 75 9 75 43 (",name" ",class-name" "jazz:register-virtual-name" ",rank-name" "define" "jazz:method-rank-name" "rank-name" "jazz:method-implementation-name" "implementation-name" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "signature")}
      {Lisp-Entry "jazz:expand-define-method" define #f 85 9 85 34 ("jazz:register-method" ",@body" ",@extra-parameters" ",object-parameter" "lambda" ",name" ",class-name" "jazz:find-nextmethod" "nextmethod" "let" ",implementation-name" "define" "begin" "jazz:method-implementation-name" "implementation-name" "extra-parameters" "%%cadr" "object-parameter" "%%caar" "class-name" "%%cdr" "parameters" "%%car" "name" "let*" "body" "signature")}
      {Lisp-Entry "jazz:method-implementation-name" define #f 100 9 100 40 ("%%string-append" "%%string->symbol" "%%symbol->string" "jazz:split-string" "jazz:last" "let" "name" "class-name")}
      {Lisp-Entry "jazz:method-rank-name" define #f 105 9 105 30 ("%%symbol->string" "%%string-append" "%%string->symbol" "implementation-name")}
      {Lisp-Entry "jazz:inherited-name?" define #f 109 9 109 29 ("%%get-class-core-virtual-names" "%%memq" "and" "%%get-class-ascendant" "ascendant" "let" "method-name" "class")}
      {Lisp-Entry "jazz:register-virtual-name" define #f 115 9 115 35 ("1" "%%length" "%%fx-" "%%list" "%%get-class-core-virtual-names" "%%append" "%%set-class-core-virtual-names" "method-name" "class")}
      {Lisp-Entry "jazz:register-method" define #f 123 9 123 29 ("%%get-class-core-virtual-alist" "%%set-class-core-virtual-alist" "%%cons" "%%list" "%%get-class-core-method-alist" "%%append" "%%set-class-core-method-alist" "jazz:inherited-name?" "if" "method-implementation" "method-name" "class")}
      {Lisp-Entry "jazz:get-method-rank" define #f 133 9 133 29 ("1" "%%fx+" "%%cdr" "%%car" "%%eq?" "jazz:error" "%%null?" "if" "0" "rank" "%%get-class-core-virtual-names" "scan" "iter" "let" "method-name" "class")}
      {Lisp-Entry "jazz:get-method-implementation" define #f 143 9 143 39 ("jazz:get-method-rank" "%%get-class-core-vtable" "%%vector-ref" "method-name" "class")}
      {Lisp-Entry "jazz:find-nextmethod" define #f 148 9 148 29 ("jazz:error" "rest" "obj" "lambda" "%%get-class-ascendant" "jazz:get-method-implementation" "jazz:inherited-name?" "if" "method-name" "class")}}})
"development"
 ({Lisp-File-Entry {File :context "src" "core" "module" "development.scm"} 1299164385 scheme
    {Lisp-Entry "core.module.development" unit #f 38 6 38 29 ()
      {Lisp-Entry "require" anonymous #f 41 1 41 8 ("core.base")}
      {Lisp-Entry "jazz:parse" define #f 49 9 49 19 ("jazz:desourcify-all" "pretty-print" "jazz:read-toplevel-form" "form-src" "jazz:find-unit-src" "src" "let" "unit-name")}
      {Lisp-Entry "jazz:parse-source" define #f 56 9 56 26 ("jazz:present-source" "pretty-print" "jazz:read-toplevel-form" "form-src" "jazz:find-unit-src" "src" "let*" "interpret" "jazz:walk-for" "parameterize" "unit-name")}
      {Lisp-Entry "jazz:expand-unit" define #f 69 9 69 25 ("jazz:expand-module-source" "module" "jazz:expand-unit-source" "unit" "case" "0" "jazz:generate-symbol-counter" "jazz:generate-symbol-context" "jazz:generate-symbol-for" "jazz:requested-unit-resource" "jazz:requested-unit-name" "cdr" "rest" "car" "jazz:source-code" "kind" "jazz:read-toplevel-form" "form" "jazz:find-unit-src" "src" "let*" "walk" "or" "jazz:walk-for" "parameterize" "walk-for" "#!key" "unit-name")}
      {Lisp-Entry "jazz:expand" define #f 85 9 85 20 ("current-output-port" "jazz:expand-to-port" "apply" "rest" "unit-name")}
      {Lisp-Entry "jazz:expand-to-port" define #f 89 9 89 28 ("jazz:expand-unit" "apply" "jazz:desourcify-all" "pretty-print" "rest" "port" "unit-name")}
      {Lisp-Entry "jazz:expand-to-file" define #f 95 9 95 28 ("jazz:expand-to-port" "apply" "port" "lambda" "or" "call-with-output-file" "jazz:scheme-readtable" "current-readtable" "parameterize" "rest" "#!rest" "file" "#!key" "unit-name")}
      {Lisp-Entry "jazz:expand-source" define #f 102 9 102 27 ("jazz:expand-unit" "apply" "jazz:present-source" "pretty-print" "rest" "unit-name")}
      {Lisp-Entry "jazz:lookup" define #f 113 9 113 20 ("jazz:walk-unit" "jazz:lookup-declaration" "access" "name" "module-name")}}})
"error"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "error.scm"} 1299164385 scheme
    {Lisp-Entry "core.base.runtime.error" unit #f 37 16 37 39 ()
      {Lisp-Entry "jazz:unimplemented" define #f 40 9 40 27 ("%%car" "jazz:error" "%%null?" "if" "rest")}}}
  {Lisp-File-Entry {File :context "src" "core" "class" "syntax" "error.scm"} 1299164385 scheme
    {Lisp-Entry "core.class.syntax.error" unit #f 37 16 37 39 ()
      {Lisp-Entry "jazz:object-of-class?" define-macro ("variable") 40 22 40 43 ()}
      {Lisp-Entry "jazz:not-object-error" define #f 43 9 43 30 ("jazz:error" "obj")}
      {Lisp-Entry "jazz:outside-object-error" define #f 47 9 47 34 ("jazz:error" "rnk" "obj")}
      {Lisp-Entry "jazz:expected-error" define #f 51 9 51 28 ("jazz:error" "obj" "class")}}}
  {Lisp-File-Entry {File :context "src" "core" "exception" "runtime" "error.scm"} 1299164385 scheme
    {Lisp-Entry "core.exception.runtime.error" unit #f 37 16 37 44 ("jazz:raise-jazz-error" "jazz:error" "set!" "jazz:encapsulate-class" "jazz:Error")
      {Lisp-Entry "jazz:Error" define-class ("class runtime") 40 27 40 37 ()}
      {Lisp-Entry "jazz:new-error" define #f 43 9 43 23 ("jazz:Error" "jazz:allocate-error" "message")}
      {Lisp-Entry "jazz:get-message" generic/specific ("jazz:Error") 47 21 47 37 ("error" "%%get-error-message")}
      {Lisp-Entry "jazz:present-exception" generic/specific ("jazz:Error") 51 21 51 43 ("error" "%%get-error-message")}
      {Lisp-Entry "jazz:raise-jazz-error" define #f 58 9 58 30 ("jazz:new-error" "raise" "jazz:format" "apply" "message" "let" "proper-tail-calls" "declare" "rest" "fmt-string")}}})
"exception"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "exception.scm"} 1299164385 scheme
    {Lisp-Entry "core.base.runtime.exception" unit #f 38 16 38 43 ()
      {Lisp-Entry "jazz:current-exception-handler" define #f 43 12 43 42 ("current-exception-handler")}
      {Lisp-Entry "jazz:with-exception-handler" define #f 46 13 46 40 ("continuation-return" "exc" "with-exception-handler" "return" "lambda" "continuation-capture" "thunk" "proc")}
      {Lisp-Entry "jazz:exception-reason" define #f 54 13 54 34 ("jazz:format" "%%not" "if" "arguments" "message" "condition-property-accessor" "location" "let" "exc")}
      {Lisp-Entry "jazz:current-exception-handler" define #f 63 12 63 42 ("current-exception-handler")}
      {Lisp-Entry "jazz:with-exception-handler" define #f 66 12 66 39 ("with-exception-handler")}
      {Lisp-Entry "jazz:with-exception-catcher" define #f 69 12 69 39 ("with-exception-catcher")}
      {Lisp-Entry "jazz:display-exception" define #f 72 12 72 34 ("display-exception")}
      {Lisp-Entry "jazz:display-continuation-backtrace" define #f 75 12 75 47 ("display-continuation-backtrace")}
      {Lisp-Entry "jazz:raise" define #f 78 13 78 23 ("raise" "obj")}}}
  {Lisp-File-Entry {File :context "src" "core" "exception" "runtime" "exception.scm"} 1299164385 scheme
    {Lisp-Entry "core.exception.runtime.exception" unit #f 37 16 37 48 ("newline" "jazz:present-exception" "display" "begin" "%%is?" "%%object?" "and" "if" "port" "exc" "lambda" "set!" "##display-exception-hook" "previous-hook" "let" "jazz:System-Exception" "jazz:Exception-Detail" "jazz:encapsulate-class" "jazz:Exception")
      {Lisp-Entry "jazz:Exception" define-class ("class runtime") 45 27 45 41 ()}
      {Lisp-Entry "jazz:print-object" generic/specific ("jazz:Exception") 48 21 48 38 ("if" "jazz:object->serial" "jazz:format" "exception" "jazz:get-message" "message" "let" "detail" "output")}
      {Lisp-Entry "jazz:present-exception" generic/specific ("jazz:Exception~virtual-runtime") 56 30 56 52 ()}
      {Lisp-Entry "jazz:get-message" generic/specific ("jazz:Exception~virtual-runtime") 57 30 57 46 ()}
      {Lisp-Entry "jazz:get-detail" generic/specific ("jazz:Exception~virtual-runtime") 58 30 58 45 ()}
      {Lisp-Entry "jazz:present-exception" generic/specific ("jazz:Exception") 61 21 61 43 ("get-output-string" "exception" "jazz:format" "open-output-string" "output" "let")}
      {Lisp-Entry "jazz:get-message" generic/specific ("jazz:Exception") 67 21 67 37 ()}
      {Lisp-Entry "jazz:get-detail" generic/specific ("jazz:Exception") 71 21 71 36 ()}
      {Lisp-Entry "jazz:Exception-Detail" define-class ("class runtime") 83 27 83 48 ()}
      {Lisp-Entry "jazz:new-exception-detail" define #f 86 9 86 34 ("jazz:Exception-Detail" "jazz:allocate-exception-detail" "children" "location" "title" "icon")}
      {Lisp-Entry "jazz:System-Exception" define-class ("class runtime") 98 27 98 48 ()}
      {Lisp-Entry "jazz:present-exception" generic/specific ("jazz:System-Exception") 101 21 101 43 ("exception" "%%get-system-exception-exception" "jazz:exception-reason")}
      {Lisp-Entry "jazz:exception-reason" define #f 113 9 113 30 ("%%substring" "1" "%%fx-" "%%string-ref" "%%eqv?" "0" "%%fx>" "and" "if" "string-length" "len" "get-output-string" "str" "jazz:display-exception" "open-output-string" "output" "let" "exc")}
      {Lisp-Entry "jazz:exception-detail" define #f 124 9 124 30 ("jazz:get-detail" "jazz:Exception" "%%is?" "%%object?" "and" "if" "exc")}
      {Lisp-Entry "jazz:exception-location" define #f 131 9 131 32 ("##exception->locat" "cont" "exc")}
      {Lisp-Entry "jazz:with-exception-filter" define #f 156 9 156 35 ("%%continuation-graft" "filter-exc" "if" "exc" "with-exception-handler" "catcher-cont" "lambda" "%%continuation-capture" "current-exception-handler" "previous-handler" "let" "thunk" "catcher" "filter")}
      {Lisp-Entry "jazz:with-exception-propagater" define #f 181 9 181 39 ("current-exception-handler" "let" "%%continuation-graft" "raise-cont" "exc" "with-exception-handler" "catcher-cont" "lambda" "%%continuation-capture" "thunk" "handler")}}})
"expander"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "syntax" "expander.scm"} 1299164385 scheme
    {Lisp-Entry "core.generic.syntax.expander" unit #f 38 16 38 44 ()
      {Lisp-Entry "jazz:dynamic-parameter?" define #f 41 9 41 32 ("%%cdr" "jazz:composite-identifier?" "or" "%%car" "type" "let" "%%pair?" "and" "parameter")}
      {Lisp-Entry "jazz:dynamic-parameter-type" define #f 49 9 49 36 ("jazz:specifier->name" "jazz:specifier?" "if" "%%car" "type" "let" "parameter")}
      {Lisp-Entry "jazz:dynamic-parameter-types" define #f 56 9 56 37 ("%%cdr" "jazz:dynamic-parameter-type" "%%cons" "%%car" "jazz:dynamic-parameter?" "%%pair?" "and" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "jazz:dynamic-parameter-name" define #f 65 9 65 36 ("%%cadr" "parameter")}
      {Lisp-Entry "jazz:dynamic-parameter-names" define #f 69 9 69 37 ("%%cdr" "jazz:dynamic-parameter-name" "%%cons" "%%car" "jazz:dynamic-parameter?" "%%pair?" "and" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "jazz:generic-parameters" define #f 78 9 78 32 ("jazz:reverse!" "values" "else" "%%symbol?" "jazz:dynamic-parameter-name" "%%cons" "%%cdr" "jazz:dynamic-parameter?" "cond" "%%car" "parameter" "%%pair?" "if" "result" "iterate" "let" "parameters")}
      {Lisp-Entry "jazz:specific-parameters" define #f 92 9 92 33 ("else" "%%cdr" "jazz:dynamic-parameter-name" "%%cons" "jazz:dynamic-parameter?" "cond" "%%car" "parameter" "%%pair?" "if" "iterate" "let" "parameters")}
      {Lisp-Entry "jazz:expand-define-generic" define #f 108 9 108 35 ("apply" "jazz:dynamic-parameter-names" ",parameter" "jazz:class-of" "parameter" "map" "%%specific-dispatch" ",gensym-specific" "jazz:process-pending-specifics" "%%get-generic-pending-specifics" "%%not" "%%when" ",gensym-rest" ",@mandatory-parameters" ",@dynamic-signature" "%%list" "jazz:new-generic" "jazz:generic-reset" "jazz:global-ref" ",gensym-generic" "jazz:global-bound?" ",generic-locator" ",@body" ",generic-method-locator" "jazz:error" ",formal-signature" "lambda" ",specific-implementation-locator" "define" "begin" "%%null?" "if" "gensym-rest" "let" "jazz:generic-parameters" "extra-parameters" "mandatory-parameters" "receive" "gensym-specific" "jazz:generate-symbol" "gensym-generic" "jazz:generic-object-locator" "generic-locator" "jazz:implementation-locator" "specific-implementation-locator" "jazz:specific-parameters" "formal-signature" "jazz:dynamic-parameter-types" "dynamic-signature" "%%cdr" "parameters" "%%car" "generic-method-locator" "let*" "body" "signature")}
      {Lisp-Entry "jazz:generic-object-locator" define #f 144 9 144 36 ("%%symbol->string" "%%string-append" "%%string->symbol" "locator")}
      {Lisp-Entry "jazz:expand-define-specific" define #f 153 9 153 36 (",generic-locator" "jazz:register-specific" "%%set-specific-implementation" ",@body" ",@nextmethod-bindings" "let" ",formal-signature" ",gensym-lambda" ",@dynamic-signature" "lambda" "jazz:new-specific" ",specific-implementation-locator" "define" ",gensym-specific" "%%get-specific-ancestor-specifics" "%%get-specific-implementation" "nextmethod" "%%list" "if" "nextmethod-bindings" "gensym-lambda" "jazz:generate-symbol" "gensym-specific" "jazz:generic-object-locator" "generic-locator" "jazz:implementation-locator" "specific-implementation-locator" "jazz:specific-parameters" "formal-signature" "jazz:dynamic-parameter-types" "dynamic-signature" "%%cdr" "parameters" "%%car" "generic-method-locator" "root" "%%eq?" "root?" "let*" "body" "modifier" "signature")}
      {Lisp-Entry "jazz:implementation-locator" define #f 174 9 174 36 ("jazz:join-strings" "%%string-append" "%%string->symbol" "%%car" "%%pair?" "if" "class/call" "lambda" "map" "dynamic-signature-strings" "%%symbol->string" "generic-string" "let" "dynamic-signature" "generic-locator")}}})
"expression"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "walker" "expression.scm"} 1299164549 scheme
    {Lisp-Entry "core.module.syntax.walker.expression" unit #f 37 16 37 52 ("jazz:Walker" "jazz:Time-Special" "jazz:Parameterize" "jazz:Declare" "jazz:Or" "jazz:And" "jazz:Case" "jazz:Cond" "jazz:If" "jazz.dialect.kernel:not-null?" "jazz:not-type-tests" "jazz:Unspecified" "jazz.dialect.kernel:unspecified?" "jazz:Values" "jazz.dialect.kernel:values?" "jazz:Foreign" "jazz.dialect.kernel:foreign?" "jazz:Thread" "jazz.dialect.kernel:thread?" "jazz:Table" "jazz.dialect.kernel:table?" "jazz:Method" "jazz.dialect.kernel:method?" "jazz:Slot" "jazz.dialect.kernel:slot?" "jazz:Field" "jazz.dialect.kernel:field?" "jazz:Interface" "jazz.dialect.kernel:interface?" "jazz:Class" "jazz.dialect.kernel:class?" "jazz:Category" "jazz.dialect.kernel:category?" "jazz:Object" "jazz.dialect.kernel:object?" "jazz:Keyword" "jazz.dialect.kernel:keyword?" "jazz:Flonum" "jazz.dialect.kernel:flonum?" "jazz:Fixnum" "jazz.dialect.kernel:fixnum?" "jazz:EOF" "scheme.dialect.kernel:eof-object?" "scheme.dialect.kernel:output-port?" "jazz:Port" "scheme.dialect.kernel:input-port?" "jazz:Procedure" "scheme.dialect.kernel:procedure?" "jazz:Continuation" "jazz.dialect.kernel:continuation?" "jazz:F64Vector" "jazz.dialect.kernel:f64vector?" "jazz:F32Vector" "jazz.dialect.kernel:f32vector?" "jazz:U64Vector" "jazz.dialect.kernel:u64vector?" "jazz:S64Vector" "jazz.dialect.kernel:s64vector?" "jazz:U32Vector" "jazz.dialect.kernel:u32vector?" "jazz:S32Vector" "jazz.dialect.kernel:s32vector?" "jazz:U16Vector" "jazz.dialect.kernel:u16vector?" "jazz:S16Vector" "jazz.dialect.kernel:s16vector?" "jazz:U8Vector" "jazz.dialect.kernel:u8vector?" "jazz:S8Vector" "jazz.dialect.kernel:s8vector?" "jazz:Vector" "scheme.dialect.kernel:vector?" "jazz:String" "scheme.dialect.kernel:string?" "jazz:Char" "scheme.dialect.kernel:char?" "jazz:Symbol" "scheme.dialect.kernel:symbol?" "jazz:Pair" "scheme.dialect.kernel:pair?" "jazz:Null" "scheme.dialect.kernel:null?" "jazz:List" "scheme.dialect.kernel:list?" "jazz:Boolean" "scheme.dialect.kernel:boolean?" "jazz:Integer" "scheme.dialect.kernel:integer?" "jazz:Rational" "scheme.dialect.kernel:rational?" "jazz:Real" "scheme.dialect.kernel:real?" "jazz:Complex" "scheme.dialect.kernel:complex?" "jazz:Number" "scheme.dialect.kernel:number?" "jazz:type-tests" "%%table-set!" "jazz:emit-inlined-call" ",name" "name" "jazz:bind" "jazz:reference-name" "primitive" "jazz:get-primitive-patterns" "patterns" "jazz:emit-primitive-call" "string^int^char:void" "##string-set!" "vector^int^any:void" "##vector-set!" "jazz.dialect.language.functional:set-element!" "string^int:char" "##string-ref" "vector^int:any" "##vector-ref" "list^int:any" "list-ref" "jazz.dialect.language.functional:element" "string:int" "##string-length" "vector:int" "##vector-length" "list:int" "##length" "scheme.dialect.kernel:length" "##cdr" "scheme.dialect.kernel:cdr" "pair:any" "##car" "scheme.dialect.kernel:car" "##eqv?" "scheme.dialect.kernel:eqv?" "any^any:bool" "##eq?" "scheme.dialect.kernel:eq?" "any:bool" "##not" "scheme.dialect.kernel:not" "fl:fx" "##flonum->fixnum" "jazz.dialect.kernel:flonum->fixnum" "fx:fl" "##fixnum->flonum" "jazz.dialect.kernel:fixnum->flonum" "jazz.dialect.kernel:fl/" "jazz.dialect.kernel:fl*" "jazz.dialect.kernel:fl-" "fl^fl:fl" "jazz.dialect.kernel:fl+" "jazz.dialect.kernel:fx*" "jazz.dialect.kernel:fx-" "jazz.dialect.kernel:fx+" "##flround" "scheme.dialect.kernel:round" "##fltruncate" "scheme.dialect.kernel:truncate" "##flceiling" "scheme.dialect.kernel:ceiling" "fl:fl" "##flfloor" "scheme.dialect.kernel:floor" "fx^fx:fx" "##fxquotient" "scheme.dialect.kernel:quotient" "##/" "##fl/" "##*" "##fl*" "##fx*" "##-" "fl^fl*:fl" "##fl-" "fx^fx*:fx" "##fx-" "number^number:number" "int^int:int" "##+" "fl*:fl" "##fl+" "fx*:fx" "##fx+" "##fl>=" "##fx>=" "##fl>" "##fx>" "##fl<=" "##fx<=" "##fl<" "##fx<" "number^number:bool" "##=" "fl*:bool" "##fl=" "fx*:bool" "##fx=" "jazz:add-primitive-patterns" "jazz:emit-primitive-new-call" "%%cdr" "%%get-function-type-result" "jazz:codes-forms" ",locator" "jazz:new-code" "jazz:emit-inlined-binding-call" "jazz:match-signature?" "%%get-lexical-binding-type" "function-type" "%%car" "specializer" "on" "jazz:debug-specializers" "%%get-lexical-binding-name" "specialized" "match" "to" "unable" "%%get-declaration-locator" "In" "Warning:" "jazz:debug" "scheme.dialect.kernel:/" "scheme.dialect.kernel:*" "scheme.dialect.kernel:-" "scheme.dialect.kernel:+" "scheme.dialect.kernel:>=" "scheme.dialect.kernel:>" "scheme.dialect.kernel:<=" "scheme.dialect.kernel:<" "scheme.dialect.kernel:=" "%%memq" "optimizations" "%%get-declaration-toplevel" "jazz:get-module-warn?" "jazz:warnings?" "and" "%%when" "begin" "%%null?" "scan" "iter" "jazz:codes-types" "types" "jazz:get-specializers" "specializers" "%%get-reference-binding" "binding" "let" "jazz:Binding-Reference" "%%class-is?" "jazz:emit-specialized-locator" "or" "%%not" "if" "environment" "declaration" "call" "arguments-codes" "arguments" "locator" "operator" "lambda" "jazz:emit-specialized-call" "set!" "jazz:Do" "jazz:Receive" "jazz:Letrec" "jazz:Letstar" "jazz:Named-Let" "jazz:Let" "jazz:Lambda" "jazz:Method-Reference" "jazz:Quasiquote" "jazz:Delay" "jazz:encapsulate-class" "jazz:Proclaim")
      {Lisp-Entry "jazz:Proclaim" define-class ("class runtime") 45 27 45 40 ()}
      {Lisp-Entry "jazz:new-proclaim" define #f 48 9 48 26 ("jazz:Proclaim" "jazz:allocate-proclaim" "clauses")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Proclaim") 52 21 52 41 ("jazz:proclaim" "clause" "lambda" "for-each" "%%get-declaration-toplevel" "module-declaration" "expression" "%%get-proclaim-clauses" "clauses" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Proclaim") 61 21 61 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Delay" define-class ("class runtime") 73 27 73 37 ()}
      {Lisp-Entry "jazz:new-delay" define #f 76 9 76 23 ("jazz:Delay" "jazz:allocate-delay" "expression")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Delay") 80 21 80 41 ("jazz:Any" "jazz:emit-expression" "jazz:sourcified-form" "delay" "jazz:new-code" "%%get-delay-expression" "expression" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Delay") 88 21 88 41 ("%%get-delay-expression" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Quasiquote" define-class ("class runtime") 102 27 102 42 ()}
      {Lisp-Entry "jazz:new-quasiquote" define #f 105 9 105 28 ("jazz:Quasiquote" "jazz:allocate-quasiquote" "form")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Quasiquote") 109 21 109 41 ("jazz:List" "expression" "%%get-quasiquote-form" "quasiquote" "jazz:new-code" "%%cdr" "%%cons" "%%cadr" "jazz:emit-expression" "jazz:sourcified-form" "%%list" "unquote-splicing" "unquote" "%%car" "%%eq?" "or" "%%pair?" "if" "form" "emit" "define" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Quasiquote") 124 21 124 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Method-Reference" define-class ("class runtime") 136 27 136 48 ()}
      {Lisp-Entry "jazz:new-method-reference" define #f 139 9 139 34 ("jazz:Method-Reference" "jazz:allocate-method-reference" "binding")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Method-Reference") 143 21 143 41 ("jazz:Any" "%%get-lexical-binding-type" "or" "%%get-declaration-locator" "jazz:new-code" "expression" "%%get-reference-binding" "method-declaration" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:emit-call" generic/specific ("jazz:Method-Reference") 152 21 152 35 ("jazz:Any" "jazz:codes-forms" "expression" "jazz:emit-expression" "jazz:sourcified-form" "jazz:new-code" "environment" "declaration" "arguments")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Method-Reference") 159 21 159 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Lambda" define-class ("class runtime") 171 27 171 38 ()}
      {Lisp-Entry "jazz:new-lambda" define #f 174 9 174 24 ("jazz:Lambda" "jazz:allocate-lambda" "body" "signature" "source" "type")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Lambda") 178 21 178 41 ("%%get-expression-source" "jazz:new-function-type" ",@signature-casts" ",cast-body" ",signature-output" "%%not" "if" "%%get-code-type" "jazz:sourcified-form" "begin" "jazz:new-code" "jazz:emit-type-cast" "jazz:simplify-begin" "cast-body" "jazz:emit-signature-casts" "signature-casts" "jazz:emit-expression" "body-code" "jazz:emit-signature" "signature-output" "%%cons" "augmented-environment" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "expression" "%%get-expression-type" "type" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Lambda") 201 21 201 41 ("%%get-lambda-body" "jazz:fold-statement" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Lambda") 207 21 207 35 ("%%get-lambda-body" "jazz:tree-fold" "cons" "aug-env" "let" "frame" "lambda" "expression" "%%get-lambda-signature" "jazz:annotate-signature" "jazz:with-annotated-frame" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Let" define-class ("class runtime") 225 27 225 35 ()}
      {Lisp-Entry "jazz:new-let" define #f 228 9 228 21 ("jazz:Let" "jazz:allocate-let" "body" "bindings" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Let") 232 21 232 41 ("%%get-expression-source" "jazz:sourcified-form" ",bindings-output" "jazz:new-code" "body-code" "%%get-lexical-binding-type" "jazz:emit-type-cast" "jazz:emit-binding-symbol" "%%get-code-type" "jazz:extend-annotated-type" "jazz:emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz:annotate-bindings" "jazz:with-annotated-frame" "%%get-let-body" "body" "expression" "%%get-let-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Let") 256 21 256 41 ("%%get-let-body" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Let") 262 21 262 35 ("%%get-let-body" "jazz:tree-fold" "cdr" "jazz:tree-fold-list" "seed2" "seed1" "car" "map" "cons" "aug-env" "expression" "%%get-let-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Named-Let" define-class ("class runtime") 278 27 278 41 ()}
      {Lisp-Entry "jazz:new-named-let" define #f 281 9 281 27 ("jazz:Named-Let" "jazz:allocate-named-let" "body" "bindings" "variable" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Named-Let") 285 21 285 41 ("%%get-expression-source" "jazz:sourcified-form" ",bindings-output" "jazz:new-code" "body-code" "%%get-lexical-binding-type" "jazz:emit-type-cast" "jazz:emit-binding-symbol" "%%get-code-type" "jazz:extend-annotated-type" "jazz:emit-expression" "value-code" "%%cdr" "value" "%%car" "annotated-variable" "binding" "map" "bindings-output" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz:annotate-bindings" "jazz:Any" "jazz:new-annotated-variable" "%%cons" "jazz:with-annotated-frame" "%%get-let-body" "body" "%%get-let-bindings" "bindings" "expression" "%%get-named-let-variable" "variable" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Named-Let") 310 21 310 41 ("%%get-let-body" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Named-Let") 316 21 316 35 ("%%get-let-body" "jazz:tree-fold" "cdr" "jazz:tree-fold-list" "seed2" "seed1" "car" "map" "%%get-named-let-variable" "cons" "aug-env" "expression" "%%get-let-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Letstar" define-class ("class runtime") 332 27 332 39 ()}
      {Lisp-Entry "jazz:new-letstar" define #f 335 9 335 25 ("jazz:Letstar" "jazz:allocate-letstar" "body" "bindings" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Letstar") 339 21 339 41 ("%%get-expression-source" "jazz:sourcified-form" ",bindings-output" "let*" "jazz:new-code" "body-code" "%%get-lexical-binding-type" "jazz:emit-type-cast" "jazz:emit-binding-symbol" "%%get-code-type" "jazz:extend-annotated-type" "jazz:emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz:annotate-bindings" "jazz:with-annotated-frame" "%%get-letstar-body" "body" "expression" "%%get-letstar-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Letstar") 363 21 363 41 ("%%get-letstar-body" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Letstar") 369 21 369 35 ("%%get-letstar-body" "caar" "list" "cons" "cdar" "jazz:tree-fold" "cdr" "pair?" "if" "aug-env" "seed2" "expression" "%%get-letstar-bindings" "ls" "lp" "let" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Letrec" define-class ("class runtime") 388 27 388 38 ()}
      {Lisp-Entry "jazz:new-letrec" define #f 391 9 391 24 ("jazz:Letrec" "jazz:allocate-letrec" "body" "bindings" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Letrec") 395 21 395 41 ("%%get-expression-source" "jazz:sourcified-form" ",bindings-output" "letrec" "jazz:new-code" "body-code" "%%get-lexical-binding-type" "jazz:emit-type-cast" "jazz:emit-binding-symbol" "%%get-code-type" "jazz:extend-annotated-type" "jazz:emit-expression" "value-code" "%%cdr" "value" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz:annotate-bindings" "jazz:with-annotated-frame" "%%get-letrec-body" "body" "expression" "%%get-letrec-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Letrec") 419 21 419 41 ("%%get-letrec-body" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Letrec") 425 21 425 35 ("%%get-letrec-body" "jazz:tree-fold" "cdr" "jazz:tree-fold-list" "seed2" "seed1" "car" "map" "cons" "aug-env" "expression" "%%get-letrec-bindings" "bindings" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Receive" define-class ("class runtime") 441 27 441 39 ()}
      {Lisp-Entry "jazz:new-receive" define #f 444 9 444 25 ("jazz:Receive" "jazz:allocate-receive" "body" "expression" "variables" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Receive") 448 21 448 41 ("%%get-expression-source" "%%get-code-type" ",expression-output" "jazz:emit-binding-symbol" "variable" "map" "receive" "jazz:new-code" "body-code" "jazz:emit-expression" "jazz:sourcified-form" "expression-output" "%%cons" "augmented-environment" "frame" "lambda" "jazz:annotate-receive" "jazz:with-annotated-frame" "%%get-receive-body" "body" "%%get-receive-expression" "expr" "expression" "%%get-receive-variables" "variables" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Receive") 467 21 467 41 ("%%get-receive-body" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Receive") 473 21 473 35 ("%%get-receive-body" "%%get-receive-expression" "jazz:tree-fold" "seed2" "seed1" "expression" "%%get-receive-variables" "cons" "aug-env" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Do" define-class ("class runtime") 488 27 488 34 ()}
      {Lisp-Entry "jazz:new-do" define #f 491 9 491 20 ("jazz:Do" "jazz:allocate-do" "body" "result" "test" "bindings")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Do") 495 21 495 41 ("%%get-code-type" ",bindings-output" "do" "jazz:new-code" "body-code" "result-code" "test-code" ",@step-code-list" ",init-code" "jazz:emit-binding-symbol" "%%list" "if" "step-code-list" "jazz:emit-expression" "jazz:sourcified-form" "init-code" "%%cddr" "step" "%%cadr" "init" "%%car" "variable" "annotated-variable" "binding" "map" "bindings-output" "%%cons" "augmented-environment" "%%get-annotated-frame-variables" "variables" "frame" "lambda" "jazz:annotate-bindings" "jazz:with-annotated-frame" "%%get-do-body" "body" "%%get-do-result" "result" "%%get-do-test" "test" "expression" "%%get-do-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Do") 527 21 527 41 ("%%get-do-body" "%%get-do-result" "%%get-do-test" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Do") 535 21 535 35 ("%%get-do-test" "%%get-do-body" "%%get-do-result" "jazz:tree-fold" "cddr" "or" "x" "lambda" "seed2" "cadr" "jazz:tree-fold-list" "seed1" "expression" "%%get-do-bindings" "car" "map" "cons" "aug-env" "let*" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:specializers" define #f 559 8 559 25 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:add-specializer" define #f 563 9 563 29 ("%%list" "%%table-ref" "%%append" "jazz:specializers" "%%table-set!" "specializer" "specialized-declaration")}
      {Lisp-Entry "jazz:get-specializers" define #f 569 9 569 30 ("jazz:specializers" "%%table-ref" "binding")}
      {Lisp-Entry "jazz:emit-specialized-locator" define #f 615 8 615 37 ()}
      {Lisp-Entry "jazz:primitive-patterns" define #f 650 8 650 31 ()}
      {Lisp-Entry "jazz:initialize-primitive-patterns" define #f 654 9 654 43 ("set!" "jazz:primitive-patterns" "jazz:walk-specifier" "%%list" "%%cadr" "specifier" "name" "pattern" "map" "%%table-set!" "%%cdr" "patterns" "%%car" "operator" "pair" "lambda" "for-each" "eq?" "test:" "%%make-table" "table" "let")}
      {Lisp-Entry "jazz:add-primitive-patterns" define #f 669 9 669 36 ("%%cons" "jazz:primitive-patterns" "set!" "patterns" "operator")}
      {Lisp-Entry "jazz:get-primitive-patterns" define #f 673 9 673 36 ("jazz:primitive-patterns" "%%table-ref" "locator")}
      {Lisp-Entry "jazz:match-signature?" define #f 764 9 764 30 ("list-tail" "lambda" "jazz:every?" "%%get-rest-type-type" "match-rest?" "else" "%%cdr" "%%car" "cond" "expected" "types" "args" "iter" "%%null?" "%%not" "%%fx<=" "%%fx>=" "match-positional?" "jazz:Any" "%%subtype?" "%%get-category-type-declaration" "%%get-reference-binding" "%%eq?" "jazz:Binding-Reference" "and" "or" "jazz:Category-Type" "%%class-is?" "if" "expect" "type" "arg" "match?" "define" "%%get-function-type-rest" "rest" "%%get-function-type-named" "named" "%%get-function-type-optional" "optional" "%%get-function-type-positional" "positional" "%%get-function-type-mandatory" "mandatory" "%%length" "argcount" "let" "function-type" "argument-types" "arguments")}
      {Lisp-Entry "jazz:If" define-class ("class runtime") 813 27 813 34 ()}
      {Lisp-Entry "jazz:new-if" define #f 816 9 816 20 ("jazz:If" "jazz:allocate-if" "no" "yes" "test" "source")}
      {Lisp-Entry "jazz:type-tests" define #f 820 8 820 23 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:not-type-tests" define #f 871 8 871 27 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:restrict-type" define #f 878 9 878 27 ("jazz:new-restriction-type" "type" "base")}
      {Lisp-Entry "jazz:restriction-of?" define #f 882 9 882 29 ("%%get-restriction-type-type" "jazz:Restriction-Type" "%%class-is?" "and" "class" "type")}
      {Lisp-Entry "jazz:complement-type" define #f 887 9 887 29 ("jazz:new-complement-type" "jazz:new-restriction-type" "%%get-restriction-type-type" "%%get-complement-type-type" "%%get-restriction-type-base" "%%eq?" "jazz:Complement-Type" "jazz:restriction-of?" "and" "if" "type" "base")}
      {Lisp-Entry "jazz:branch-types" define #f 894 9 894 26 ("%%get-nillable-type-type" "jazz:Nillable-Type" "jazz:not-type-tests" "jazz:type-tests" "%%table-ref" "class" "jazz.dialect.language.functional:is-not?" "%%cadr" "2" "jazz.dialect.kernel:is?" "1" "%%fx=" "scheme.dialect.kernel:not" "case" "%%length" "count" "%%get-call-arguments" "arguments" "%%get-declaration-locator" "operator-locator" "operator-binding" "%%get-call-operator" "operator" "jazz:Call" "%%get-or-expressions" "jazz:Or" "%%get-and-expressions" "jazz:And" "%%get-lexical-binding-type" "values" "%%get-annotated-variable-variable" "jazz:find-annotated" "actual-variable" "frame" "jazz:Variable" "no" "jazz:new-restricted-binding" "%%list" "jazz:new-annotated-frame" "yes" "jazz:Pair" "jazz:Null" "jazz:List" "%%eq?" "no-type" "else" "jazz:resolve-binding" "jazz:Declaration" "%%get-reference-binding" "binding" "jazz:Binding-Reference" "%%class-is?" "jazz:type?" "cond" "yes-type" "extract-binding" "actual-type" "origin" "receive" "type-expr" "process-is" "process-or" "%%cons" "%%cdr" "newenv" "%%car" "%%null?" "if" "augmented" "scan" "iter" "let" "expr-list" "process-and" "process-expr" "revenv" "env" "expr" "process-not" "define" "environment" "test")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:If") 1015 21 1015 41 ("%%get-expression-source" "%%get-code-type" "jazz:extend-type" "jazz:simplify-begin" "jazz:sourcified-form" "if" "jazz:new-code" "%%get-if-no" "no" "%%get-if-yes" "yes" "jazz:emit-expression" "jazz:branch-types" "no-environment" "yes-environment" "jazz:bind" "expression" "%%get-if-test" "test" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:If") 1029 21 1029 41 ("%%get-if-no" "%%get-if-yes" "%%get-if-test" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:If") 1037 21 1037 35 ("%%get-if-test" "%%get-if-yes" "%%get-if-no" "jazz:tree-fold" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Cond" define-class ("class runtime") 1059 27 1059 36 ()}
      {Lisp-Entry "jazz:new-cond" define #f 1062 9 1062 22 ("jazz:Cond" "jazz:allocate-cond" "clauses" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Cond") 1066 21 1066 41 ("%%get-expression-source" "%%get-code-type" "lambda" "map" "jazz:extend-types" "%%cdr" "%%cons" "=>" "jazz:emit-expression" "jazz:sourcified-form" "else" "%%not" "output" "jazz:branch-types" "no-environment" "yes-environment" "jazz:bind" "%%cddr" "body" "%%cadr" "arrow?" "test" "%%car" "clause" "%%null?" "if" "recurse" "cond" "jazz:new-code" "expression" "%%get-cond-clauses" "clauses" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Cond") 1092 21 1092 41 ("%%get-cond-clauses" "jazz:fold-expression" "%%not" "if" "%%cdr" "body" "%%car" "test" "let" "clause" "lambda" "map" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Cond") 1104 21 1104 35 ("%%not" "%%cdr" "jazz:tree-fold" "%%cddr" "body" "test" "%%car" "clause" "let*" "null?" "if" "%%get-cond-clauses" "ls" "fold" "let" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Case" define-class ("class runtime") 1130 27 1130 36 ()}
      {Lisp-Entry "jazz:new-case" define #f 1133 9 1133 22 ("jazz:Case" "jazz:allocate-case" "clauses" "target" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Case") 1137 21 1137 41 ("%%get-expression-source" "%%get-code-type" "jazz:extend-types" ",tries" "%%car" "tries" "emited-clause" "jazz:sourcified-form" "case" "jazz:new-code" "jazz:emit-expression" "%%cdr" "body" "clause" "lambda" "map" "emited-clauses" "%%get-case-clauses" "clauses" "expression" "%%get-case-target" "target" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Case") 1157 21 1157 41 ("%%get-case-clauses" "cdr" "map" "jazz:fold-expressions" "%%get-case-target" "jazz:fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Case") 1163 21 1163 35 ("%%get-case-target" "jazz:tree-fold" "%%get-case-clauses" "cdr" "map" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:And" define-class ("class runtime") 1181 27 1181 35 ()}
      {Lisp-Entry "jazz:new-and" define #f 1184 9 1184 21 ("jazz:And" "jazz:allocate-and" "expressions" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:And") 1188 21 1188 41 ("%%get-expression-source" "jazz:Any" "expression" "%%get-and-expressions" "jazz:emit-expressions" "jazz:codes-forms" "and" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:And") 1195 21 1195 41 ("%%get-and-expressions" "jazz:fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:And") 1200 21 1200 35 ("%%get-and-expressions" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Or" define-class ("class runtime") 1216 27 1216 34 ()}
      {Lisp-Entry "jazz:new-or" define #f 1219 9 1219 20 ("jazz:Or" "jazz:allocate-or" "expressions" "source")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Or") 1223 21 1223 41 ("%%get-expression-source" "jazz:Any" "expression" "%%get-or-expressions" "jazz:emit-expressions" "jazz:codes-forms" "or" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Or") 1230 21 1230 41 ("%%get-or-expressions" "jazz:fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Or") 1235 21 1235 35 ("%%get-or-expressions" "jazz:tree-fold-list" "expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Declare" define-class ("class runtime") 1251 27 1251 39 ()}
      {Lisp-Entry "jazz:new-declare" define #f 1254 9 1254 25 ("jazz:Declare" "jazz:allocate-declare" "declarations")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Declare") 1258 21 1258 41 ("jazz:Any" ",@declarations" "declare" "jazz:new-code" "expression" "%%get-declare-declarations" "declarations" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Declare") 1266 21 1266 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:Parameterize" define-class ("class runtime") 1278 27 1278 44 ()}
      {Lisp-Entry "jazz:new-parameterize" define #f 1281 9 1281 30 ("jazz:Parameterize" "jazz:allocate-parameterize" "body" "bindings")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Parameterize") 1285 21 1285 41 ("%%get-code-type" "jazz:sourcified-form" "%%cdr" "value" "%%car" "variable" "binding" "lambda" "map" "parameterize" "jazz:new-code" "jazz:emit-expression" "body-code" "%%get-parameterize-body" "body" "expression" "%%get-parameterize-bindings" "bindings" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Parameterize") 1301 21 1301 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Parameterize") 1305 21 1305 35 ("%%get-parameterize-body" "jazz:tree-fold" "expression" "%%get-parameterize-bindings" "cdr" "map" "jazz:tree-fold-list" "seed2" "let" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Time-Special" define-class ("class runtime") 1321 27 1321 44 ()}
      {Lisp-Entry "jazz:new-time-special" define #f 1324 9 1324 30 ("jazz:Time-Special" "jazz:allocate-time" "expressions")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:Time-Special") 1328 21 1328 41 ("jazz:Any" "jazz:emit-expressions" "jazz:codes-forms" "begin" "time" "jazz:new-code" "expression" "%%get-time-special-expressions" "expressions" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:Time-Special") 1338 21 1338 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:validate-proclaim" generic/specific ("jazz:Walker~virtual-runtime") 1350 30 1350 52 ("form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:validate-proclaim" generic/specific ("jazz:Walker") 1353 21 1353 43 ("walker" "jazz:walk-error" "jazz:Module-Declaration" "%%class-is?" "%%not" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz:walk-proclaim" define #f 1358 9 1358 27 ("jazz:new-proclaim" "%%cdr" "clauses" "%%desourcify" "form" "let" "jazz:validate-proclaim" "form-src" "environment" "declaration" "resume" "walker")}}})
"ffi"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "walker" "ffi.scm"} 1299164387 scheme
    {Lisp-Entry "core.module.syntax.walker.ffi" unit #f 37 16 37 45 ("jazz:C-Function" "jazz:C-Initialize" "jazz:C-Named-Declare-Declaration" "jazz:C-Declare" "jazz:C-Include" "jazz:C-Definition-Declaration" "jazz:encapsulate-class" "jazz:C-Type-Declaration")
      {Lisp-Entry "jazz:C-Type-Declaration" define-class ("class runtime") 45 27 45 50 ()}
      {Lisp-Entry "jazz:new-c-type-declaration" define #f 48 9 48 36 ("jazz:setup-declaration" "jazz:C-Type-Declaration" "jazz:allocate-c-type-declaration" "new-declaration" "let" "declare" "scheme-to-c" "c-to-scheme" "inclusions" "base-type" "expansion" "kind" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:get-declaration-inclusions" generic/specific ("jazz:C-Type-Declaration") 54 21 54 52 ("declaration" "%%get-c-type-declaration-inclusions")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:C-Type-Declaration") 58 21 58 42 ("begin" "environment")}
      {Lisp-Entry "jazz:expand-referenced-declaration" generic/specific ("jazz:C-Type-Declaration") 62 21 62 55 ("%%list" "and" "if" ",expansion" ",locator" "c-define-type" "%%get-c-type-declaration-scheme-to-c" "scheme-to-c" "%%get-c-type-declaration-c-to-scheme" "c-to-scheme" "%%get-c-type-declaration-expansion" "expansion" "declaration" "%%get-declaration-locator" "locator" "let")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:C-Type-Declaration") 72 21 72 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:C-Definition-Declaration" define-class ("class runtime") 84 27 84 56 ()}
      {Lisp-Entry "jazz:new-c-definition-declaration" define #f 87 9 87 42 ("jazz:setup-declaration" "jazz:C-Definition-Declaration" "jazz:allocate-c-definition-declaration" "new-declaration" "let" "scope" "c-name" "result-type" "parameter-types" "signature" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:walk-binding-validate-call" generic/specific ("jazz:C-Definition-Declaration") 93 21 93 52 ("jazz:validate-arguments" "if" "declaration" "%%get-c-definition-declaration-signature" "signature" "let" "form-src" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:C-Definition-Declaration") 99 21 99 42 ("%%get-declaration-source" "jazz:emit-expression" "jazz:sourcified-form" ",scope" ",c-name" ",result-type" ",parameter-types" "jazz:emit-signature" "c-define" "jazz:sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz:annotate-signature" "jazz:with-annotated-frame" "%%get-c-definition-declaration-body" "body" "%%get-c-definition-declaration-scope" "scope" "%%get-c-definition-declaration-c-name" "c-name" "%%get-c-definition-declaration-result-type" "result-type" "%%get-c-definition-declaration-parameter-types" "parameter-types" "%%get-c-definition-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz:emit-binding-reference" generic/specific ("jazz:C-Definition-Declaration") 116 21 116 48 ("jazz:Any" "declaration" "%%get-declaration-locator" "jazz:new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:C-Definition-Declaration") 123 21 123 42 ("%%get-c-definition-declaration-body" "jazz:fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz:C-Include" define-class ("class runtime") 137 27 137 41 ()}
      {Lisp-Entry "jazz:new-c-include" define #f 140 9 140 27 ("jazz:C-Include" "jazz:allocate-c-include" "name")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:C-Include") 144 21 144 41 ("jazz:Any" "%%string-append" "c-declare" "jazz:new-code" "expression" "%%get-c-include-name" "name" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:C-Include") 152 21 152 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:C-Declare" define-class ("class runtime") 164 27 164 41 ()}
      {Lisp-Entry "jazz:new-c-declare" define #f 167 9 167 27 ("jazz:C-Declare" "jazz:allocate-c-declare" "code")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:C-Declare") 171 21 171 41 ("jazz:Any" ",code" "c-declare" "jazz:new-code" "expression" "%%get-c-declare-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:C-Declare") 179 21 179 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:C-Named-Declare-Declaration" define-class ("class runtime") 191 27 191 59 ()}
      {Lisp-Entry "jazz:new-c-named-declare-declaration" define #f 194 9 194 45 ("jazz:setup-declaration" "jazz:C-Named-Declare-Declaration" "jazz:allocate-c-named-declare-declaration" "new-declaration" "let" "code" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz:emit-declaration" generic/specific ("jazz:C-Named-Declare-Declaration") 200 21 200 42 ("begin" "environment")}
      {Lisp-Entry "jazz:expand-referenced-declaration" generic/specific ("jazz:C-Named-Declare-Declaration") 204 21 204 55 (",code" "c-declare" "declaration" "%%get-c-named-declare-declaration-code" "code" "let")}
      {Lisp-Entry "jazz:fold-declaration" generic/specific ("jazz:C-Named-Declare-Declaration") 209 21 209 42 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:C-Initialize" define-class ("class runtime") 221 27 221 44 ()}
      {Lisp-Entry "jazz:new-c-initialize" define #f 224 9 224 30 ("jazz:C-Initialize" "jazz:allocate-c-initialize" "code")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:C-Initialize") 228 21 228 41 ("jazz:Any" ",code" "c-initialize" "jazz:new-code" "expression" "%%get-c-initialize-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:C-Initialize") 236 21 236 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz:C-Function" define-class ("class runtime") 248 27 248 42 ()}
      {Lisp-Entry "jazz:new-c-function" define #f 251 9 251 28 ("jazz:C-Function" "jazz:allocate-c-function" "expansion")}
      {Lisp-Entry "jazz:emit-expression" generic/specific ("jazz:C-Function") 255 21 255 41 ("jazz:Any" "expression" "%%get-c-function-expansion" "jazz:new-code" "environment" "declaration")}
      {Lisp-Entry "jazz:fold-expression" generic/specific ("jazz:C-Function") 262 21 262 41 ("expression" "s" "k" "f")}}})
"generic"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "runtime" "generic.scm"} 1299164388 scheme
    {Lisp-Entry "core.generic.runtime.generic" unit #f 38 16 38 44 ()
      {Lisp-Entry "jazz:new-generic" define #f 41 9 41 25 ("jazz:generic-make-root" "jazz:Generic" "jazz:allocate-generic" "generic" "jazz:identifier-name" "name" "let*" "root-proc" "dynamic-signature" "locator")}
      {Lisp-Entry "jazz:generic-reset" define #f 48 9 48 27 ("%%get-generic-root-specific" "%%get-specific-dynamic-signature" "jazz:generic-make-root" "root-proc" "generic")}
      {Lisp-Entry "jazz:generic-make-root" define #f 52 9 52 31 ("%%get-generic-pending-specifics" "%%cons" "%%set-generic-pending-specifics" "%%set-generic-root-specific" "jazz:invalid-generic-call" "apply" "rest" "lambda" "or" "jazz:new-specific" "root-specific" "let" "root-proc" "dynamic-signature" "generic")}
      {Lisp-Entry "jazz:invalid-generic-call" define #f 58 9 58 34 ("jazz:generic-error" "%%cdr" "%%car" "jazz:class-of" "%%cons" "%%pair?" "and" "if" "%%get-generic-root-specific" "%%get-specific-dynamic-signature" "signature" "iter" "dynamic-parameters" "let" "rest" "generic")}
      {Lisp-Entry "jazz:generic-error" define #f 68 9 68 27 ("%%cons" "jazz:error" "%%get-generic-root-specific" "%%get-specific-dynamic-signature" "root-signature" "%%get-generic-name" "name" "let" "signature" "generic")}
      {Lisp-Entry "jazz:register-specific" define #f 80 9 80 31 ("%%get-generic-pending-specifics" "%%cons" "%%set-generic-pending-specifics" "specific" "generic")}
      {Lisp-Entry "jazz:process-pending-specifics" define #f 89 9 89 39 ("%%set-generic-pending-specifics" "%%get-generic-pending-specifics" "%%reverse" "jazz:insert/replace-specific" "specific" "lambda" "for-each" "%%get-generic-root-specific" "jazz:resolve-signature" "generic")}
      {Lisp-Entry "jazz:resolve-signature" define #f 99 9 99 31 ("%%set-specific-dynamic-signature" "%%procedure?" "%%when" "%%get-specific-dynamic-signature" "signature/proc" "let" "specific")}
      {Lisp-Entry "jazz:insert/replace-specific" define #f 105 9 105 37 ("%%set-car!" "%%set-generic-root-specific" "%%get-generic-root-specific" "perfect-match" "%%set-specific-descendant-specifics" "set!" "%%memq" "%%when" "else" "jazz:remove!" "%%get-specific-ancestor-specifics" "brothers" "brother-partition" "descendants" "%%assq" "descendant-partition" "assv" "jazz:dynamic-signature-compare" "ordered" "%%eq?" "descendant-signature" "descendant" "%%get-specific-descendant-specifics" "jazz:partition" "partition" "ancestor-signature" "ancestor" "lambda" "for-each" "%%set-specific-ancestor-specifics" "descendant-specifics" "ancestors" "jazz:generic-error" "%%not" "cond" "jazz:gather-dynamic-signature-ancestors" "matches" "%%get-specific-dynamic-signature" "dynamic-signature" "let*" "%%cons" "jazz:specific-better?" "%%pair?" "if" "others" "%%car" "best" "%%cdr" "scan" "iter" "let" "specifics" "put-best-first" "define" "specific" "generic")}
      {Lisp-Entry "jazz:gather-dynamic-signature-ancestors" define #f 180 9 180 48 ("%%null?" "else" "%%cons" "%%memq" "%%cdr" "%%get-specific-descendant-specifics" "found-in-descendants" "ordered" "set!" "equal" "%%get-specific-dynamic-signature" "jazz:dynamic-signature-compare" "case" "%%car" "specific" "%%pair?" "if" "partial-matches" "%%get-generic-root-specific" "%%list" "specifics" "iter" "or" "perfect-match" "let" "dynamic-signature" "generic")}
      {Lisp-Entry "jazz:dynamic-signature-compare" define #f 206 9 206 39 ("else" "ordered" "reverse-ordered" "jazz:subcategory?" "%%cdr" "%%car" "%%eq?" "cond" "unordered" "and" "%%null?" "or" "if" "equal" "match" "iter" "let" "ancestor-signature" "descendant-signature")}
      {Lisp-Entry "jazz:dynamic-signature-equal?" define #f 228 9 228 38 ("%%cdr" "%%car" "%%eq?" "and" "%%null?" "or" "if" "iter" "let" "dynamic-signature2" "dynamic-signature1")}
      {Lisp-Entry "jazz:specific-better?" define #f 237 9 237 30 ("%%cdr" "%%car" "%%get-class-level" "%%fx>" "or" "signature2" "%%get-specific-dynamic-signature" "signature1" "iter" "let" "specific2" "specific1")}
      {Lisp-Entry "jazz:display-tree" define #f 249 9 249 26 ("1" "%%fx+" "newline" "%%get-specific-descendant-specifics" "%%get-specific-ancestor-specifics" "%%get-specific-dynamic-signature" "write" "specific" "lambda" "for-each" "0" "level" "%%get-generic-root-specific" "%%list" "specifics" "iterate" "let" "jazz:process-pending-specifics" "%%get-generic-pending-specifics" "%%null?" "%%not" "%%when" "generic")}
      {Lisp-Entry "jazz:dispatch-from-root" define #f 274 9 274 32 ("else" "%%car" "%%pair?" "jazz:generic-error" "%%not" "cond" "jazz:gather-dynamic-signature-ancestors" "matches" "let" "dynamic-classes" "generic")}}}
  {Lisp-File-Entry {File :context "src" "core" "generic" "syntax" "generic.scm"} 1299164387 scheme
    {Lisp-Entry "core.generic.syntax.generic" unit #f 44 16 44 43 ("jazz:Generic" "jazz:encapsulate-class")
      {Lisp-Entry "jazz:Generic" define-class ("class") 47 19 47 31 ("%%set-generic-pending-specifics" "%%get-generic-pending-specifics" "pending-specifics" "%%set-generic-root-specific" "%%get-generic-root-specific" "root-specific" "%%get-generic-name" "name" "%%get-generic-locator" "locator" "jazz:allocate-generic" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Generic" define-class ("class runtime") 54 27 54 39 ()}
      {Lisp-Entry "jazz:define-generic" define-macro ("macro") 57 20 57 39 ("jazz:expand-define-generic" "%%apply" "rest")}
      {Lisp-Entry "%%specific-dispatch" define-macro ("macro") 61 20 61 39 (",dynamic-classes" ",generic" "jazz:dispatch-from-root" "%%get-specific-implementation" "dynamic-classes" "generic")}}})
"initialize"
 ({Lisp-File-Entry {File :context "src" "core" "module" "initialize.scm"} 1299164388 scheme
    {Lisp-Entry "core.module.initialize" unit #f 37 16 37 38 ("jazz:initialize-primitive-patterns")}})
"keyword"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "keyword.scm"} 1299164388 scheme
    {Lisp-Entry "core.base.runtime.keyword" unit #f 37 16 37 41 ()
      {Lisp-Entry "jazz:keyword?" define #f 42 13 42 26 ("keyword?" "obj")}
      {Lisp-Entry "jazz:keyword->string" define #f 45 13 45 33 ("keyword->string" "keyword")}
      {Lisp-Entry "jazz:string->keyword" define #f 48 13 48 33 ("string->keyword" "string")}
      {Lisp-Entry "jazz:keyword?" define #f 52 13 52 26 ("%%keyword?" "obj")}
      {Lisp-Entry "jazz:keyword->string" define #f 55 13 55 33 ("%%keyword->string" "keyword")}
      {Lisp-Entry "jazz:string->keyword" define #f 58 13 58 33 ("%%string->keyword" "string")}
      {Lisp-Entry "jazz:keyword?" define #f 62 12 62 25 ("1" "%%string-length" "%%fx-" "%%string-ref" "%%eqv?" "%%symbol->string" "str" "let" "%%symbol?" "and" "obj")}
      {Lisp-Entry "jazz:keyword->string" define #f 68 12 68 32 ("1" "%%length" "%%fx-" "0" "%%substring" "%%symbol->string" "str" "let" "keyword")}
      {Lisp-Entry "jazz:string->keyword" define #f 73 12 73 32 ("%%string-append" "%%string->symbol" "string")}}})
"list"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "list.scm"} 1299164388 scheme
    {Lisp-Entry "core.base.runtime.list" unit #f 37 16 37 38 ()
      {Lisp-Entry "jazz:find-in" define #f 40 9 40 21 ("%%cdr" "%%car" "or" "%%null?" "if" "scan" "iter" "let" "lst" "proc")}
      {Lisp-Entry "jazz:find-if" define #f 48 9 48 21 ("%%cdr" "%%car" "value" "%%null?" "if" "scan" "iter" "let" "lst" "predicate")}
      {Lisp-Entry "jazz:getprop" define #f 58 9 58 21 ("%%cddr" "else" "%%car" "%%eqv?" "%%null?" "cond" "scan" "iter" "let" "target" "plist")}
      {Lisp-Entry "jazz:getf" define #f 68 9 68 18 ("%%cadr" "if" "jazz:getprop" "pair" "let" "not-found" "#!key" "target" "plist")}
      {Lisp-Entry "jazz:reverse!" define #f 75 8 75 21 ("reverse")}
      {Lisp-Entry "jazz:list-copy" define #f 79 9 79 23 ("obj" "lambda" "map" "lst")}
      {Lisp-Entry "jazz:last-tail" define #f 83 9 83 23 ("else" "%%null?" "cond" "%%cdr" "tail" "scan" "iter" "let" "%%pair?" "if" "lst")}
      {Lisp-Entry "jazz:last-pair" define #f 96 9 96 23 ("%%cdr" "tail" "scan" "iter" "let" "%%pair?" "if" "lst")}
      {Lisp-Entry "jazz:last" define #f 106 9 106 18 ("jazz:last-pair" "%%car" "lst")}
      {Lisp-Entry "jazz:remove-duplicates" define #f 110 9 110 31 ("%%cons" "%%memv" "%%cdr" "result" "%%car" "value" "%%not-null?" "if" "scan" "iter" "let" "lst")}
      {Lisp-Entry "jazz:partition" define #f 121 9 121 23 ("%%set-cdr!" "begin" "%%list" "%%cons" "%%not" "set" "category" "%%car" "element" "%%cdr" "partition" "let*" "%%null?" "if" "scan" "iter" "let" "associate" "key" "lst")}
      {Lisp-Entry "jazz:rassq" define #f 136 9 136 19 ("%%cdr" "else" "%%car" "%%cdar" "%%eq?" "%%null?" "cond" "rest" "iter" "let" "alist" "obj")}
      {Lisp-Entry "jazz:butlast" define #f 146 9 146 21 ("jazz:butlast" "%%car" "%%cons" "%%cdr" "%%null?" "if" "lst")}
      {Lisp-Entry "jazz:naturals" define #f 152 9 152 22 ("jazz:reverse!" "1" "%%fx+" "%%cons" "set!" "%%fx<" "%%while" "n" "lst" "let" "to" "from")}
      {Lisp-Entry "jazz:remove!" define #f 161 9 161 21 ("%%set-cdr!" "scan" "previous" "let" "begin" "%%null?" "if" "%%cdr" "set!" "%%car" "%%eqv?" "%%not-null?" "and" "%%while" "lst" "target")}
      {Lisp-Entry "jazz:values?" define #f 180 9 180 21 ("%%values?" "obj")}}})
"macros"
 ({Lisp-File-Entry {File :context "src" "core" "base" "syntax" "macros.scm"} 1299164388 scheme
    {Lisp-Entry "core.base.syntax.macros" unit #f 37 16 37 39 ()
      {Lisp-Entry "%%boolean" define-macro ("syntax") 40 20 40 29 (",expr" "if" "jazz:source-code" "%%cadr" "expr" "let" "src" "lambda")}
      {Lisp-Entry "%%not-null?" define-macro ("syntax") 46 20 46 31 (",expr" "%%null?" "%%not" "jazz:source-code" "%%cadr" "expr" "let" "src" "lambda")}
      {Lisp-Entry "%%when" define-macro ("syntax") 57 20 57 26 (",@body" "begin" ",test" "if" "%%cddr" "body" "jazz:source-code" "%%cadr" "test" "let" "src" "lambda")}
      {Lisp-Entry "%%while" define-macro ("syntax") 72 20 72 27 (",@body" "begin" ",test" "if" ",iter" "jazz:generate-symbol" "iter" "%%cddr" "body" "jazz:source-code" "%%cadr" "test" "let" "src" "lambda")}
      {Lisp-Entry "%%core-assert" define-macro ("syntax") 89 20 89 33 ("jazz:debug-core?" "jazz:expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%core-assertion" define-macro ("syntax") 94 20 94 36 ("jazz:debug-core?" "jazz:expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "%%debug-assert" define-macro ("syntax") 99 20 99 34 ("jazz:debug-user?" "jazz:expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%debug-assertion" define-macro ("syntax") 104 20 104 37 ("jazz:debug-user?" "jazz:expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "%%assert" define-macro ("syntax") 109 20 109 28 ("jazz:expand-%%assert" "src" "lambda")}
      {Lisp-Entry "%%assertion" define-macro ("syntax") 114 20 114 31 ("jazz:expand-%%assertion" "src" "lambda")}
      {Lisp-Entry "jazz:expand-%%assert" define #f 119 9 119 29 ("error" "jazz:expand-%%assertion-body" "%%unspecified" "%%list" "%%null?" "if" "effective-body" "get-output-string" "%%desourcify" "write" "display" "open-output-string" "port" "message" "%%cddr" "body" "jazz:source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "jazz:expand-%%assertion" define #f 131 9 131 32 ("jazz:expand-%%assertion-body" "%%unspecified" "%%list" "%%null?" "if" "effective-body" "%%cdr" "body" "%%cddr" "%%car" "action" "jazz:source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "jazz:expand-%%assertion-body" define #f 139 9 139 37 (",@body" "begin" "jazz:simplify-begin" ",action" ",assertion" "%%not" "if" "body" "action" "assertion" "test?")}
      {Lisp-Entry "jazz:bind" define-macro ("macro") 166 20 166 29 (",tree-symbol" "tree-symbol" ",cdr-symbol" "cdr-symbol" ",@body" ",cdr-binding" "%%cdr" "cdr-binding" ",car-symbol" "jazz:error" "%%null?" "if" "jazz:generate-symbol" "car-symbol" "%%pair?" "expand-cdr" ",tree" ",car-binding" "%%symbol?" "cond" "%%car" "car-binding" "let" "expand-car" "define" "body" "tree" "bindings")}
      {Lisp-Entry "%%compose-identifier" define-macro ("macro") 203 20 203 40 (",s2" ",s1" "%%symbol->string" "%%string-append" "%%string->symbol" "s2" "s1")}
      {Lisp-Entry "%%compose-reference" define-macro ("macro") 207 20 207 39 (",s2" ",s1" "%%symbol->string" "%%string-append" "%%string->symbol" "s2" "s1")}}})
"module"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "module.scm"} 1299164388 scheme
    {Lisp-Entry "core.module.syntax.module" unit #f 37 16 37 41 ()
      {Lisp-Entry "module" define-macro ("syntax") 40 20 40 26 ("jazz:save-emit-if" "jazz:source-code" "%%cdr" "jazz:expand-module-source" "emit" "let" "form-src" "lambda")}
      {Lisp-Entry "script" define-macro ("syntax") 47 20 47 26 ("jazz:source-code" "%%cdr" "jazz:expand-script-source" "form-src" "lambda")}}})
"object"
 ({Lisp-File-Entry {File :context "src" "core" "class" "syntax" "object.scm"} 1299164388 scheme
    {Lisp-Entry "core.class.syntax.object" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz:instances-statistics?" define #f 41 8 41 34 ()}
      {Lisp-Entry "jazz:instances-statistics" define #f 45 8 45 33 ("eq?" "test:" "%%make-table" "jazz:instances-statistics?" "if")}
      {Lisp-Entry "jazz:register-instance" define #f 51 9 51 31 ("%%cons" "list" "0" "%%table-ref" "%%fx+" "jazz:instances-statistics" "%%table-set!" "count" "case" "1" "##vector-ref" "name" "if" "jazz:keep-instances-statistics" "keep" "let" "obj" "class")}
      {Lisp-Entry "%%register-instance" define-macro ("macro") 65 20 65 39 (",obj" ",class" "jazz:register-instance" "jazz:instances-statistics?" "if" "obj" "class")}
      {Lisp-Entry "%%object-content" define #f 73 12 73 28 ("0")}
      {Lisp-Entry "%%object-marker" define #f 77 11 77 26 ("jazz:object")}
      {Lisp-Entry "%%object-content" define #f 80 11 80 27 ("1")}
      {Lisp-Entry "jazz:object-class" define #f 84 8 84 25 ("%%object-content")}
      {Lisp-Entry "jazz:object-size" define #f 88 8 88 24 ("1" "jazz:object-class" "%%fx+")}
      {Lisp-Entry "%%subtype-jazz" define-macro ("macro") 94 24 94 38 ("7")}
      {Lisp-Entry "%%object?" define-macro ("macro") 97 24 97 33 (",expr" "##jazz?" "expr")}
      {Lisp-Entry "%%object" define-macro ("macro") 100 24 100 32 ("%%register-instance" "%%subtype-jazz" ",@rest" ",cls" "##vector" "##subtype-set!" ",obj" "jazz:generate-symbol" "obj" "let" "jazz:instances-statistics?" "if" "cls" "lambda" "jazz:with-uniqueness" "rest" "class")}
      {Lisp-Entry "%%make-object" define-macro ("macro") 110 24 110 37 ("%%register-instance" ",cls" "%%set-object-class" "%%subtype-jazz" "%%unspecified" ",size" "%%make-vector" "##subtype-set!" ",obj" "jazz:generate-symbol" "obj" "let" "cls" "lambda" "jazz:with-uniqueness" "size" "class")}
      {Lisp-Entry "%%object-length" define-macro ("macro") 119 24 119 39 (",object" "##vector-length" "jazz:not-object-error" ",obj" "%%object?" "%%core-assertion" "obj" "lambda" "jazz:with-uniqueness" "jazz:debug-core?" "if" "object")}
      {Lisp-Entry "%%object-ref" define-macro ("macro") 127 24 127 36 (",object" ",n" "##vector-ref" "jazz:not-object-error" ",obj" "%%object?" "%%core-assertion" "rnk" "obj" "lambda" "jazz:with-uniqueness" "jazz:debug-core?" "if" "n" "object")}
      {Lisp-Entry "%%object-set!" define-macro ("syntax") 140 24 140 37 (",object" ",value" ",n" "##vector-set!" "jazz:not-object-error" ",obj" "%%object?" "%%core-assertion" "rnk" "obj" "jazz:with-uniqueness" "jazz:debug-core?" "if" "value" "%%cddr" "%%car" "n" "%%source-code" "%%cadr" "object" "let" "src" "lambda")}
      {Lisp-Entry "%%object?" define-macro ("macro") 158 23 158 32 ("%%object-marker" "%%object-ref" "%%eq?" "0" "%%object-length" "%%fx>" ",expr" "%%vector?" "and" "expr")}
      {Lisp-Entry "%%object" define-macro ("macro") 163 23 163 31 (",@rest" "%%object-marker" "%%vector" "rest")}
      {Lisp-Entry "%%make-object" define-macro ("macro") 166 23 166 36 ("%%object-marker" "0" "%%object-set!" "%%unspecified" ",size" "%%make-vector" ",object" "jazz:generate-symbol" "object" "let" "size")}
      {Lisp-Entry "%%object-length" define-macro ("macro") 172 23 172 38 (",vector" "%%vector-length" "vector")}
      {Lisp-Entry "%%object-ref" define-macro ("macro") 175 23 175 35 (",n" ",vector" "%%vector-ref" "n" "vector")}
      {Lisp-Entry "%%object-set!" define-macro ("macro") 178 23 178 36 (",value" ",n" ",vector" "%%vector-set!" "value" "n" "vector")}}})
"output"
 ({Lisp-File-Entry {File :context "src" "core" "class" "runtime" "output.scm"} 1299164548 scheme
    {Lisp-Entry "core.class.runtime.output" unit #f 37 16 37 41 ("jazz:print-jazz" "display" "eq?" "if" "detail" "let" "style" "port" "object" "jazz:print-hook" "jazz.dialect.language.object:Object:call-print" ":reader" "jazz:write" ":human" "jazz:output-value" "output" "value" "lambda" "jazz:display" "set!")
      {Lisp-Entry "jazz:output-mode" define #f 40 8 40 24 (":reader")}
      {Lisp-Entry "jazz:print" define #f 54 9 54 19 ("jazz:error" "else" "write" ":describe" ":text" ":reader" "display" ":human" "case" "detail" "output" "value")}
      {Lisp-Entry "jazz:->string" define #f 61 9 61 22 ("get-output-string" "jazz:output-mode" "jazz:output-value" "open-output-string" "output" "let" "else" "%%values?" "%%unspecified?" "cond" "value")}
      {Lisp-Entry "jazz:output-value" define #f 72 9 72 26 ("jazz:print-jazz" "else" "jazz:print" "jazz:primitive?" "jazz:output-list" "%%pair?" "%%null?" "or" "cond" "detail" "output" "value")}
      {Lisp-Entry "jazz:output-list" define #f 81 9 81 25 ("begin" "display" "%%pair?" "%%cdr" "set!" "%%car" "jazz:output-value" "and" "%%while" "done?" "scan" "let" "%%null?" "%%not" "if" "output-list-content" "define" "detail" "output" "lst")}
      {Lisp-Entry "jazz:debug" define #f 102 9 102 19 ("force-output" "newline" "%%cdr" "expr" "lambda" "for-each" "%%car" "jazz:->string" "display" "%%not-null?" "%%when" "console-port" "port" "let" "rest")}
      {Lisp-Entry "jazz:debug-string" define #f 114 9 114 26 ("force-output" "newline" "display" "console-port" "port" "let" "str")}
      {Lisp-Entry "jazz:terminal" define #f 121 8 121 21 ("jazz:debug")}
      {Lisp-Entry "jazz:terminal-string" define #f 125 8 125 28 ("jazz:debug-string")}
      {Lisp-Entry "jazz:terminal-port" define #f 129 9 129 27 ("console-port")}
      {Lisp-Entry "jazz:bootstrap-output-value" define #f 133 9 133 36 ("jazz:->string" "display" "output" "value")}
      {Lisp-Entry "jazz:pretty-print" define #f 139 13 139 30 ("pretty-print" "apply" "rest" "expr")}
      {Lisp-Entry "jazz:pretty-print" define #f 143 13 143 30 ("pretty-print" "apply" "rest" "expr")}
      {Lisp-Entry "jazz:pretty-print" define #f 147 12 147 29 ("newline" "display" "rest" "expr")}
      {Lisp-Entry "jazz.dialect.language.object:Object:call-print" define #f 157 8 157 54 ()}
      {Lisp-Entry "jazz:print-jazz" define #f 163 9 163 24 ("jazz:print-serial" "jazz:print-object" "2" "0" "jazz:class-of" "%%class-dispatch" "jazz.dialect.language.object:Object:call-print" "jazz:use-print?" "if" "detail" "output" "object")}}})
"output-hook"
 ({Lisp-File-Entry {File :context "src" "core" "class" "runtime" "output-hook.scm"} 1299164388 scheme
    {Lisp-Entry "core.class.runtime.output-hook" unit #f 37 16 37 46 ("##default-wr" "else" "jazz:writeenv-style" "jazz:writeenv-port" "##jazz?" "and" "cond" "obj" "we" "lambda" "##wr" "jazz:print-hook" "set!")
      {Lisp-Entry "jazz:print-hook" define #f 42 12 42 27 ()}}})
"reader"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "reader.scm"} 1299164388 scheme
    {Lisp-Entry "core.base.runtime.reader" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz:read-source-all" define #f 40 9 40 29 ("%%vector-ref" "%%source-code" "%%cdr" "jazz:readtable-start-syntax" "##unwrap-datum" "##wrap-datum" "%%current-readtable" "%%read-all-as-a-begin-expr-from-port" "begin-vector" "let" "%%input-port-column-set!" "1" "%%fx+" "%%input-port-line-set!" "lambda" "%%input-port-names-set!" "if" "col" "line" "container" "#!optional" "port")}
      {Lisp-Entry "jazz:read-source-first" define #f 59 9 59 31 ("jazz:read-source-all" "%%car" "col" "line" "container" "#!optional" "port")}}})
"register"
 ({Lisp-File-Entry {File :context "src" "core" "module" "syntax" "walker" "register.scm"} 1299164388 scheme
    {Lisp-Entry "core.module.syntax.walker.register" unit #f 37 16 37 50 ()
      {Lisp-Entry "core" define ("dialect") 45 21 45 25 ("jazz:new-core-dialect")}
      {Lisp-Entry "require" define ("special") 49 28 49 35 ("jazz:walk-require" "core")}
      {Lisp-Entry "export" define ("special") 50 28 50 34 ("jazz:walk-export" "core")}
      {Lisp-Entry "import" define ("special") 51 28 51 34 ("jazz:walk-import" "core")}
      {Lisp-Entry "proclaim" define ("special") 52 28 52 36 ("jazz:walk-proclaim" "core")}
      {Lisp-Entry "native" define ("special") 53 28 53 34 ("jazz:walk-native" "core")}
      {Lisp-Entry "native-syntax" define ("special") 54 28 54 41 ("jazz:walk-native-syntax" "core")}
      {Lisp-Entry "macro" define ("special") 55 28 55 33 ("jazz:walk-macro" "core")}
      {Lisp-Entry "local-macro" define ("special") 56 28 56 39 ("jazz:walk-local-macro" "core")}
      {Lisp-Entry "syntax" define ("special") 57 28 57 34 ("jazz:walk-syntax" "core")}
      {Lisp-Entry "define-syntax" define ("special") 58 28 58 41 ("jazz:walk-define-syntax" "core")}
      {Lisp-Entry "define-local-syntax" define ("special") 59 28 59 47 ("jazz:walk-define-local-syntax" "core")}
      {Lisp-Entry "let-syntax" define ("special") 60 28 60 38 ("jazz:walk-let-syntax" "core")}
      {Lisp-Entry "letrec-syntax" define ("special") 61 28 61 41 ("jazz:walk-letrec-syntax" "core")}
      {Lisp-Entry "reference" define ("special") 62 28 62 37 ("jazz:walk-reference" "core")}
      {Lisp-Entry "walk-failed?" define ("special") 63 28 63 40 ("jazz:walk-walk-failed" "core")}}})
"runtime"
 ({Lisp-File-Entry {File :context "src" "core" "class" "runtime" "runtime.scm"} 1299164391 scheme
    {Lisp-Entry "core.class.runtime.runtime" unit #f 37 16 37 42 ("jazz:Queue" "jazz:Method-Node" "jazz:Method" "jazz:Property" "jazz:Slot" "jazz:Field" "jazz:Interface" "#xF" "#xE" "#xD" "#xC" "#xB" "#xA" "#x9" "#x8" "#x7" "#x6" "#x5" "#x4" "#x3" "#x2" "#x1" "#x0" "jazz:specialtypes" "jazz:subtype-boxvalues" "jazz:subtype-f64vector" "jazz:subtype-f32vector" "jazz:subtype-u64vector" "jazz:subtype-s64vector" "jazz:subtype-u32vector" "jazz:subtype-s32vector" "jazz:subtype-u16vector" "jazz:subtype-s16vector" "jazz:subtype-u8vector" "jazz:subtype-s8vector" "jazz:subtype-foreign" "jazz:subtype-bignum" "jazz:subtype-flonum" "jazz:subtype-string" "jazz:subtype-procedure" "jazz:subtype-continuation" "jazz:subtype-keyword" "jazz:subtype-symbol" "jazz:subtype-cpxnum" "jazz:subtype-ratnum" "jazz:subtype-pair" "jazz:subtype-vector" "jazz:subtypes" "%%vector-set!" "jazz:Marker" "jazz:Marker-Class" "jazz:Unspecified" "jazz:Unspecified-Class" "jazz:EOF" "jazz:EOF-Class" "jazz:Values" "jazz:Values-Class" "jazz:Foreign" "jazz:Foreign-Class" "jazz:Promise" "jazz:Promise-Class" "thread?" "jazz:Thread" "jazz:Thread-Class" "table?" "jazz:Table" "jazz:Table-Class" "jazz:Keyword" "jazz:Keyword-Class" "jazz:Symbol" "jazz:Symbol-Class" "jazz:Procedure" "jazz:Procedure-Class" "jazz:Continuation" "jazz:Continuation-Class" "port?" "jazz:register-structure-type" "jazz:Port" "jazz:Port-Class" "jazz:Structure" "jazz:Structure-Class" "jazz:F64Vector" "jazz:F64Vector-Class" "jazz:F32Vector" "jazz:F32Vector-Class" "jazz:U64Vector" "jazz:U64Vector-Class" "jazz:S64Vector" "jazz:S64Vector-Class" "jazz:U32Vector" "jazz:U32Vector-Class" "jazz:S32Vector" "jazz:S32Vector-Class" "jazz:U16Vector" "jazz:U16Vector-Class" "jazz:S16Vector" "jazz:S16Vector-Class" "jazz:U8Vector" "jazz:U8Vector-Class" "jazz:S8Vector" "jazz:S8Vector-Class" "jazz:Vector" "jazz:Vector-Class" "jazz:String" "jazz:String-Class" "jazz:Pair" "jazz:Pair-Class" "jazz:Null" "jazz:Null-Class" "jazz:List" "jazz:List-Class" "jazz:Sequence" "jazz:Sequence-Class" "jazz:Flonum" "jazz:Flonum-Class" "jazz:Fixnum" "jazz:Fixnum-Class" "jazz:Integer" "jazz:Integer-Class" "jazz:Rational" "jazz:Rational-Class" "jazz:Real" "jazz:Real-Class" "jazz:Complex" "jazz:Complex-Class" "jazz:Number" "jazz:Number-Class" "jazz:Numeric" "jazz:Numeric-Class" "jazz:Char" "jazz:Char-Class" "jazz:Boolean" "jazz:Boolean-Class" "%%set-object-class" "jazz:Object-Class" "jazz:Class" "jazz:Category" "jazz:Type" "jazz:encapsulate-class" "jazz:Object" "%%get-object-class" "%%subclass?" "class" "object" "lambda" "jazz:object-of-class?" "set!")
      {Lisp-Entry "jazz:new-interface-rank" define #f 40 8 40 31 ("0")}
      {Lisp-Entry "jazz:dispatch?" define #f 49 9 49 23 ("%%fx-" "%%string-ref" "%%eqv?" "1" "%%fx>" "%%string-length" "len" "%%symbol->string" "name" "let" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "jazz:dispatch->symbol" define #f 58 9 58 30 ("1" "%%string-length" "%%fx-" "0" "%%substring" "%%string->symbol" "%%symbol->string" "name" "let" "dispatch")}
      {Lisp-Entry "jazz:composite-identifier?" define #f 63 9 63 35 ("%%symbol->string" "jazz:memstring" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "jazz:composite-reference?" define #f 68 9 68 34 ("%%symbol->string" "jazz:memstring" "%%symbol?" "and" "symbol")}
      {Lisp-Entry "jazz:compose-helper" define #f 73 9 73 28 ("%%symbol->string" "%%string-append" "%%string->symbol" "suffix" "locator")}
      {Lisp-Entry "jazz:split-symbol" define #f 77 9 77 26 ("%%symbol->string" "jazz:split-string" "string->symbol" "map" "%%symbol?" "%%debug-assert" "separator" "identifier")}
      {Lisp-Entry "jazz:split-identifier" define #f 82 9 82 30 ("jazz:split-symbol" "identifier")}
      {Lisp-Entry "jazz:split-reference" define #f 86 9 86 29 ("jazz:split-symbol" "identifier")}
      {Lisp-Entry "jazz:inspect-object" define #f 95 9 95 28 ("1" "%%fx+" "%%object-ref" "%%vector-set!" "begin" "%%fx<" "if" "0" "n" "iter" "let" "%%make-vector" "content" "%%object-length" "size" "let*" "%%object?" "%%assert" "object")}
      {Lisp-Entry "jazz:Core-Classes" define #f 112 8 112 25 ("eq?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:get-core-classes" define #f 116 9 116 30 ("jazz:Core-Classes")}
      {Lisp-Entry "jazz:core-class?" define #f 120 9 120 25 ("jazz:Core-Classes" "%%table-ref" "%%boolean" "name")}
      {Lisp-Entry "jazz:get-core-class" define #f 124 9 124 28 ("jazz:Core-Classes" "%%table-ref" "name")}
      {Lisp-Entry "jazz:set-core-class" define #f 128 9 128 28 ("jazz:Core-Classes" "%%table-set!" "class" "name")}
      {Lisp-Entry "jazz:set-core-class-redefined" define #f 132 9 132 38 ("jazz:Core-Classes" "%%table-set!" "core-class-locator" "name")}
      {Lisp-Entry "jazz:object?" define #f 141 9 141 21 ("%%object?" "expr")}
      {Lisp-Entry "jazz:primitive?" define #f 145 9 145 24 ("%%object?" "%%not" "expr")}
      {Lisp-Entry "jazz:subtype?" define #f 149 9 149 22 ("%%subtype?" "%%boolean" "jazz:type?" "and" "%%debug-assert" "type" "target")}
      {Lisp-Entry "jazz:subcategory?" define #f 154 9 154 26 ("%%subcategory?" "%%boolean" "category" "target")}
      {Lisp-Entry "jazz:subclass?" define #f 158 9 158 23 ("%%subclass?" "%%boolean" "class" "target")}
      {Lisp-Entry "jazz:get-category-descendants" define #f 162 9 162 38 ("%%get-category-descendants" "category")}
      {Lisp-Entry "jazz:get-class-ascendant" define #f 166 9 166 33 ("%%get-class-ascendant" "class")}
      {Lisp-Entry "jazz:collect-type" define #f 175 9 175 26 ("%%is?" "obj" "lambda" "jazz:collect-if" "lst" "type")}
      {Lisp-Entry "jazz:create-class-tables" define #f 181 9 181 33 ("jazz:create-class-class-table" "jazz:create-class-interface-table" "class")}
      {Lisp-Entry "jazz:create-core-class-tables" define #f 186 9 186 38 ("jazz:create-class-class-table" "class")}
      {Lisp-Entry "jazz:create-class-interface-table" define #f 190 9 190 42 ("%%set-class-interface-table" "%%get-category-ancestors" "jazz:class-of" "jazz:call-into-abstract" "rest" "object" "%%get-method-implementation-rank" "jazz:Method" "%%is?" "field" "field-name" "%%get-category-fields" "jazz:iterate-table" "category-identifier" "%%get-category-identifier" "class-name" "jazz:call-into-incoherent" "category-vtable" "%%get-category-virtual-size" "%%get-interface-rank" "rank" "let*" "jazz:Interface" "%%class-is?" "category" "lambda" "jazz:vector-for-each" "1" "%%fx+" "%%vector-copy" "%%vector-set!" "%%vector-ref" "ascendant-vtable" "%%fx<" "0" "i" "iter" "%%vector-length" "size" "ascendant-interface-table" "%%get-class-ascendant" "ascendant" "jazz:new-interface-rank" "%%make-vector" "vtable" "let" "%%get-class-interface-table" "%%not" "%%when" "class")}
      {Lisp-Entry "jazz:create-class-class-table" define #f 224 9 224 38 ("%%vector-ref" "%%vector-copy" "%%vector-set!" "%%fx<" "0" "i" "iter" "#" "1" "%%fx+" "%%make-vector" "vtable" "%%vector-length" "size" "ascendant-class-table" "let*" "if" "%%set-class-class-table" "%%get-class-ascendant" "ascendant" "let" "%%get-class-class-table" "%%not" "%%when" "class")}
      {Lisp-Entry "jazz:encapsulate-class" define #f 240 9 240 31 ("jazz:update-core-class" "%%set-class-core-vtable" "%%get-class-core-method-alist" "%%get-class-core-virtual-alist" "jazz:get-method-rank" "%%cdr" "method-implementation" "%%car" "method-name" "method" "lambda" "for-each" "%%vector-ref" "%%vector-set!" "%%fx>=" "1" "%%vector-length" "%%fx-" "n" "iter" "%%get-class-core-vtable" "ascendant-vtable" "%%get-class-ascendant" "ascendant" "%%make-vector" "vtable" "0" "%%fx>" "%%when" "%%length" "vtable-size" "%%get-class-core-virtual-names" "virtual-names" "let" "class")}
      {Lisp-Entry "jazz:update-class" define #f 267 9 267 26 ("jazz:update-class-class-table" "class")}
      {Lisp-Entry "jazz:update-core-class" define #f 271 9 271 31 ("jazz:update-class-class-table" "class")}
      {Lisp-Entry "jazz:update-class-class-table" define #f 275 9 275 38 ("implementation" "jazz:resize-vector" "%%get-category-virtual-size" "class-virtual-size" "%%not-null?" "%%cons" "set!" "%%set-method-category-rank" "begin" "%%get-category-descendants" "descendant" "for-each" "%%vector-set!" "%%eq?" "implementation-table" "iter" "%%neq?" "%%get-method-implementation-tree" "%%get-method-node-implementation" "new-implementation" "old-implementation" "%%get-method-implementation-rank" "implementation-rank" "let" "%%get-method-category-rank" "if" "jazz:virtual-method?" "%%when" "field" "key" "lambda" "%%get-category-fields" "jazz:iterate-table" "added-methods" "%%vector-ref" "root-implementation-table" "%%get-class-level" "class-rank" "%%get-class-class-table" "class-table" "let*" "update-class-class-root-methods" "define" "class")}
      {Lisp-Entry "jazz:new-core-class" define #f 326 9 326 28 ("jazz:create-core-class-tables" "%%get-category-descendants" "%%cons" "%%set-category-descendants" "%%when" "%%list->vector" "%%set-category-ancestors" "%%get-class-core-virtual-names" "1" "%%get-class-level" "%%fx+" "0" "%%object" "core-class" "let" "%%get-category-ancestors" "%%vector->list" "%%append" "%%list" "%%not" "if" "compute-core-class-ancestors" "define" "instance-size" "slot-names" "ascendant" "fields" "name" "class")}
      {Lisp-Entry "jazz:validate-inherited-slots" define #f 362 9 362 38 ("jazz:error" "%%equal?" "%%null?" "and" "or" "%%get-field-name" "slot" "lambda" "map" "symbol?" "jazz:some?" "all-slots" "core-class-all-slot-names" "%%append" "%%not" "if" "%%get-class-ascendant" "%%get-class-instance-slots" "slots" "let" "core-class" "core-class-all-slots" "define" "inherited-slot-names" "ascendant" "name")}
      {Lisp-Entry "jazz:Object" define-class ("class runtime") 389 27 389 38 ()}
      {Lisp-Entry "jazz:get-object-slot" define #f 392 9 392 29 ("jazz:unspecified" "%%object-ref" "%%integer?" "if" "%%object?" "%%debug-assert" "slot-offset" "object")}
      {Lisp-Entry "jazz:set-object-slot" define #f 399 9 399 29 ("%%object-set!" "%%integer?" "%%object?" "%%debug-assert" "value" "slot-offset" "object")}
      {Lisp-Entry "jazz:classname->string" define #f 405 9 405 31 ("%%get-category-identifier" "%%symbol->string" "%%null?" "if" "class")}
      {Lisp-Entry "jazz:print-object" generic/specific ("jazz:Object~virtual-runtime") 411 30 411 47 ("detail" "output")}
      {Lisp-Entry "jazz:print-object" generic/specific ("jazz:Object") 414 21 414 38 ("object" "jazz:print-serial" "detail" "output")}
      {Lisp-Entry "jazz:print-serial" define #f 418 9 418 26 ("display" "object->serial-number" "serial" "let" "output" "object")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Object~virtual-runtime") 425 30 425 44 ("environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:tree-fold" generic/specific ("jazz:Object") 428 21 428 35 ("expression" "environment" "seed" "here" "up" "down")}
      {Lisp-Entry "jazz:Type" define-class ("class runtime") 440 27 440 36 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Type~virtual-runtime") 443 30 443 43 ("object")}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Type") 446 21 446 34 ("jazz:class-of" "type" "jazz:of-subtype?" "object")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Type~virtual-runtime") 450 30 450 46 ("subtype")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Type") 453 21 453 37 ("type" "jazz:error" "subtype")}
      {Lisp-Entry "jazz:specifiable?" generic/specific ("jazz:Type~virtual-runtime") 457 30 457 47 ()}
      {Lisp-Entry "jazz:specifiable?" generic/specific ("jazz:Type") 460 21 460 38 ()}
      {Lisp-Entry "jazz:category-type?" generic/specific ("jazz:Type~virtual-runtime") 464 30 464 49 ()}
      {Lisp-Entry "jazz:category-type?" generic/specific ("jazz:Type") 467 21 467 40 ()}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Type~virtual-runtime") 471 30 471 49 ()}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Type") 474 21 474 40 ("type" "jazz:error")}
      {Lisp-Entry "jazz:emit-type" generic/specific ("jazz:Type~virtual-runtime") 478 30 478 44 ("environment" "source-declaration")}
      {Lisp-Entry "jazz:emit-type" generic/specific ("jazz:Type") 481 21 481 35 ("type" "jazz:error" "environment" "source-declaration")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Type~virtual-runtime") 485 30 485 44 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Type") 488 21 488 35 (",locator" ",value" "%%is?" "type" "jazz:emit-type" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:emit-check" generic/specific ("jazz:Type~virtual-runtime") 493 30 493 45 ("environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:emit-check" generic/specific ("jazz:Type") 496 21 496 36 (",locator" ",value" "jazz:type-error" "jazz:emit-test" "%%not" "if" "type" "jazz:emit-type" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:bootstrap-type?" define #f 503 9 503 29 ("type-class" "object")}
      {Lisp-Entry "jazz:type?" define #f 508 9 508 19 ("jazz:Type" "%%is?" "%%object?" "and" "object")}
      {Lisp-Entry "jazz:structure-types" define #f 521 8 521 28 ()}
      {Lisp-Entry "jazz:register-structure-type" define #f 525 9 525 37 ("%%cons" "jazz:structure-types" "set!" "type" "test")}
      {Lisp-Entry "jazz:structure-type" define #f 529 9 529 28 ("%%cdr" "%%cdar" "%%caar" "jazz:Structure" "%%null?" "if" "jazz:structure-types" "scan" "iter" "let" "object")}
      {Lisp-Entry "jazz:Category" define-class ("class runtime") 543 27 543 40 ()}
      {Lisp-Entry "jazz:category?" define #f 546 9 546 23 ("jazz:category-type?" "jazz:type?" "and" "object")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Category") 551 21 551 37 ("%%get-category-ancestors" "type" "jazz:vector-memq?" "jazz:category-type?" "and" "subtype")}
      {Lisp-Entry "jazz:category-type?" generic/specific ("jazz:Category") 556 21 556 40 ()}
      {Lisp-Entry "jazz:emit-type" generic/specific ("jazz:Category") 560 21 560 35 ("type" "%%get-category-identifier" "environment" "source-declaration")}
      {Lisp-Entry "jazz:update-category" generic/specific ("jazz:Category~virtual-runtime") 564 30 564 50 ()}
      {Lisp-Entry "jazz:update-category" generic/specific ("jazz:Category") 567 21 567 41 ()}
      {Lisp-Entry "jazz:is?" define #f 571 9 571 17 ("%%is?" "%%boolean" "category" "object")}
      {Lisp-Entry "jazz:is-not?" define #f 575 9 575 21 ("%%is?" "%%not" "%%boolean" "category" "object")}
      {Lisp-Entry "jazz:get-category-identifier" define #f 579 9 579 37 ("%%get-category-identifier" "jazz:category?" "%%debug-assert" "category")}
      {Lisp-Entry "jazz:add-field" define #f 584 9 584 23 ("%%unspecified" "%%get-field-name" "%%set-category-field" "field" "category")}
      {Lisp-Entry "jazz:Class" define-class ("class runtime") 597 27 597 37 ()}
      {Lisp-Entry "jazz:new-class" define #f 600 9 600 23 ("%%class-dispatch" "jazz:initialize-slots" "jazz:create-class-tables" "%%get-category-descendants" "%%list->vector" "%%set-class-interface-table" "%%set-class-class-table" "%%get-class-core-vtable" "%%set-class-core-vtable" "%%set-class-core-virtual-names" "%%set-class-core-virtual-alist" "%%set-class-core-method-alist" "%%set-class-dispatch-table" "1" "%%get-class-level" "%%fx+" "%%set-class-level" "jazz:object-size" "%%set-class-instance-size" "%%get-class-instance-slots" "if" "%%set-class-instance-slots" "%%set-class-slots" "%%set-class-interfaces" "%%set-class-ascendant" "%%set-category-descendants" "%%set-category-ancestors" "0" "%%set-category-virtual-size" "eq?" "test:" "%%make-table" "%%set-category-fields" "%%set-category-identifier" "%%get-class-instance-size" "%%make-object" "add-classes" "%%get-interface-ascendants" "%%cons" "set!" "%%memq" "%%not" "else" "%%get-class-interfaces" "for-each" "%%when" "%%get-class-ascendant" "%%class?" "cond" "category" "add-interfaces" "ancestors" "let" "class" "compute-class-ancestors" "define" "interfaces" "ascendant" "identifier" "class-of-class")}
      {Lisp-Entry "jazz:class?" define #f 648 9 648 20 ("jazz:Class" "%%class-is?" "object")}
      {Lisp-Entry "jazz:class-of" define #f 652 9 652 22 ("%%class-of-impl" "expr")}
      {Lisp-Entry "jazz:class-subtype?" define #f 656 9 656 28 ("%%class-subtype?" "class" "target")}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Class") 660 21 660 34 ("class" "jazz:class-of" "%%class-subtype?" "object")}
      {Lisp-Entry "jazz:update-category" generic/specific ("jazz:Class") 664 21 664 41 ("class" "jazz:update-class")}
      {Lisp-Entry "jazz:slot-form?" define #f 668 9 668 24 ("slot" "%%car" "%%eq?" "%%pair?" "and" "form")}
      {Lisp-Entry "jazz:new" define #f 673 9 673 17 ("0" "%%class-dispatch" "apply" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "rest" "class")}
      {Lisp-Entry "jazz:new0" define #f 681 9 681 18 ("0" "%%class-dispatch" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "class")}
      {Lisp-Entry "jazz:new1" define #f 689 9 689 18 ("0" "%%class-dispatch" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "arg1" "class")}
      {Lisp-Entry "jazz:new2" define #f 697 9 697 18 ("0" "%%class-dispatch" "jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "arg2" "arg1" "class")}
      {Lisp-Entry "jazz:nascent-new" define #f 705 9 705 25 ("jazz:initialize-slots" "%%get-class-instance-size" "%%make-object" "object" "let" "%%class?" "%%debug-assert" "rest" "class")}
      {Lisp-Entry "jazz:iterate-descendants-tree" define #f 712 9 712 38 ("%%get-category-descendants" "for-each" "iter" "let" "proc" "class")}
      {Lisp-Entry "jazz:Object-Class" define-class ("class runtime") 726 27 726 44 ()}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Object-Class") 729 21 729 37 ("nextmethod" "class" "%%object-class?" "if" "subtype")}
      {Lisp-Entry "jazz:Boolean-Class" define-class ("class runtime") 755 27 755 45 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Boolean-Class") 758 21 758 34 ("%%boolean?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Boolean-Class") 762 21 762 40 ("bool")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Boolean-Class") 766 21 766 35 (",value" "%%boolean?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Boolean" define-class ("class runtime") 773 27 773 39 ()}
      {Lisp-Entry "jazz:Char-Class" define-class ("class runtime") 784 27 784 42 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Char-Class") 787 21 787 34 ("%%char?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Char-Class") 791 21 791 40 ("char")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Char-Class") 795 21 795 35 (",value" "%%char?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Char" define-class ("class runtime") 802 27 802 36 ()}
      {Lisp-Entry "jazz:Numeric-Class" define-class ("class runtime") 813 27 813 45 ()}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Numeric-Class") 816 21 816 40 ("numeric")}
      {Lisp-Entry "jazz:Numeric" define-class ("class runtime") 823 27 823 39 ()}
      {Lisp-Entry "jazz:Number-Class" define-class ("class runtime") 834 27 834 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Number-Class") 837 21 837 34 ("%%number?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Number-Class") 841 21 841 40 ("number")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Number-Class") 845 21 845 35 (",value" "%%number?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Number" define-class ("class runtime") 852 27 852 38 ()}
      {Lisp-Entry "jazz:Complex-Class" define-class ("class runtime") 863 27 863 45 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Complex-Class") 866 21 866 34 ("%%complex?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Complex-Class") 870 21 870 40 ("complex")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Complex-Class") 874 21 874 35 (",value" "%%complex?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Complex" define-class ("class runtime") 881 27 881 39 ()}
      {Lisp-Entry "jazz:Real-Class" define-class ("class runtime") 892 27 892 42 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Real-Class") 895 21 895 34 ("%%real?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Real-Class") 899 21 899 40 ("real")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Real-Class") 903 21 903 35 (",value" "%%real?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Real" define-class ("class runtime") 910 27 910 36 ()}
      {Lisp-Entry "jazz:Rational-Class" define-class ("class runtime") 921 27 921 46 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Rational-Class") 924 21 924 34 ("%%rational?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Rational-Class") 928 21 928 40 ("rational")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Rational-Class") 932 21 932 35 (",value" "%%rational?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Rational" define-class ("class runtime") 939 27 939 40 ()}
      {Lisp-Entry "jazz:Integer-Class" define-class ("class runtime") 950 27 950 45 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Integer-Class") 953 21 953 34 ("%%integer?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Integer-Class") 957 21 957 40 ("int")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Integer-Class") 961 21 961 35 (",value" "%%integer?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Integer" define-class ("class runtime") 968 27 968 39 ()}
      {Lisp-Entry "jazz:Fixnum-Class" define-class ("class runtime") 979 27 979 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Fixnum-Class") 982 21 982 34 ("%%fixnum?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Fixnum-Class") 986 21 986 40 ("fx")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Fixnum-Class") 990 21 990 35 (",value" "%%fixnum?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Fixnum" define-class ("class runtime") 997 27 997 38 ()}
      {Lisp-Entry "jazz:Flonum-Class" define-class ("class runtime") 1008 27 1008 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Flonum-Class") 1011 21 1011 34 ("%%flonum?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Flonum-Class") 1015 21 1015 40 ("fl")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Flonum-Class") 1019 21 1019 35 (",value" "%%flonum?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Flonum" define-class ("class runtime") 1026 27 1026 38 ()}
      {Lisp-Entry "jazz:Sequence-Class" define-class ("class runtime") 1037 27 1037 46 ()}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Sequence-Class") 1040 21 1040 40 ("sequence")}
      {Lisp-Entry "jazz:Sequence" define-class ("class runtime") 1047 27 1047 40 ()}
      {Lisp-Entry "jazz:List-Class" define-class ("class runtime") 1058 27 1058 42 ()}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:List-Class") 1061 21 1061 40 ("list")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:List-Class") 1065 21 1065 35 ("%%pair?" ",value" "%%null?" "or" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:List" define-class ("class runtime") 1072 27 1072 36 ()}
      {Lisp-Entry "jazz:Null-Class" define-class ("class runtime") 1083 27 1083 42 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Null-Class") 1086 21 1086 34 ("%%null?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Null-Class") 1090 21 1090 40 ("null")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Null-Class") 1094 21 1094 35 (",value" "%%null?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Null" define-class ("class runtime") 1101 27 1101 36 ()}
      {Lisp-Entry "jazz:Pair-Class" define-class ("class runtime") 1112 27 1112 42 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Pair-Class") 1115 21 1115 34 ("%%pair?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Pair-Class") 1119 21 1119 40 ("pair")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Pair-Class") 1123 21 1123 35 (",value" "%%pair?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Pair" define-class ("class runtime") 1130 27 1130 36 ()}
      {Lisp-Entry "jazz:String-Class" define-class ("class runtime") 1141 27 1141 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:String-Class") 1144 21 1144 34 ("%%string?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:String-Class") 1148 21 1148 40 ("string")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:String-Class") 1152 21 1152 35 (",value" "%%string?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:String" define-class ("class runtime") 1159 27 1159 38 ()}
      {Lisp-Entry "jazz:Vector-Class" define-class ("class runtime") 1170 27 1170 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Vector-Class") 1173 21 1173 34 ("%%vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Vector-Class") 1177 21 1177 40 ("vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Vector-Class") 1181 21 1181 35 (",value" "%%vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Vector" define-class ("class runtime") 1188 27 1188 38 ()}
      {Lisp-Entry "jazz:S8Vector-Class" define-class ("class runtime") 1199 27 1199 46 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:S8Vector-Class") 1202 21 1202 34 ("%%s8vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:S8Vector-Class") 1206 21 1206 40 ("s8vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:S8Vector-Class") 1210 21 1210 35 (",value" "%%s8vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:S8Vector" define-class ("class runtime") 1217 27 1217 40 ()}
      {Lisp-Entry "jazz:U8Vector-Class" define-class ("class runtime") 1228 27 1228 46 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:U8Vector-Class") 1231 21 1231 34 ("%%u8vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:U8Vector-Class") 1235 21 1235 40 ("u8vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:U8Vector-Class") 1239 21 1239 35 (",value" "%%u8vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:U8Vector" define-class ("class runtime") 1246 27 1246 40 ()}
      {Lisp-Entry "jazz:S16Vector-Class" define-class ("class runtime") 1257 27 1257 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:S16Vector-Class") 1260 21 1260 34 ("%%s16vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:S16Vector-Class") 1264 21 1264 40 ("s16vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:S16Vector-Class") 1268 21 1268 35 (",value" "%%s16vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:S16Vector" define-class ("class runtime") 1275 27 1275 41 ()}
      {Lisp-Entry "jazz:U16Vector-Class" define-class ("class runtime") 1286 27 1286 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:U16Vector-Class") 1289 21 1289 34 ("%%u16vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:U16Vector-Class") 1293 21 1293 40 ("u16vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:U16Vector-Class") 1297 21 1297 35 (",value" "%%u16vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:U16Vector" define-class ("class runtime") 1304 27 1304 41 ()}
      {Lisp-Entry "jazz:S32Vector-Class" define-class ("class runtime") 1315 27 1315 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:S32Vector-Class") 1318 21 1318 34 ("%%s32vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:S32Vector-Class") 1322 21 1322 40 ("s32vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:S32Vector-Class") 1326 21 1326 35 (",value" "%%s32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:S32Vector" define-class ("class runtime") 1333 27 1333 41 ()}
      {Lisp-Entry "jazz:U32Vector-Class" define-class ("class runtime") 1344 27 1344 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:U32Vector-Class") 1347 21 1347 34 ("%%u32vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:U32Vector-Class") 1351 21 1351 40 ("u32vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:U32Vector-Class") 1355 21 1355 35 (",value" "%%u32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:U32Vector" define-class ("class runtime") 1362 27 1362 41 ()}
      {Lisp-Entry "jazz:S64Vector-Class" define-class ("class runtime") 1373 27 1373 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:S64Vector-Class") 1376 21 1376 34 ("%%s64vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:S64Vector-Class") 1380 21 1380 40 ("s64vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:S64Vector-Class") 1384 21 1384 35 (",value" "%%s64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:S64Vector" define-class ("class runtime") 1391 27 1391 41 ()}
      {Lisp-Entry "jazz:U64Vector-Class" define-class ("class runtime") 1402 27 1402 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:U64Vector-Class") 1405 21 1405 34 ("%%u64vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:U64Vector-Class") 1409 21 1409 40 ("u64vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:U64Vector-Class") 1413 21 1413 35 (",value" "%%u64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:U64Vector" define-class ("class runtime") 1420 27 1420 41 ()}
      {Lisp-Entry "jazz:F32Vector-Class" define-class ("class runtime") 1431 27 1431 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:F32Vector-Class") 1434 21 1434 34 ("%%f32vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:F32Vector-Class") 1438 21 1438 40 ("f32vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:F32Vector-Class") 1442 21 1442 35 (",value" "%%f32vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:F32Vector" define-class ("class runtime") 1449 27 1449 41 ()}
      {Lisp-Entry "jazz:F64Vector-Class" define-class ("class runtime") 1460 27 1460 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:F64Vector-Class") 1463 21 1463 34 ("%%f64vector?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:F64Vector-Class") 1467 21 1467 40 ("f64vector")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:F64Vector-Class") 1471 21 1471 35 (",value" "%%f64vector?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:F64Vector" define-class ("class runtime") 1478 27 1478 41 ()}
      {Lisp-Entry "jazz:Structure-Class" define-class ("class runtime") 1489 27 1489 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Structure-Class") 1492 21 1492 34 ("%%structure?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Structure-Class") 1496 21 1496 40 ("structure")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Structure-Class") 1500 21 1500 35 (",value" "%%structure?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Structure" define-class ("class runtime") 1507 27 1507 41 ()}
      {Lisp-Entry "jazz:Port-Class" define-class ("class runtime") 1518 27 1518 42 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Port-Class") 1521 21 1521 34 ("%%port?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Port-Class") 1525 21 1525 40 ("port")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Port-Class") 1529 21 1529 35 (",value" "%%port?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Port" define-class ("class runtime") 1536 27 1536 36 ()}
      {Lisp-Entry "jazz:Continuation-Class" define-class ("class runtime") 1550 27 1550 50 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Continuation-Class") 1553 21 1553 34 ("%%continuation?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Continuation-Class") 1557 21 1557 40 ("continuation")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Continuation-Class") 1561 21 1561 35 (",value" "%%continuation?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Continuation" define-class ("class runtime") 1568 27 1568 44 ()}
      {Lisp-Entry "jazz:Procedure-Class" define-class ("class runtime") 1579 27 1579 47 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Procedure-Class") 1582 21 1582 34 ("%%procedure?" "object")}
      {Lisp-Entry "jazz:of-subtype?" generic/specific ("jazz:Procedure-Class") 1586 21 1586 37 ("class" "nextmethod" "or" "subtype")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Procedure-Class") 1592 21 1592 40 ("procedure")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Procedure-Class") 1596 21 1596 35 (",value" "%%procedure?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Procedure" define-class ("class runtime") 1603 27 1603 41 ()}
      {Lisp-Entry "jazz:Symbol-Class" define-class ("class runtime") 1614 27 1614 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Symbol-Class") 1617 21 1617 34 ("%%symbol?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Symbol-Class") 1621 21 1621 40 ("symbol")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Symbol-Class") 1625 21 1625 35 (",value" "%%symbol?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Symbol" define-class ("class runtime") 1632 27 1632 38 ()}
      {Lisp-Entry "jazz:Keyword-Class" define-class ("class runtime") 1643 27 1643 45 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Keyword-Class") 1646 21 1646 34 ("%%keyword?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Keyword-Class") 1650 21 1650 40 ("keyword")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Keyword-Class") 1654 21 1654 35 (",value" "%%keyword?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Keyword" define-class ("class runtime") 1661 27 1661 39 ()}
      {Lisp-Entry "jazz:Table-Class" define-class ("class runtime") 1672 27 1672 43 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Table-Class") 1675 21 1675 34 ("%%table?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Table-Class") 1679 21 1679 40 ("table")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Table-Class") 1683 21 1683 35 (",value" "%%table?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Table" define-class ("class runtime") 1690 27 1690 37 ()}
      {Lisp-Entry "jazz:Thread-Class" define-class ("class runtime") 1704 27 1704 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Thread-Class") 1707 21 1707 34 ("%%thread?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Thread-Class") 1711 21 1711 40 ("thread")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Thread-Class") 1715 21 1715 35 (",value" "%%thread?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Thread" define-class ("class runtime") 1722 27 1722 38 ()}
      {Lisp-Entry "jazz:Promise-Class" define-class ("class runtime") 1736 27 1736 45 ()}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Promise-Class") 1739 21 1739 40 ("promise")}
      {Lisp-Entry "jazz:Promise" define-class ("class runtime") 1746 27 1746 39 ()}
      {Lisp-Entry "jazz:Foreign-Class" define-class ("class runtime") 1757 27 1757 45 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Foreign-Class") 1760 21 1760 34 ("%%foreign?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Foreign-Class") 1764 21 1764 40 ("foreign")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Foreign-Class") 1768 21 1768 35 (",value" "%%foreign?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Foreign" define-class ("class runtime") 1775 27 1775 39 ()}
      {Lisp-Entry "jazz:Values-Class" define-class ("class runtime") 1786 27 1786 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Values-Class") 1789 21 1789 34 ("%%values?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Values-Class") 1793 21 1793 40 ("values")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Values-Class") 1797 21 1797 35 (",value" "%%values?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Values" define-class ("class runtime") 1804 27 1804 38 ()}
      {Lisp-Entry "jazz:EOF-Class" define-class ("class runtime") 1815 27 1815 41 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:EOF-Class") 1818 21 1818 34 ("%%eof-object?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:EOF-Class") 1822 21 1822 40 ("eof")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:EOF-Class") 1826 21 1826 35 (",value" "%%eof-object?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:EOF" define-class ("class runtime") 1833 27 1833 35 ()}
      {Lisp-Entry "jazz:Unspecified-Class" define-class ("class runtime") 1844 27 1844 49 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Unspecified-Class") 1847 21 1847 34 ("%%unspecified?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Unspecified-Class") 1851 21 1851 40 ("unspecified")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Unspecified-Class") 1855 21 1855 35 (",value" "%%unspecified?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Unspecified" define-class ("class runtime") 1862 27 1862 43 ()}
      {Lisp-Entry "jazz:Marker-Class" define-class ("class runtime") 1873 27 1873 44 ()}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Marker-Class") 1876 21 1876 34 ("jazz:marker?" "object")}
      {Lisp-Entry "jazz:emit-specifier" generic/specific ("jazz:Marker-Class") 1880 21 1880 40 ("marker")}
      {Lisp-Entry "jazz:emit-test" generic/specific ("jazz:Marker-Class") 1884 21 1884 35 (",value" "jazz:marker?" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz:Marker" define-class ("class runtime") 1891 27 1891 38 ()}
      {Lisp-Entry "jazz:subtypes" define #f 1904 12 1904 25 ("32" "%%make-vector")}
      {Lisp-Entry "jazz:specialtypes" define #f 1907 12 1907 29 ("16" "%%make-vector")}
      {Lisp-Entry "jazz:table-type" define #f 1911 12 1911 27 ("make-table" "%%structure-type")}
      {Lisp-Entry "jazz:port-type" define #f 1915 12 1915 26 ("open-output-string" "%%structure-type")}
      {Lisp-Entry "jazz:thread-type" define #f 1919 12 1919 28 ("current-thread" "%%structure-type")}
      {Lisp-Entry "jazz:Interface" define-class ("class runtime") 1972 27 1972 41 ()}
      {Lisp-Entry "jazz:new-interface" define #f 1975 9 1975 27 ("%%get-category-descendants" "%%set-category-descendants" "for-each" "%%list->vector" "%%set-category-ancestors" "1" "%%fx+" "set!" "jazz:new-interface-rank" "0" "eq?" "test:" "%%make-table" "jazz:allocate-interface" "let" "%%list" "%%get-category-ancestors" "%%vector->list" "ascendant" "lambda" "map" "%%cons" "append" "%%apply" "jazz:remove-duplicates" "interface" "compute-interface-ancestors" "define" "ascendants" "identifier" "class")}
      {Lisp-Entry "jazz:interface?" define #f 1992 9 1992 24 ("jazz:Interface" "%%class-is?" "object")}
      {Lisp-Entry "jazz:of-type?" generic/specific ("jazz:Interface") 2007 21 2007 34 ("jazz:class-of" "interface" "jazz:of-subtype?" "object")}
      {Lisp-Entry "jazz:update-category" generic/specific ("jazz:Interface") 2011 21 2011 41 ("interface" "jazz:update-interface")}
      {Lisp-Entry "jazz:update-interface" define #f 2015 9 2015 30 ("%%get-category-descendants" "descendant" "%%vector-set!" "%%get-method-implementation-tree" "%%get-method-node-implementation" "implementation" "%%get-method-implementation-rank" "implementation-rank" "for-each" "%%get-category-virtual-size" "%%vector-ref" "jazz:resize-vector" "implementation-table" "%%get-class-interface-table" "interface-table" "jazz:Class" "%%class-is?" "category" "iter" "%%not-null?" "let" "%%cons" "set!" "%%set-method-category-rank" "%%get-method-category-rank" "%%not" "jazz:virtual-method?" "and" "%%when" "field" "key" "lambda" "%%get-category-fields" "jazz:iterate-table" "added-methods" "%%get-interface-rank" "interface-rank" "let*" "update-interface-root-methods" "define" "interface")}
      {Lisp-Entry "jazz:Field" define-class ("class runtime") 2053 27 2053 37 ()}
      {Lisp-Entry "jazz:field?" define #f 2056 9 2056 20 ("jazz:Field" "%%class-is?" "object")}
      {Lisp-Entry "jazz:field-name" define #f 2060 9 2060 24 ("%%get-field-name" "field")}
      {Lisp-Entry "jazz:category-field" define #f 2064 9 2064 28 ("jazz:category-field" "and" "%%get-class-ascendant" "ascendant" "let" "%%get-category-field" "or" "field-name" "category")}
      {Lisp-Entry "jazz:require-object-field" define #f 2071 9 2071 34 ("%%get-category-identifier" "jazz:error" "%%not" "if" "jazz:category-field" "field" "%%get-object-class" "class" "let*" "name" "object")}
      {Lisp-Entry "jazz:Slot" define-class ("class runtime") 2087 27 2087 36 ()}
      {Lisp-Entry "jazz:new-slot" define #f 2090 9 2090 22 ("jazz:Slot" "jazz:allocate-slot" "slot-initialize" "slot-offset" "slot-name")}
      {Lisp-Entry "jazz:slot?" define #f 2094 9 2094 19 ("jazz:Slot" "%%class-is?" "object")}
      {Lisp-Entry "jazz:add-slot" define #f 2098 9 2098 22 ("1" "%%fx+" "%%set-class-instance-size" "%%when" "%%get-class-instance-slots" "%%set-class-instance-slots" "%%list" "%%get-class-slots" "%%append" "%%set-class-slots" "jazz:add-field" "jazz:new-slot" "slot" "and" "slot-offset" "%%get-class-instance-size" "instance-size" "let*" "else" "%%set-slot-initialize" "cond" "%%get-category-field" "actual" "let" "slot-allocate?" "slot-initialize" "slot-name" "class")}
      {Lisp-Entry "jazz:remove-own-slots" define #f 2115 9 2115 30 ("%%length" "%%get-class-instance-size" "%%fx-" "%%set-class-instance-size" "if" "%%set-class-instance-slots" "%%set-class-slots" "%%get-class-instance-slots" "actual" "%%get-class-ascendant" "ascendant" "let" "class")}
      {Lisp-Entry "jazz:slot-value" define #f 2123 9 2123 24 ("jazz:find-slot-offset" "jazz:get-object-slot" "slot-name" "object")}
      {Lisp-Entry "jazz:set-slot-value" define #f 2127 9 2127 28 ("jazz:find-slot-offset" "jazz:set-object-slot" "value" "slot-name" "object")}
      {Lisp-Entry "jazz:find-slot-offset" define #f 2131 9 2131 30 ("%%get-slot-offset" "jazz:require-object-field" "slot" "let" "%%object?" "%%debug-assert" "slot-name" "object")}
      {Lisp-Entry "jazz:initialize-slots" define #f 2137 9 2137 30 ("%%object-set!" "%%when" "%%get-slot-initialize" "initialize" "%%get-slot-offset" "offset" "slot" "lambda" "for-each" "%%get-object-class" "%%get-class-instance-slots" "slots" "let" "object")}
      {Lisp-Entry "jazz:Property" define-class ("class runtime") 2155 27 2155 40 ()}
      {Lisp-Entry "jazz:new-property" define #f 2158 9 2158 26 ("jazz:Property" "jazz:allocate-property" "slot-setter" "slot-getter" "slot-initialize" "slot-offset" "slot-name")}
      {Lisp-Entry "jazz:property?" define #f 2162 9 2162 23 ("jazz:Property" "%%class-is?" "object")}
      {Lisp-Entry "jazz:property-getter" define #f 2166 9 2166 29 ("%%get-property-getter" "property")}
      {Lisp-Entry "jazz:property-setter" define #f 2170 9 2170 29 ("%%get-property-setter" "property")}
      {Lisp-Entry "jazz:all-properties" define #f 2174 9 2174 28 ("else" "%%cdr" "%%cons" "%%car" "jazz:property?" "%%null?" "cond" "%%get-class-instance-slots" "slots" "iter" "let" "category")}
      {Lisp-Entry "jazz:add-property" define #f 2181 9 2181 26 ("1" "%%fx+" "%%set-class-instance-size" "%%when" "%%get-class-instance-slots" "%%set-class-instance-slots" "%%list" "%%get-class-slots" "%%append" "%%set-class-slots" "jazz:add-field" "jazz:new-property" "slot" "and" "slot-offset" "%%get-class-instance-size" "instance-size" "let*" "else" "%%set-property-setter" "%%set-property-getter" "%%set-slot-initialize" "cond" "%%get-category-field" "actual" "let" "slot-setter" "slot-getter" "slot-allocate?" "slot-initialize" "slot-name" "class")}
      {Lisp-Entry "jazz:Method" define-class ("class runtime") 2208 27 2208 38 ()}
      {Lisp-Entry "jazz:method?" define #f 2211 9 2211 21 ("jazz:Method" "%%class-is?" "object")}
      {Lisp-Entry "jazz:final-method?" define #f 2215 9 2215 27 ("final" "%%get-method-dispatch-type" "%%eq?" "jazz:Method" "%%class-is?" "and" "field")}
      {Lisp-Entry "jazz:virtual-method?" define #f 2220 9 2220 29 ("final" "%%get-method-dispatch-type" "%%neq?" "jazz:Method" "%%class-is?" "and" "field")}
      {Lisp-Entry "jazz:locate-method-owner" define #f 2225 9 2225 33 ("%%get-interface-ascendants" "jazz:Interface" "%%get-class-interfaces" "jazz:find-in" "%%get-class-ascendant" "or" "jazz:Class" "%%class-is?" "%%get-category-field" "%%not" "cond" "iter" "let" "method-name" "category")}
      {Lisp-Entry "jazz:iterate-class-overrides" define #f 2241 9 2241 37 ("%%class-dispatch" "%%neq?" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "category-rank" "interface" "%%eq?" "or" "%%get-method-dispatch-type" "dispatch-type" "jazz:Method" "%%is?" "and" "field" "name" "lambda" "%%get-category-fields" "jazz:iterate-table-safe" "begin" "if" "ancestor" "iter" "%%get-class-ascendant" "ascendant" "let" "proc" "class")}
      {Lisp-Entry "jazz:update-method" define #f 2260 9 2260 27 ("jazz:add-method-node" "jazz:add-final-method" "final" "jazz:add-virtual-method" "interface" "%%get-method-dispatch-type" "case" "%%eq?" "if" "jazz:global-set!" "%%get-category-identifier" "%%compose-reference" "method-locator" "%%get-category-field" "method" "jazz:locate-method-owner" "owner" "let" "method-implementation" "method-name" "class")}
      {Lisp-Entry "jazz:new-final-method" define #f 2277 9 2277 30 ("final" "jazz:Method" "jazz:allocate-method" "implementation" "name")}
      {Lisp-Entry "jazz:add-final-method" define #f 2281 9 2281 30 ("else" "%%eq?" "%%not" "cond" "jazz:locate-method-owner" "owner" "jazz:error" "%%set-method-implementation" "jazz:final-method?" "if" "%%get-category-field" "field" "update-final-method" "jazz:add-field" "jazz:new-final-method" "method" "let" "create-final-method" "define" "method-implementation" "method-name" "class")}
      {Lisp-Entry "jazz:new-virtual-method" define #f 2308 9 2308 32 ("jazz:Method" "jazz:allocate-method" "implementation-rank" "category-rank" "implementation-tree" "dispatch-type" "name")}
      {Lisp-Entry "jazz:add-virtual-method" define #f 2312 9 2312 32 ("else" "%%eq?" "%%not" "cond" "jazz:locate-method-owner" "owner" "%%get-method-implementation-rank" "jazz:error" "%%get-method-node-children" "%%set-method-node-next-implementation" "child" "lambda" "for-each" "%%set-method-node-implementation" "%%get-method-implementation-tree" "jazz:virtual-method?" "%%get-category-field" "field" "let" "update-virtual-method" "jazz:update-category" "jazz:add-field" "1" "%%fx+" "%%set-category-virtual-size" "%%set-method-implementation-rank" "%%get-category-virtual-size" "virtual-size" "jazz:new-virtual-method" "method" "jazz:new-method-node" "node" "interface" "class" "jazz:Class" "%%class-is?" "if" "dispatch-type" "let*" "create-virtual-method" "define" "method-implementation" "method-name" "category")}
      {Lisp-Entry "jazz:add-method-node" define #f 2350 9 2350 29 ("error" "jazz:final-method?" "%%vector-set!" "%%vector-ref" "method-table" "%%get-class-interface-table" "interface" "%%get-class-class-table" "%%get-method-dispatch-type" "case" "dispatch-table" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "category-rank" "receive" "%%get-method-implementation-tree" "jazz:virtual-method?" "%%get-category-field" "field" "else" "jazz:error" "cond" "jazz:locate-method-owner" "owner" "%%get-category-descendants" "descendant" "%%memq" "%%not" "%%when" "map" "end-categories" "end-nodes" "start-node" "proc" "update-method-tree" "%%set-method-node-implementation" "values" "%%cons" "%%set-method-node-children" "%%set-method-node-next-implementation" "%%set-method-node-next-node" "for-each" "jazz:new-method-node" "new-node" "old-children" "%%assq" "or" "new-children" "assv" "child-class" "lambda" "jazz:partition" "partition" "%%cdr" "%%subtype?" "child-category" "%%car" "child" "let*" "%%null?" "%%get-method-node-children" "children" "sub-iter" "iter" "category" "create-method-node" "update-method-node" "%%get-method-node-category" "%%eq?" "if" "locate-most-specific-method-node" "node" "let" "root-node" "create/update-method-node" "define" "method-implementation" "method-name" "class")}
      {Lisp-Entry "jazz:Method-Node" define-class ("class runtime") 2435 27 2435 43 ()}
      {Lisp-Entry "jazz:new-method-node" define #f 2438 9 2438 29 ("jazz:Method-Node" "jazz:allocate-method-node" "%%get-method-node-implementation" "if" "next-implementation" "let" "children" "next-node" "implementation" "category")}
      {Lisp-Entry "jazz:call-into-incoherent" define #f 2443 9 2443 34 ("jazz:error" "rest")}
      {Lisp-Entry "jazz:call-into-abstract" define #f 2447 9 2447 32 ("jazz:error" "arguments" "object" "method" "class")}
      {Lisp-Entry "jazz:Queue" define-class ("class runtime") 2459 27 2459 37 ()}
      {Lisp-Entry "jazz:new-queue" define #f 2462 9 2462 23 ("jazz:Queue" "jazz:allocate-queue")}
      {Lisp-Entry "jazz:enqueue" define #f 2466 9 2466 21 ("jazz:enqueue-impl" "%%cons" "pair" "let" "object" "queue")}
      {Lisp-Entry "jazz:enqueue-list" define #f 2471 9 2471 26 ("jazz:enqueue-impl" "%%not-null?" "%%when" "lst" "queue")}
      {Lisp-Entry "jazz:enqueue-impl" define #f 2476 9 2476 26 ("else" "%%cdr" "%%pair?" "jazz:last-pair" "%%get-queue-head" "jazz:list-copy" "copy" "%%get-queue-shared?" "%%set-queue-head" "%%null?" "cond" "%%get-queue-tail" "let" "%%set-queue-shared?" "if" "%%set-queue-tail" "set-cdr!" "tail" "stitch" "define" "shared?" "lst" "queue")}
      {Lisp-Entry "jazz:dequeue" define #f 2499 9 2499 21 ("%%car" "%%set-queue-shared?" "%%set-queue-tail" "%%get-queue-tail" "%%eq?" "%%set-queue-head" "%%cdr" "next" "%%pair?" "%%when" "%%get-queue-head" "head" "let" "queue")}
      {Lisp-Entry "jazz:queue-list" define #f 2510 9 2510 24 ("%%get-queue-head" "queue")}
      {Lisp-Entry "jazz:reset-queue" define #f 2514 9 2514 25 ("%%set-queue-shared?" "%%set-queue-tail" "%%set-queue-head" "queue")}}})
"serial"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "serial.scm"} 1299164392 scheme
    {Lisp-Entry "core.base.runtime.serial" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz:object->serial" define #f 42 13 42 32 ("object->serial-number" "obj")}
      {Lisp-Entry "jazz:serial->object" define #f 45 13 45 32 ("serial-number->object" "number")}
      {Lisp-Entry "jazz:object->serial-symbol" define #f 49 13 49 39 ("jazz:object->serial" "%%number->string" "%%string-append" "%%string->symbol" "obj")}
      {Lisp-Entry "jazz:serial-number" define #f 56 11 56 29 ("1")}
      {Lisp-Entry "jazz:serialized-objects" define #f 59 11 59 34 ("equal?" "test:" "%%make-table")}
      {Lisp-Entry "jazz:object->serial" define #f 62 12 62 31 ("%%table-set!" "1" "%%fx+" "set!" "jazz:serial-number" "number" "let" "jazz:serialized-objects" "%%table-ref" "or" "obj")}
      {Lisp-Entry "jazz:serial->object" define #f 69 12 69 31 ("%%car" "jazz:error" "%%null?" "continuation-return" "%%fx=" "if" "value" "key" "jazz:serialized-objects" "jazz:iterate-table" "return" "lambda" "continuation-capture" "rest" "number")}}})
"specific"
 ({Lisp-File-Entry {File :context "src" "core" "generic" "runtime" "specific.scm"} 1299164392 scheme
    {Lisp-Entry "core.generic.runtime.specific" unit #f 38 16 38 45 ()
      {Lisp-Entry "jazz:new-specific" define #f 41 9 41 26 ("jazz:Specific" "jazz:allocate-specific" "implementation" "signature-proc")}}}
  {Lisp-File-Entry {File :context "src" "core" "generic" "syntax" "specific.scm"} 1299164392 scheme
    {Lisp-Entry "core.generic.syntax.specific" unit #f 45 16 45 44 ("jazz:Specific" "jazz:encapsulate-class")
      {Lisp-Entry "jazz:Specific" define-class ("class") 48 19 48 32 ("%%set-specific-descendant-specifics" "%%get-specific-descendant-specifics" "descendant-specifics" "%%set-specific-ancestor-specifics" "%%get-specific-ancestor-specifics" "ancestor-specifics" "%%set-specific-implementation" "%%get-specific-implementation" "implementation" "%%set-specific-dynamic-signature" "%%get-specific-dynamic-signature" "dynamic-signature" "jazz:allocate-specific" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:Specific" define-class ("class runtime") 55 27 55 40 ()}
      {Lisp-Entry "jazz:define-specific" define-macro ("macro") 58 20 58 40 ("jazz:expand-define-specific" "%%apply" "rest")}}})
"string"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "string.scm"} 1299164392 scheme
    {Lisp-Entry "core.base.runtime.string" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz:memstring" define #f 40 9 40 23 ("1" "%%fx+" "else" "%%string-ref" "%%eqv?" "%%fx=" "cond" "0" "n" "iter" "%%string-length" "len" "let" "string" "char")}}})
"symbol"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "symbol.scm"} 1299164392 scheme
    {Lisp-Entry "core.base.runtime.symbol" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz:identifier-unit" define #f 45 9 45 29 ("0" "%%substring" "%%string->symbol" "%%not" "if" "jazz:string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "identifier")}
      {Lisp-Entry "jazz:identifier-name" define #f 54 9 54 29 ("%%string-length" "1" "%%fx+" "%%substring" "%%string->symbol" "%%not" "if" "jazz:string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "identifier")}
      {Lisp-Entry "jazz:reference-unit" define #f 68 9 68 28 ("0" "%%substring" "%%string->symbol" "%%not" "if" "jazz:string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "reference")}
      {Lisp-Entry "jazz:reference-name" define #f 77 9 77 28 ("%%string-length" "1" "%%fx+" "%%substring" "%%string->symbol" "%%not" "if" "jazz:string-find-reversed" "pos" "%%symbol->string" "str" "let*" "%%symbol?" "%%assert" "reference")}
      {Lisp-Entry "jazz:specifier?" define #f 91 9 91 24 ("1" "%%fx-" "0" "%%string-ref" "%%eqv?" "2" "%%fx>" "%%string-length" "len" "%%symbol->string" "str" "let" "%%symbol?" "and" "expr")}
      {Lisp-Entry "jazz:specifier->name" define #f 100 9 100 29 ("%%symbol->string" "%%string->symbol" "%%string-length" "%%fx-" "1" "%%substring" "string" "lambda" "extract" "let" "specifier")}
      {Lisp-Entry "jazz:name->specifier" define #f 107 9 107 29 ("%%symbol->string" "%%string-append" "%%string->symbol" "name")}
      {Lisp-Entry "jazz:binding-specifier" define #f 111 9 111 31 ("%%car" "jazz:specifier?" "%%pair?" "and" "jazz:source-code" "%%cdr" "cdr-binding" "let" "binding")}
      {Lisp-Entry "jazz:enumerator?" define #f 123 9 123 25 ("0" "%%symbol->string" "%%string-ref" "%%eqv?" "%%symbol?" "and" "obj")}
      {Lisp-Entry "jazz:enumerator->symbol" define #f 128 9 128 32 ("%%string-length" "1" "%%substring" "%%string->symbol" "%%symbol->string" "name" "let" "enumerator")}
      {Lisp-Entry "jazz:symbol->enumerator" define #f 133 9 133 32 ("%%symbol->string" "%%string-append" "%%string->symbol" "symbol")}}})
"syntax"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "syntax.scm"} 1299164392 scheme
    {Lisp-Entry "core.base.runtime.syntax" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz:source?" define #f 40 9 40 21 ("%%source?" "obj")}
      {Lisp-Entry "jazz:source-code" define #f 44 9 44 25 ("%%source-code" "%%source?" "if" "expr")}
      {Lisp-Entry "jazz:source-locat" define #f 50 9 50 26 ("%%source-locat" "%%source?" "if" "expr")}
      {Lisp-Entry "jazz:desourcify" define #f 56 9 56 24 ("%%desourcify" "expr")}
      {Lisp-Entry "jazz:desourcify-all" define #f 60 9 60 28 ("%%box?" "%%vector?" "%%source?" "%%unbox" "%%box" "box" "desourcify-box" "%%vector-ref" "%%vector-set!" "begin" "%%fx<" "if" "1" "%%fx-" "i" "loop" "let" "0" "%%make-vector" "x" "%%vector-length" "len" "let*" "vect" "desourcify-vector" "else" "%%null?" "%%cdr" "%%car" "%%cons" "%%pair?" "cond" "lst" "desourcify-list" "%%source-code" "desourcify-all" "src" "desourcify-source" "define" "expr")}
      {Lisp-Entry "jazz:sourcify" define #f 102 9 102 22 ("%%sourcify" "src" "expr")}
      {Lisp-Entry "jazz:sourcify-if" define #f 106 9 106 25 ("jazz:sourcify" "jazz:source?" "if" "src" "expr")}
      {Lisp-Entry "jazz:sourcify-list" define #f 112 9 112 27 ("jazz:desourcify-all" "jazz:sourcify-if" "expr" "lambda" "map" "src" "lst")}
      {Lisp-Entry "jazz:locat-container" define #f 118 9 118 29 ("%%locat-container" "locat")}
      {Lisp-Entry "jazz:locat-position" define #f 122 9 122 28 ("%%locat-position" "locat")}
      {Lisp-Entry "jazz:locat->line/col" define #f 126 9 126 29 ("%%cons" "%%filepos-col" "col" "%%filepos-line" "line" "%%locat-position" "%%position->filepos" "filepos" "let" "locat")}
      {Lisp-Entry "jazz:locat->file/line/col" define #f 133 9 133 34 ("%%list" "%%filepos-col" "col" "%%filepos-line" "line" "%%locat-position" "%%position->filepos" "filepos" "if" "%%locat-container" "%%container->path" "and" "file" "let" "locat")}
      {Lisp-Entry "jazz:container->path" define #f 143 9 143 29 ("%%container->path" "container")}
      {Lisp-Entry "jazz:position->filepos" define #f 147 9 147 31 ("%%position->filepos" "position")}
      {Lisp-Entry "jazz:filepos-line" define #f 151 9 151 26 ("%%filepos-line" "filepos")}
      {Lisp-Entry "jazz:filepos-col" define #f 155 9 155 25 ("%%filepos-col" "filepos")}
      {Lisp-Entry "jazz:save-emit-if" define #f 164 9 164 26 ("jazz:present-source" "pretty-print" "port" "lambda" "jazz:kernel-platform" "jazz:platform-eol-encoding" "eol-encoding:" "jazz:binary-with-extension" "path:" "list" "call-with-output-file" "jazz:scheme-readtable" "current-readtable" "parameterize" "jazz:compiled-source" "jazz:save-emit?" "and" "%%when" "emit")}
      {Lisp-Entry "jazz:present-source" define #f 177 9 177 28 ("%%vector?" "%%source?" "%%vector-ref" "%%vector-set!" "begin" "%%fx<" "if" "%%fx-" "i" "loop" "0" "%%make-vector" "x" "%%vector-length" "len" "let*" "vect" "present-vector" "else" "%%null?" "%%cdr" "%%car" "%%cons" "%%pair?" "cond" "lst" "present-list" "%%filepos-col" "1" "%%filepos-line" "%%fx+" "jazz:present-source" "source" "%%vector" "%%source-locat" "%%locat-position" "pos" "jazz:source-code" "code" "let" "src" "present-src" "define" "obj")}}}
  {Lisp-File-Entry {File :context "src" "core" "module" "syntax" "dialect" "syntax.scm"} 1299164392 scheme
    {Lisp-Entry "core.module.syntax.dialect.syntax" unit #f 37 16 37 49 ("jazz:Dialect")
      {Lisp-Entry "jazz:Dialect" define-class ("class") 40 19 40 31 ("%%set-dialect-bindings" "%%get-dialect-bindings" "bindings" "jazz:Object-Class" "jazz:Object")}
      {Lisp-Entry "jazz:dialect-name" generic/specific ("jazz:Dialect~virtual") 44 22 44 39 ()}
      {Lisp-Entry "jazz:dialect-walker" generic/specific ("jazz:Dialect~virtual") 45 22 45 41 ()}}})
"unspecified"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "unspecified.scm"} 1299164392 scheme
    {Lisp-Entry "core.base.runtime.unspecified" unit #f 37 16 37 45 ()
      {Lisp-Entry "jazz:unspecified" define #f 40 9 40 25 ("%%unspecified")}
      {Lisp-Entry "jazz:unspecified?" define #f 44 9 44 26 ("%%unspecified?" "expr")}
      {Lisp-Entry "jazz:specified?" define #f 48 9 48 24 ("%%unspecified?" "%%not" "expr")}}})
"vector"
 ({Lisp-File-Entry {File :context "src" "core" "base" "runtime" "vector.scm"} 1299164392 scheme
    {Lisp-Entry "core.base.runtime.vector" unit #f 37 16 37 40 ()
      {Lisp-Entry "jazz:vector-for-each" define #f 40 9 40 29 ("1" "%%fx+" "%%vector-ref" "begin" "%%fx<" "if" "0" "n" "iter" "%%vector-length" "len" "let" "vector" "proc")}
      {Lisp-Entry "jazz:vector-memq?" define #f 49 9 49 26 ("1" "%%fx+" "%%vector-ref" "%%eq?" "%%fx<" "if" "0" "n" "iter" "%%vector-length" "len" "let" "vector" "obj")}
      {Lisp-Entry "jazz:resize-vector" define #f 59 9 59 27 ("%%vector-ref" "%%vector-set!" "0" "%%fx>=" "%%when" "1" "%%vector-length" "min" "%%fx-" "offset" "iter" "%%make-vector" "new-vector" "let" "size" "vector")}}})
