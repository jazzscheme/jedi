"Lisp-Console-Manager"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "text" "Lisp-Console-Manager.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.text.Lisp-Console-Manager" module #f 37 18 37 60 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.console" "jazz.editor.lisp")}
      {Lisp-Entry "Lisp-Console-Manager" class #f 44 7 44 27 ("Console-Manager")
        {Lisp-Entry "external-name" method #f 47 25 47 38 ("lisp-console-manager" "rest")}}}})
"Lisp-Entry"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "catalog" "Lisp-Entry.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.catalog.Lisp-Entry" module #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.system" "jazz.platform" "jazz.library" "jazz.catalog")}
      {Lisp-Entry "Lisp-Entry" class #f 46 7 46 17 ("Indexed-Entry")
        {Lisp-Entry "kind" slot #f 49 8 49 12 ()}
        {Lisp-Entry "get-kind" accessor #f 49 25 49 33 ()}
        {Lisp-Entry "signature" slot #f 50 8 50 17 ()}
        {Lisp-Entry "get-signature" accessor #f 50 25 50 33 ()}
        {Lisp-Entry "initialize" method #f 53 20 53 30 ("signature~self" "self" "kind~self" "set!" "nextmethod" "references" "definitions" "end-column" "end-line" "column" "line" "signature" "kind" "name")}
        {Lisp-Entry "print-catalog" method #f 59 20 59 33 ("print-definitions" "references" "end-column" "end-line" "column" "line" "signature" "kind" "name" "self" "class-of" "category-name" "2" "*" "format" "output" "level")}
        {Lisp-Entry "get-image" method #f 69 20 69 29 ("Image-Resource")}
        {Lisp-Entry "present" method #f 78 20 78 27 ("present-identifier")}
        {Lisp-Entry "present-name" method #f 82 20 82 32 ("else" "string-append" "signature" "string?" "present-noname" "not" "cond" "get-name" "name" "let")}
        {Lisp-Entry "present-identifier" method #f 92 20 92 38 ("compose-name" "present-name" ":string" "format" "signature" "pair?" "present-noname" "not" "if" "get-name" "name" "let")}
        {Lisp-Entry "compose-name" method #f 101 11 101 23 (":string" "format" "present-name" "present-name~" "parent-name" "let" "get-name" "get-name~" "Lisp-Entry" "parent" "is?" "and" "if" "name")}
        {Lisp-Entry "present-noname" method #f 108 20 108 34 ()}
        {Lisp-Entry "->locator" method #f 112 18 112 27 ("self" "string->symbol" ":string" "format" "Lisp-Entry" "is-not?" "if" "get-name" "get-name~" "name" "get-parent" "get-parent~" "parent" "let" "entry" "locator-name" "define")}
        {Lisp-Entry "edit-reference" method #f 128 20 128 34 ("values" "highlight-reference" "highlight-reference~" "backward" "Range$Cell$" "new" "case" "forward" "set-ending" "set-ending~" "set-beginning" "set-beginning~" "get-end" "get-end~" "end" "start" "if" "range" "get-guest" "get-guest~" "return-new?:" "edit" "apply" "new?" "frame" "receive" "select-previous" "select-previous~" "select-next" "select-next~" "or" "get-search" "get-search~" "get-find" "get-find~" "target" "let" "user-message" "fallback-find" "get-start" "get-start~" "declaration-range" "declaration-range~" "name" "get-selection" "get-selection~" "get-string" "get-string~" "reference->name" "equal?" "when" "text" "find-declaration-range" "define" "rest" "search-result" "direction")}
        {Lisp-Entry "update-indexes" method #f 161 20 161 34 ("definitions" "update-indexes" "update-indexes~" "definition" "references" "key" "lambda" "for-each" "name" "update-index" "references-index" "definitions-index")}}}})
"Lisp-Explorer"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "text" "Lisp-Explorer.jazz"} 239511689. jazz
    {Lisp-Entry "jazz.editor.lisp.text.Lisp-Explorer" module #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.ui" "jazz.library" "jazz.editor.lisp" "jazz.editor.jazz")}
      {Lisp-Entry "proclaim" anonymous #f 46 1 46 9 ("optimizations" "warn")}
      {Lisp-Entry "Lisp-Explorer" class #f 66 7 66 20 ("initialize" "fx+" "<fx+>" "Code-Explorer")
        {Lisp-Entry "find-comment-last-row" slot #f 71 8 71 29 ()}
        {Lisp-Entry "find-comment-last-col" slot #f 72 8 72 29 ()}
        {Lisp-Entry "Composites" constant #f 75 12 75 22 ("literal" "reference" "list")}
        {Lisp-Entry "Open-Composites" constant #f 81 12 81 27 ()}
        {Lisp-Entry "Close-Composites" constant #f 87 12 87 28 ()}
        {Lisp-Entry "explore-error" method #f 93 11 93 24 ("message:" "end:" "start:" "Explore-Error" "new" "signal" "text-ending" "text-ending~" "text-beginning" "text-beginning~" "or" "model" "get-moniker" "get-moniker~" "source" "let" "end" "start" "message")}
        {Lisp-Entry "present-char" method #f 100 11 100 23 ("string" "else" "char-symbol" "memv?" "not" "cond" "c")}
        {Lisp-Entry "current-expr" method #f 109 18 109 30 ("get-marked" "symbol" "kind" "eq?" "backward-expr" "and" "when")}
        {Lisp-Entry "forward-expr" method #f 114 20 114 32 ("forward-simple-expr" "prog1" "while" "get-start" "s" "end" "set-start" "forward-whites" "forward" "1" "eqv?" "and" "memv?" "when" "0" "char-forward" "c" "let" "forward-quotes" "define")}
        {Lisp-Entry "backward-expr" method #f 132 20 132 33 ("name-comment" "get-char" "Jazz-Syntax" "get-syntax" "is?" "while" "when" "backward-simple-expr" "found" "backward-scheme-char" "2" "backward-delimited-string" "if" "c1" "c0" "start" "set-end" "backward-whites" "else" "1" "eqv?" "and" "backward" "memv?" "cond" "0" "char-backward" "c" "let" "backward-quote" "define")}
        {Lisp-Entry "forward-simple-expr" method #f 161 19 161 38 ("else" "literal" "reference" "list" "forward-composite" "forward-named-comment" "forward-constituent" "text-constituent?" "forward-escaped-symbol" "forward-backslahed-symbol" "forward-string" "string-delimiter?" "forward-sharp" "eqv?" "cond" "when" "0" "char-forward" "c" "let")}
        {Lisp-Entry "backward-simple-expr" method #f 176 19 176 39 ("else" "literal" "reference" "list" "backward-composite" "backward" "backward-constituent" "text-constituent?" "backward-escaped-symbol" "backward-string" "string-delimiter?" "cond" "when" "let" "1" "char-backward" "0" "char-forward" "eqv?" "and" "c" "space-literal?" "define")}
        {Lisp-Entry "forward-all-expr" method #f 194 18 194 34 ("start" "set!" "forward-expr" "while" "end" "copy" "initial-end" "let")}
        {Lisp-Entry "backward-all-expr" method #f 201 18 201 35 ("end" "set!" "backward-expr" "while" "start" "copy" "initial-start" "let")}
        {Lisp-Entry "forward-constituent" method #f 208 20 208 39 ("else" "symbol" "keyword" "and" "if" "kind" "text-constituent?" "not" "or" "set!" "forward" "cond" "c" "iterate" "last" "0" "char-forward" "eqv?" "keyword?" "let")}
        {Lisp-Entry "backward-constituent" method #f 227 20 227 40 ("else" "symbol" "keyword" "if" "kind" "text-constituent?" "not" "or" "set!" "backward" "2" "1" "and" "cond" "c" "iterate" "last" "0" "char-backward" "eqv?" "keyword?" "let")}
        {Lisp-Entry "backward-escaped-symbol" method #f 247 19 247 42 ("else" "symbol" "kind" "set!" "1" "eqv?" "cond" "not" "if" "0" "char-backward" "c" "iterate" "let" "backward")}
        {Lisp-Entry "backward-scheme-char" method #f 266 19 266 39 ("char" "kind" "set!" "backward")}
        {Lisp-Entry "forward-expr-comment" method #f 274 19 274 39 ("expr-comment" "kind" "set!" "forward-expr" "forward")}
        {Lisp-Entry "forward-named-comment" method #f 281 19 281 40 ("named-comment" "kind" "set!" "forward-expr" "forward" "forward-constituent" "Jazz-Syntax" "get-syntax" "is-not?" "if")}
        {Lisp-Entry "forward-sharp" method #f 290 19 290 32 ("forward-constituent" "else" "forward-expr-comment" "forward-scheme-char" "forward-named-string" "forward-delimited-string" "eqv?" "boolean" "kind" "set!" "text-constituent?" "not" "or" "memq?" "and" "cond" "1" "c1" "0" "char-forward" "c0" "let" "forward")}
        {Lisp-Entry "forward-backslahed-symbol" method #f 310 19 310 44 ("forward-constituent" "forward")}
        {Lisp-Entry "forward-escaped-symbol" method #f 316 19 316 41 ("else" "symbol" "kind" "set!" "eqv?" "cond" "not" "if" "0" "char-forward" "c" "iterate" "let" "forward")}
        {Lisp-Entry "forward-delimited-string" method #f 335 19 335 43 ("else" "delimited-string" "kind" "set!" "eqv?" "and" "not" "or" "cond" "1" "c1" "0" "char-forward" "c0" "iterate" "let" "forward")}
        {Lisp-Entry "forward-named-string" method #f 352 19 352 39 ("named-string" "continuation-return" "begin" "nu=?" "if" "limit" "<" "while" "0" "1" "+" "Cell" "new" "set-end" "get-col" "get-col~" "end" "get-line" "get-line~" "paragraph-string" "subseq" "name" "let" "return" "lambda" "continuation-capture" "forward")}
        {Lisp-Entry "forward-scheme-char" method #f 368 19 368 38 ("else" "text-constituent?" "cond" "iterate" "char" "kind" "set!" "begin" "alphanumeric?" "not" "if" "0" "char-forward" "c" "let" "forward")}
        {Lisp-Entry "forward-string" method #f 388 19 388 33 ("else" "string" "kind" "set!" "string-delimiter?" "eqv?" "not" "cond" "0" "char-forward" "c" "call-line-hook" "iterate" "let" "forward")}
        {Lisp-Entry "backward-delimited-string" method #f 408 19 408 44 ("else" "delimited-string" "kind" "set!" "eqv?" "and" "not" "or" "cond" "1" "c1" "0" "char-backward" "c0" "iterate" "let" "backward")}
        {Lisp-Entry "backward-string" method #f 426 19 426 34 ("else" "string" "kind" "set!" "string-delimiter?" "1" "eqv?" "not" "cond" "0" "char-backward" "c" "iterate" "let" "backward")}
        {Lisp-Entry "forward-composite" method #f 445 19 445 36 ("kind" "set!" "1" "next-pos" "present-char" "format" "explore-error" "eqv?" "not" "if" "0" "char-forward" "c" "let" "forward-whites" "forward-all-expr" "forward" "end" "set-start" "delimiter" "Object" "<Object>" "knd")}
        {Lisp-Entry "backward-composite" method #f 458 19 458 37 ("kind" "end" "set!" "1" "previous-pos" "present-char" "format" "explore-error" "eqv?" "not" "if" "0" "char-backward" "c" "backward-whites" "backward-all-expr" "backward" "start" "copy" "initial-start" "let" "delimiter" "Object" "<Object>" "knd")}
        {Lisp-Entry "enter-list" method #f 472 18 472 28 ("forward" "0" "char-forward" "eqv?" "when" "forward-whites")}
        {Lisp-Entry "exit-list" method #f 479 18 479 27 ("forward" "0" "char-forward" "eqv?" "when" "forward-whites" "forward-all-expr")}
        {Lisp-Entry "enter-composite" method #f 487 18 487 33 ("else" "literal" "reference" "list" "quasiquote" "quote" "unquote" "unquote-splicing" "kind" "set!" "forward" "1" "eqv?" "and" "cond" "0" "char-forward" "c0" "forward-whites" "get-start" "set-end" "get-end" "end" "let")}
        {Lisp-Entry "exit-composite" method #f 526 18 526 32 ("forward" "Close-Composites" "0" "char-forward" "memv?" "when" "forward-whites" "forward-all-expr")}
        {Lisp-Entry "skip-forward" method #f 534 18 534 30 ("get-marked" "=" "forward-expr" "and" "string" "<string>" "name")}
        {Lisp-Entry "skip-backward" method #f 538 18 538 31 ("get-marked" "=" "backward-expr" "and" "string" "<string>" "name")}
        {Lisp-Entry "forward-modifiers" method #f 542 18 542 35 ("reverse!" "cons" "memq?" "find-marked-symbol" "set!" "kind" "eq?" "forward-expr" "and" "when" "iterate" "result" "symbol" "end" "copy" "old" "let" "modifiers")}
        {Lisp-Entry "forward-comments" method #f 557 11 557 27 ("next-paragraph")}
        {Lisp-Entry "backward-comments" method #f 561 11 561 28 ()}
        {Lisp-Entry "forward-whites" method #f 565 18 565 32 ("call-line-hook" "forward-comments" "case" "forward" "whitespace?" "if" "when" "0" "char-forward" "c" "iterate" "let" "void" "<void>")}
        {Lisp-Entry "backward-whites" method #f 579 18 579 33 ("backward-lisp-comment" "backward" "whitespace?" "and" "when" "0" "char-backward" "c" "iterate" "let" "void" "<void>")}
        {Lisp-Entry "backward-lisp-comment" method #f 589 11 589 32 ("set-col" "set-col~" "set!" "find-comment-last-col" "find-comment-last-row" "if" "col" "start-col" "start" "start-line" "else" "forward-scheme-char" "forward-delimited-string" "forward" "1" "c1" "forward-string" "eqv?" "cond" "char-forward" "c0" "get-col" "get-col~" "<" "get-line" "get-line~" "=" "and" "when" "iterate" "0" "Cell" "new" "set-end" "result" "end" "copy" "preserved-end" "paragraph-length" "max-col" "let" "fx+" "<fx+>" "fx" "<fx>" "line" "find-lisp-comment" "define" "bool" "<bool>")}
        {Lisp-Entry "outer-expr" method #f 663 20 663 30 ("forward-all-expr" "end-char" "end-pos" "present-char" "format" "explore-error" "values" "backward-all-expr" "e" "start-char" "start-pos" "receive" "while" "naturals" "n" "lambda" "for-each" ">" "quote-count" "composites-match?" "prepend-expr-comment" "unless" "prepend-literal" "backward" "backward-whitespaces" "Cell" "<Cell>" "prepend-quoting" "nxt-open-composite?" "prv-close-composite?" "outer-composite" "backward-expr" "next-pos" "set-end" "previous-pos" "nxt-string?" "prv-string?" "outer-string" "forward-constituent" "backward-constituent" "nxt-constituent?" "text-constituent?" "prv-constituent?" "equal?" "forward-expr" "get-marked" "marked" "if" "backward-until" "copy" "s" "backward-to-sharp" "outer-literal" "forward-until" "get-char" "when" "outer-constituent" "advance-literal" "else" "cond" "1" "+" "forward-whitespaces" "forward" "skip-quoting" "count" "iterate" "advance-quoting" "member?" "str" "homogeneous?" "string-delimiter?" "close-composite?" "open-composite?" "whitespace?" "not" "or" "terminal?" "memv?" "c" "quote?" "eqv?" "and" "at" "comma" "unquote-splicing?" "set!" "set-start" "reset" "define" "next-char" "nxt" "0" "previous-char" "prv" "end" "start" "=" "empty?" "let" "explore-whitespace?" "explore-whitespace?:" "atomic?" "atomic?:")}
        {Lisp-Entry "form-expr" method #f 843 18 843 27 ("set-start" "find-marked-symbol" "symbol" "kind" "eq?" "forward-expr" "enter-list" "0" "next-char" "eqv?" "when" "prog1" "set-end" "end" "e" "start" "copy" "s" "let")}
        {Lisp-Entry "form-name" method #f 857 18 857 27 ("symbol?" "expr" "set!" "memq?" "not-null?" "while" "get-modifiers" "get-modifiers~" "modifiers" "cdr" "scan" "get-anonymous?" "get-anonymous?~" "if" "get-declaration?" "get-declaration?~" "and" "car" "get-expression-syntax" "expression-syntax" "let" "pair?" "when" "form")}
        {Lisp-Entry "namespace-expr?" method #f 875 26 875 41 ("form-expr" "namespace-name?")}
        {Lisp-Entry "declaration-expr?" method #f 879 26 879 43 ("form-expr" "declaration-name?")}
        {Lisp-Entry "namespace-name?" method #f 883 26 883 41 ("expression-syntax-namespace?" "name")}
        {Lisp-Entry "declaration-name?" method #f 887 26 887 43 ("expression-syntax-declaration?" "name")}
        {Lisp-Entry "inner-name?" method #f 891 26 891 37 ("expression-syntax-inner?" "name")}
        {Lisp-Entry "declaration-modifiers/name" method #f 895 18 895 44 ("set-start" "values" "prog1" "begin" "0" "char-forward" "eqv?" "if" "forward-whites" "specific" "generic" "memq?" "cond" "expression-syntax-modifiers" "forward-modifiers" "modifiers" "find-marked-symbol" "decl" "let*" "forward-expr" "enter-list" "set-end" "end" "e" "start" "copy" "s" "let")}
        {Lisp-Entry "declaration-name" method #f 916 11 916 27 ("declaration-modifiers/name" "name" "modifiers" "receive")}
        {Lisp-Entry "find-expression-syntax" method #f 921 29 921 51 ("get-expression-syntax" "symbol")}
        {Lisp-Entry "for-each-comment" method #f 930 18 930 34 ("end:" "start:" "comment-string" "comment-string~" "text-search-all" "text-search-all~" "paragraph-length" "new" "subseq" "string=?" "cardinality" "fx" "<fx>" "cast" "<" "end" "paragraph-end" "set-end" "set!" "string-style?" "string-style?~" "Named-Comment" "Expr-Comment" "inherits?" "inherits?~" "unless" "start" "model" "get-style-at" "get-style-at~" "style" "paragraph-string" "/=" "not" "when" "get-col" "get-col~" "get-line" "get-line~" "line" "let" "Cell" "<Cell>" "pos" "lambda" "for-each" "limit" "0" "or" "string-length" "title-comment-size" "syntax" "title-comment-string" "title-comment-string~" "title-comment" "previous-line" "let*" "1" "+" "-" "substring" "equal?" "2" ">=" "and" "col" "string" "semicolon-literal?" "define" "end-line" "end-line:" "start-line" "start-line:" "procedure" "<procedure>" "proc")}
        {Lisp-Entry "walk-declarations" method #f 962 26 962 43 ("walk-declaration" "while" "doc" "expression" "keyword" "declaration" "context")}
        {Lisp-Entry "walk-declaration" method #f 967 26 967 42 ("else" "end" "start" "code" "walk-expression" "walk-named-declaration" "find-expression-syntax" "form" "find-marked-symbol" "let" "symbol" "kind" "eq?" "if" "forward-expr" "exit-list" "walk-expressions" "enter-list" "cond" "doc" "expression" "keyword" "declaration" "context")}
        {Lisp-Entry "walk-named-declaration" method #f 989 29 989 51 ("find-named-walker" "proc-walk" "self" "procedure?" "if" "get-walk" "get-walk~" "and" "walk" "let" "doc" "expression" "keyword" "declaration" "form" "symbol" "context")}
        {Lisp-Entry "find-named-walker" method #f 997 29 997 46 ("walk-unknown" "error" "if" "name")}
        {Lisp-Entry "walk-parameters" method #f 1003 21 1003 36 ("code" "walk-expression" "forward-expr" "when" "iterate" "let" "doc" "expression" "keyword" "declaration" "context")}
        {Lisp-Entry "walk-unknown" method #f 1010 21 1010 33 ("walk-expressions" "code" "walk-expression" "doc" "expression" "keyword" "declaration" "form" "symbol" "context")}
        {Lisp-Entry "iterate-expressions" method #f 1021 18 1021 37 ("for-each-expressions" "recursive?" "recursive?:" "code" "mode" "mode:" "proc")}
        {Lisp-Entry "iterate-expression" method #f 1025 18 1025 36 ("for-each-expression" "recursive?" "recursive?:" "code" "mode" "mode:" "proc")}
        {Lisp-Entry "for-each-expressions" method #f 1029 11 1029 31 ("for-each-expression" "forward-expr" "while" "mode" "proc")}
        {Lisp-Entry "for-each-expression" method #f 1034 11 1034 30 ("code" "else" "exit-composite" "literal" "composite-kind?" "exit-list" "list" "cond" "enter-composite" "for-each-expressions" "for-each-expression" "quotation" "0" "char-forward" "eqv?" "intern-marked-symbol" "neq?" "or" "find-marked-symbol" "memq?" "symbol" "eq?" "and" "if" "let" "kind" "when" "forward-expr" "for-each-forms" "intrinsic" "external" "jml" "<jml>" "<form>" "form" "quasiquote" "quote" "Quotation-Forms" "define" "mode" "proc")}
        {Lisp-Entry "walk-expressions" method #f 1065 18 1065 34 ("walk-expression" "forward-expr" "exit-list" "walk-expressions" "enter-list" "cond" "iterate" "let" "first?" "code" "mode" "expression" "context")}
        {Lisp-Entry "walk-expression" method #f 1076 11 1076 26 ("walk-expression" "forward-expr" "code" "quasiquote" "quote" "memq?" "let" "else" "exit-composite" "walk-expressions" "composite-kind?" "cond" "enter-composite" "when" "specifier" "tag" "if" "1" "end" "-" "start" "get-char" "eqv?" "symbol" "kind" "eq?" "and" "specifier-marked?" "define" "first?" "mode" "expression" "context")}
        {Lisp-Entry "constant?" method #f 1103 18 1103 27 ("keyword" "tag" "specifier" "symbol" "char" "boolean" "number" "kind" "memq?")}
        {Lisp-Entry "get-constant" method #f 1107 18 1107 30 ("get-marked" "read-string-element" "lambda" "with-jazz-readtable" "else" "intern-marked-symbol" "symbol" "kind" "case")}
        {Lisp-Entry "search-expressions" method #f 1147 18 1147 36 ("mode:" "get-range" "list" "continuation-return" "match?" "start" ">=" "and" "when" "bind" "info" "for-each" "iterate-expressions" "return" "continuation-capture" "get-contexts" "get-contexts~" "get-target" "get-target~" "pair?" "if" "cons" "read-string-element" "target" "target-string" "lambda" "map" "all" "let" "ignore-case?" "whole-words?" "position" "search-context" "mode")}
        {Lisp-Entry "match?" method #f 1167 11 1167 17 ("get-marked" "read-string-element" "equal?" "not" "or" "get-kind" "expl-kind" "receive" "string->symbol" "empty-string?" "mode" "kind" "name" "bind-optionals" "separator:" "1" "subseq" "parse-strings" "elements" "let" "variable" "parse-pattern-variable" "0" "symbol->string" "element" "eqv?" "pattern-variable?" "cadr" "quotation" "values" "quote" "car" "eq?" "pair?" "and" "if" "parse-expression" "unimplemented" "else" "symbol" "symbol?" "string" "string?" "char" "char?" "boolean" "boolean?" "number" "number?" "cond" "expression" "expression-kind" "define" "target" "expl-mode")}
        {Lisp-Entry "open-composite?" method #f 1209 11 1209 26 ("Open-Composites" "memv?" "char")}
        {Lisp-Entry "close-composite?" method #f 1213 11 1213 27 ("Close-Composites" "memv?" "char")}
        {Lisp-Entry "composite-kind?" method #f 1217 11 1217 26 ("literal" "reference" "list" "memq?" "kind")}}}})
"Lisp-File-Entry"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "catalog" "Lisp-File-Entry.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.catalog.Lisp-File-Entry" module #f 37 18 37 58 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.catalog")}
      {Lisp-Entry "Lisp-File-Entry" class #f 43 7 43 22 ("File-Entry")}}})
"Lisp-Parser"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "parser" "Lisp-Parser.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.parser.Lisp-Parser" module #f 37 18 37 53 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.jml" "jazz.editor.lisp" "jazz.catalog")}
      {Lisp-Entry "Lisp-Parser" class #f 45 7 45 18 ("File-Parser")
        {Lisp-Entry "iterate-references" method #f 53 34 53 52 ("string-ref" "eqv?" "or" "unless" "ref" "increase!" "part" "lambda" "for-each" "cardinality" "+" "set!" "equal?" "pos" "last" "first" "empty-string?" "cdr" "null?" "not" "and" "split-string" "parts" "let" "parse-composite-colon" "1" "tag->name" "0" "call-proc" "tag-string?" "when" "parse-tag" "define" "procedure" "<procedure>" "proc" "string" "<string>" "name")}
        {Lisp-Entry "get-match-test" method #f 90 25 90 39 ("continuation-return" "equal?" "when" "pos" "ref" "iterate-references" "return" "continuation-capture" "subseq" "found" "=" "before" "<=" "+" "after" "extend-after" "element" "0" ">=" "and" "if" "1" "-" "previous" "extend-before" "define" "cardinality" "card" "let" "not" "or" "to" "from" "constituent-test" "whole-words?" "seq" "lambda")}
        {Lisp-Entry "get-constituent-test" method #f 121 25 121 45 ("scheme-constituent?")}
        {Lisp-Entry "parse" method #f 130 20 130 25 ("parse-definitions" "catalog" "Lisp-File-Entry" "new" "dialect" "time" "file")}
        {Lisp-Entry "parse-definitions" method #f 134 11 134 28 ("get-output" "get-output~" "add-reference" "add-reference~" "pos" "ref" "self" "class-of" "iterate-references" "iterate-references~" "string=?" "0" "string-ref" "eqv?" "empty-string?" "unless" "get-marked" "get-marked~" "keyword" "tag" "specifier" "memq?" "mode" "add-definition" "add-definition~" "set-parent" "set-parent~" "put" "put~" "not" "get-col" "get-col~" "get-line" "get-line~" "Lisp-Entry" "entry" "pair?" "reference->name" "else" "append" "cond" "or" "when" "and" "signature-mangle" "name-mangle" "mangle-declaration" "cdr" "car" "string-append" "cons" "if" "expression-syntax-signature-mangler" "mangler" "signature" "mangle-signature" "expression-syntax-name-mangler" "name" "mangle-name" "documented?" "marked" "end" "start" "symbol" "kind" "parent" "lambda" "walk-declarations" "walk-declarations~" "List-Factory" "fact" "end:" "start:" "explorer-class" "expl" "text-beginning" "text-beginning~" "beginning" "let*" "set-moniker" "set-moniker~" "set-colorize?" "set-colorize?~" "char-encoding" "set-char-encoding" "set-char-encoding~" "get-syntax" "get-syntax~" "syntax" "get-model" "get-model~" "model" "text-view-class" "new" "text" "let" "Lisp-Period" "define" "file")}
        {Lisp-Entry "text-view-class" method #f 203 29 203 44 ()}
        {Lisp-Entry "explorer-class" method #f 207 29 207 43 ("file")}}}})
"Lisp-Syntax"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "text" "Lisp-Syntax.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.text.Lisp-Syntax" module #f 37 18 37 51 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.ui.view" "jazz.ui" "jazz.system" "jazz.library.automata" "jazz.library" "jazz.editor.lisp")}
      {Lisp-Entry "Lisp-Syntax" class #f 48 7 48 18 ("Code-Syntax")
        {Lisp-Entry "parser-class" method #f 56 20 56 32 ("Lisp-Parser")}
        {Lisp-Entry "translate-lisp-key" method #f 67 11 67 29 ("else" "case" "key")}
        {Lisp-Entry "translate-lisp-key" method #f 89 11 89 29 ("else" "case" "key")}
        {Lisp-Entry "range-expr" method #f 110 20 110 30 ("model" "get-string" "get-string~" "read-string-element" "lambda" "get-readtable" "with-readtable" "range")}
        {Lisp-Entry "expr-at" method #f 116 20 116 27 ("read-string-element" "lambda" "get-readtable" "with-readtable" "expr-range" "model" "get-string" "get-string~" "string" "let" "pos")}
        {Lisp-Entry "supports-expr?" method #f 123 20 123 34 ()}
        {Lisp-Entry "colorize-syntax" method #f 132 20 132 35 ("colorize-comments" "colorize-declarations" "lambda" "with-safe-explore" "entries?:" "nextmethod" "finish-current" "finish-current~" "when" "new-colorizer" "new-colorizer~" "not" "and" "colorizer" "end:" "text-beginning" "text-beginning~" "start:" "model" "explorer-class" "new" "Text-Explorer" "<Text-Explorer>" "expl" "let" "proc" "colorize" "define" "recoloring?" "recoloring?:")}
        {Lisp-Entry "Syntax-Targets" definition #f 147 14 147 28 ()}
        {Lisp-Entry "Syntax-Automata" definition #f 150 14 150 29 ()}
        {Lisp-Entry "syntax-targets" method #f 154 20 154 34 ("compute-syntax-targets" "set!" "Syntax-Targets" "unless")}
        {Lisp-Entry "syntax-automata" method #f 160 20 160 35 ("compute-syntax-automata" "set!" "Syntax-Automata" "unless")}
        {Lisp-Entry "compute-syntax-targets" method #f 166 20 166 42 ("Syntax-Targets")}
        {Lisp-Entry "compute-syntax-automata" method #f 170 20 170 43 ("text-constituent?" "build-search-automata" "when" "syntax-targets" "targets" "let")}
        {Lisp-Entry "colorize-type" method #f 176 20 176 33 ("recolorize?" "colorizer" "end" "start" "type" "found")}
        {Lisp-Entry "colorize-declarations" method #f 180 20 180 41 ("get-application" "get-documentation-cataloguer" "get-documentation-cataloguer~" "Feature" "feature" "Literal" "literal" "Named-Comment" "named-comment" "Expr-Comment" "expr-comment" "Named-String" "named-string" "Delimited-String" "delimited-string" "String" "string" "Boolean" "boolean" "Number" "number" "Char" "char" "colorize-specifier" "specifier" "colorize-tag" "tag" "Keyword" "Base" "get-style-at" "get-name" "get-name~" "eq?" "keyword" "Quotation" "quasiquote" "quote" "case" "mode" "Declaration-Keyword" "declaration-style" "apply-coloring" "setter" "getter" "anonymous" "script" "memq?" "not" "and" "when" "documented?" "marked" "end" "start" "symbol" "kind" "context" "lambda" "walk-declarations" "walk-declarations~" "colorizer" "expl")}
        {Lisp-Entry "colorize-tag" method #f 231 29 231 41 ("end" "start" "colorizer")}
        {Lisp-Entry "colorize-specifier" method #f 235 29 235 47 ("end" "start" "colorizer")}
        {Lisp-Entry "declaration-style" method #f 239 29 239 46 ("documented?")}
        {Lisp-Entry "colorize-comments" method #f 243 20 243 37 ("end-line:" "start-line:" "Title" "4" "+" "Comment" "apply-coloring" "not" "if" "new" "model" "paragraph-length" "paragraph-length~" "len" "get-line" "get-line~" "line" "let*" "title?" "Cell" "<Cell>" "lambda" "for-each-comment" "for-each-comment~" "end" "end:" "start" "start:" "colorizer" "expl")}
        {Lisp-Entry "recolorize-text" method #f 257 20 257 35 ("nextmethod" "colorize-comments" "recolorize-comments" "finish-current" "finish-current~" "exit-list" "exit-list~" "colorize-declarations" "iterate" "continuation-return" "get-end" "get-end~" "get-line" "get-line~" ">" "when" "set-line-hook" "set-line-hook~" "exit" "lambda" "continuation-capture" "new-colorizer" "new-colorizer~" "colorizer" "Text-Explorer" "<Text-Explorer>" "expl" "let" "Explore-Error" "catch" "end:" "start:" "explorer-class" "Cell" "new" "pos" "skip-whitespace" "col" "model" "paragraph-string" "paragraph-string~" "str" "let*" "explorer" "start-line" "recolorize-declarations" "define" "end-line" "start")}
        {Lisp-Entry "Comment" definition #f 309 14 309 21 ("1" "make-string")}
        {Lisp-Entry "Title-Comment" definition #f 313 14 313 27 ("4" "make-string" "string-append")}
        {Lisp-Entry "comment-string" method #f 317 20 317 34 ("Comment")}
        {Lisp-Entry "title-comment-string" method #f 321 20 321 40 ("Title-Comment")}
        {Lisp-Entry "get-constituent-test" method #f 331 20 331 40 ("scheme-constituent?")}
        {Lisp-Entry "get-match-test" method #f 335 20 335 34 ("parser-class" "get-match-test" "get-match-test~")}
        {Lisp-Entry "Auto-Complete-Characters" definition #f 344 14 344 38 ()}
        {Lisp-Entry "auto-complete-characters" method #f 348 20 348 44 ("Auto-Complete-Characters")}
        {Lisp-Entry "favorite-completions" method #f 352 20 352 40 ("preferences" "get-completions" "get-completions~")}
        {Lisp-Entry "Comment-Styles" definition #f 361 14 361 28 ("Comment" "Title")}
        {Lisp-Entry "String-Styles" definition #f 364 14 364 27 ("Named-String" "Delimited-String" "String")}
        {Lisp-Entry "comment-style?" method #f 368 20 368 34 ("Comment-Styles" "inherits?" "inherits?~" "style-name" "lambda" "some?" "style")}
        {Lisp-Entry "string-style?" method #f 374 20 374 33 ("String-Styles" "inherits?" "inherits?~" "style-name" "lambda" "some?" "style")}
        {Lisp-Entry "textual-style?" method #f 380 20 380 34 ("string-style?" "comment-style?" "or" "style")}}}})
"Lisp-Text-Actions"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "text" "Lisp-Text-Actions.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.text.Lisp-Text-Actions" module #f 37 18 37 57 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.ui" "jazz.library" "jazz.jml" "jazz.editor.lisp")}
      {Lisp-Entry "Lisp-Text-Actions" class #f 46 7 46 24 ("Actions")
        {Lisp-Entry "form" anonymous #f 49 3 49 7 (":shift" "on-remove-highlights" "remove-highlights" "on-highlight-selection" "highlight-selection" ":alt" "on-highlight-declaration" "highlight-declaration" "Tab" "Shortcut" "shortcut:" "on-tabulate" ":focus" "Event-Handler" "action-handler:" "tabulate" "name:" "Action-Item" "<Action-Item>" "install" "<install>")}}}})
"Lisp-Text-Preferences"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "text" "Lisp-Text-Preferences.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.text.Lisp-Text-Preferences" module #f 37 18 37 61 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.ui" "jazz.jml" "jazz.editor.lisp")}
      {Lisp-Entry "Lisp-Text-Preferences" class #f 45 7 45 28 ("initialize" "Code-Text-Preferences")
        {Lisp-Entry "title-style" property #f 48 12 48 23 ()}
        {Lisp-Entry "get-title-style" accessor #f 48 63 48 71 ()}
        {Lisp-Entry "set-title-style" accessor #f 48 63 48 71 ()}
        {Lisp-Entry "comment-style" property #f 49 12 49 25 ()}
        {Lisp-Entry "get-comment-style" accessor #f 49 63 49 71 ()}
        {Lisp-Entry "set-comment-style" accessor #f 49 63 49 71 ()}
        {Lisp-Entry "expr-comment-style" property #f 50 12 50 30 ()}
        {Lisp-Entry "get-expr-comment-style" accessor #f 50 63 50 71 ()}
        {Lisp-Entry "set-expr-comment-style" accessor #f 50 63 50 71 ()}
        {Lisp-Entry "named-comment-style" property #f 51 12 51 31 ()}
        {Lisp-Entry "get-named-comment-style" accessor #f 51 62 51 70 ()}
        {Lisp-Entry "set-named-comment-style" accessor #f 51 62 51 70 ()}
        {Lisp-Entry "declaration-keyword-style" property #f 52 12 52 37 ()}
        {Lisp-Entry "get-declaration-keyword-style" accessor #f 52 63 52 71 ()}
        {Lisp-Entry "set-declaration-keyword-style" accessor #f 52 63 52 71 ()}
        {Lisp-Entry "declaration-style" property #f 53 12 53 29 ()}
        {Lisp-Entry "get-declaration-style" accessor #f 53 63 53 71 ()}
        {Lisp-Entry "set-declaration-style" accessor #f 53 63 53 71 ()}
        {Lisp-Entry "keyword-style" property #f 54 12 54 25 ()}
        {Lisp-Entry "get-keyword-style" accessor #f 54 63 54 71 ()}
        {Lisp-Entry "set-keyword-style" accessor #f 54 63 54 71 ()}
        {Lisp-Entry "tag-style" property #f 55 12 55 21 ()}
        {Lisp-Entry "get-tag-style" accessor #f 55 63 55 71 ()}
        {Lisp-Entry "set-tag-style" accessor #f 55 63 55 71 ()}
        {Lisp-Entry "specifier-style" property #f 56 12 56 27 ()}
        {Lisp-Entry "get-specifier-style" accessor #f 56 63 56 71 ()}
        {Lisp-Entry "set-specifier-style" accessor #f 56 63 56 71 ()}
        {Lisp-Entry "char-style" property #f 57 12 57 22 ()}
        {Lisp-Entry "get-char-style" accessor #f 57 63 57 71 ()}
        {Lisp-Entry "set-char-style" accessor #f 57 63 57 71 ()}
        {Lisp-Entry "number-style" property #f 58 12 58 24 ()}
        {Lisp-Entry "get-number-style" accessor #f 58 63 58 71 ()}
        {Lisp-Entry "set-number-style" accessor #f 58 63 58 71 ()}
        {Lisp-Entry "boolean-style" property #f 59 12 59 25 ()}
        {Lisp-Entry "get-boolean-style" accessor #f 59 63 59 71 ()}
        {Lisp-Entry "set-boolean-style" accessor #f 59 63 59 71 ()}
        {Lisp-Entry "string-style" property #f 60 12 60 24 ()}
        {Lisp-Entry "get-string-style" accessor #f 60 63 60 71 ()}
        {Lisp-Entry "set-string-style" accessor #f 60 63 60 71 ()}
        {Lisp-Entry "delimited-string-style" property #f 61 12 61 34 ()}
        {Lisp-Entry "get-delimited-string-style" accessor #f 61 63 61 71 ()}
        {Lisp-Entry "set-delimited-string-style" accessor #f 61 63 61 71 ()}
        {Lisp-Entry "named-string-style" property #f 62 12 62 30 ()}
        {Lisp-Entry "get-named-string-style" accessor #f 62 63 62 71 ()}
        {Lisp-Entry "set-named-string-style" accessor #f 62 63 62 71 ()}
        {Lisp-Entry "quotation-style" property #f 63 12 63 27 ()}
        {Lisp-Entry "get-quotation-style" accessor #f 63 63 63 71 ()}
        {Lisp-Entry "set-quotation-style" accessor #f 63 63 63 71 ()}
        {Lisp-Entry "feature-style" property #f 64 12 64 25 ()}
        {Lisp-Entry "get-feature-style" accessor #f 64 63 64 71 ()}
        {Lisp-Entry "set-feature-style" accessor #f 64 63 64 71 ()}
        {Lisp-Entry "reference-style" property #f 65 12 65 27 ()}
        {Lisp-Entry "get-reference-style" accessor #f 65 63 65 71 ()}
        {Lisp-Entry "set-reference-style" accessor #f 65 63 65 71 ()}
        {Lisp-Entry "warning-style" property #f 66 12 66 25 ()}
        {Lisp-Entry "get-warning-style" accessor #f 66 63 66 71 ()}
        {Lisp-Entry "set-warning-style" accessor #f 66 63 66 71 ()}
        {Lisp-Entry "fatal-style" property #f 67 12 67 23 ()}
        {Lisp-Entry "get-fatal-style" accessor #f 67 63 67 71 ()}
        {Lisp-Entry "set-fatal-style" accessor #f 67 63 67 71 ()}
        {Lisp-Entry "break-style" property #f 68 12 68 23 ()}
        {Lisp-Entry "get-break-style" accessor #f 68 63 68 71 ()}
        {Lisp-Entry "set-break-style" accessor #f 68 63 68 71 ()}
        {Lisp-Entry "completions" property #f 69 12 69 23 ()}
        {Lisp-Entry "get-completions" accessor #f 69 63 69 71 ()}
        {Lisp-Entry "set-completions" accessor #f 69 63 69 71 ()}
        {Lisp-Entry "translate-keys?" property #f 70 12 70 27 ()}
        {Lisp-Entry "get-translate-keys?" accessor #f 70 63 70 71 ()}
        {Lisp-Entry "set-translate-keys?" accessor #f 70 63 70 71 ()}
        {Lisp-Entry "form" anonymous #f 73 3 73 7 ("Text-Break" "break-style:" "Text-Fatal" "fatal-style:" "Text-Warning" "warning-style:" "Text-Reference" "reference-style:" "Text-Feature" "feature-style:" "Text-Quotation" "quotation-style:" "Text-Named-String" "named-string-style:" "Text-Delimited-String" "delimited-string-style:" "Text-String" "string-style:" "Text-Boolean" "boolean-style:" "Text-Number" "number-style:" "Text-Char" "char-style:" "Text-Specifier" "specifier-style:" "Text-Tag" "tag-style:" "Text-Keyword" "keyword-style:" "Text-Declaration" "declaration-style:" "Text-Declaration-Keyword" "declaration-keyword-style:" "Text-Named-Comment" "named-comment-style:" "Text-Expr-Comment" "expr-comment-style:" "Text-Comment" "comment-style:" "Text-Title" "Base" "Text-Style" "title-style:" "install" "<install>")}
        {Lisp-Entry "get-class-descriptor" method #f 103 25 103 45 ("Lisp-Text-Preferences-Descriptor" "new")}}
      {Lisp-Entry "design" submodule #f 112 11 112 17 ()
        {Lisp-Entry "import" anonymous #f 115 1 115 7 ("jazz.designer")}
        {Lisp-Entry "Lisp-Text-Preferences-Descriptor" class #f 118 7 118 39 ("Code-Text-Preferences-Descriptor")
          {Lisp-Entry "form" anonymous #f 121 3 121 7 ("Boolean-Domain" "<Boolean-Domain>" "domain" "Completions-Domain" "<Completions-Domain>" "feature-style" "quotation-style" "named-string-style" "delimited-string-style" "string-style" "boolean-style" "number-style" "char-style" "specifier-style" "tag-style" "declaration-keyword-style" "name:" "Property-Descriptor" "<Property-Descriptor>" "translate-keys?" "keyword-style" "declaration-style" "expr-comment-style" "comment-style" "title-style" "completions" "categorized:" ">" "<properties" "<properties~>" "install" "<install>")}}}}})
"Lisp-Text-View"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "text" "Lisp-Text-View.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.text.Lisp-Text-View" module #f 37 18 37 54 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("jazz.ui.view" "jazz.ui.search" "jazz.ui" "jazz.system" "jazz.platform" "jazz.library.automata" "jazz.library" "jazz.jml" "jazz.editor.lisp" "jazz.debugger" "jazz.catalog")}
      {Lisp-Entry "Auto-Complete-Characters" constant #f 53 10 53 34 ()}
      {Lisp-Entry "Lisp-Text-View" class #f 57 7 57 21 ("cond" "list" "x" "lambda" "for-each" "b" "a" "foo" "virtual" "public" "method" "comment" "Code-Text-View")
        {Lisp-Entry "install" method #f 60 20 60 27 ("get-break-style" "get-break-style~" "Break" "get-fatal-style" "get-fatal-style~" "Fatal" "get-warning-style" "get-warning-style~" "Warning" "get-reference-style" "get-reference-style~" "Reference" "get-feature-style" "get-feature-style~" "Feature" "get-quotation-style" "get-quotation-style~" "Quotation" "get-named-string-style" "get-named-string-style~" "Named-String" "get-delimited-string-style" "get-delimited-string-style~" "Delimited-String" "get-string-style" "get-string-style~" "String" "get-boolean-style" "get-boolean-style~" "Boolean" "get-number-style" "get-number-style~" "Number" "get-char-style" "get-char-style~" "Char" "get-specifier-style" "get-specifier-style~" "Specifier" "get-tag-style" "get-tag-style~" "Tag" "get-keyword-style" "get-keyword-style~" "Keyword" "get-declaration-style" "get-declaration-style~" "Declaration" "get-declaration-keyword-style" "get-declaration-keyword-style~" "Declaration-Keyword" "get-named-comment-style" "get-named-comment-style~" "Named-Comment" "get-expr-comment-style" "get-expr-comment-style~" "Expr-Comment" "get-comment-style" "get-comment-style~" "Comment" "get-title-style" "get-title-style~" "Title" "add-style" "preferences" "pref" "let" "nextmethod" "rest")}
        {Lisp-Entry "new-syntax" method #f 86 20 86 30 ("model" "Lisp-Syntax" "new")}
        {Lisp-Entry "host-icon" method #f 95 25 95 34 ("Image-Resource")}
        {Lisp-Entry "get-locat-container" method #f 104 18 104 37 ("parse" "parse~" "if" "get-moniker" "moniker" "let")}
        {Lisp-Entry "focus-actions" method #f 116 20 116 33 ("nextmethod" "lisp-text" "find-actions" "cons")}
        {Lisp-Entry "context-menu" method #f 126 20 126 32 ("get-context-menu" "track-popup-menu" "edit-references" "edit-definitions" "move-caret:" "context-menu-click" "always" "else" "never" "outside-selection" "not" "and" "cond" "move-caret" "let" "modifiers-down" "alt?" "control?" "shift?" "receive" "pos")}
        {Lisp-Entry "tab-press" method #f 139 20 139 29 ("tabulate" "lambda" "model" "get-undoer" "get-undoer~" "with-atomic-undo" "with-atomic-undo~" "insert-char" "shift-key?" "nextmethod" "accepts-returns?" "not" "has-completion?" "or" "if" "modifiers" "key")}
        {Lisp-Entry "on-tabulate" method #f 173 11 173 22 ("tabulate" "lambda" "model" "get-undoer" "get-undoer~" "with-atomic-undo" "with-atomic-undo~" "evt")}
        {Lisp-Entry "return-press" method #f 179 20 179 32 ("tabulate" "nextmethod" "lambda" "model" "get-undoer" "get-undoer~" "with-atomic-undo" "with-atomic-undo~" "key")}
        {Lisp-Entry "tabulate" method #f 186 20 186 28 ("ignore" "action:" "set-modified?" "when" "+" "get-line" "get-line~" "tabulate-lines" "fx" "<fx>" "last-delta" "modified?" "receive" "set-caret" "with-safe-explore" "lambda" "with-update-locked" "get-end" "end" "get-start" "start" "let")}
        {Lisp-Entry "tabulate-lines" method #f 201 20 201 34 ("values" "set!" "0" "/=" "when" "tabulate-line" "=" "delta" "to" "from" "line" "for" "loop" "last-delta" "modified?" "let" "end" "start")}
        {Lisp-Entry "tabulate-line" method #f 212 20 212 33 ("tabulate-delta" "+" "make-string" "list" "Cell" "Range$Cell$" "new" "replace-text" "get-column" "actual" "let" "0" "/=" "when" "delta" "tabulate-column" "define" "line")}
        {Lisp-Entry "tabulate-delta" method #f 224 18 224 32 ("get-column" "*" "-1" "decrease!" "when" "specials" "bind" "element" "upper-case?" "default-col" "4" "threshold" "proposed-col" "else" "neq?" "2" "/=" "first-line" "first-last" "list" "get-tabulate" "get-tabulate~" "tabulate" "get-modifiers" "get-modifiers~" "get-expression-syntax" "form" "info" "first-indent" "first-dispatch?" "first-without?" "first-with?" "starts-with?" "first-call-with?" "tag?" "first-tag?" "get-kind" "get-kind~" "eq?" "first-symbol" "first-string" "get-col" "get-col~" "+" "null?" "col" "rank" "length" "opening" "collect-backward-exprs" "collect-backward-exprs~" "remove-expression-comments" "remove-expression-comments~" "start:" "model" "explorer-class" "Text-Explorer" "<Text-Explorer>" "expl" "Cell" "new" "pos" "get-end" "get-end~" "get-char" "eqv?" "Range$Cell$" "<Range$Cell$>" "range" "mark" "lambda" "collect-if" "cons" "pair?" "lst" "remove-specifiers" "=" "get-start" "get-start~" "get-line" "get-line~" "first" "reverse" ">" "reversed" "let*" "count" "first-on-last-line" "1" "cardinality" "fx" "<fx>" "cast" "-" "subseq" "string->symbol" "ends-with?" "string" "effective-symbol" "cdr" "increase!" "set!" "memq?" "or" "if" "car" "get-range" "get-range~" "get-string" "find-symbol" "symbol" "not" "not-null?" "and" "while" "done?" "0" "total" "let" "modifiers" "expressions" "count-modifiers" "define" "line")}
        {Lisp-Entry "evaluate-selection" method #f 315 20 315 38 ("evaluate-range" ".1" "sleep" ":wait" "with-cursor" "bell" "not" "if" "current-declaration-range" "range" "let" "lambda" "with-safe-explore")}
        {Lisp-Entry "evaluate-buffer" method #f 327 20 327 35 ("buffer-selection" "evaluate-range" ".1" "sleep" "lambda" ":wait" "with-cursor")}
        {Lisp-Entry "evaluate-range" method #f 334 20 334 34 ("user-message" "not-null?" "names" "evaluate-expressions" "evaluate-expressions~" "prepare-expressions" "col" "line" "container" "str" "bind" "bell" "not" "if" "get-debugger-manager" "get-focused-process" "get-focused-process~" "debugged" "queue-list" "explore-error" "explore-error~" "nu<?" "enqueue" "form-name" "form-name~" "name" "get-range" "get-range~" "syntax" "read-text-form" "read-text-form~" "form" "nu<=?" "cond" "e" "s" "iterate" "forward-expr" "forward-expr~" "when" "new-queue" "queue" "end:" "start:" "model" "explorer-class" "new" "expl" "get-end" "get-end~" "end" "get-start" "get-start~" "start" "let" "collect-declaration-names" "define" "range")}
        {Lisp-Entry "prepare-expressions" method #f 365 29 365 48 ("range")}
        {Lisp-Entry "match-backwards?" method #f 374 20 374 36 ("memq?" "char")}
        {Lisp-Entry "match-forwards?" method #f 378 20 378 35 ("memq?" "char")}
        {Lisp-Entry "headers" constant #f 387 12 387 19 ("4" "make-string" "string-append" "list")}
        {Lisp-Entry "get-headers" method #f 392 20 392 31 ("headers")}
        {Lisp-Entry "current-declaration" method #f 401 11 401 30 ("get-string" "read-string-element" "when" "current-declaration-range" "range" "let")}
        {Lisp-Entry "current-declaration-range" method #f 407 11 407 36 ("get-end" "declaration-range" "effective-selection" "or")}
        {Lisp-Entry "declaration-range" method #f 412 18 412 35 ("else" "inner-name?" "inner-name?~" "declaration-name?" "declaration-name?~" "and" "get-end" "get-end~" "nu=?" "get-start" "get-start~" "get-line" "get-line~" "=" "or" "namespace-name?" "namespace-name?~" "cond" "form-expr" "form-expr~" "name" "get-range" "get-range~" "new-range" "outer-expr" "outer-expr~" "not" "if" "range" "iterate" "end:" "start:" "model" "explorer-class" "new" "Text-Explorer" "<Text-Explorer>" "expl" "let" "pos")}
        {Lisp-Entry "outer-declaration-range" method #f 434 18 434 41 ("declaration-name" "declaration-name~" "values" "inner-name?" "inner-name?~" "declaration-name?" "declaration-name?~" "and" "form-expr" "form-expr~" "name" "get-range" "get-range~" "new-range" "outer-expr" "outer-expr~" "not" "if" "iterate" "range:" "model" "explorer-class" "new" "Text-Explorer" "<Text-Explorer>" "expl" "let" "range")}
        {Lisp-Entry "info-message" method #f 447 20 447 32 ("cdr" "format" "2" "length" ">=" "nextmethod" "concatenate" "outer-expr" "outer-expr~" "declaration-name" "declaration-name~" "cons" "declaration-expr?" "declaration-expr?~" "if" "names" "iter" "get-selection" "current-declaration-range" "or" "range:" "model" "explorer-class" "new" "expl" "let" "collect-names" "define")}
        {Lisp-Entry "Highlight-Styles" definition #f 470 14 470 30 ("Break" "Fatal" "Warning" "Reference")}
        {Lisp-Entry "highlight-style?" definition #f 474 15 474 31 ("Highlight-Styles" "inherits?" "inherits?~" "style-name" "lambda" "some?" "style")}
        {Lisp-Entry "constant?" definition #f 480 15 480 24 ("keyword?" "symbol?" "char?" "boolean?" "number?" "or" "expr")}
        {Lisp-Entry "reference-search-context" method #f 488 11 488 35 ("whole-words?:" "empty-effective-selection?" "standardize-form" "and" "model" "search-context" "search-context~" "target")}
        {Lisp-Entry "on-highlight-selection" method #f 493 11 493 33 ("highlight-expression" "unhighlight-expression" "highlight-style?" "model" "get-style-at" "get-style-at~" "style" "reference-search-context" "target" "constant?" "range-expr" "constant" "bell" "not" "or" "if" "current-expr-range" "expr-range" "declaration-range" "get-start" "pos" "let" "evt")}
        {Lisp-Entry "on-highlight-declaration" method #f 509 11 509 35 ("highlight-declaration" "get-string" "reference-search-context" "target" "bell" "current-expr-range" "range" "0" "substring" "not" "if" "find" "pos" "let" "str" "single-line" "define" "evt")}
        {Lisp-Entry "highlight-declaration" method #f 523 18 523 39 ("highlight?:" "select-command-highlight" "select-command-highlight~" "get-end" "get-end~" "get-start~" "self" "make-text-search-result" "search-result" "forward" "get-application" "select-command-search" "select-command-search~" "bell" "begin" "not" "if" "get-start" "declaration-range" "let" "target" "range")}
        {Lisp-Entry "on-remove-highlights" method #f 533 11 533 31 ("remove-highlights" "bell" "not" "if" "get-start" "declaration-range" "range" "let" "evt")}
        {Lisp-Entry "find-expression" method #f 540 18 540 33 ("continuation-return" "found" "iterate-expression-target" "return" "lambda" "continuation-capture" "target" "range")}
        {Lisp-Entry "highlight-reference" method #f 549 18 549 37 ("self" "get-application" "select-command-highlight" "select-command-highlight~" "search-result" "range" "direction")}
        {Lisp-Entry "highlight-expression" method #f 553 18 553 38 ("queue-list" "enqueue" "Reference" "model" "push-style" "push-style~" "found" "lambda" "iterate-expression-target" "new-queue" "ranges" "let" "target" "range")}
        {Lisp-Entry "unhighlight-expression" method #f 562 18 562 40 ("Reference" "model" "pop-style" "pop-style~" "found" "lambda" "iterate-expression-target" "target" "range")}
        {Lisp-Entry "remove-highlights" method #f 568 18 568 35 ("get-end" "get-end~" "end:" "get-start" "get-start~" "get-line" "get-line~" "start:" "get-runs" "get-runs~" "invalidate-paragraph" "invalidate-paragraph~" "get-default-style" "get-default-style~" "set-style" "set-style~" "highlight-style?" "when" "get-style" "get-style~" "style" "let" "run" "for-each" "Paragraph" "<Paragraph>" "paragraph" "fx" "<fx>" "line" "lambda" "model" "for-each-paragraph" "for-each-paragraph~" "range")}
        {Lisp-Entry "iterate-expression-target" method #f 581 11 581 36 ("Range$Cell$" "cdr" "-" "end" "car" "nu+" "start" "regular-search" "found" "0" "string-ref" "eqv?" "unless" "get-marked" "get-marked~" "seq" "constant?" "constant?~" "when" "mode" "lambda" "iterate-expression" "iterate-expression~" "end:" "get-start" "get-start~" "start:" "model" "explorer-class" "new" "Text-Explorer" "<Text-Explorer>" "expl" "let" "proc" "target" "range")}}}})
"_lisp"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "_lisp.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp" module #f 37 8 37 24 ("jazz")
      {Lisp-Entry "export" anonymous #f 40 1 40 7 ("syntax" "phase" "jazz.editor.lisp.syntax" "jazz.editor.lisp.autoload")}
      {Lisp-Entry "*expression-syntaxes*" definition #f 49 12 49 33 ("eq?" "test:" "make-table")}
      {Lisp-Entry "get-expression-syntax" definition #f 53 20 53 41 ("*expression-syntaxes*" "table-ref" "name")}
      {Lisp-Entry "register-expression-syntax" definition #f 57 20 57 46 ("get-name" "get-name~" "*expression-syntaxes*" "table-set!" "form")}
      {Lisp-Entry "Expression-Syntax" class #f 61 7 61 24 ("Object")
        {Lisp-Entry "name" slot #f 64 8 64 12 ()}
        {Lisp-Entry "get-name" accessor #f 64 33 64 41 ()}
        {Lisp-Entry "dialect" slot #f 65 8 65 15 ()}
        {Lisp-Entry "get-dialect" accessor #f 65 33 65 41 ()}
        {Lisp-Entry "namespace?" slot #f 66 8 66 18 ()}
        {Lisp-Entry "get-namespace?" accessor #f 66 33 66 41 ()}
        {Lisp-Entry "declaration?" slot #f 67 8 67 20 ()}
        {Lisp-Entry "get-declaration?" accessor #f 67 33 67 41 ()}
        {Lisp-Entry "anonymous?" slot #f 68 8 68 18 ()}
        {Lisp-Entry "get-anonymous?" accessor #f 68 33 68 41 ()}
        {Lisp-Entry "inner?" slot #f 69 8 69 14 ()}
        {Lisp-Entry "get-inner?" accessor #f 69 33 69 41 ()}
        {Lisp-Entry "modifiers" slot #f 70 8 70 17 ()}
        {Lisp-Entry "get-modifiers" accessor #f 70 33 70 41 ()}
        {Lisp-Entry "keywords" slot #f 71 8 71 16 ()}
        {Lisp-Entry "get-keywords" accessor #f 71 33 71 41 ()}
        {Lisp-Entry "tabulate" slot #f 72 8 72 16 ()}
        {Lisp-Entry "get-tabulate" accessor #f 72 33 72 41 ()}
        {Lisp-Entry "walk" slot #f 73 8 73 12 ()}
        {Lisp-Entry "get-walk" accessor #f 73 33 73 41 ()}
        {Lisp-Entry "name-mangler" slot #f 74 8 74 20 ()}
        {Lisp-Entry "get-name-mangler" accessor #f 74 33 74 41 ()}
        {Lisp-Entry "signature-mangler" slot #f 75 8 75 25 ()}
        {Lisp-Entry "get-signature-mangler" accessor #f 75 33 75 41 ()}
        {Lisp-Entry "initialize" method #f 78 20 78 30 ("signature-mangler~self" "name-mangler~self" "walk~self" "tabulate~self" "keywords~self" "modifiers~self" "inner?~self" "anonymous?~self" "declaration?~self" "namespace?~self" "dialect~self" "self" "name~self" "set!" "nextmethod" "signature-mangler" "signature-mangler:" "name-mangler" "name-mangler:" "walk" "walk:" "tabulate" "tabulate:" "keywords" "keywords:" "modifiers" "modifiers:" "inner?" "inner?:" "anonymous?" "anonymous?:" "declaration?" "declaration?:" "namespace?" "namespace?:" "jazz" "dialect" "dialect:" "name")}}
      {Lisp-Entry "expression-syntax-namespace?" definition #f 110 20 110 48 ("get-namespace?" "get-namespace?~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-declaration?" definition #f 115 20 115 50 ("get-declaration?" "get-declaration?~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-anonymous?" definition #f 120 20 120 48 ("get-anonymous?" "get-anonymous?~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-inner?" definition #f 125 20 125 44 ("get-inner?" "get-inner?~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-modifiers" definition #f 130 20 130 47 ("get-modifiers" "get-modifiers~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-keywords" definition #f 135 20 135 46 ("get-keywords" "get-keywords~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-tabulate" definition #f 140 20 140 46 ("get-tabulate" "get-tabulate~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-walk" definition #f 145 20 145 42 ("get-walk" "get-walk~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-name-mangler" definition #f 150 20 150 50 ("get-name-mangler" "get-name-mangler~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}
      {Lisp-Entry "expression-syntax-signature-mangler" definition #f 155 20 155 55 ("get-signature-mangler" "get-signature-mangler~" "and" "get-expression-syntax" "expression-syntax" "let" "symbol")}}})
"autoload"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "autoload.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.autoload" module #f 37 18 37 43 ("jazz")
      {Lisp-Entry "export" anonymous #f 40 1 40 7 ("Lisp-Syntax" "jazz.editor.lisp.text.Lisp-Syntax" "Lisp-Text-View" "jazz.editor.lisp.text.Lisp-Text-View" "Lisp-Text-Preferences-Descriptor" "Lisp-Text-Preferences" "jazz.editor.lisp.text.Lisp-Text-Preferences" "Lisp-Text-Actions" "jazz.editor.lisp.text.Lisp-Text-Actions" "Lisp-Explorer" "jazz.editor.lisp.text.Lisp-Explorer" "Lisp-Console-Manager" "jazz.editor.lisp.text.Lisp-Console-Manager" "Lisp-Parser" "jazz.editor.lisp.parser.Lisp-Parser" "Lisp-File-Entry" "jazz.editor.lisp.catalog.Lisp-File-Entry" "Lisp-Entry" "autoload" "jazz.editor.lisp.catalog.Lisp-Entry")}}})
"install"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "install.scm"} 236918187. scheme
    {Lisp-Entry "jazz.editor.lisp.install" unit #f 37 6 37 30 ()
      {Lisp-Entry "Lisp-File-Entry" define ("literal") 40 21 40 36 ("construct-lisp-file-entry" "jazz.editor.lisp.literals" "jazz.editor.lisp.literals:construct-lisp-file-entry")}
      {Lisp-Entry "Lisp-Entry" define ("literal") 41 21 41 31 ("construct-lisp-entry" "jazz.editor.lisp.literals" "jazz.editor.lisp.literals:construct-lisp-entry")}}})
"literals"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "literals.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.literals" module #f 37 8 37 33 ("jazz")
      {Lisp-Entry "import" anonymous #f 40 1 40 7 ("time" "jazz.editor.lisp")}
      {Lisp-Entry "construct-lisp-file-entry" definition #f 44 21 44 46 ("seconds->time" "Lisp-File-Entry" "new" "definitions" "dialect" "time" "file")}
      {Lisp-Entry "construct-lisp-entry" definition #f 48 21 48 41 ("Lisp-Entry" "new" "definitions" "references" "end-column" "end-line" "column" "line" "signature" "kind" "name")}}})
"syntax"
 ({Lisp-File-Entry {File :context "src" "jazz" "editor" "lisp" "syntax.jazz"} 236918187. jazz
    {Lisp-Entry "jazz.editor.lisp.syntax" module #f 37 18 37 41 ("jazz")
      {Lisp-Entry "define-expression" macro ("macro") 40 15 40 32 (",signature-mangler" "signature-mangler:" ",name-mangler" "name-mangler:" ",walk" "walk:" ",tabulate" "tabulate:" ",keywords" "keywords:" ",modifiers" "modifiers:" ",inner?" "inner?:" ",anonymous?" "anonymous?:" ",declaration?" "declaration?:" ",namespace?" "namespace?:" ",dialect" "dialect:" ",name" "Expression-Syntax" "new" "register-expression-syntax" "signature-mangler" "name-mangler" "walk" "tabulate" "keywords" "modifiers" "inner?" "anonymous?" "declaration?" "namespace?" "jazz" "dialect" "bind-keywords" "rest" "name")}}})
