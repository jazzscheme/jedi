"_irregex"
 ({Lisp-File-Entry {File Jazz "lib" "contrib.irregex" "src" "irregex" "_irregex.jazz"} 1288732032
    {Lisp-Entry "irregex" module #f 37 8 37 15 ("scheme")
      {Lisp-Entry "irregex" native #f 43 8 43 15 ()}
      {Lisp-Entry "string->irregex" native #f 44 8 44 23 ()}
      {Lisp-Entry "sre->irregex" native #f 45 8 45 20 ()}
      {Lisp-Entry "irregex?" native #f 46 8 46 16 ()}
      {Lisp-Entry "irregex-num-submatches" native #f 47 8 47 30 ()}
      {Lisp-Entry "make-irregex-chunker" native #f 48 8 48 28 ()}
      {Lisp-Entry "irregex-match" native #f 49 8 49 21 ()}
      {Lisp-Entry "irregex-match/chunked" native #f 50 8 50 29 ()}
      {Lisp-Entry "irregex-search" native #f 51 8 51 22 ()}
      {Lisp-Entry "irregex-search/chunked" native #f 52 8 52 30 ()}
      {Lisp-Entry "irregex-match-data?" native #f 53 8 53 27 ()}
      {Lisp-Entry "irregex-match-valid-index?" native #f 54 8 54 34 ()}
      {Lisp-Entry "irregex-match-substring" native #f 55 8 55 31 ()}
      {Lisp-Entry "irregex-match-subchunk" native #f 56 8 56 30 ()}
      {Lisp-Entry "irregex-match-start-chunk" native #f 57 8 57 33 ()}
      {Lisp-Entry "irregex-match-start-index" native #f 58 8 58 33 ()}
      {Lisp-Entry "irregex-match-end-chunk" native #f 59 8 59 31 ()}
      {Lisp-Entry "irregex-match-end-index" native #f 60 8 60 31 ()}
      {Lisp-Entry "irregex-replace" native #f 61 8 61 23 ()}
      {Lisp-Entry "irregex-replace/all" native #f 62 8 62 27 ()}
      {Lisp-Entry "irregex-fold" native #f 63 8 63 20 ()}
      {Lisp-Entry "irregex-fold/chunked" native #f 64 8 64 28 ()}}})
"irregex"
 ({Lisp-File-Entry {File Jazz "lib" "contrib.irregex" "src" "irregex" "implementation" "irregex.scm"} 1288732032
    {Lisp-Entry "irregex.implementation.irregex" unit #f 57 6 57 36 ()
      {Lisp-Entry "irregex-tag" define #f 61 8 61 19 ("*irregex-tag*" "'*irregex-tag*")}
      {Lisp-Entry "make-irregex" define #f 63 9 63 21 ("irregex-tag" "vector" "names" "lengths" "submatches" "flags" "nfa" "dfa/extract" "dfa/search" "dfa")}
      {Lisp-Entry "irregex?" define #f 68 9 68 17 ("0" "vector-ref" "irregex-tag" "eq?" "vector-length" "9" "=" "vector?" "and" "obj")}
      {Lisp-Entry "irregex-dfa" define #f 73 9 73 20 ("1" "vector-ref" "x")}
      {Lisp-Entry "irregex-dfa/search" define #f 74 9 74 27 ("2" "vector-ref" "x")}
      {Lisp-Entry "irregex-dfa/extract" define #f 75 9 75 28 ("3" "vector-ref" "x")}
      {Lisp-Entry "irregex-nfa" define #f 76 9 76 20 ("4" "vector-ref" "x")}
      {Lisp-Entry "irregex-flags" define #f 77 9 77 22 ("5" "vector-ref" "x")}
      {Lisp-Entry "irregex-num-submatches" define #f 78 9 78 31 ("6" "vector-ref" "x")}
      {Lisp-Entry "irregex-lengths" define #f 79 9 79 24 ("7" "vector-ref" "x")}
      {Lisp-Entry "irregex-names" define #f 80 9 80 22 ("8" "vector-ref" "x")}
      {Lisp-Entry "irregex-new-matches" define #f 82 9 82 28 ("irregex-names" "irregex-num-submatches" "make-irregex-match" "irx")}
      {Lisp-Entry "irregex-reset-matches!" define #f 85 9 85 31 ("vector-set!" "3" "<=" "1" "vector-length" "-" "i" "do" "m")}
      {Lisp-Entry "irregex-copy-matches" define #f 90 9 90 29 ("vector-ref" "vector-set!" "0" "<" "1" "-" "i" "do" "vector-length" "make-vector" "r" "let" "vector?" "and" "m")}
      {Lisp-Entry "irregex-match-tag" define #f 97 8 97 25 ("*irregex-match-tag*" "'*irregex-match-tag*")}
      {Lisp-Entry "irregex-match-data?" define #f 99 9 99 28 ("0" "vector-ref" "irregex-match-tag" "eq?" "11" "vector-length" ">=" "vector?" "and" "obj")}
      {Lisp-Entry "make-irregex-match" define #f 104 9 104 27 ("irregex-match-tag" "0" "vector-set!" "3" "2" "4" "*" "+" "make-vector" "res" "let" "names" "count")}
      {Lisp-Entry "irregex-match-num-submatches" define #f 110 9 110 37 ("2" "4" "3" "vector-length" "quotient" "-" "m")}
      {Lisp-Entry "irregex-match-chunker" define #f 113 9 113 30 ("1" "vector-ref" "m")}
      {Lisp-Entry "irregex-match-names" define #f 115 9 115 28 ("2" "vector-ref" "m")}
      {Lisp-Entry "irregex-match-chunker-set!" define #f 117 9 117 35 ("1" "vector-set!" "str" "m")}
      {Lisp-Entry "%irregex-match-start-chunk" define #f 120 9 120 35 ("4" "*" "3" "+" "vector-ref" "n" "m")}
      {Lisp-Entry "%irregex-match-start-index" define #f 121 9 121 35 ("*" "4" "+" "vector-ref" "n" "m")}
      {Lisp-Entry "%irregex-match-end-chunk" define #f 122 9 122 33 ("4" "*" "5" "+" "vector-ref" "n" "m")}
      {Lisp-Entry "%irregex-match-end-index" define #f 123 9 123 33 ("4" "*" "6" "+" "vector-ref" "n" "m")}
      {Lisp-Entry "irregex-match-start-chunk" define #f 126 9 126 34 ("%irregex-match-start-chunk" "error" "irregex-match-valid-index?" "not" "if" "n" "m")}
      {Lisp-Entry "irregex-match-start-index" define #f 130 9 130 34 ("%irregex-match-start-index" "error" "irregex-match-valid-index?" "not" "if" "n" "m")}
      {Lisp-Entry "irregex-match-end-chunk" define #f 134 9 134 32 ("%irregex-match-end-chunk" "error" "irregex-match-valid-index?" "not" "if" "n" "m")}
      {Lisp-Entry "irregex-match-end-index" define #f 138 9 138 32 ("%irregex-match-end-index" "error" "irregex-match-valid-index?" "not" "if" "n" "m")}
      {Lisp-Entry "irregex-match-start-chunk-set!" define #f 143 9 143 39 ("4" "*" "3" "+" "vector-set!" "start" "n" "m")}
      {Lisp-Entry "irregex-match-start-index-set!" define #f 145 9 145 39 ("*" "4" "+" "vector-set!" "start" "n" "m")}
      {Lisp-Entry "irregex-match-end-chunk-set!" define #f 147 9 147 37 ("4" "*" "5" "+" "vector-set!" "end" "n" "m")}
      {Lisp-Entry "irregex-match-end-index-set!" define #f 149 9 149 37 ("4" "*" "6" "+" "vector-set!" "end" "n" "m")}
      {Lisp-Entry "irregex-match-index" define #f 152 9 152 28 ("0" "error" "else" "cdr" "=>" "irregex-match-names" "assq" "car" "number?" "cond" "pair?" "if" "opt" "m")}
      {Lisp-Entry "%irregex-match-valid-index?" define #f 159 9 159 36 ("vector-ref" "vector-length" "4" "*" "3" "+" "<" "and" "n" "m")}
      {Lisp-Entry "irregex-match-valid-index?" define #f 163 9 163 35 ("%irregex-match-valid-index?" "integer?" "error" "irregex-match-data?" "not" "if" "n" "m")}
      {Lisp-Entry "irregex-match-substring" define #f 170 9 170 32 ("%irregex-match-end-index" "%irregex-match-end-chunk" "%irregex-match-start-index" "%irregex-match-start-chunk" "chunker-get-substring" "%irregex-match-valid-index?" "and" "irregex-match-index" "n" "irregex-match-chunker" "cnk" "let*" "error" "irregex-match-data?" "not" "if" "opt" "m")}
      {Lisp-Entry "irregex-match-subchunk" define #f 182 9 182 31 ("%irregex-match-end-index" "%irregex-match-end-chunk" "%irregex-match-start-index" "%irregex-match-start-chunk" "%irregex-match-valid-index?" "and" "chunker-get-subchunk" "get-subchunk" "irregex-match-index" "n" "irregex-match-chunker" "cnk" "let*" "error" "irregex-match-data?" "not" "if" "opt" "m")}
      {Lisp-Entry "make-irregex-chunker" define #f 199 9 199 29 ("vector" "error" "procedure?" "not" "get-subchunk" "cons" "string-cat-reverse" "list" "res" "loop" "let" "substring" "eq?" "end" "cnk2" "start" "cnk1" "get-substr" "string-length" "get-end" "cdr" "if" "0" "cnk" "lambda" "car" "pair?" "and" "or" "get-start" "let*" "o" "get-str" "get-next")}
      {Lisp-Entry "chunker-get-next" define #f 232 9 232 25 ("0" "vector-ref" "cnk")}
      {Lisp-Entry "chunker-get-str" define #f 233 9 233 24 ("1" "vector-ref" "cnk")}
      {Lisp-Entry "chunker-get-start" define #f 234 9 234 26 ("2" "vector-ref" "cnk")}
      {Lisp-Entry "chunker-get-end" define #f 235 9 235 24 ("3" "vector-ref" "cnk")}
      {Lisp-Entry "chunker-get-substring" define #f 236 9 236 30 ("4" "vector-ref" "cnk")}
      {Lisp-Entry "chunker-get-subchunk" define #f 237 9 237 29 ("5" "vector-ref" "cnk")}
      {Lisp-Entry "chunker-prev-chunk" define #f 239 9 239 27 ("and" "next" "lp" "chunker-get-next" "get-next" "let" "eq?" "if" "end" "start" "cnk")}
      {Lisp-Entry "chunker-prev-char" define #f 249 9 249 26 ("1" "chunker-get-end" "-" "chunker-get-str" "string-ref" "and" "chunker-prev-chunk" "prev" "let" "end" "start" "cnk")}
      {Lisp-Entry "chunker-next-char" define #f 255 9 255 26 ("chunker-get-start" "chunker-get-str" "string-ref" "and" "chunker-get-next" "next" "let" "src" "cnk")}
      {Lisp-Entry "chunk-before?" define #f 261 9 261 22 ("chunk-before?" "if" "chunker-get-next" "next" "let" "eq?" "not" "and" "b" "a" "cnk")}
      {Lisp-Entry "*all-chars*" define #f 273 8 273 19 ("#x10FFFF" "#xE000" "#xD7FF" "0" "integer->char" "/")}
      {Lisp-Entry "*allow-utf8-mode?*" define #f 281 8 281 26 ()}
      {Lisp-Entry "string-scan-char" define #f 285 9 285 25 ("1" "+" "else" "string-ref" "eqv?" "=" "cond" "0" "car" "pair?" "if" "i" "scan" "string-length" "end" "let" "o" "c" "str")}
      {Lisp-Entry "string-scan-char-escape" define #f 292 9 292 32 ("1" "else" "2" "+" "string-ref" "eqv?" "=" "cond" "0" "car" "pair?" "if" "i" "scan" "string-length" "end" "let" "o" "c" "str")}
      {Lisp-Entry "string-scan-pred" define #f 300 9 300 25 ("1" "+" "else" "string-ref" "=" "cond" "0" "car" "pair?" "if" "i" "scan" "string-length" "end" "let" "o" "pred" "str")}
      {Lisp-Entry "string-split-char" define #f 307 9 307 26 ("else" "1" "+" "string-ref" "eqv?" "reverse" ">=" "cond" "substring" "cons" "collect" "define" "res" "from" "0" "i" "lp" "string-length" "end" "let" "c" "str")}
      {Lisp-Entry "char-alphanumeric?" define #f 315 9 315 27 ("char-numeric?" "char-alphabetic?" "or" "c")}
      {Lisp-Entry "%substring=?" define #f 318 9 318 21 ("else" "1" "+" "string-ref" "char=?" ">=" "cond" "0" "i" "lp" "let" "len" "start2" "start1" "b" "a")}
      {Lisp-Entry "%%string-copy!" define #f 329 9 329 23 ("string-ref" "string-set!" ">=" "j" "1" "+" "i" "do" "fend" "fstart" "from" "tstart" "to")}
      {Lisp-Entry "string-cat-reverse" define #f 335 9 335 27 ("0" "string-length" "+" "a" "s" "lambda" "fold" "string-cat-reverse/aux" "string-list")}
      {Lisp-Entry "string-cat-reverse/aux" define #f 340 9 340 31 ("cdr" "0" "%%string-copy!" "-" "string-length" "slen" "car" "s" "let*" "pair?" "if" "ls" "i" "lp" "make-string" "res" "let" "string-list" "len")}
      {Lisp-Entry "zero-to" define #f 355 9 355 16 ("cons" "zero?" "res" "1" "-" "i" "lp" "let" "0" "<=" "if" "n")}
      {Lisp-Entry "take-up-to" define #f 363 9 363 19 ("reverse" "car" "cons" "cdr" "eq?" "not" "pair?" "and" "if" "res" "ls" "lp" "let" "to" "from")}
      {Lisp-Entry "find" define #f 371 9 371 13 ("else" "car" "=>" "find-tail" "cond" "ls" "pred")}
      {Lisp-Entry "find-tail" define #f 375 9 375 18 ("cdr" "else" "car" "null?" "cond" "lp" "let" "ls" "pred")}
      {Lisp-Entry "last" define #f 381 9 381 13 ("car" "cdr" "lp" "let" "error" "pair?" "not" "if" "ls")}
      {Lisp-Entry "any" define #f 389 9 389 12 ("or" "null?" "if" "cdr" "tail" "car" "head" "lp" "let" "pair?" "and" "ls" "pred")}
      {Lisp-Entry "every" define #f 396 9 396 14 ("and" "if" "cdr" "tail" "car" "head" "lp" "let" "null?" "or" "ls" "pred")}
      {Lisp-Entry "fold" define #f 403 9 403 13 ("car" "cdr" "null?" "if" "res" "lp" "let" "ls" "knil" "kons")}
      {Lisp-Entry "filter" define #f 409 9 409 15 ("cons" "car" "cdr" "reverse" "null?" "if" "res" "lp" "let" "ls" "pred")}
      {Lisp-Entry "remove" define #f 415 9 415 15 ("cons" "car" "cdr" "reverse" "null?" "if" "res" "lp" "let" "ls" "pred")}
      {Lisp-Entry "integer-log" define #f 424 9 424 20 ("1" "integer-length" "-" "zero?" "if" "n")}
      {Lisp-Entry "flag-set?" define #f 426 9 426 18 ("bitwise-and" "=" "i" "flags")}
      {Lisp-Entry "flag-join" define #f 428 9 428 18 ("bitwise-ior" "if" "b" "a")}
      {Lisp-Entry "flag-clear" define #f 430 9 430 19 ("bitwise-not" "bitwise-and" "b" "a")}
      {Lisp-Entry "~none" define #f 433 8 433 13 ("0")}
      {Lisp-Entry "~searcher?" define #f 434 8 434 18 ("1")}
      {Lisp-Entry "~consumer?" define #f 435 8 435 18 ("2")}
      {Lisp-Entry "close-token" define #f 451 8 451 19 ("close" "'close" "list")}
      {Lisp-Entry "dot-token" define #f 452 8 452 17 ("string->symbol")}
      {Lisp-Entry "with-read-from-string" define #f 454 9 454 30 ("'close-token" "string->symbol" "string->number" "str2" "memv" "c" "char-whitespace?" "0" "symbol->string" "number->string" "number?" "s" "newline" "space" "string-cat-reverse" "substring" "=" "collect" "res" "from" "scan" "2" "unquote" "'unquote" "uquote-splicing" "'uquote-splicing" "u" "<" "and" "at?" "let*" "list" "quasiquote" "'quasiquote" "quote" "'quote" "q" "sexp" "eqv?" "or" "skip" "car" "cons" "cdr" "append" "not" "j3" "z" "j2" "y" "null?" "if" "dot-token" "reverse" "close-token" "eq?" "j" "x" "lambda" "ls" "1" "+" "lp" "let" "string-ref" "case" "else" "error" ">=" "cond" "k" "read" "string-length" "end" "define" "proc" "i" "str")}
      {Lisp-Entry "~save?" define #f 549 8 549 14 ("1")}
      {Lisp-Entry "~case-insensitive?" define #f 550 8 550 26 ("2")}
      {Lisp-Entry "~multi-line?" define #f 551 8 551 20 ("4")}
      {Lisp-Entry "~single-line?" define #f 552 8 552 21 ("8")}
      {Lisp-Entry "~ignore-space?" define #f 553 8 553 22 ("16")}
      {Lisp-Entry "~utf8?" define #f 554 8 554 14 ("32")}
      {Lisp-Entry "symbol-list->flags" define #f 556 9 556 27 ("else" "~utf8?" "*allow-utf8-mode?*" "utf8" "u" "~ignore-space?" "ignore-space" "x" "~single-line?" "single-line" "s" "~multi-line?" "multi-line" "m" "~case-insensitive?" "case-insensitive" "ci" "i" "car" "case" "flag-join" "cdr" "pair?" "not" "if" "~none" "res" "lp" "let" "ls")}
      {Lisp-Entry "maybe-string->sre" define #f 571 9 571 26 ("string->sre" "string?" "if" "obj")}
      {Lisp-Entry "string->sre" define #f 574 9 574 20 ("'eos" "eol" "'eol" "'bos" "bol" "'bol" "sym" "posix-escape-sequences" "assv" "cell" "string-scan-pred" ",backref" "'backref" "backref-ci" "'backref-ci" "backref" "char-mirror" "terminal" "memv" "string-parse-hex-escape" "reset" "newline" "eos" "bos" "nwb" "eow" "bow" "alphanumeric" "space" "" "numeric" ",m" ",@tail" "m" "string-split-char" "s2" "tail" "string-parse-cset" "apply" "cdar" "caar" "*allow-utf8-mode?*" "~ignore-space?" "~multi-line?" "'w/noutf8" "'w/utf8" "after" "before" "new-res" "join" "invert?" "lp2" "old-flags" ",s" "s" ",n" "string->number" "n" "char-numeric?" "4" "flag-clear" "string-scan-char" "sre" "lambda" "3" "with-read-from-string" "eqv?" "2" "flag-join" "sre-empty?" "sre-repeater?" "string" "string->symbol" "op" ",x" "**" "??" "?" "**?" "*?" "*" "x" "nonl" "'nonl" "any" "'any" "~single-line?" "+" "case" ">=" "save" "'or" ",res" ",@prefix" "cddadr" "cadadr" "seq" "'seq" "epsilon" "'epsilon" "'if" "eq?" "submatch" "'submatch" "~save?" "sre-alternate" "null?" "shift" "term" "cdr" "cddr" "reverse" "cadr" "'submatch-named" "list" "car" "prefix" "w/noutf8" "w/utf8" "submatch-named" "=>" "neg-look-behind" "look-behind" "neg-look-ahead" "look-ahead" "atomic" "last" "memq" "pair?" "func" "ls" "collect/terms" "string-ref" "utf8-string-ref" "c" "else" "<" "cond" "-" "utf8-backup-to-initial-char" "1" ">" "j" "~utf8?" "utf8?" "let*" "collect/single" "substring" "cons" "=" "collect" "string->list" "map" "sre-sequence" "cased-string" "char-altcase" ",ch" "or" "char-alphabetic?" "~case-insensitive?" "flag-set?" "and" "ch" "cased-char" "define" "st" "res" "from" "0" "i" "lp" "symbol-list->flags" "flags" "string-length" "end" "let" "error" "string?" "not" "if" "o" "str")}
      {Lisp-Entry "posix-escape-sequences" define #f 1011 8 1011 30 ("2" "#x11" "1" "-" "3" "char->integer" "+" "integer->char")}
      {Lisp-Entry "char-altcase" define #f 1020 9 1020 21 ("char-upcase" "char-downcase" "char-upper-case?" "if" "c")}
      {Lisp-Entry "char-mirror" define #f 1023 9 1023 20 ("else" "case" "c")}
      {Lisp-Entry "string-parse-hex-escape" define #f 1026 9 1026 32 ("2" "else" "integer->char" "list" "16" "string->number" "n" "substring" "s" "let*" "not" "if" "1" "+" "string-scan-char-escape" "j" "let" "string-ref" "eqv?" "error" ">=" "cond" "end" "i" "str")}
      {Lisp-Entry "string-parse-cset" define #f 1048 9 1048 26 ("~multi-line?" "ch" "string" "string->sre" "char?" "cset-complement" "substring" "string->symbol" "sre->cset" "cset" "not" "string-scan-char" "i2" "inv?" "utf8-string-ref" "utf8-start-char->length" "len" "#xFF" "char->integer" "#x80" "<=" "string-parse-hex-escape" "2" "3" "=>" "posix-escape-sequences" "assv" "cdr" "char<?" "j" "apply" "c2" "car" "c1" "else" "=" "or" "cond" "alist->plist" "/" "'/" "reverse" "x" "cset-case-insensitive" "list->string" "pair?" "append" "sre-alternate" "" "'" "res" "lambda" "list" "remove" "high-char?" "filter" "hi-chars" "~case-insensitive?" "ci?" "cons" "1" "+" "null?" "case" "c" "let" "error" ">=" "if" "ranges" "chars" "i" "go" "define" "~utf8?" "flag-set?" "utf8?" "string-ref" "eqv?" "<" "and" "invert?" "string-length" "end" "let*" "flags" "start" "str")}
      {Lisp-Entry "high-char?" define #f 1182 9 1182 19 ("char->integer" "#x80" "<=" "c")}
      {Lisp-Entry "utf8-start-char->length" define #f 1186 8 1186 31 ("char->integer" "vector-ref" "c" "lambda" "0" "6" "5" "4" "3" "2" "1" "#" "'#" "table" "let")}
      {Lisp-Entry "utf8-string-ref" define #f 1207 9 1207 24 ("error" "else" "18" "#b00000111" "4" "12" "#b00001111" "3" "#b00111111" "6" "#b00011111" "bitwise-and" "fxarithmetic-shift-left" "+" "integer->char" "2" "1" "case" "string-ref" "char->integer" "n" "byte" "define" "len" "i" "str")}
      {Lisp-Entry "utf8-backup-to-initial-char" define #f 1230 9 1230 36 ("1" "-" "#xC0" ">=" "#x80" "<" "or" "string-ref" "char->integer" "c" "0" "=" "if" "lp" "let" "i" "str")}
      {Lisp-Entry "utf8-lowest-digit-of-length" define #f 1239 9 1239 36 ("error" "else" "#xF0" "4" "#xE0" "3" "#xC0" "2" "0" "1" "case" "len")}
      {Lisp-Entry "utf8-highest-digit-of-length" define #f 1244 9 1244 37 ("error" "else" "#xF7" "4" "#xEF" "3" "#xDF" "2" "#x7F" "1" "case" "len")}
      {Lisp-Entry "char->utf8-list" define #f 1249 9 1249 24 ("error" "else" "18" "#b11110000" "#x1FFFFF" "12" "#b11100000" "#xFFFF" "#b111111" "bitwise-and" "#b10000000" "6" "fxarithmetic-shift-right" "#b11000000" "bitwise-ior" "#x7FF" "list" "#x7F" "<=" "cond" "char->integer" "i" "let" "c")}
      {Lisp-Entry "unicode-range->utf8-pattern" define #f 1267 9 1267 36 ("unicode-range-middle" "else" "unicode-range-up-from" "1" "+" "cdr" "integer->char" "sre-sequence" "car" "null?" "cond" "lp" "unicode-range-up-to" "unicode-range-climb-digits" "list" "sre-alternate" "length" "=" "not" "if" "hi-ls" "char->utf8-list" "lo-ls" "let" "hi" "lo")}
      {Lisp-Entry "unicode-range-helper" define #f 1289 9 1289 29 ("#xFF" "#x80" "/" "_" "lambda" "integer->char" "map" "sre-sequence" "car" "cons" "cdr" "unicode-range-helper" "null?" "if" "res" "prefix" "ls" "one")}
      {Lisp-Entry "unicode-range-up-from" define #f 1305 9 1305 30 ("last" "map" "append" "reverse" "cdr" "#xFF" "1" "+" "/" "c" "lambda" "unicode-range-helper" "sre-alternate" "car" "integer->char" "list" "sre-sequence" "lo-ls")}
      {Lisp-Entry "unicode-range-up-to" define #f 1321 9 1321 28 ("last" "map" "append" "reverse" "cdr" "1" "-" "#x80" "/" "c" "lambda" "unicode-range-helper" "sre-alternate" "car" "integer->char" "list" "sre-sequence" "hi-ls")}
      {Lisp-Entry "unicode-range-climb-digits" define #f 1337 9 1337 35 ("utf8-start-char->length" "-" "zero-to" "utf8-highest-digit-of-length" "1" "+" "utf8-lowest-digit-of-length" "i" "cdr" "#x80" "_" "lambda" "map" "#xFF" "#x7F" "<=" "if" "car" "integer->char" "/" "cons" "sre-sequence" "list" "append" "sre-alternate" "length" "lo-len" "let" "hi-ls" "lo-ls")}
      {Lisp-Entry "unicode-range-middle" define #f 1369 9 1369 29 ("cdr" "#xFF" "#x80" "_" "lambda" "map" ",hi" ",lo" "/" "char=?" "if" "cons" "sre-sequence" "-" "hi" "1" "car" "+" "integer->char" "lo" "let" "hi-ls" "lo-ls")}
      {Lisp-Entry "cset->utf8-pattern" define #f 1377 9 1377 27 ("unicode-range->utf8-pattern" "cdar" "caar" "or" "else" "cdr" "high-char?" "car" "char?" "/" "'/" "cons" "list" "if" "reverse" "append" "sre-alternate" "null?" "cond" "lo-cset" "alts" "ls" "lp" "let" "cset")}
      {Lisp-Entry "sre-adjust-utf8" define #f 1396 9 1396 24 ("char->utf8-list" "integer->char" "char?" "and" "utf8-nonl" "'utf8-nonl" "utf8-any" "'utf8-any" "'*" "else" "nonl" "*" "cset->utf8-pattern" "'w/case" "list" "high-char?" "or" "x" "any" "sre->cset" "cset" "not" "if" "-" "&" "" "/" "w/nocase" "s" "lambda" "map" "cons" "w/case" "w/noutf8" "cdr" "sre-sequence" "w/utf8" "car" "case" "pair?" "cond" "rec" "define" "~case-insensitive?" "ci?" "~utf8?" "flag-set?" "utf8?" "adjust" "let" "flags" "sre")}
      {Lisp-Entry "irregex" define #f 1443 9 1443 16 ("sre->irregex" "else" "string->irregex" "apply" "string?" "irregex?" "cond" "o" "x")}
      {Lisp-Entry "string->irregex" define #f 1449 9 1449 24 ("string->sre" "sre->irregex" "apply" "o" "str")}
      {Lisp-Entry "sre->irregex" define #f 1452 9 1452 21 ("sre->procedure" "f" "let" "make-irregex" "~consumer?" "sre-consumer?" "~searcher?" "~none" "flag-join" "flags" "sre-length-ranges" "lens" "sre-names" "names" "sre-match-extractor" "extractor" "sre-count-submatches" "submatches" "and" "dfa" "nfa-num-states" "nfa->dfa" "nfa" "lambda" "=>" ",sre-dfa" "any" "*" "seq" "sre->nfa" "backtrack" "'backtrack" "dfa/search" "10" "else" "50" "fast" "'fast" "1" "small" "'small" "memq" "cond" "dfa-limit" "sre-remove-initial-bos" "sre-dfa" "sre-searcher?" "searcher?" "sre-adjust-utf8" "*allow-utf8-mode?*" "if" "symbol-list->flags" "pat-flags" "let*" "o" "sre")}
      {Lisp-Entry "sre-empty?" define #f 1490 9 1490 19 ("commit" "eow" "bow" "eol" "bol" "eos" "bos" "epsilon" "memq" "else" "every" "atomic" "+" "submatch-named" "=>" "submatch" "$" "seq" ":" "cdr" "sre-empty?" "any" "zero?" "cadr" "number?" "not" "or" "**" "neg-look-behind" "neg-look-ahead" "look-behind" "look-ahead" "?" "*" "car" "case" "pair?" "if" "sre")}
      {Lisp-Entry "sre-any?" define #f 1501 9 1501 17 ("else" "every" "cadr" "sre-any?" "cddr" "null?" "cdr" "submatch-named" "=>" "submatch" "$" ":" "seq" "car" "case" "pair?" "and" "any" "'any" "eq?" "or" "sre")}
      {Lisp-Entry "sre-repeater?" define #f 1510 9 1510 22 ("cadr" "sre-repeater?" "cddr" "null?" "cdr" ":" "seq" "submatch-named" "=>" "submatch" "$" "+" "*" "car" "memq" "or" "pair?" "and" "sre")}
      {Lisp-Entry "sre-searcher?" define #f 1518 9 1518 22 ("bos" "'bos" "eq?" "else" "every" "or" "cadr" "sre-searcher?" "and" "submatch-named" "=>" "submatch" "$" ":" "seq" "cdr" "sre-sequence" "sre-any?" "+" "*" "car" "case" "pair?" "if" "sre")}
      {Lisp-Entry "sre-consumer?" define #f 1528 9 1528 22 ("eos" "'eos" "eq?" "else" "every" "or" "last" "sre-consumer?" "and" "submatch-named" "=>" "submatch" "$" ":" "seq" "cdr" "sre-sequence" "sre-any?" "+" "*" "car" "case" "pair?" "if" "sre")}
      {Lisp-Entry "sre-has-submatches?" define #f 1538 9 1538 28 ("cdr" "any" "cadr" "string->sre" "sre-has-submatches?" "posix-string" "'posix-string" "eq?" "if" "submatch-named" "=>" "submatch" "$" "car" "memq" "or" "pair?" "and" "sre")}
      {Lisp-Entry "sre-count-submatches" define #f 1545 9 1545 29 ("cdr" "else" "string->sre" "sre-count-submatches" "posix-string" "caddr" "cadr" "dsm" "1" "submatch-named" "=>" "submatch" "$" "car" "case" "+" "fold" "pair?" "if" "0" "sum" "count" "let" "sre")}
      {Lisp-Entry "sre-length-ranges" define #f 1558 9 1558 26 ("procedure?" "commit" "nwb" "eow" "bow" "eol" "bol" "eos" "bos" "nonl" "any" "string-length" "char?" "apply" "cell" "sre-named-definitions" "neg-look-behind" "look-behind" "neg-look-ahead" "look-ahead" "memq" ">=?" ">=" "=?" "=" "??" "?" ">" "**?" "**" "*?" "*" "vector-ref" "vector-length" "<" "integer?" "not" "error" "assq" "backref-ci" "backref" "'submatch" "eq?" "submatch-named" "=>" "submatch" "$" "sre-sequence" "dsm" "hi4" "lo4" "cadddr" "cdddr" "caddr" "epsilon" "'epsilon" "symbol?" "number?" "n2" "n1" "else" "cddr" "max" "min" "or" "hi3" "lo3" "lambda" "null?" "hi2" "lo2" "cdr" "ls" "lp2" "atomic" "w/nocase" "w/case" ":" "seq" "cadr" "string->sre" "posix-string" "-" "&" "" "/" "case" "string?" "cond" "and" "i" "grow" "define" "cons" "return" "hi" "lo" "n" "lp" "0" "vector-set!" "sre-count-submatches" "+" "make-vector" "sublens" "1" "sre-names" "car" "pair?" "if" "names" "let" "o" "sre")}
      {Lisp-Entry "sre-sequence" define #f 1703 9 1703 21 ("seq" "'seq" "cons" "else" "car" "cdr" "epsilon" "'epsilon" "null?" "cond" "ls")}
      {Lisp-Entry "sre-alternate" define #f 1710 9 1710 22 ("'or" "cons" "else" "car" "cdr" "or" "null?" "cond" "ls")}
      {Lisp-Entry "sre-strip-submatches" define #f 1717 9 1717 29 ("map" "else" "cdddr" "dsm" "cddr" "submatch-named" "=>" "cdr" "sre-sequence" "sre-strip-submatches" "submatch" "$" "car" "case" "pair?" "not" "if" "sre")}
      {Lisp-Entry "sre-flatten-ranges" define #f 1728 9 1728 27 ("cons" "else" "cdr" "string->list" "append" "car" "string?" "reverse" "null?" "cond" "res" "lp" "let" "ls")}
      {Lisp-Entry "sre-names" define #f 1738 9 1738 18 ("else" "**?" "**" ">=" "=" "sre-sequence-names" "neg-look-behind" "neg-look-ahead" "look-behind" "look-ahead" "atomic" "w/nocase" "w/case" "??" "*?" "?" "*" "or" ":" "seq" "cdddr" "dsm" "cadr" "cons" "cddr" "submatch-named" "=>" "1" "+" "cdr" "sre-sequence" "sre-names" "submatch" "$" "car" "case" "pair?" "not" "if" "names" "n" "sre")}
      {Lisp-Entry "sre-sequence-names" define #f 1760 9 1760 27 ("sre-names" "car" "sre-count-submatches" "+" "cdr" "sre-sequence-names" "null?" "if" "names" "n" "ls")}
      {Lisp-Entry "sre-remove-initial-bos" define #f 1767 9 1767 31 ("map" "sre-alternate" "or" "sre-remove-initial-bos" "else" "cddr" "cons" "cadr" "bos" "'bos" "eq?" "cdr" "not" "+" "*" "submatch-named" "=>" "submatch" "$" ":" "seq" "car" "case" "pair?" "cond" "sre")}
      {Lisp-Entry "irregex-basic-string-chunker" define #f 1790 8 1790 36 ("substring" "j" "src2" "i" "src1" "caddr" "cadr" "car" "x" "lambda" "make-irregex-chunker")}
      {Lisp-Entry "irregex-search" define #f 1798 9 1798 23 ("list" "irregex-basic-string-chunker" "irregex-search/chunked" "string-length" "cadr" "cdr" "end" "0" "car" "pair?" "and" "or" "start" "let" "error" "string?" "not" "if" "o" "str" "x")}
      {Lisp-Entry "irregex-search/chunked" define #f 1807 9 1807 31 ("irregex-search/matches" "irregex-match-chunker-set!" "chunker-get-start" "car" "pair?" "if" "i" "irregex-new-matches" "matches" "irregex" "irx" "let*" "o" "src" "cnk" "x")}
      {Lisp-Entry "irregex-search/matches" define #f 1816 9 1816 31 ("<" "src2" "lp" "lambda" "if" "cons" "init" "chunker-get-str" "str" "irregex-nfa" "matcher" "1" "+" "and" "next" ">=" "lp2" "end" "lp1" "chunker-get-next" "get-next" "chunker-get-end" "get-end" "chunker-get-start" "get-start" "dfa" "let" "irregex-dfa/search" "dfa-match/shortest" "else" "%irregex-match-end-index" "%irregex-match-end-chunk" "irregex-dfa/extract" "irregex-match-start-index-set!" "irregex-match-start-chunk-set!" "0" "dfa-match/longest" "~searcher?" "irregex-flags" "flag-set?" "irregex-dfa" "cond" "matches" "i" "src" "cnk" "irx")}
      {Lisp-Entry "irregex-match" define #f 1887 9 1887 22 ("list" "irregex-basic-string-chunker" "irregex-match/chunked" "string-length" "cadr" "cdr" "end" "0" "car" "pair?" "and" "or" "start" "let" "error" "string?" "not" "if" "o" "str" "irx")}
      {Lisp-Entry "irregex-match/chunked" define #f 1895 9 1895 30 ("chunker-get-next" "not" "lambda" "m" "end" "i" "chunker-get-str" "str" "irregex-nfa" "matcher" "else" "irregex-dfa/extract" "irregex-match-start-index-set!" "irregex-match-start-chunk-set!" "begin" "%irregex-match-end-index" "%irregex-match-end-chunk" "chunker-get-end" "=" "0" "chunker-get-start" "dfa-match/longest" "and" "irregex-dfa" "cond" "irregex-match-chunker-set!" "irregex-new-matches" "matches" "irregex" "let*" "src" "cnk" "irx")}
      {Lisp-Entry "irregex-match?" define #f 1929 9 1929 23 ("irregex-match" "apply" "and" "args")}
      {Lisp-Entry "dfa-init-state" define #f 1936 9 1936 23 ("0" "vector-ref" "dfa")}
      {Lisp-Entry "dfa-next-state" define #f 1938 9 1938 23 ("cdr" "vector-ref" "node" "dfa")}
      {Lisp-Entry "dfa-final-state?" define #f 1940 9 1940 25 ("car" "state" "dfa")}
      {Lisp-Entry "dfa-match/shortest" define #f 1944 9 1944 27 ("else" "dfa-next-state" "1" "+" "cdr" "cdar" "caar" "char<=?" "pair?" "car" "eqv?" "if" "x" "lambda" "find" "next" "string-ref" "ch" "let*" "<" "irregex-match-end-index-set!" "irregex-match-end-chunk-set!" "dfa-final-state?" "cond" "i" "lp2" "end" "str" "and" "dfa-init-state" "state" "lp1" "chunker-get-next" "get-next" "chunker-get-end" "get-end" "chunker-get-start" "get-start" "chunker-get-str" "get-str" "let" "index" "matches" "start" "src" "cnk" "dfa")}
      {Lisp-Entry "dfa-match/longest" define #f 1977 9 1977 26 ("1" "+" "dfa-next-state" "cdr" "cdar" "caar" "char<=?" "pair?" "car" "eqv?" "x" "lambda" "find" "cell" "string-ref" "ch" "let*" "else" "%irregex-match-end-chunk" "not" "next" ">=" "i" "lp2" "eq?" "if" "str" "res-index" "and" "res-src" "state" "lp1" "irregex-match-end-index-set!" "irregex-match-end-chunk-set!" "cond" "dfa-init-state" "dfa-final-state?" "start-is-final?" "chunker-get-next" "get-next" "chunker-get-end" "get-end" "chunker-get-start" "get-start" "chunker-get-str" "get-str" "let" "index" "matches" "end" "end-src" "start" "src" "cnk" "dfa")}
      {Lisp-Entry "sre-named-definitions" define #f 2039 8 2039 29 ("http-url" "url-final-char" "url-char" "email" "email-local-part" "domain/common" "2" "w/nocase" "top-level-domain" "domain" "domain-atom" "ip-address" "7" "4" "0" "**" "ipv6-address" "=" "ipv4-address" "ipv4-digit" ",@o" ",esc" "" "o" "esc" "lambda" "escape" "sexp-space" "*" "symbol" "symbol-subsequent" "symbol-initial" "real" "?" "integer" "utf8-nonl" "utf8-any" "#xD7" "#xD0" "utf8-4-char" "#xCF" "#xC0" "utf8-3-char" "#xBF" "#xA2" "utf8-2-char" "#xA1" "#x60" "utf8-tail-char" "eow" "bow" "word" "3" "seq" "newline" "ascii-nonl" "95" "+" "ascii" "xdigit" "hex-digit" "cntrl" "1" "32" "control" "print" "printing" "white" "space" "whitespace" "23" "char->integer" "integer->char" "blank" "graph" "graphic" "punct" "or" "punctuation" "digit" "num" "numeric" "upper" "upper-case" "lower" "lower-case" "alnum" "alphanum" "alphanumeric" "alpha" "/" "alphabetic" "string" "-" "nonl" "*all-chars*" ",*all-chars*" "any")}
      {Lisp-Entry "*nfa-presize*" define #f 2157 8 2157 21 ("128")}
      {Lisp-Entry "*nfa-num-fields*" define #f 2158 8 2158 24 ("4")}
      {Lisp-Entry "nfa-num-states" define #f 2160 9 2160 23 ("*nfa-num-fields*" "vector-length" "quotient" "nfa")}
      {Lisp-Entry "nfa-start-state" define #f 2161 9 2161 24 ("1" "nfa-num-states" "-" "nfa")}
      {Lisp-Entry "nfa-get-state-trans" define #f 2163 9 2163 28 ("*nfa-num-fields*" "*" "vector-ref" "i" "nfa")}
      {Lisp-Entry "nfa-set-state-trans!" define #f 2165 9 2165 29 ("*nfa-num-fields*" "*" "vector-set!" "x" "i" "nfa")}
      {Lisp-Entry "nfa-push-state-trans!" define #f 2167 9 2167 30 ("nfa-get-state-trans" "cons" "nfa-set-state-trans!" "x" "i" "nfa")}
      {Lisp-Entry "nfa-get-epsilons" define #f 2170 9 2170 25 ("1" "*nfa-num-fields*" "*" "+" "vector-ref" "i" "nfa")}
      {Lisp-Entry "nfa-set-epsilons!" define #f 2172 9 2172 26 ("1" "*nfa-num-fields*" "*" "+" "vector-set!" "x" "i" "nfa")}
      {Lisp-Entry "nfa-add-epsilon!" define #f 2174 9 2174 25 ("cons" "nfa-set-epsilons!" "memq" "not" "if" "nfa-get-epsilons" "eps" "let" "x" "i" "nfa")}
      {Lisp-Entry "nfa-get-state-closure" define #f 2179 9 2179 30 ("2" "*nfa-num-fields*" "*" "+" "vector-ref" "i" "nfa")}
      {Lisp-Entry "nfa-set-state-closure!" define #f 2181 9 2181 31 ("2" "*nfa-num-fields*" "*" "+" "vector-set!" "x" "i" "nfa")}
      {Lisp-Entry "nfa-get-closure" define #f 2184 9 2184 24 ("else" "cdr" "=>" "1" "-" "*nfa-num-fields*" "nfa-multi-state-hash" "*" "+" "vector-ref" "assoc" "cond" "mst" "nfa")}
      {Lisp-Entry "nfa-add-closure!" define #f 2191 9 2191 25 ("vector-ref" "cons" "vector-set!" "1" "-" "*nfa-num-fields*" "nfa-multi-state-hash" "*" "+" "i" "let" "x" "mst" "nfa")}
      {Lisp-Entry "sre->nfa" define #f 2200 9 2200 17 ("nfa" "len" "error" "apply" "sre-sequence" "submatch-named" "=>" "submatch" "$" "'*" "?" "c" "cadar" "a" "cddar" "b" "or" "'/" "list" "length" "sre->cset" "ranges" "" "&" "/" "~utf8?" "flag-join" "flag-clear" "memq" "let*" "w/noutf8" "w/utf8" "w/nocase" "w/case" "cdar" "append" ":" "seq" "case" "else" "string->list" "sre-alternate" "caar" "pair?" "procedure?" "sre-named-definitions" "assq" "cell" "symbol?" "char?" "nfa-add-epsilon!" "new" "epsilon" "'epsilon" "eq?" "string-ref" "string-length" "lp2" "cdr" "car" "string?" "cond" "null?" "eqv?" "not" "~case-insensitive?" "flag-set?" "char-altcase" "alt" "ch" "add-char-state!" "cons" "x" "lambda" "map" "and" "trans" "extend-state!" "nfa-set-state-trans!" "set!" "vector-ref" "vector-set!" "0" "<" "-" "i" "do" "2" "tmp" "vector-length" ">=" "if" "trans-ls" "n2" "add-state!" "1" "+" "max" "state" "new-state-number" "next" "flags" "n" "ls" "lp" "define" "*nfa-num-fields*" "*nfa-presize*" "*" "make-vector" "buf" "let" "init-flags" "sre")}
      {Lisp-Entry "nfa-multi-state-hash" define #f 2492 9 2492 29 ("nfa-num-states" "equal?-hash" "modulo" "mst" "nfa")}
      {Lisp-Entry "make-nfa-multi-state" define #f 2495 9 2495 29 ("0" "-1" "16" "nfa-num-states" "+" "quotient" "make-u16vector" "nfa")}
      {Lisp-Entry "nfa-state->multi-state" define #f 2498 9 2498 31 ("make-nfa-multi-state" "nfa-multi-state-add!" "state" "nfa")}
      {Lisp-Entry "nfa-multi-state-copy" define #f 2501 9 2501 29 ("u16vector-ref" "u16vector-set!" "0" "<" "1" "-" "i" "do" "u16vector-length" "make-u16vector" "res" "let" "mst")}
      {Lisp-Entry "nfa-multi-state-contains?" define #f 2507 9 2507 34 ("1" "fxarithmetic-shift-left" "u16vector-ref" "bitwise-and" "zero?" "not" "remainder" "bit" "16" "quotient" "cell" "let" "i" "mst")}
      {Lisp-Entry "nfa-multi-state-add!" define #f 2512 9 2512 29 ("1" "fxarithmetic-shift-left" "u16vector-ref" "bitwise-ior" "u16vector-set!" "remainder" "bit" "16" "quotient" "cell" "let" "i" "mst")}
      {Lisp-Entry "nfa-multi-state-add" define #f 2518 9 2518 28 ("nfa-multi-state-copy" "nfa-multi-state-add!" "i" "mst")}
      {Lisp-Entry "nfa-multi-state-union!" define #f 2521 9 2521 31 ("u16vector-ref" "bitwise-ior" "u16vector-set!" "0" "<" "1" "u16vector-length" "-" "i" "do" "b" "a")}
      {Lisp-Entry "nfa-multi-state-union" define #f 2526 9 2526 30 ("nfa-multi-state-copy" "nfa-multi-state-union!" "b" "a")}
      {Lisp-Entry "nfa-multi-state-fold" define #f 2529 9 2529 29 ("integer-log" "16" "*" "bit" "n-tail" "-" "bitwise-and" "n2" "let*" "1" "+" "zero?" "u16vector-ref" "n" "lp2" ">=" "if" "acc" "0" "i" "lp1" "u16vector-length" "limit" "let" "knil" "kons" "mst")}
      {Lisp-Entry "nfa->dfa" define #f 2556 9 2556 17 (",@res" ",@trans" ",accept?" ",states" "1" "+" "map" "append" "nfa-multi-state-contains?" "accept?" "nfa-state-transitions" "trans" "states" "let*" "else" ">" "cdr" "assoc" "reverse" "dfa-renumber" "null?" "cond" "res" "0" "i" "nfa-start-state" "nfa-cache-state-closure!" "list" "ls" "lp" "car" "pair?" "and" "max-states" "let" "o" "nfa")}
      {Lisp-Entry "dfa-renumber" define #f 2578 9 2578 21 ("cdar" "cddar" "set-cdr!" "x" "lambda" "for-each" "1" "+" "cons" "vector-set!" "caar" "j" "pair?" "cond" "0" "i" "ls" "lp" "let" "nfa-multi-state-hash" "vector-ref" "assoc" "cdr" "mst" "renumber" "define" "res" "nfa-num-states" "make-vector" "states" "length" "len" "let*" "dfa" "nfa")}
      {Lisp-Entry "nfa-state-transitions" define #f 2602 9 2602 30 ("nfa-closure" "set-cdr!" "x" "for-each" "nfa-get-state-trans" "cdr" "car" "nfa-join-transitions!" "trans" "fold" "st" "lambda" "nfa-multi-state-fold" "res" "let" "states" "nfa")}
      {Lisp-Entry "nfa-join-transitions!" define #f 2614 9 2614 30 ("intersect-char-ranges" "let*" "set-car!" "right2-copy" "right1-copy" "right2" "right1" "same" "left2" "left1" "or" "hi" "lo" "else" "split-char-range" "cdr" "list" "append" "right-copy" "nfa-multi-state-copy" "left-copy" "right" "left" "lambda" "apply" "cdaar" "caaar" "char<=?" "pair?" "and" "cdar" "nfa-multi-state-add!" "car" "set-cdr!" "caar" "eq?" "nfa-state->multi-state" "cons" "null?" "res" "lp" "let" "char?" "cond" "nfa-join-transitions!" "not" "if" "ls" "join!" "define" "state" "elt" "existing" "nfa")}
      {Lisp-Entry "char-range" define #f 2683 9 2683 19 ("cons" "eqv?" "if" "c2" "c1")}
      {Lisp-Entry "split-char-range" define #f 2687 9 2687 25 ("+" "cdr" "1" "char->integer" "-" "integer->char" "char-range" "car" "eqv?" "not" "and" "list" "ch" "range")}
      {Lisp-Entry "intersect-char-ranges" define #f 2696 9 2696 30 ("+" "1" "char->integer" "-" "integer->char" "char-range" "char<?" "and" "list" "b-hi" "b-lo" "cdr" "a-hi" "a-lo" "let" "intersect-char-ranges" "reverse" "car" "char>?" "if" "b" "a")}
      {Lisp-Entry "nfa-cache-state-closure!" define #f 2713 9 2713 33 ("nfa-set-state-closure!" "nfa-state-closure-internal" "res" "else" "null?" "not" "cond" "nfa-get-state-closure" "cached" "let" "state" "nfa")}
      {Lisp-Entry "nfa-state-closure-internal" define #f 2725 9 2725 35 ("nfa-multi-state-add!" "nfa-get-epsilons" "append" "else" "cdr" "car" "nfa-multi-state-contains?" "null?" "cond" "make-nfa-multi-state" "res" "list" "ls" "lp" "let" "state" "nfa")}
      {Lisp-Entry "nfa-closure-internal" define #f 2737 9 2737 29 ("make-nfa-multi-state" "nfa-cache-state-closure!" "nfa-multi-state-union!" "res" "st" "lambda" "nfa-multi-state-fold" "states" "nfa")}
      {Lisp-Entry "nfa-closure" define #f 2744 9 2744 20 ("nfa-add-closure!" "nfa-closure-internal" "res" "let" "nfa-get-closure" "or" "states" "nfa")}
      {Lisp-Entry "sre-match-extractor" define #f 2759 9 2759 28 ("error" "end-index-offset" "end-src-offset" "start-index-offset" "3" "start-src-offset" "match-one" "submatch" "$" "?" "'*" "begin" "src" "match-all" "match-once" "letrec" "match-rest" "match-first" "sre-alternate" "rest" "cdr" "null?" "-" "chunk-before?" ">" "or" "right-src" "eqv?" "vector-ref" "and" "else" "vector-set!" "chunker-get-end" "chunker-prev-chunk" "prev" "<" "k" "lp2" "chunker-get-start" "eq?" "limit" "best-index" "best-src" "j2" "end2" "lp1" "sre-count-submatches" "match-right" "cadr" "match-left" "cddr" "sre-sequence" "right" "seq" ":" "car" "case" "pair?" "dfa-match/longest" "~none" "sre->nfa" "nfa->dfa" "dfa" "matches" "j" "end" "i" "start" "cnk" "lambda" "if" "sre-has-submatches?" "not" "cond" "submatch-deps?" "n" "lp" "let" "6" "tmp-end-index-offset" "4" "*" "5" "tmp-end-src-offset" "1" "+" "tmp" "let*" "num-submatches" "sre")}
      {Lisp-Entry "sre->procedure" define #f 2897 9 2897 23 ("string->list" "char=?" "char-ci=?" "char?" "sre-named-definitions" "cell" "epsilon" "c2" "c1" "nwb" "chunker-next-char" "eol" "chunker-prev-char" "ch" "char-alphanumeric?" "bol" "bos" "string-ref" "eqv?" "nonl" "end2" "i2" "str2" "<" "submatch-named" "%irregex-match-start-index" "%irregex-match-start-chunk" "%irregex-match-end-index" "old-index" "old-source" "submatch" "$" "dsm" "chunker-get-end" "chunker-get-start" "chunker-get-str" "chunker-get-next" "substring" "<=" "irregex-match-substring" "s" "string=?" "string-ci=?" "'backref-ci" "compare" "backref-ci" "backref" "test" "%irregex-match-end-chunk" "fail2" "=>" "assq" "index" "symbol?" "cadddr" "pass" "test-submatches" "j" "once" "atomic" "'look-behind" "src2" "string-length" "len" "chunker-get-substring" "prev" "eos" "append" "any" "cons" "neg-look-behind" "look-behind" "neg-look-ahead" "check" "look-ahead" "string->sre" "posix-string" "alphanumeric" "word+" "eow" "bow" "word" "map" "zero?" ",*" "zero-to" ",sre" ",?" "x" "fold" "sre-strip-submatches" "x-sre" "cdddr" "'*?" "'??" "'?" "'**" "eq?" "to" "from" "not" ">" "caddr" "number?" "**?" ">=" "**" "=" "'*" "list" "*?" "letrec" "error" "sre-empty?" "*" "??" "body" "?" ":" "seq" "w/noutf8" "~utf8?" "w/utf8" "flag-join" "w/nocase" "flag-clear" "sre-sequence" "w/case" "sre-count-submatches" "+" "cddr" "sre-alternate" "rest" "first" "let*" "else" "length" "or" "/" "&" "-" "" "case" "~case-insensitive?" "flag-set?" "sre->cset" "sre-cset->procedure" "string?" "cond" "rec" "irregex-match-end-index-set!" "irregex-match-end-chunk-set!" "irregex-match-start-index-set!" "0" "irregex-match-start-chunk-set!" "fail" "matches" "end" "i" "str" "src" "init" "cnk" "lambda" "next" "~none" "car" "flags" "n" "lp" "let" "1" "sre-names" "cadr" "cdr" "pair?" "and" "if" "names" "define" "o" "sre")}
      {Lisp-Entry "sre-cset->procedure" define #f 3379 9 3379 28 ("chunker-get-end" "end2" "chunker-get-start" "i2" "chunker-get-str" "str2" "chunker-get-next" "src2" "let" "1" "+" "string-ref" "cset-contains?" "<" "if" "fail" "matches" "end" "i" "str" "src" "init" "cnk" "lambda" "next" "cset")}
      {Lisp-Entry "plist->alist" define #f 3395 9 3395 21 ("cadr" "car" "cons" "cddr" "reverse" "null?" "if" "res" "lp" "let" "ls")}
      {Lisp-Entry "alist->plist" define #f 3401 9 3401 21 ("caar" "cdar" "cons" "cdr" "reverse" "null?" "if" "res" "lp" "let" "ls")}
      {Lisp-Entry "sre->cset" define #f 3407 9 3407 18 ("sre-named-definitions" "assq" "cell" "string" "list" "char?" "error" "else" "w/nocase" "sre-alternate" "w/case" "or" "cdr" "sre-flatten-ranges" "plist->alist" "/" "cset-difference" "res" "x" "lambda" "-" "cset-intersection" "&" "cddr" "map" "cadr" "cset-union" "fold" "cset-complement" "" "case" "string->list" "cset-case-insensitive" "string?" "if" "cond" "rec" "define" "car" "pair?" "and" "ci?" "lp" "let" "o" "sre")}
      {Lisp-Entry "cset-contains?" define #f 3459 9 3459 23 ("cdr" "car" "char<=?" "pair?" "and" "eqv?" "or" "x" "lambda" "find" "ch" "cset")}
      {Lisp-Entry "cset-range" define #f 3465 9 3465 19 ("cons" "char?" "if" "x")}
      {Lisp-Entry "char-ranges-overlap?" define #f 3468 9 3468 29 ("eqv?" "char-ranges-overlap?" "cdr" "car" "char<=?" "and" "or" "pair?" "if" "b" "a")}
      {Lisp-Entry "char-ranges-union" define #f 3478 9 3478 26 ("cdr" "char>=?" "car" "char<=?" "if" "cons" "b" "a")}
      {Lisp-Entry "cset-union" define #f 3482 9 3482 19 ("cons" "else" "cset-range" "char-ranges-union" "list" "cdr" "take-up-to" "append" "cset-union" "ls" "=>" "car" "char-ranges-overlap?" "x" "lambda" "find-tail" "null?" "cond" "b" "a")}
      {Lisp-Entry "cset-difference" define #f 3493 9 3493 24 ("else" "cset-range" "intersect-char-ranges" "list" "cset-union" "cons" "if" "take-up-to" "append" "let*" "right2" "right1" "same" "left2" "left1" "apply" "ls" "=>" "char-ranges-overlap?" "x" "lambda" "find-tail" "cdr" "cset-difference" "car" "not" "null?" "cond" "b" "a")}
      {Lisp-Entry "cset-intersection" define #f 3510 9 3510 26 ("else" "cset-range" "intersect-char-ranges" "list" "cset-union" "cons" "if" "cdr" "take-up-to" "append" "let*" "right2" "right1" "same" "left2" "left1" "apply" "ls" "=>" "car" "char-ranges-overlap?" "x" "lambda" "find-tail" "null?" "cond" "res" "intersect" "let" "b" "a")}
      {Lisp-Entry "cset-complement" define #f 3527 9 3527 24 ("*all-chars*" "sre->cset" "cset-difference" "a")}
      {Lisp-Entry "cset-case-insensitive" define #f 3530 9 3530 30 ("else" "list" "cset-union" "cdar" "caar" "pair?" "cset-contains?" "if" "cdr" "cons" "char-altcase" "c2" "char-alphabetic?" "car" "char?" "and" "reverse" "null?" "cond" "res" "ls" "lp" "let" "a")}
      {Lisp-Entry "irregex-fold/fast" define #f 3549 9 3549 26 ("irregex-reset-matches!" "%irregex-match-end-index" "list" "irregex-search/matches" "m" ">=" "lp" "let" "irregex-basic-string-chunker" "irregex-match-chunker-set!" "string-length" "caddr" "cddr" "end" "0" "cadr" "cdr" "start" "acc" "i" "lambda" "car" "pair?" "and" "or" "finish" "irregex-new-matches" "matches" "irregex" "let*" "procedure?" "error" "string?" "not" "if" "o" "str" "knil" "kons" "irx")}
      {Lisp-Entry "irregex-fold" define #f 3576 9 3576 21 ("irregex-fold/fast" "apply" "irregex-copy-matches" "acc" "m" "i" "lambda" "kons2" "let" "args" "kons" "irx")}
      {Lisp-Entry "irregex-fold/chunked/fast" define #f 3580 9 3580 34 ("irregex-reset-matches!" "%irregex-match-end-index" "end-index" "0" "%irregex-match-end-chunk" "end-src" "irregex-search/matches" "m" "not" "lp" "let" "irregex-match-chunker-set!" "chunker-get-start" "cadr" "cdr" "if" "acc" "i" "src" "lambda" "car" "pair?" "and" "or" "finish" "irregex-new-matches" "matches" "irregex" "let*" "o" "start" "cnk" "knil" "kons" "irx")}
      {Lisp-Entry "irregex-fold/chunked" define #f 3600 9 3600 29 ("irregex-fold/chunked/fast" "apply" "irregex-copy-matches" "acc" "m" "i" "s" "lambda" "kons2" "let" "args" "kons" "irx")}
      {Lisp-Entry "irregex-replace" define #f 3604 9 3604 24 ("%irregex-match-start-index" "list" "irregex-apply-match" "append" "string-length" "0" "%irregex-match-end-index" "substring" "cons" "string-cat-reverse" "and" "irregex-search" "m" "let" "error" "string?" "not" "if" "o" "str" "irx")}
      {Lisp-Entry "irregex-replace/all" define #f 3615 9 3615 28 ("string-cat-reverse" "string-length" "end" "substring" "cons" ">=" "irregex-apply-match" "append" "0" "%irregex-match-start-index" "m-start" "let" "acc" "m" "i" "lambda" "irregex-fold/fast" "error" "string?" "not" "if" "o" "str" "irx")}
      {Lisp-Entry "irregex-apply-match" define #f 3633 9 3633 28 ("error" "x" "lambda" "=>" "irregex-match-names" "assq" "else" "string-length" "%irregex-match-end-index" "str" "post" "%irregex-match-start-index" "0" "%irregex-match-start-chunk" "substring" "pre" "case" "symbol?" "procedure?" "irregex-match-substring" "or" "cons" "cdr" "car" "integer?" "cond" "null?" "if" "res" "lp" "let" "ls" "m")}
      {Lisp-Entry "irregex-extract" define #f 3667 9 3667 24 ("reverse" "irregex-match-substring" "cons" "a" "m" "i" "lambda" "irregex-fold/fast" "apply" "error" "string?" "not" "if" "o" "str" "irx")}
      {Lisp-Entry "irregex-split" define #f 3675 9 3675 22 ("reverse" "substring" "cons" "%irregex-match-start-index" "=" "a" "m" "i" "lambda" "irregex-fold/fast" "string-length" "cadr" "cdr" "and" "end" "0" "car" "pair?" "start" "let" "error" "string?" "not" "if" "o" "str" "irx")}}})
